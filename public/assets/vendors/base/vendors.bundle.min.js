
( function( global, factory ) {
"use strict";
if ( typeof module === "object" && typeof module.exports === "object" ) {
module.exports = global.document ?
factory( global, true ) :
function( w ) {
if ( !w.document ) {
throw new Error( "jQuery requires a window with a document" );
}
return factory( w );
};
} else {
factory( global );
}
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {
"use strict";
var arr = [];
var document = window.document;
var getProto = Object.getPrototypeOf;
var slice = arr.slice;
var concat = arr.concat;
var push = arr.push;
var indexOf = arr.indexOf;
var class2type = {};
var toString = class2type.toString;
var hasOwn = class2type.hasOwnProperty;
var fnToString = hasOwn.toString;
var ObjectFunctionString = fnToString.call( Object );
var support = {};
function DOMEval( code, doc ) {
doc = doc || document;
var script = doc.createElement( "script" );
script.text = code;
doc.head.appendChild( script ).parentNode.removeChild( script );
}
var
version = "3.2.1",
jQuery = function( selector, context ) {
return new jQuery.fn.init( selector, context );
},
rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
rmsPrefix = /^-ms-/,
rdashAlpha = /-([a-z])/g,
fcamelCase = function( all, letter ) {
return letter.toUpperCase();
};
jQuery.fn = jQuery.prototype = {
jquery: version,
constructor: jQuery,
length: 0,
toArray: function() {
return slice.call( this );
},
get: function( num ) {
if ( num == null ) {
return slice.call( this );
}
return num < 0 ? this[ num + this.length ] : this[ num ];
},
pushStack: function( elems ) {
var ret = jQuery.merge( this.constructor(), elems );
ret.prevObject = this;
return ret;
},
each: function( callback ) {
return jQuery.each( this, callback );
},
map: function( callback ) {
return this.pushStack( jQuery.map( this, function( elem, i ) {
return callback.call( elem, i, elem );
} ) );
},
slice: function() {
return this.pushStack( slice.apply( this, arguments ) );
},
first: function() {
return this.eq( 0 );
},
last: function() {
return this.eq( -1 );
},
eq: function( i ) {
var len = this.length,
j = +i + ( i < 0 ? len : 0 );
return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
},
end: function() {
return this.prevObject || this.constructor();
},
push: push,
sort: arr.sort,
splice: arr.splice
};
jQuery.extend = jQuery.fn.extend = function() {
var options, name, src, copy, copyIsArray, clone,
target = arguments[ 0 ] || {},
i = 1,
length = arguments.length,
deep = false;
if ( typeof target === "boolean" ) {
deep = target;
target = arguments[ i ] || {};
i++;
}
if ( typeof target !== "object" && !jQuery.isFunction( target ) ) {
target = {};
}
if ( i === length ) {
target = this;
i--;
}
for ( ; i < length; i++ ) {
if ( ( options = arguments[ i ] ) != null ) {
for ( name in options ) {
src = target[ name ];
copy = options[ name ];
if ( target === copy ) {
continue;
}
if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
( copyIsArray = Array.isArray( copy ) ) ) ) {
if ( copyIsArray ) {
copyIsArray = false;
clone = src && Array.isArray( src ) ? src : [];
} else {
clone = src && jQuery.isPlainObject( src ) ? src : {};
}
target[ name ] = jQuery.extend( deep, clone, copy );
} else if ( copy !== undefined ) {
target[ name ] = copy;
}
}
}
}
return target;
};
jQuery.extend( {
expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),
isReady: true,
error: function( msg ) {
throw new Error( msg );
},
noop: function() {},
isFunction: function( obj ) {
return jQuery.type( obj ) === "function";
},
isWindow: function( obj ) {
return obj != null && obj === obj.window;
},
isNumeric: function( obj ) {
var type = jQuery.type( obj );
return ( type === "number" || type === "string" ) &&
!isNaN( obj - parseFloat( obj ) );
},
isPlainObject: function( obj ) {
var proto, Ctor;
if ( !obj || toString.call( obj ) !== "[object Object]" ) {
return false;
}
proto = getProto( obj );
if ( !proto ) {
return true;
}
Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
},
isEmptyObject: function( obj ) {
var name;
for ( name in obj ) {
return false;
}
return true;
},
type: function( obj ) {
if ( obj == null ) {
return obj + "";
}
return typeof obj === "object" || typeof obj === "function" ?
class2type[ toString.call( obj ) ] || "object" :
typeof obj;
},
globalEval: function( code ) {
DOMEval( code );
},
camelCase: function( string ) {
return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
},
each: function( obj, callback ) {
var length, i = 0;
if ( isArrayLike( obj ) ) {
length = obj.length;
for ( ; i < length; i++ ) {
if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
break;
}
}
} else {
for ( i in obj ) {
if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
break;
}
}
}
return obj;
},
trim: function( text ) {
return text == null ?
"" :
( text + "" ).replace( rtrim, "" );
},
makeArray: function( arr, results ) {
var ret = results || [];
if ( arr != null ) {
if ( isArrayLike( Object( arr ) ) ) {
jQuery.merge( ret,
typeof arr === "string" ?
[ arr ] : arr
);
} else {
push.call( ret, arr );
}
}
return ret;
},
inArray: function( elem, arr, i ) {
return arr == null ? -1 : indexOf.call( arr, elem, i );
},
merge: function( first, second ) {
var len = +second.length,
j = 0,
i = first.length;
for ( ; j < len; j++ ) {
first[ i++ ] = second[ j ];
}
first.length = i;
return first;
},
grep: function( elems, callback, invert ) {
var callbackInverse,
matches = [],
i = 0,
length = elems.length,
callbackExpect = !invert;
for ( ; i < length; i++ ) {
callbackInverse = !callback( elems[ i ], i );
if ( callbackInverse !== callbackExpect ) {
matches.push( elems[ i ] );
}
}
return matches;
},
map: function( elems, callback, arg ) {
var length, value,
i = 0,
ret = [];
if ( isArrayLike( elems ) ) {
length = elems.length;
for ( ; i < length; i++ ) {
value = callback( elems[ i ], i, arg );
if ( value != null ) {
ret.push( value );
}
}
} else {
for ( i in elems ) {
value = callback( elems[ i ], i, arg );
if ( value != null ) {
ret.push( value );
}
}
}
return concat.apply( [], ret );
},
guid: 1,
proxy: function( fn, context ) {
var tmp, args, proxy;
if ( typeof context === "string" ) {
tmp = fn[ context ];
context = fn;
fn = tmp;
}
if ( !jQuery.isFunction( fn ) ) {
return undefined;
}
args = slice.call( arguments, 2 );
proxy = function() {
return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
};
proxy.guid = fn.guid = fn.guid || jQuery.guid++;
return proxy;
},
now: Date.now,
support: support
} );
if ( typeof Symbol === "function" ) {
jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
function( i, name ) {
class2type[ "[object " + name + "]" ] = name.toLowerCase();
} );
function isArrayLike( obj ) {
var length = !!obj && "length" in obj && obj.length,
type = jQuery.type( obj );
if ( type === "function" || jQuery.isWindow( obj ) ) {
return false;
}
return type === "array" || length === 0 ||
typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
(function( window ) {
var i,
support,
Expr,
getText,
isXML,
tokenize,
compile,
select,
outermostContext,
sortInput,
hasDuplicate,
setDocument,
document,
docElem,
documentIsHTML,
rbuggyQSA,
rbuggyMatches,
matches,
contains,
expando = "sizzle" + 1 * new Date(),
preferredDoc = window.document,
dirruns = 0,
done = 0,
classCache = createCache(),
tokenCache = createCache(),
compilerCache = createCache(),
sortOrder = function( a, b ) {
if ( a === b ) {
hasDuplicate = true;
}
return 0;
},
hasOwn = ({}).hasOwnProperty,
arr = [],
pop = arr.pop,
push_native = arr.push,
push = arr.push,
slice = arr.slice,
indexOf = function( list, elem ) {
var i = 0,
len = list.length;
for ( ; i < len; i++ ) {
if ( list[i] === elem ) {
return i;
}
}
return -1;
},
booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
whitespace = "[\\x20\\t\\r\\n\\f]",
identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",
attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
"*([*^$|!~]?=)" + whitespace +
"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
"*\\]",
pseudos = ":(" + identifier + ")(?:\\((" +
"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
".*" +
")\\)|)",
rwhitespace = new RegExp( whitespace + "+", "g" ),
rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),
rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),
rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),
rpseudo = new RegExp( pseudos ),
ridentifier = new RegExp( "^" + identifier + "$" ),
matchExpr = {
"ID": new RegExp( "^#(" + identifier + ")" ),
"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
"TAG": new RegExp( "^(" + identifier + "|[*])" ),
"ATTR": new RegExp( "^" + attributes ),
"PSEUDO": new RegExp( "^" + pseudos ),
"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
},
rinputs = /^(?:input|select|textarea|button)$/i,
rheader = /^h\d$/i,
rnative = /^[^{]+\{\s*\[native \w/,
rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
rsibling = /[+~]/,
runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
funescape = function( _, escaped, escapedWhitespace ) {
var high = "0x" + escaped - 0x10000;
return high !== high || escapedWhitespace ?
escaped :
high < 0 ?
String.fromCharCode( high + 0x10000 ) :
String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
},
rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
fcssescape = function( ch, asCodePoint ) {
if ( asCodePoint ) {
if ( ch === "\0" ) {
return "\uFFFD";
}
return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
}
return "\\" + ch;
},
unloadHandler = function() {
setDocument();
},
disabledAncestor = addCombinator(
function( elem ) {
return elem.disabled === true && ("form" in elem || "label" in elem);
},
{ dir: "parentNode", next: "legend" }
);
try {
push.apply(
(arr = slice.call( preferredDoc.childNodes )),
preferredDoc.childNodes
);
arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
push = { apply: arr.length ?
function( target, els ) {
push_native.apply( target, slice.call(els) );
} :
function( target, els ) {
var j = target.length,
i = 0;
while ( (target[j++] = els[i++]) ) {}
target.length = j - 1;
}
};
}
function Sizzle( selector, context, results, seed ) {
var m, i, elem, nid, match, groups, newSelector,
newContext = context && context.ownerDocument,
nodeType = context ? context.nodeType : 9;
results = results || [];
if ( typeof selector !== "string" || !selector ||
nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {
return results;
}
if ( !seed ) {
if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
setDocument( context );
}
context = context || document;
if ( documentIsHTML ) {
if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {
if ( (m = match[1]) ) {
if ( nodeType === 9 ) {
if ( (elem = context.getElementById( m )) ) {
if ( elem.id === m ) {
results.push( elem );
return results;
}
} else {
return results;
}
} else {
if ( newContext && (elem = newContext.getElementById( m )) &&
contains( context, elem ) &&
elem.id === m ) {
results.push( elem );
return results;
}
}
} else if ( match[2] ) {
push.apply( results, context.getElementsByTagName( selector ) );
return results;
} else if ( (m = match[3]) && support.getElementsByClassName &&
context.getElementsByClassName ) {
push.apply( results, context.getElementsByClassName( m ) );
return results;
}
}
if ( support.qsa &&
!compilerCache[ selector + " " ] &&
(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
if ( nodeType !== 1 ) {
newContext = context;
newSelector = selector;
} else if ( context.nodeName.toLowerCase() !== "object" ) {
if ( (nid = context.getAttribute( "id" )) ) {
nid = nid.replace( rcssescape, fcssescape );
} else {
context.setAttribute( "id", (nid = expando) );
}
groups = tokenize( selector );
i = groups.length;
while ( i-- ) {
groups[i] = "#" + nid + " " + toSelector( groups[i] );
}
newSelector = groups.join( "," );
newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
context;
}
if ( newSelector ) {
try {
push.apply( results,
newContext.querySelectorAll( newSelector )
);
return results;
} catch ( qsaError ) {
} finally {
if ( nid === expando ) {
context.removeAttribute( "id" );
}
}
}
}
}
}
return select( selector.replace( rtrim, "$1" ), context, results, seed );
}
function createCache() {
var keys = [];
function cache( key, value ) {
if ( keys.push( key + " " ) > Expr.cacheLength ) {
delete cache[ keys.shift() ];
}
return (cache[ key + " " ] = value);
}
return cache;
}
function markFunction( fn ) {
fn[ expando ] = true;
return fn;
}
function assert( fn ) {
var el = document.createElement("fieldset");
try {
return !!fn( el );
} catch (e) {
return false;
} finally {
if ( el.parentNode ) {
el.parentNode.removeChild( el );
}
el = null;
}
}
function addHandle( attrs, handler ) {
var arr = attrs.split("|"),
i = arr.length;
while ( i-- ) {
Expr.attrHandle[ arr[i] ] = handler;
}
}
function siblingCheck( a, b ) {
var cur = b && a,
diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
a.sourceIndex - b.sourceIndex;
if ( diff ) {
return diff;
}
if ( cur ) {
while ( (cur = cur.nextSibling) ) {
if ( cur === b ) {
return -1;
}
}
}
return a ? 1 : -1;
}
function createInputPseudo( type ) {
return function( elem ) {
var name = elem.nodeName.toLowerCase();
return name === "input" && elem.type === type;
};
}
function createButtonPseudo( type ) {
return function( elem ) {
var name = elem.nodeName.toLowerCase();
return (name === "input" || name === "button") && elem.type === type;
};
}
function createDisabledPseudo( disabled ) {
return function( elem ) {
if ( "form" in elem ) {
if ( elem.parentNode && elem.disabled === false ) {
if ( "label" in elem ) {
if ( "label" in elem.parentNode ) {
return elem.parentNode.disabled === disabled;
} else {
return elem.disabled === disabled;
}
}
return elem.isDisabled === disabled ||
elem.isDisabled !== !disabled &&
disabledAncestor( elem ) === disabled;
}
return elem.disabled === disabled;
} else if ( "label" in elem ) {
return elem.disabled === disabled;
}
return false;
};
}
function createPositionalPseudo( fn ) {
return markFunction(function( argument ) {
argument = +argument;
return markFunction(function( seed, matches ) {
var j,
matchIndexes = fn( [], seed.length, argument ),
i = matchIndexes.length;
while ( i-- ) {
if ( seed[ (j = matchIndexes[i]) ] ) {
seed[j] = !(matches[j] = seed[j]);
}
}
});
});
}
function testContext( context ) {
return context && typeof context.getElementsByTagName !== "undefined" && context;
}
support = Sizzle.support = {};
isXML = Sizzle.isXML = function( elem ) {
var documentElement = elem && (elem.ownerDocument || elem).documentElement;
return documentElement ? documentElement.nodeName !== "HTML" : false;
};
setDocument = Sizzle.setDocument = function( node ) {
var hasCompare, subWindow,
doc = node ? node.ownerDocument || node : preferredDoc;
if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
return document;
}
document = doc;
docElem = document.documentElement;
documentIsHTML = !isXML( document );
if ( preferredDoc !== document &&
(subWindow = document.defaultView) && subWindow.top !== subWindow ) {
if ( subWindow.addEventListener ) {
subWindow.addEventListener( "unload", unloadHandler, false );
} else if ( subWindow.attachEvent ) {
subWindow.attachEvent( "onunload", unloadHandler );
}
}
support.attributes = assert(function( el ) {
el.className = "i";
return !el.getAttribute("className");
});
support.getElementsByTagName = assert(function( el ) {
el.appendChild( document.createComment("") );
return !el.getElementsByTagName("*").length;
});
support.getElementsByClassName = rnative.test( document.getElementsByClassName );
support.getById = assert(function( el ) {
docElem.appendChild( el ).id = expando;
return !document.getElementsByName || !document.getElementsByName( expando ).length;
});
if ( support.getById ) {
Expr.filter["ID"] = function( id ) {
var attrId = id.replace( runescape, funescape );
return function( elem ) {
return elem.getAttribute("id") === attrId;
};
};
Expr.find["ID"] = function( id, context ) {
if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
var elem = context.getElementById( id );
return elem ? [ elem ] : [];
}
};
} else {
Expr.filter["ID"] =  function( id ) {
var attrId = id.replace( runescape, funescape );
return function( elem ) {
var node = typeof elem.getAttributeNode !== "undefined" &&
elem.getAttributeNode("id");
return node && node.value === attrId;
};
};
Expr.find["ID"] = function( id, context ) {
if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
var node, i, elems,
elem = context.getElementById( id );
if ( elem ) {
node = elem.getAttributeNode("id");
if ( node && node.value === id ) {
return [ elem ];
}
elems = context.getElementsByName( id );
i = 0;
while ( (elem = elems[i++]) ) {
node = elem.getAttributeNode("id");
if ( node && node.value === id ) {
return [ elem ];
}
}
}
return [];
}
};
}
Expr.find["TAG"] = support.getElementsByTagName ?
function( tag, context ) {
if ( typeof context.getElementsByTagName !== "undefined" ) {
return context.getElementsByTagName( tag );
} else if ( support.qsa ) {
return context.querySelectorAll( tag );
}
} :
function( tag, context ) {
var elem,
tmp = [],
i = 0,
results = context.getElementsByTagName( tag );
if ( tag === "*" ) {
while ( (elem = results[i++]) ) {
if ( elem.nodeType === 1 ) {
tmp.push( elem );
}
}
return tmp;
}
return results;
};
Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
return context.getElementsByClassName( className );
}
};
rbuggyMatches = [];
rbuggyQSA = [];
if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
assert(function( el ) {
docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
"<select id='" + expando + "-\r\\' msallowcapture=''>" +
"<option selected=''></option></select>";
if ( el.querySelectorAll("[msallowcapture^='']").length ) {
rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
}
if ( !el.querySelectorAll("[selected]").length ) {
rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
}
if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
rbuggyQSA.push("~=");
}
if ( !el.querySelectorAll(":checked").length ) {
rbuggyQSA.push(":checked");
}
if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
rbuggyQSA.push(".#.+[+~]");
}
});
assert(function( el ) {
el.innerHTML = "<a href='' disabled='disabled'></a>" +
"<select disabled='disabled'><option/></select>";
var input = document.createElement("input");
input.setAttribute( "type", "hidden" );
el.appendChild( input ).setAttribute( "name", "D" );
if ( el.querySelectorAll("[name=d]").length ) {
rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
}
if ( el.querySelectorAll(":enabled").length !== 2 ) {
rbuggyQSA.push( ":enabled", ":disabled" );
}
docElem.appendChild( el ).disabled = true;
if ( el.querySelectorAll(":disabled").length !== 2 ) {
rbuggyQSA.push( ":enabled", ":disabled" );
}
el.querySelectorAll("*,:x");
rbuggyQSA.push(",.*:");
});
}
if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
docElem.webkitMatchesSelector ||
docElem.mozMatchesSelector ||
docElem.oMatchesSelector ||
docElem.msMatchesSelector) )) ) {
assert(function( el ) {
support.disconnectedMatch = matches.call( el, "*" );
matches.call( el, "[s!='']:x" );
rbuggyMatches.push( "!=", pseudos );
});
}
rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );
hasCompare = rnative.test( docElem.compareDocumentPosition );
contains = hasCompare || rnative.test( docElem.contains ) ?
function( a, b ) {
var adown = a.nodeType === 9 ? a.documentElement : a,
bup = b && b.parentNode;
return a === bup || !!( bup && bup.nodeType === 1 && (
adown.contains ?
adown.contains( bup ) :
a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
));
} :
function( a, b ) {
if ( b ) {
while ( (b = b.parentNode) ) {
if ( b === a ) {
return true;
}
}
}
return false;
};
sortOrder = hasCompare ?
function( a, b ) {
if ( a === b ) {
hasDuplicate = true;
return 0;
}
var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
if ( compare ) {
return compare;
}
compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
a.compareDocumentPosition( b ) :
1;
if ( compare & 1 ||
(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {
if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
return -1;
}
if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
return 1;
}
return sortInput ?
( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
0;
}
return compare & 4 ? -1 : 1;
} :
function( a, b ) {
if ( a === b ) {
hasDuplicate = true;
return 0;
}
var cur,
i = 0,
aup = a.parentNode,
bup = b.parentNode,
ap = [ a ],
bp = [ b ];
if ( !aup || !bup ) {
return a === document ? -1 :
b === document ? 1 :
aup ? -1 :
bup ? 1 :
sortInput ?
( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
0;
} else if ( aup === bup ) {
return siblingCheck( a, b );
}
cur = a;
while ( (cur = cur.parentNode) ) {
ap.unshift( cur );
}
cur = b;
while ( (cur = cur.parentNode) ) {
bp.unshift( cur );
}
while ( ap[i] === bp[i] ) {
i++;
}
return i ?
siblingCheck( ap[i], bp[i] ) :
ap[i] === preferredDoc ? -1 :
bp[i] === preferredDoc ? 1 :
0;
};
return document;
};
Sizzle.matches = function( expr, elements ) {
return Sizzle( expr, null, null, elements );
};
Sizzle.matchesSelector = function( elem, expr ) {
if ( ( elem.ownerDocument || elem ) !== document ) {
setDocument( elem );
}
expr = expr.replace( rattributeQuotes, "='$1']" );
if ( support.matchesSelector && documentIsHTML &&
!compilerCache[ expr + " " ] &&
( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {
try {
var ret = matches.call( elem, expr );
if ( ret || support.disconnectedMatch ||
elem.document && elem.document.nodeType !== 11 ) {
return ret;
}
} catch (e) {}
}
return Sizzle( expr, document, null, [ elem ] ).length > 0;
};
Sizzle.contains = function( context, elem ) {
if ( ( context.ownerDocument || context ) !== document ) {
setDocument( context );
}
return contains( context, elem );
};
Sizzle.attr = function( elem, name ) {
if ( ( elem.ownerDocument || elem ) !== document ) {
setDocument( elem );
}
var fn = Expr.attrHandle[ name.toLowerCase() ],
val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
fn( elem, name, !documentIsHTML ) :
undefined;
return val !== undefined ?
val :
support.attributes || !documentIsHTML ?
elem.getAttribute( name ) :
(val = elem.getAttributeNode(name)) && val.specified ?
val.value :
null;
};
Sizzle.escape = function( sel ) {
return (sel + "").replace( rcssescape, fcssescape );
};
Sizzle.error = function( msg ) {
throw new Error( "Syntax error, unrecognized expression: " + msg );
};
Sizzle.uniqueSort = function( results ) {
var elem,
duplicates = [],
j = 0,
i = 0;
hasDuplicate = !support.detectDuplicates;
sortInput = !support.sortStable && results.slice( 0 );
results.sort( sortOrder );
if ( hasDuplicate ) {
while ( (elem = results[i++]) ) {
if ( elem === results[ i ] ) {
j = duplicates.push( i );
}
}
while ( j-- ) {
results.splice( duplicates[ j ], 1 );
}
}
sortInput = null;
return results;
};
getText = Sizzle.getText = function( elem ) {
var node,
ret = "",
i = 0,
nodeType = elem.nodeType;
if ( !nodeType ) {
while ( (node = elem[i++]) ) {
ret += getText( node );
}
} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
if ( typeof elem.textContent === "string" ) {
return elem.textContent;
} else {
for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
ret += getText( elem );
}
}
} else if ( nodeType === 3 || nodeType === 4 ) {
return elem.nodeValue;
}
return ret;
};
Expr = Sizzle.selectors = {
cacheLength: 50,
createPseudo: markFunction,
match: matchExpr,
attrHandle: {},
find: {},
relative: {
">": { dir: "parentNode", first: true },
" ": { dir: "parentNode" },
"+": { dir: "previousSibling", first: true },
"~": { dir: "previousSibling" }
},
preFilter: {
"ATTR": function( match ) {
match[1] = match[1].replace( runescape, funescape );
match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );
if ( match[2] === "~=" ) {
match[3] = " " + match[3] + " ";
}
return match.slice( 0, 4 );
},
"CHILD": function( match ) {
match[1] = match[1].toLowerCase();
if ( match[1].slice( 0, 3 ) === "nth" ) {
if ( !match[3] ) {
Sizzle.error( match[0] );
}
match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );
} else if ( match[3] ) {
Sizzle.error( match[0] );
}
return match;
},
"PSEUDO": function( match ) {
var excess,
unquoted = !match[6] && match[2];
if ( matchExpr["CHILD"].test( match[0] ) ) {
return null;
}
if ( match[3] ) {
match[2] = match[4] || match[5] || "";
} else if ( unquoted && rpseudo.test( unquoted ) &&
(excess = tokenize( unquoted, true )) &&
(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {
match[0] = match[0].slice( 0, excess );
match[2] = unquoted.slice( 0, excess );
}
return match.slice( 0, 3 );
}
},
filter: {
"TAG": function( nodeNameSelector ) {
var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
return nodeNameSelector === "*" ?
function() { return true; } :
function( elem ) {
return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
};
},
"CLASS": function( className ) {
var pattern = classCache[ className + " " ];
return pattern ||
(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
classCache( className, function( elem ) {
return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
});
},
"ATTR": function( name, operator, check ) {
return function( elem ) {
var result = Sizzle.attr( elem, name );
if ( result == null ) {
return operator === "!=";
}
if ( !operator ) {
return true;
}
result += "";
return operator === "=" ? result === check :
operator === "!=" ? result !== check :
operator === "^=" ? check && result.indexOf( check ) === 0 :
operator === "*=" ? check && result.indexOf( check ) > -1 :
operator === "$=" ? check && result.slice( -check.length ) === check :
operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
false;
};
},
"CHILD": function( type, what, argument, first, last ) {
var simple = type.slice( 0, 3 ) !== "nth",
forward = type.slice( -4 ) !== "last",
ofType = what === "of-type";
return first === 1 && last === 0 ?
function( elem ) {
return !!elem.parentNode;
} :
function( elem, context, xml ) {
var cache, uniqueCache, outerCache, node, nodeIndex, start,
dir = simple !== forward ? "nextSibling" : "previousSibling",
parent = elem.parentNode,
name = ofType && elem.nodeName.toLowerCase(),
useCache = !xml && !ofType,
diff = false;
if ( parent ) {
if ( simple ) {
while ( dir ) {
node = elem;
while ( (node = node[ dir ]) ) {
if ( ofType ?
node.nodeName.toLowerCase() === name :
node.nodeType === 1 ) {
return false;
}
}
start = dir = type === "only" && !start && "nextSibling";
}
return true;
}
start = [ forward ? parent.firstChild : parent.lastChild ];
if ( forward && useCache ) {
node = parent;
outerCache = node[ expando ] || (node[ expando ] = {});
uniqueCache = outerCache[ node.uniqueID ] ||
(outerCache[ node.uniqueID ] = {});
cache = uniqueCache[ type ] || [];
nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
diff = nodeIndex && cache[ 2 ];
node = nodeIndex && parent.childNodes[ nodeIndex ];
while ( (node = ++nodeIndex && node && node[ dir ] ||
(diff = nodeIndex = 0) || start.pop()) ) {
if ( node.nodeType === 1 && ++diff && node === elem ) {
uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
break;
}
}
} else {
if ( useCache ) {
node = elem;
outerCache = node[ expando ] || (node[ expando ] = {});
uniqueCache = outerCache[ node.uniqueID ] ||
(outerCache[ node.uniqueID ] = {});
cache = uniqueCache[ type ] || [];
nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
diff = nodeIndex;
}
if ( diff === false ) {
while ( (node = ++nodeIndex && node && node[ dir ] ||
(diff = nodeIndex = 0) || start.pop()) ) {
if ( ( ofType ?
node.nodeName.toLowerCase() === name :
node.nodeType === 1 ) &&
++diff ) {
if ( useCache ) {
outerCache = node[ expando ] || (node[ expando ] = {});
uniqueCache = outerCache[ node.uniqueID ] ||
(outerCache[ node.uniqueID ] = {});
uniqueCache[ type ] = [ dirruns, diff ];
}
if ( node === elem ) {
break;
}
}
}
}
}
diff -= last;
return diff === first || ( diff % first === 0 && diff / first >= 0 );
}
};
},
"PSEUDO": function( pseudo, argument ) {
var args,
fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
Sizzle.error( "unsupported pseudo: " + pseudo );
if ( fn[ expando ] ) {
return fn( argument );
}
if ( fn.length > 1 ) {
args = [ pseudo, pseudo, "", argument ];
return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
markFunction(function( seed, matches ) {
var idx,
matched = fn( seed, argument ),
i = matched.length;
while ( i-- ) {
idx = indexOf( seed, matched[i] );
seed[ idx ] = !( matches[ idx ] = matched[i] );
}
}) :
function( elem ) {
return fn( elem, 0, args );
};
}
return fn;
}
},
pseudos: {
"not": markFunction(function( selector ) {
var input = [],
results = [],
matcher = compile( selector.replace( rtrim, "$1" ) );
return matcher[ expando ] ?
markFunction(function( seed, matches, context, xml ) {
var elem,
unmatched = matcher( seed, null, xml, [] ),
i = seed.length;
while ( i-- ) {
if ( (elem = unmatched[i]) ) {
seed[i] = !(matches[i] = elem);
}
}
}) :
function( elem, context, xml ) {
input[0] = elem;
matcher( input, null, xml, results );
input[0] = null;
return !results.pop();
};
}),
"has": markFunction(function( selector ) {
return function( elem ) {
return Sizzle( selector, elem ).length > 0;
};
}),
"contains": markFunction(function( text ) {
text = text.replace( runescape, funescape );
return function( elem ) {
return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
};
}),
"lang": markFunction( function( lang ) {
if ( !ridentifier.test(lang || "") ) {
Sizzle.error( "unsupported lang: " + lang );
}
lang = lang.replace( runescape, funescape ).toLowerCase();
return function( elem ) {
var elemLang;
do {
if ( (elemLang = documentIsHTML ?
elem.lang :
elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {
elemLang = elemLang.toLowerCase();
return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
}
} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
return false;
};
}),
"target": function( elem ) {
var hash = window.location && window.location.hash;
return hash && hash.slice( 1 ) === elem.id;
},
"root": function( elem ) {
return elem === docElem;
},
"focus": function( elem ) {
return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
},
"enabled": createDisabledPseudo( false ),
"disabled": createDisabledPseudo( true ),
"checked": function( elem ) {
var nodeName = elem.nodeName.toLowerCase();
return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
},
"selected": function( elem ) {
if ( elem.parentNode ) {
elem.parentNode.selectedIndex;
}
return elem.selected === true;
},
"empty": function( elem ) {
for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
if ( elem.nodeType < 6 ) {
return false;
}
}
return true;
},
"parent": function( elem ) {
return !Expr.pseudos["empty"]( elem );
},
"header": function( elem ) {
return rheader.test( elem.nodeName );
},
"input": function( elem ) {
return rinputs.test( elem.nodeName );
},
"button": function( elem ) {
var name = elem.nodeName.toLowerCase();
return name === "input" && elem.type === "button" || name === "button";
},
"text": function( elem ) {
var attr;
return elem.nodeName.toLowerCase() === "input" &&
elem.type === "text" &&
( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
},
"first": createPositionalPseudo(function() {
return [ 0 ];
}),
"last": createPositionalPseudo(function( matchIndexes, length ) {
return [ length - 1 ];
}),
"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
return [ argument < 0 ? argument + length : argument ];
}),
"even": createPositionalPseudo(function( matchIndexes, length ) {
var i = 0;
for ( ; i < length; i += 2 ) {
matchIndexes.push( i );
}
return matchIndexes;
}),
"odd": createPositionalPseudo(function( matchIndexes, length ) {
var i = 1;
for ( ; i < length; i += 2 ) {
matchIndexes.push( i );
}
return matchIndexes;
}),
"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
var i = argument < 0 ? argument + length : argument;
for ( ; --i >= 0; ) {
matchIndexes.push( i );
}
return matchIndexes;
}),
"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
var i = argument < 0 ? argument + length : argument;
for ( ; ++i < length; ) {
matchIndexes.push( i );
}
return matchIndexes;
})
}
};
Expr.pseudos["nth"] = Expr.pseudos["eq"];
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
Expr.pseudos[ i ] = createButtonPseudo( i );
}
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();
tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
var matched, match, tokens, type,
soFar, groups, preFilters,
cached = tokenCache[ selector + " " ];
if ( cached ) {
return parseOnly ? 0 : cached.slice( 0 );
}
soFar = selector;
groups = [];
preFilters = Expr.preFilter;
while ( soFar ) {
if ( !matched || (match = rcomma.exec( soFar )) ) {
if ( match ) {
soFar = soFar.slice( match[0].length ) || soFar;
}
groups.push( (tokens = []) );
}
matched = false;
if ( (match = rcombinators.exec( soFar )) ) {
matched = match.shift();
tokens.push({
value: matched,
type: match[0].replace( rtrim, " " )
});
soFar = soFar.slice( matched.length );
}
for ( type in Expr.filter ) {
if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
(match = preFilters[ type ]( match ))) ) {
matched = match.shift();
tokens.push({
value: matched,
type: type,
matches: match
});
soFar = soFar.slice( matched.length );
}
}
if ( !matched ) {
break;
}
}
return parseOnly ?
soFar.length :
soFar ?
Sizzle.error( selector ) :
tokenCache( selector, groups ).slice( 0 );
};
function toSelector( tokens ) {
var i = 0,
len = tokens.length,
selector = "";
for ( ; i < len; i++ ) {
selector += tokens[i].value;
}
return selector;
}
function addCombinator( matcher, combinator, base ) {
var dir = combinator.dir,
skip = combinator.next,
key = skip || dir,
checkNonElements = base && key === "parentNode",
doneName = done++;
return combinator.first ?
function( elem, context, xml ) {
while ( (elem = elem[ dir ]) ) {
if ( elem.nodeType === 1 || checkNonElements ) {
return matcher( elem, context, xml );
}
}
return false;
} :
function( elem, context, xml ) {
var oldCache, uniqueCache, outerCache,
newCache = [ dirruns, doneName ];
if ( xml ) {
while ( (elem = elem[ dir ]) ) {
if ( elem.nodeType === 1 || checkNonElements ) {
if ( matcher( elem, context, xml ) ) {
return true;
}
}
}
} else {
while ( (elem = elem[ dir ]) ) {
if ( elem.nodeType === 1 || checkNonElements ) {
outerCache = elem[ expando ] || (elem[ expando ] = {});
uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});
if ( skip && skip === elem.nodeName.toLowerCase() ) {
elem = elem[ dir ] || elem;
} else if ( (oldCache = uniqueCache[ key ]) &&
oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {
return (newCache[ 2 ] = oldCache[ 2 ]);
} else {
uniqueCache[ key ] = newCache;
if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
return true;
}
}
}
}
}
return false;
};
}
function elementMatcher( matchers ) {
return matchers.length > 1 ?
function( elem, context, xml ) {
var i = matchers.length;
while ( i-- ) {
if ( !matchers[i]( elem, context, xml ) ) {
return false;
}
}
return true;
} :
matchers[0];
}
function multipleContexts( selector, contexts, results ) {
var i = 0,
len = contexts.length;
for ( ; i < len; i++ ) {
Sizzle( selector, contexts[i], results );
}
return results;
}
function condense( unmatched, map, filter, context, xml ) {
var elem,
newUnmatched = [],
i = 0,
len = unmatched.length,
mapped = map != null;
for ( ; i < len; i++ ) {
if ( (elem = unmatched[i]) ) {
if ( !filter || filter( elem, context, xml ) ) {
newUnmatched.push( elem );
if ( mapped ) {
map.push( i );
}
}
}
}
return newUnmatched;
}
function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
if ( postFilter && !postFilter[ expando ] ) {
postFilter = setMatcher( postFilter );
}
if ( postFinder && !postFinder[ expando ] ) {
postFinder = setMatcher( postFinder, postSelector );
}
return markFunction(function( seed, results, context, xml ) {
var temp, i, elem,
preMap = [],
postMap = [],
preexisting = results.length,
elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),
matcherIn = preFilter && ( seed || !selector ) ?
condense( elems, preMap, preFilter, context, xml ) :
elems,
matcherOut = matcher ?
postFinder || ( seed ? preFilter : preexisting || postFilter ) ?
[] :
results :
matcherIn;
if ( matcher ) {
matcher( matcherIn, matcherOut, context, xml );
}
if ( postFilter ) {
temp = condense( matcherOut, postMap );
postFilter( temp, [], context, xml );
i = temp.length;
while ( i-- ) {
if ( (elem = temp[i]) ) {
matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
}
}
}
if ( seed ) {
if ( postFinder || preFilter ) {
if ( postFinder ) {
temp = [];
i = matcherOut.length;
while ( i-- ) {
if ( (elem = matcherOut[i]) ) {
temp.push( (matcherIn[i] = elem) );
}
}
postFinder( null, (matcherOut = []), temp, xml );
}
i = matcherOut.length;
while ( i-- ) {
if ( (elem = matcherOut[i]) &&
(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {
seed[temp] = !(results[temp] = elem);
}
}
}
} else {
matcherOut = condense(
matcherOut === results ?
matcherOut.splice( preexisting, matcherOut.length ) :
matcherOut
);
if ( postFinder ) {
postFinder( null, results, matcherOut, xml );
} else {
push.apply( results, matcherOut );
}
}
});
}
function matcherFromTokens( tokens ) {
var checkContext, matcher, j,
len = tokens.length,
leadingRelative = Expr.relative[ tokens[0].type ],
implicitRelative = leadingRelative || Expr.relative[" "],
i = leadingRelative ? 1 : 0,
matchContext = addCombinator( function( elem ) {
return elem === checkContext;
}, implicitRelative, true ),
matchAnyContext = addCombinator( function( elem ) {
return indexOf( checkContext, elem ) > -1;
}, implicitRelative, true ),
matchers = [ function( elem, context, xml ) {
var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
(checkContext = context).nodeType ?
matchContext( elem, context, xml ) :
matchAnyContext( elem, context, xml ) );
checkContext = null;
return ret;
} ];
for ( ; i < len; i++ ) {
if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
} else {
matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );
if ( matcher[ expando ] ) {
j = ++i;
for ( ; j < len; j++ ) {
if ( Expr.relative[ tokens[j].type ] ) {
break;
}
}
return setMatcher(
i > 1 && elementMatcher( matchers ),
i > 1 && toSelector(
tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
).replace( rtrim, "$1" ),
matcher,
i < j && matcherFromTokens( tokens.slice( i, j ) ),
j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
j < len && toSelector( tokens )
);
}
matchers.push( matcher );
}
}
return elementMatcher( matchers );
}
function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
var bySet = setMatchers.length > 0,
byElement = elementMatchers.length > 0,
superMatcher = function( seed, context, xml, results, outermost ) {
var elem, j, matcher,
matchedCount = 0,
i = "0",
unmatched = seed && [],
setMatched = [],
contextBackup = outermostContext,
elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
len = elems.length;
if ( outermost ) {
outermostContext = context === document || context || outermost;
}
for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
if ( byElement && elem ) {
j = 0;
if ( !context && elem.ownerDocument !== document ) {
setDocument( elem );
xml = !documentIsHTML;
}
while ( (matcher = elementMatchers[j++]) ) {
if ( matcher( elem, context || document, xml) ) {
results.push( elem );
break;
}
}
if ( outermost ) {
dirruns = dirrunsUnique;
}
}
if ( bySet ) {
if ( (elem = !matcher && elem) ) {
matchedCount--;
}
if ( seed ) {
unmatched.push( elem );
}
}
}
matchedCount += i;
if ( bySet && i !== matchedCount ) {
j = 0;
while ( (matcher = setMatchers[j++]) ) {
matcher( unmatched, setMatched, context, xml );
}
if ( seed ) {
if ( matchedCount > 0 ) {
while ( i-- ) {
if ( !(unmatched[i] || setMatched[i]) ) {
setMatched[i] = pop.call( results );
}
}
}
setMatched = condense( setMatched );
}
push.apply( results, setMatched );
if ( outermost && !seed && setMatched.length > 0 &&
( matchedCount + setMatchers.length ) > 1 ) {
Sizzle.uniqueSort( results );
}
}
if ( outermost ) {
dirruns = dirrunsUnique;
outermostContext = contextBackup;
}
return unmatched;
};
return bySet ?
markFunction( superMatcher ) :
superMatcher;
}
compile = Sizzle.compile = function( selector, match ) {
var i,
setMatchers = [],
elementMatchers = [],
cached = compilerCache[ selector + " " ];
if ( !cached ) {
if ( !match ) {
match = tokenize( selector );
}
i = match.length;
while ( i-- ) {
cached = matcherFromTokens( match[i] );
if ( cached[ expando ] ) {
setMatchers.push( cached );
} else {
elementMatchers.push( cached );
}
}
cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );
cached.selector = selector;
}
return cached;
};
select = Sizzle.select = function( selector, context, results, seed ) {
var i, tokens, token, type, find,
compiled = typeof selector === "function" && selector,
match = !seed && tokenize( (selector = compiled.selector || selector) );
results = results || [];
if ( match.length === 1 ) {
tokens = match[0] = match[0].slice( 0 );
if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {
context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
if ( !context ) {
return results;
} else if ( compiled ) {
context = context.parentNode;
}
selector = selector.slice( tokens.shift().value.length );
}
i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
while ( i-- ) {
token = tokens[i];
if ( Expr.relative[ (type = token.type) ] ) {
break;
}
if ( (find = Expr.find[ type ]) ) {
if ( (seed = find(
token.matches[0].replace( runescape, funescape ),
rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
)) ) {
tokens.splice( i, 1 );
selector = seed.length && toSelector( tokens );
if ( !selector ) {
push.apply( results, seed );
return results;
}
break;
}
}
}
}
( compiled || compile( selector, match ) )(
seed,
context,
!documentIsHTML,
results,
!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
);
return results;
};
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;
support.detectDuplicates = !!hasDuplicate;
setDocument();
support.sortDetached = assert(function( el ) {
return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
});
if ( !assert(function( el ) {
el.innerHTML = "<a href='#'></a>";
return el.firstChild.getAttribute("href") === "#" ;
}) ) {
addHandle( "type|href|height|width", function( elem, name, isXML ) {
if ( !isXML ) {
return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
}
});
}
if ( !support.attributes || !assert(function( el ) {
el.innerHTML = "<input/>";
el.firstChild.setAttribute( "value", "" );
return el.firstChild.getAttribute( "value" ) === "";
}) ) {
addHandle( "value", function( elem, name, isXML ) {
if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
return elem.defaultValue;
}
});
}
if ( !assert(function( el ) {
return el.getAttribute("disabled") == null;
}) ) {
addHandle( booleans, function( elem, name, isXML ) {
var val;
if ( !isXML ) {
return elem[ name ] === true ? name.toLowerCase() :
(val = elem.getAttributeNode( name )) && val.specified ?
val.value :
null;
}
});
}
return Sizzle;
})( window );
jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;
jQuery.escapeSelector = Sizzle.escape;
var dir = function( elem, dir, until ) {
var matched = [],
truncate = until !== undefined;
while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
if ( elem.nodeType === 1 ) {
if ( truncate && jQuery( elem ).is( until ) ) {
break;
}
matched.push( elem );
}
}
return matched;
};
var siblings = function( n, elem ) {
var matched = [];
for ( ; n; n = n.nextSibling ) {
if ( n.nodeType === 1 && n !== elem ) {
matched.push( n );
}
}
return matched;
};
var rneedsContext = jQuery.expr.match.needsContext;
function nodeName( elem, name ) {
return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
};
var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );
var risSimple = /^.[^:#\[\.,]*$/;
function winnow( elements, qualifier, not ) {
if ( jQuery.isFunction( qualifier ) ) {
return jQuery.grep( elements, function( elem, i ) {
return !!qualifier.call( elem, i, elem ) !== not;
} );
}
if ( qualifier.nodeType ) {
return jQuery.grep( elements, function( elem ) {
return ( elem === qualifier ) !== not;
} );
}
if ( typeof qualifier !== "string" ) {
return jQuery.grep( elements, function( elem ) {
return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
} );
}
if ( risSimple.test( qualifier ) ) {
return jQuery.filter( qualifier, elements, not );
}
qualifier = jQuery.filter( qualifier, elements );
return jQuery.grep( elements, function( elem ) {
return ( indexOf.call( qualifier, elem ) > -1 ) !== not && elem.nodeType === 1;
} );
}
jQuery.filter = function( expr, elems, not ) {
var elem = elems[ 0 ];
if ( not ) {
expr = ":not(" + expr + ")";
}
if ( elems.length === 1 && elem.nodeType === 1 ) {
return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
}
return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
return elem.nodeType === 1;
} ) );
};
jQuery.fn.extend( {
find: function( selector ) {
var i, ret,
len = this.length,
self = this;
if ( typeof selector !== "string" ) {
return this.pushStack( jQuery( selector ).filter( function() {
for ( i = 0; i < len; i++ ) {
if ( jQuery.contains( self[ i ], this ) ) {
return true;
}
}
} ) );
}
ret = this.pushStack( [] );
for ( i = 0; i < len; i++ ) {
jQuery.find( selector, self[ i ], ret );
}
return len > 1 ? jQuery.uniqueSort( ret ) : ret;
},
filter: function( selector ) {
return this.pushStack( winnow( this, selector || [], false ) );
},
not: function( selector ) {
return this.pushStack( winnow( this, selector || [], true ) );
},
is: function( selector ) {
return !!winnow(
this,
typeof selector === "string" && rneedsContext.test( selector ) ?
jQuery( selector ) :
selector || [],
false
).length;
}
} );
var rootjQuery,
rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,
init = jQuery.fn.init = function( selector, context, root ) {
var match, elem;
if ( !selector ) {
return this;
}
root = root || rootjQuery;
if ( typeof selector === "string" ) {
if ( selector[ 0 ] === "<" &&
selector[ selector.length - 1 ] === ">" &&
selector.length >= 3 ) {
match = [ null, selector, null ];
} else {
match = rquickExpr.exec( selector );
}
if ( match && ( match[ 1 ] || !context ) ) {
if ( match[ 1 ] ) {
context = context instanceof jQuery ? context[ 0 ] : context;
jQuery.merge( this, jQuery.parseHTML(
match[ 1 ],
context && context.nodeType ? context.ownerDocument || context : document,
true
) );
if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
for ( match in context ) {
if ( jQuery.isFunction( this[ match ] ) ) {
this[ match ]( context[ match ] );
} else {
this.attr( match, context[ match ] );
}
}
}
return this;
} else {
elem = document.getElementById( match[ 2 ] );
if ( elem ) {
this[ 0 ] = elem;
this.length = 1;
}
return this;
}
} else if ( !context || context.jquery ) {
return ( context || root ).find( selector );
} else {
return this.constructor( context ).find( selector );
}
} else if ( selector.nodeType ) {
this[ 0 ] = selector;
this.length = 1;
return this;
} else if ( jQuery.isFunction( selector ) ) {
return root.ready !== undefined ?
root.ready( selector ) :
selector( jQuery );
}
return jQuery.makeArray( selector, this );
};
init.prototype = jQuery.fn;
rootjQuery = jQuery( document );
var rparentsprev = /^(?:parents|prev(?:Until|All))/,
guaranteedUnique = {
children: true,
contents: true,
next: true,
prev: true
};
jQuery.fn.extend( {
has: function( target ) {
var targets = jQuery( target, this ),
l = targets.length;
return this.filter( function() {
var i = 0;
for ( ; i < l; i++ ) {
if ( jQuery.contains( this, targets[ i ] ) ) {
return true;
}
}
} );
},
closest: function( selectors, context ) {
var cur,
i = 0,
l = this.length,
matched = [],
targets = typeof selectors !== "string" && jQuery( selectors );
if ( !rneedsContext.test( selectors ) ) {
for ( ; i < l; i++ ) {
for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {
if ( cur.nodeType < 11 && ( targets ?
targets.index( cur ) > -1 :
cur.nodeType === 1 &&
jQuery.find.matchesSelector( cur, selectors ) ) ) {
matched.push( cur );
break;
}
}
}
}
return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
},
index: function( elem ) {
if ( !elem ) {
return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
}
if ( typeof elem === "string" ) {
return indexOf.call( jQuery( elem ), this[ 0 ] );
}
return indexOf.call( this,
elem.jquery ? elem[ 0 ] : elem
);
},
add: function( selector, context ) {
return this.pushStack(
jQuery.uniqueSort(
jQuery.merge( this.get(), jQuery( selector, context ) )
)
);
},
addBack: function( selector ) {
return this.add( selector == null ?
this.prevObject : this.prevObject.filter( selector )
);
}
} );
function sibling( cur, dir ) {
while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
return cur;
}
jQuery.each( {
parent: function( elem ) {
var parent = elem.parentNode;
return parent && parent.nodeType !== 11 ? parent : null;
},
parents: function( elem ) {
return dir( elem, "parentNode" );
},
parentsUntil: function( elem, i, until ) {
return dir( elem, "parentNode", until );
},
next: function( elem ) {
return sibling( elem, "nextSibling" );
},
prev: function( elem ) {
return sibling( elem, "previousSibling" );
},
nextAll: function( elem ) {
return dir( elem, "nextSibling" );
},
prevAll: function( elem ) {
return dir( elem, "previousSibling" );
},
nextUntil: function( elem, i, until ) {
return dir( elem, "nextSibling", until );
},
prevUntil: function( elem, i, until ) {
return dir( elem, "previousSibling", until );
},
siblings: function( elem ) {
return siblings( ( elem.parentNode || {} ).firstChild, elem );
},
children: function( elem ) {
return siblings( elem.firstChild );
},
contents: function( elem ) {
if ( nodeName( elem, "iframe" ) ) {
return elem.contentDocument;
}
if ( nodeName( elem, "template" ) ) {
elem = elem.content || elem;
}
return jQuery.merge( [], elem.childNodes );
}
}, function( name, fn ) {
jQuery.fn[ name ] = function( until, selector ) {
var matched = jQuery.map( this, fn, until );
if ( name.slice( -5 ) !== "Until" ) {
selector = until;
}
if ( selector && typeof selector === "string" ) {
matched = jQuery.filter( selector, matched );
}
if ( this.length > 1 ) {
if ( !guaranteedUnique[ name ] ) {
jQuery.uniqueSort( matched );
}
if ( rparentsprev.test( name ) ) {
matched.reverse();
}
}
return this.pushStack( matched );
};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );
function createOptions( options ) {
var object = {};
jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
object[ flag ] = true;
} );
return object;
}
jQuery.Callbacks = function( options ) {
options = typeof options === "string" ?
createOptions( options ) :
jQuery.extend( {}, options );
var // Flag to know if list is currently firing
firing,
memory,
fired,
locked,
list = [],
queue = [],
firingIndex = -1,
fire = function() {
locked = locked || options.once;
fired = firing = true;
for ( ; queue.length; firingIndex = -1 ) {
memory = queue.shift();
while ( ++firingIndex < list.length ) {
if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
options.stopOnFalse ) {
firingIndex = list.length;
memory = false;
}
}
}
if ( !options.memory ) {
memory = false;
}
firing = false;
if ( locked ) {
if ( memory ) {
list = [];
} else {
list = "";
}
}
},
self = {
add: function() {
if ( list ) {
if ( memory && !firing ) {
firingIndex = list.length - 1;
queue.push( memory );
}
( function add( args ) {
jQuery.each( args, function( _, arg ) {
if ( jQuery.isFunction( arg ) ) {
if ( !options.unique || !self.has( arg ) ) {
list.push( arg );
}
} else if ( arg && arg.length && jQuery.type( arg ) !== "string" ) {
add( arg );
}
} );
} )( arguments );
if ( memory && !firing ) {
fire();
}
}
return this;
},
remove: function() {
jQuery.each( arguments, function( _, arg ) {
var index;
while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
list.splice( index, 1 );
if ( index <= firingIndex ) {
firingIndex--;
}
}
} );
return this;
},
has: function( fn ) {
return fn ?
jQuery.inArray( fn, list ) > -1 :
list.length > 0;
},
empty: function() {
if ( list ) {
list = [];
}
return this;
},
disable: function() {
locked = queue = [];
list = memory = "";
return this;
},
disabled: function() {
return !list;
},
lock: function() {
locked = queue = [];
if ( !memory && !firing ) {
list = memory = "";
}
return this;
},
locked: function() {
return !!locked;
},
fireWith: function( context, args ) {
if ( !locked ) {
args = args || [];
args = [ context, args.slice ? args.slice() : args ];
queue.push( args );
if ( !firing ) {
fire();
}
}
return this;
},
fire: function() {
self.fireWith( this, arguments );
return this;
},
fired: function() {
return !!fired;
}
};
return self;
};
function Identity( v ) {
return v;
}
function Thrower( ex ) {
throw ex;
}
function adoptValue( value, resolve, reject, noValue ) {
var method;
try {
if ( value && jQuery.isFunction( ( method = value.promise ) ) ) {
method.call( value ).done( resolve ).fail( reject );
} else if ( value && jQuery.isFunction( ( method = value.then ) ) ) {
method.call( value, resolve, reject );
} else {
resolve.apply( undefined, [ value ].slice( noValue ) );
}
} catch ( value ) {
reject.apply( undefined, [ value ] );
}
}
jQuery.extend( {
Deferred: function( func ) {
var tuples = [
[ "notify", "progress", jQuery.Callbacks( "memory" ),
jQuery.Callbacks( "memory" ), 2 ],
[ "resolve", "done", jQuery.Callbacks( "once memory" ),
jQuery.Callbacks( "once memory" ), 0, "resolved" ],
[ "reject", "fail", jQuery.Callbacks( "once memory" ),
jQuery.Callbacks( "once memory" ), 1, "rejected" ]
],
state = "pending",
promise = {
state: function() {
return state;
},
always: function() {
deferred.done( arguments ).fail( arguments );
return this;
},
"catch": function( fn ) {
return promise.then( null, fn );
},
pipe: function( ) {
var fns = arguments;
return jQuery.Deferred( function( newDefer ) {
jQuery.each( tuples, function( i, tuple ) {
var fn = jQuery.isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];
deferred[ tuple[ 1 ] ]( function() {
var returned = fn && fn.apply( this, arguments );
if ( returned && jQuery.isFunction( returned.promise ) ) {
returned.promise()
.progress( newDefer.notify )
.done( newDefer.resolve )
.fail( newDefer.reject );
} else {
newDefer[ tuple[ 0 ] + "With" ](
this,
fn ? [ returned ] : arguments
);
}
} );
} );
fns = null;
} ).promise();
},
then: function( onFulfilled, onRejected, onProgress ) {
var maxDepth = 0;
function resolve( depth, deferred, handler, special ) {
return function() {
var that = this,
args = arguments,
mightThrow = function() {
var returned, then;
if ( depth < maxDepth ) {
return;
}
returned = handler.apply( that, args );
if ( returned === deferred.promise() ) {
throw new TypeError( "Thenable self-resolution" );
}
then = returned &&
( typeof returned === "object" ||
typeof returned === "function" ) &&
returned.then;
if ( jQuery.isFunction( then ) ) {
if ( special ) {
then.call(
returned,
resolve( maxDepth, deferred, Identity, special ),
resolve( maxDepth, deferred, Thrower, special )
);
} else {
maxDepth++;
then.call(
returned,
resolve( maxDepth, deferred, Identity, special ),
resolve( maxDepth, deferred, Thrower, special ),
resolve( maxDepth, deferred, Identity,
deferred.notifyWith )
);
}
} else {
if ( handler !== Identity ) {
that = undefined;
args = [ returned ];
}
( special || deferred.resolveWith )( that, args );
}
},
process = special ?
mightThrow :
function() {
try {
mightThrow();
} catch ( e ) {
if ( jQuery.Deferred.exceptionHook ) {
jQuery.Deferred.exceptionHook( e,
process.stackTrace );
}
if ( depth + 1 >= maxDepth ) {
if ( handler !== Thrower ) {
that = undefined;
args = [ e ];
}
deferred.rejectWith( that, args );
}
}
};
if ( depth ) {
process();
} else {
if ( jQuery.Deferred.getStackHook ) {
process.stackTrace = jQuery.Deferred.getStackHook();
}
window.setTimeout( process );
}
};
}
return jQuery.Deferred( function( newDefer ) {
tuples[ 0 ][ 3 ].add(
resolve(
0,
newDefer,
jQuery.isFunction( onProgress ) ?
onProgress :
Identity,
newDefer.notifyWith
)
);
tuples[ 1 ][ 3 ].add(
resolve(
0,
newDefer,
jQuery.isFunction( onFulfilled ) ?
onFulfilled :
Identity
)
);
tuples[ 2 ][ 3 ].add(
resolve(
0,
newDefer,
jQuery.isFunction( onRejected ) ?
onRejected :
Thrower
)
);
} ).promise();
},
promise: function( obj ) {
return obj != null ? jQuery.extend( obj, promise ) : promise;
}
},
deferred = {};
jQuery.each( tuples, function( i, tuple ) {
var list = tuple[ 2 ],
stateString = tuple[ 5 ];
promise[ tuple[ 1 ] ] = list.add;
if ( stateString ) {
list.add(
function() {
state = stateString;
},
tuples[ 3 - i ][ 2 ].disable,
tuples[ 0 ][ 2 ].lock
);
}
list.add( tuple[ 3 ].fire );
deferred[ tuple[ 0 ] ] = function() {
deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
return this;
};
deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
} );
promise.promise( deferred );
if ( func ) {
func.call( deferred, deferred );
}
return deferred;
},
when: function( singleValue ) {
var
remaining = arguments.length,
i = remaining,
resolveContexts = Array( i ),
resolveValues = slice.call( arguments ),
master = jQuery.Deferred(),
updateFunc = function( i ) {
return function( value ) {
resolveContexts[ i ] = this;
resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
if ( !( --remaining ) ) {
master.resolveWith( resolveContexts, resolveValues );
}
};
};
if ( remaining <= 1 ) {
adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
!remaining );
if ( master.state() === "pending" ||
jQuery.isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {
return master.then();
}
}
while ( i-- ) {
adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
}
return master.promise();
}
} );
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
jQuery.Deferred.exceptionHook = function( error, stack ) {
if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
}
};
jQuery.readyException = function( error ) {
window.setTimeout( function() {
throw error;
} );
};
var readyList = jQuery.Deferred();
jQuery.fn.ready = function( fn ) {
readyList
.then( fn )
.catch( function( error ) {
jQuery.readyException( error );
} );
return this;
};
jQuery.extend( {
isReady: false,
readyWait: 1,
ready: function( wait ) {
if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
return;
}
jQuery.isReady = true;
if ( wait !== true && --jQuery.readyWait > 0 ) {
return;
}
readyList.resolveWith( document, [ jQuery ] );
}
} );
jQuery.ready.then = readyList.then;
function completed() {
document.removeEventListener( "DOMContentLoaded", completed );
window.removeEventListener( "load", completed );
jQuery.ready();
}
if ( document.readyState === "complete" ||
( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {
window.setTimeout( jQuery.ready );
} else {
document.addEventListener( "DOMContentLoaded", completed );
window.addEventListener( "load", completed );
}
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
var i = 0,
len = elems.length,
bulk = key == null;
if ( jQuery.type( key ) === "object" ) {
chainable = true;
for ( i in key ) {
access( elems, fn, i, key[ i ], true, emptyGet, raw );
}
} else if ( value !== undefined ) {
chainable = true;
if ( !jQuery.isFunction( value ) ) {
raw = true;
}
if ( bulk ) {
if ( raw ) {
fn.call( elems, value );
fn = null;
} else {
bulk = fn;
fn = function( elem, key, value ) {
return bulk.call( jQuery( elem ), value );
};
}
}
if ( fn ) {
for ( ; i < len; i++ ) {
fn(
elems[ i ], key, raw ?
value :
value.call( elems[ i ], i, fn( elems[ i ], key ) )
);
}
}
}
if ( chainable ) {
return elems;
}
if ( bulk ) {
return fn.call( elems );
}
return len ? fn( elems[ 0 ], key ) : emptyGet;
};
var acceptData = function( owner ) {
return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};
function Data() {
this.expando = jQuery.expando + Data.uid++;
}
Data.uid = 1;
Data.prototype = {
cache: function( owner ) {
var value = owner[ this.expando ];
if ( !value ) {
value = {};
if ( acceptData( owner ) ) {
if ( owner.nodeType ) {
owner[ this.expando ] = value;
} else {
Object.defineProperty( owner, this.expando, {
value: value,
configurable: true
} );
}
}
}
return value;
},
set: function( owner, data, value ) {
var prop,
cache = this.cache( owner );
if ( typeof data === "string" ) {
cache[ jQuery.camelCase( data ) ] = value;
} else {
for ( prop in data ) {
cache[ jQuery.camelCase( prop ) ] = data[ prop ];
}
}
return cache;
},
get: function( owner, key ) {
return key === undefined ?
this.cache( owner ) :
owner[ this.expando ] && owner[ this.expando ][ jQuery.camelCase( key ) ];
},
access: function( owner, key, value ) {
if ( key === undefined ||
( ( key && typeof key === "string" ) && value === undefined ) ) {
return this.get( owner, key );
}
this.set( owner, key, value );
return value !== undefined ? value : key;
},
remove: function( owner, key ) {
var i,
cache = owner[ this.expando ];
if ( cache === undefined ) {
return;
}
if ( key !== undefined ) {
if ( Array.isArray( key ) ) {
key = key.map( jQuery.camelCase );
} else {
key = jQuery.camelCase( key );
key = key in cache ?
[ key ] :
( key.match( rnothtmlwhite ) || [] );
}
i = key.length;
while ( i-- ) {
delete cache[ key[ i ] ];
}
}
if ( key === undefined || jQuery.isEmptyObject( cache ) ) {
if ( owner.nodeType ) {
owner[ this.expando ] = undefined;
} else {
delete owner[ this.expando ];
}
}
},
hasData: function( owner ) {
var cache = owner[ this.expando ];
return cache !== undefined && !jQuery.isEmptyObject( cache );
}
};
var dataPriv = new Data();
var dataUser = new Data();
var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
rmultiDash = /[A-Z]/g;
function getData( data ) {
if ( data === "true" ) {
return true;
}
if ( data === "false" ) {
return false;
}
if ( data === "null" ) {
return null;
}
if ( data === +data + "" ) {
return +data;
}
if ( rbrace.test( data ) ) {
return JSON.parse( data );
}
return data;
}
function dataAttr( elem, key, data ) {
var name;
if ( data === undefined && elem.nodeType === 1 ) {
name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
data = elem.getAttribute( name );
if ( typeof data === "string" ) {
try {
data = getData( data );
} catch ( e ) {}
dataUser.set( elem, key, data );
} else {
data = undefined;
}
}
return data;
}
jQuery.extend( {
hasData: function( elem ) {
return dataUser.hasData( elem ) || dataPriv.hasData( elem );
},
data: function( elem, name, data ) {
return dataUser.access( elem, name, data );
},
removeData: function( elem, name ) {
dataUser.remove( elem, name );
},
_data: function( elem, name, data ) {
return dataPriv.access( elem, name, data );
},
_removeData: function( elem, name ) {
dataPriv.remove( elem, name );
}
} );
jQuery.fn.extend( {
data: function( key, value ) {
var i, name, data,
elem = this[ 0 ],
attrs = elem && elem.attributes;
if ( key === undefined ) {
if ( this.length ) {
data = dataUser.get( elem );
if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
i = attrs.length;
while ( i-- ) {
if ( attrs[ i ] ) {
name = attrs[ i ].name;
if ( name.indexOf( "data-" ) === 0 ) {
name = jQuery.camelCase( name.slice( 5 ) );
dataAttr( elem, name, data[ name ] );
}
}
}
dataPriv.set( elem, "hasDataAttrs", true );
}
}
return data;
}
if ( typeof key === "object" ) {
return this.each( function() {
dataUser.set( this, key );
} );
}
return access( this, function( value ) {
var data;
if ( elem && value === undefined ) {
data = dataUser.get( elem, key );
if ( data !== undefined ) {
return data;
}
data = dataAttr( elem, key );
if ( data !== undefined ) {
return data;
}
return;
}
this.each( function() {
dataUser.set( this, key, value );
} );
}, null, value, arguments.length > 1, null, true );
},
removeData: function( key ) {
return this.each( function() {
dataUser.remove( this, key );
} );
}
} );
jQuery.extend( {
queue: function( elem, type, data ) {
var queue;
if ( elem ) {
type = ( type || "fx" ) + "queue";
queue = dataPriv.get( elem, type );
if ( data ) {
if ( !queue || Array.isArray( data ) ) {
queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
} else {
queue.push( data );
}
}
return queue || [];
}
},
dequeue: function( elem, type ) {
type = type || "fx";
var queue = jQuery.queue( elem, type ),
startLength = queue.length,
fn = queue.shift(),
hooks = jQuery._queueHooks( elem, type ),
next = function() {
jQuery.dequeue( elem, type );
};
if ( fn === "inprogress" ) {
fn = queue.shift();
startLength--;
}
if ( fn ) {
if ( type === "fx" ) {
queue.unshift( "inprogress" );
}
delete hooks.stop;
fn.call( elem, next, hooks );
}
if ( !startLength && hooks ) {
hooks.empty.fire();
}
},
_queueHooks: function( elem, type ) {
var key = type + "queueHooks";
return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
empty: jQuery.Callbacks( "once memory" ).add( function() {
dataPriv.remove( elem, [ type + "queue", key ] );
} )
} );
}
} );
jQuery.fn.extend( {
queue: function( type, data ) {
var setter = 2;
if ( typeof type !== "string" ) {
data = type;
type = "fx";
setter--;
}
if ( arguments.length < setter ) {
return jQuery.queue( this[ 0 ], type );
}
return data === undefined ?
this :
this.each( function() {
var queue = jQuery.queue( this, type, data );
jQuery._queueHooks( this, type );
if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
jQuery.dequeue( this, type );
}
} );
},
dequeue: function( type ) {
return this.each( function() {
jQuery.dequeue( this, type );
} );
},
clearQueue: function( type ) {
return this.queue( type || "fx", [] );
},
promise: function( type, obj ) {
var tmp,
count = 1,
defer = jQuery.Deferred(),
elements = this,
i = this.length,
resolve = function() {
if ( !( --count ) ) {
defer.resolveWith( elements, [ elements ] );
}
};
if ( typeof type !== "string" ) {
obj = type;
type = undefined;
}
type = type || "fx";
while ( i-- ) {
tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
if ( tmp && tmp.empty ) {
count++;
tmp.empty.add( resolve );
}
}
resolve();
return defer.promise( obj );
}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;
var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );
var cssExpand = [ "Top", "Right", "Bottom", "Left" ];
var isHiddenWithinTree = function( elem, el ) {
elem = el || elem;
return elem.style.display === "none" ||
elem.style.display === "" &&
jQuery.contains( elem.ownerDocument, elem ) &&
jQuery.css( elem, "display" ) === "none";
};
var swap = function( elem, options, callback, args ) {
var ret, name,
old = {};
for ( name in options ) {
old[ name ] = elem.style[ name ];
elem.style[ name ] = options[ name ];
}
ret = callback.apply( elem, args || [] );
for ( name in options ) {
elem.style[ name ] = old[ name ];
}
return ret;
};
function adjustCSS( elem, prop, valueParts, tween ) {
var adjusted,
scale = 1,
maxIterations = 20,
currentValue = tween ?
function() {
return tween.cur();
} :
function() {
return jQuery.css( elem, prop, "" );
},
initial = currentValue(),
unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),
initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
rcssNum.exec( jQuery.css( elem, prop ) );
if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {
unit = unit || initialInUnit[ 3 ];
valueParts = valueParts || [];
initialInUnit = +initial || 1;
do {
scale = scale || ".5";
initialInUnit = initialInUnit / scale;
jQuery.style( elem, prop, initialInUnit + unit );
} while (
scale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations
);
}
if ( valueParts ) {
initialInUnit = +initialInUnit || +initial || 0;
adjusted = valueParts[ 1 ] ?
initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
+valueParts[ 2 ];
if ( tween ) {
tween.unit = unit;
tween.start = initialInUnit;
tween.end = adjusted;
}
}
return adjusted;
}
var defaultDisplayMap = {};
function getDefaultDisplay( elem ) {
var temp,
doc = elem.ownerDocument,
nodeName = elem.nodeName,
display = defaultDisplayMap[ nodeName ];
if ( display ) {
return display;
}
temp = doc.body.appendChild( doc.createElement( nodeName ) );
display = jQuery.css( temp, "display" );
temp.parentNode.removeChild( temp );
if ( display === "none" ) {
display = "block";
}
defaultDisplayMap[ nodeName ] = display;
return display;
}
function showHide( elements, show ) {
var display, elem,
values = [],
index = 0,
length = elements.length;
for ( ; index < length; index++ ) {
elem = elements[ index ];
if ( !elem.style ) {
continue;
}
display = elem.style.display;
if ( show ) {
if ( display === "none" ) {
values[ index ] = dataPriv.get( elem, "display" ) || null;
if ( !values[ index ] ) {
elem.style.display = "";
}
}
if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
values[ index ] = getDefaultDisplay( elem );
}
} else {
if ( display !== "none" ) {
values[ index ] = "none";
dataPriv.set( elem, "display", display );
}
}
}
for ( index = 0; index < length; index++ ) {
if ( values[ index ] != null ) {
elements[ index ].style.display = values[ index ];
}
}
return elements;
}
jQuery.fn.extend( {
show: function() {
return showHide( this, true );
},
hide: function() {
return showHide( this );
},
toggle: function( state ) {
if ( typeof state === "boolean" ) {
return state ? this.show() : this.hide();
}
return this.each( function() {
if ( isHiddenWithinTree( this ) ) {
jQuery( this ).show();
} else {
jQuery( this ).hide();
}
} );
}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );
var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]+)/i );
var rscriptType = ( /^$|\/(?:java|ecma)script/i );
var wrapMap = {
option: [ 1, "<select multiple='multiple'>", "</select>" ],
thead: [ 1, "<table>", "</table>" ],
col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
tr: [ 2, "<table><tbody>", "</tbody></table>" ],
td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
_default: [ 0, "", "" ]
};
wrapMap.optgroup = wrapMap.option;
wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;
function getAll( context, tag ) {
var ret;
if ( typeof context.getElementsByTagName !== "undefined" ) {
ret = context.getElementsByTagName( tag || "*" );
} else if ( typeof context.querySelectorAll !== "undefined" ) {
ret = context.querySelectorAll( tag || "*" );
} else {
ret = [];
}
if ( tag === undefined || tag && nodeName( context, tag ) ) {
return jQuery.merge( [ context ], ret );
}
return ret;
}
function setGlobalEval( elems, refElements ) {
var i = 0,
l = elems.length;
for ( ; i < l; i++ ) {
dataPriv.set(
elems[ i ],
"globalEval",
!refElements || dataPriv.get( refElements[ i ], "globalEval" )
);
}
}
var rhtml = /<|&#?\w+;/;
function buildFragment( elems, context, scripts, selection, ignored ) {
var elem, tmp, tag, wrap, contains, j,
fragment = context.createDocumentFragment(),
nodes = [],
i = 0,
l = elems.length;
for ( ; i < l; i++ ) {
elem = elems[ i ];
if ( elem || elem === 0 ) {
if ( jQuery.type( elem ) === "object" ) {
jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );
} else if ( !rhtml.test( elem ) ) {
nodes.push( context.createTextNode( elem ) );
} else {
tmp = tmp || fragment.appendChild( context.createElement( "div" ) );
tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
wrap = wrapMap[ tag ] || wrapMap._default;
tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];
j = wrap[ 0 ];
while ( j-- ) {
tmp = tmp.lastChild;
}
jQuery.merge( nodes, tmp.childNodes );
tmp = fragment.firstChild;
tmp.textContent = "";
}
}
}
fragment.textContent = "";
i = 0;
while ( ( elem = nodes[ i++ ] ) ) {
if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
if ( ignored ) {
ignored.push( elem );
}
continue;
}
contains = jQuery.contains( elem.ownerDocument, elem );
tmp = getAll( fragment.appendChild( elem ), "script" );
if ( contains ) {
setGlobalEval( tmp );
}
if ( scripts ) {
j = 0;
while ( ( elem = tmp[ j++ ] ) ) {
if ( rscriptType.test( elem.type || "" ) ) {
scripts.push( elem );
}
}
}
}
return fragment;
}
( function() {
var fragment = document.createDocumentFragment(),
div = fragment.appendChild( document.createElement( "div" ) ),
input = document.createElement( "input" );
input.setAttribute( "type", "radio" );
input.setAttribute( "checked", "checked" );
input.setAttribute( "name", "t" );
div.appendChild( input );
support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;
div.innerHTML = "<textarea>x</textarea>";
support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
} )();
var documentElement = document.documentElement;
var
rkeyEvent = /^key/,
rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
function returnTrue() {
return true;
}
function returnFalse() {
return false;
}
function safeActiveElement() {
try {
return document.activeElement;
} catch ( err ) { }
}
function on( elem, types, selector, data, fn, one ) {
var origFn, type;
if ( typeof types === "object" ) {
if ( typeof selector !== "string" ) {
data = data || selector;
selector = undefined;
}
for ( type in types ) {
on( elem, type, selector, data, types[ type ], one );
}
return elem;
}
if ( data == null && fn == null ) {
fn = selector;
data = selector = undefined;
} else if ( fn == null ) {
if ( typeof selector === "string" ) {
fn = data;
data = undefined;
} else {
fn = data;
data = selector;
selector = undefined;
}
}
if ( fn === false ) {
fn = returnFalse;
} else if ( !fn ) {
return elem;
}
if ( one === 1 ) {
origFn = fn;
fn = function( event ) {
jQuery().off( event );
return origFn.apply( this, arguments );
};
fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
}
return elem.each( function() {
jQuery.event.add( this, types, fn, data, selector );
} );
}
jQuery.event = {
global: {},
add: function( elem, types, handler, data, selector ) {
var handleObjIn, eventHandle, tmp,
events, t, handleObj,
special, handlers, type, namespaces, origType,
elemData = dataPriv.get( elem );
if ( !elemData ) {
return;
}
if ( handler.handler ) {
handleObjIn = handler;
handler = handleObjIn.handler;
selector = handleObjIn.selector;
}
if ( selector ) {
jQuery.find.matchesSelector( documentElement, selector );
}
if ( !handler.guid ) {
handler.guid = jQuery.guid++;
}
if ( !( events = elemData.events ) ) {
events = elemData.events = {};
}
if ( !( eventHandle = elemData.handle ) ) {
eventHandle = elemData.handle = function( e ) {
return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
jQuery.event.dispatch.apply( elem, arguments ) : undefined;
};
}
types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
t = types.length;
while ( t-- ) {
tmp = rtypenamespace.exec( types[ t ] ) || [];
type = origType = tmp[ 1 ];
namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();
if ( !type ) {
continue;
}
special = jQuery.event.special[ type ] || {};
type = ( selector ? special.delegateType : special.bindType ) || type;
special = jQuery.event.special[ type ] || {};
handleObj = jQuery.extend( {
type: type,
origType: origType,
data: data,
handler: handler,
guid: handler.guid,
selector: selector,
needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
namespace: namespaces.join( "." )
}, handleObjIn );
if ( !( handlers = events[ type ] ) ) {
handlers = events[ type ] = [];
handlers.delegateCount = 0;
if ( !special.setup ||
special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
if ( elem.addEventListener ) {
elem.addEventListener( type, eventHandle );
}
}
}
if ( special.add ) {
special.add.call( elem, handleObj );
if ( !handleObj.handler.guid ) {
handleObj.handler.guid = handler.guid;
}
}
if ( selector ) {
handlers.splice( handlers.delegateCount++, 0, handleObj );
} else {
handlers.push( handleObj );
}
jQuery.event.global[ type ] = true;
}
},
remove: function( elem, types, handler, selector, mappedTypes ) {
var j, origCount, tmp,
events, t, handleObj,
special, handlers, type, namespaces, origType,
elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );
if ( !elemData || !( events = elemData.events ) ) {
return;
}
types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
t = types.length;
while ( t-- ) {
tmp = rtypenamespace.exec( types[ t ] ) || [];
type = origType = tmp[ 1 ];
namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();
if ( !type ) {
for ( type in events ) {
jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
}
continue;
}
special = jQuery.event.special[ type ] || {};
type = ( selector ? special.delegateType : special.bindType ) || type;
handlers = events[ type ] || [];
tmp = tmp[ 2 ] &&
new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );
origCount = j = handlers.length;
while ( j-- ) {
handleObj = handlers[ j ];
if ( ( mappedTypes || origType === handleObj.origType ) &&
( !handler || handler.guid === handleObj.guid ) &&
( !tmp || tmp.test( handleObj.namespace ) ) &&
( !selector || selector === handleObj.selector ||
selector === "**" && handleObj.selector ) ) {
handlers.splice( j, 1 );
if ( handleObj.selector ) {
handlers.delegateCount--;
}
if ( special.remove ) {
special.remove.call( elem, handleObj );
}
}
}
if ( origCount && !handlers.length ) {
if ( !special.teardown ||
special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
jQuery.removeEvent( elem, type, elemData.handle );
}
delete events[ type ];
}
}
if ( jQuery.isEmptyObject( events ) ) {
dataPriv.remove( elem, "handle events" );
}
},
dispatch: function( nativeEvent ) {
var event = jQuery.event.fix( nativeEvent );
var i, j, ret, matched, handleObj, handlerQueue,
args = new Array( arguments.length ),
handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
special = jQuery.event.special[ event.type ] || {};
args[ 0 ] = event;
for ( i = 1; i < arguments.length; i++ ) {
args[ i ] = arguments[ i ];
}
event.delegateTarget = this;
if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
return;
}
handlerQueue = jQuery.event.handlers.call( this, event, handlers );
i = 0;
while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
event.currentTarget = matched.elem;
j = 0;
while ( ( handleObj = matched.handlers[ j++ ] ) &&
!event.isImmediatePropagationStopped() ) {
if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {
event.handleObj = handleObj;
event.data = handleObj.data;
ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
handleObj.handler ).apply( matched.elem, args );
if ( ret !== undefined ) {
if ( ( event.result = ret ) === false ) {
event.preventDefault();
event.stopPropagation();
}
}
}
}
}
if ( special.postDispatch ) {
special.postDispatch.call( this, event );
}
return event.result;
},
handlers: function( event, handlers ) {
var i, handleObj, sel, matchedHandlers, matchedSelectors,
handlerQueue = [],
delegateCount = handlers.delegateCount,
cur = event.target;
if ( delegateCount &&
cur.nodeType &&
!( event.type === "click" && event.button >= 1 ) ) {
for ( ; cur !== this; cur = cur.parentNode || this ) {
if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
matchedHandlers = [];
matchedSelectors = {};
for ( i = 0; i < delegateCount; i++ ) {
handleObj = handlers[ i ];
sel = handleObj.selector + " ";
if ( matchedSelectors[ sel ] === undefined ) {
matchedSelectors[ sel ] = handleObj.needsContext ?
jQuery( sel, this ).index( cur ) > -1 :
jQuery.find( sel, this, null, [ cur ] ).length;
}
if ( matchedSelectors[ sel ] ) {
matchedHandlers.push( handleObj );
}
}
if ( matchedHandlers.length ) {
handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
}
}
}
}
cur = this;
if ( delegateCount < handlers.length ) {
handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
}
return handlerQueue;
},
addProp: function( name, hook ) {
Object.defineProperty( jQuery.Event.prototype, name, {
enumerable: true,
configurable: true,
get: jQuery.isFunction( hook ) ?
function() {
if ( this.originalEvent ) {
return hook( this.originalEvent );
}
} :
function() {
if ( this.originalEvent ) {
return this.originalEvent[ name ];
}
},
set: function( value ) {
Object.defineProperty( this, name, {
enumerable: true,
configurable: true,
writable: true,
value: value
} );
}
} );
},
fix: function( originalEvent ) {
return originalEvent[ jQuery.expando ] ?
originalEvent :
new jQuery.Event( originalEvent );
},
special: {
load: {
noBubble: true
},
focus: {
trigger: function() {
if ( this !== safeActiveElement() && this.focus ) {
this.focus();
return false;
}
},
delegateType: "focusin"
},
blur: {
trigger: function() {
if ( this === safeActiveElement() && this.blur ) {
this.blur();
return false;
}
},
delegateType: "focusout"
},
click: {
trigger: function() {
if ( this.type === "checkbox" && this.click && nodeName( this, "input" ) ) {
this.click();
return false;
}
},
_default: function( event ) {
return nodeName( event.target, "a" );
}
},
beforeunload: {
postDispatch: function( event ) {
if ( event.result !== undefined && event.originalEvent ) {
event.originalEvent.returnValue = event.result;
}
}
}
}
};
jQuery.removeEvent = function( elem, type, handle ) {
if ( elem.removeEventListener ) {
elem.removeEventListener( type, handle );
}
};
jQuery.Event = function( src, props ) {
if ( !( this instanceof jQuery.Event ) ) {
return new jQuery.Event( src, props );
}
if ( src && src.type ) {
this.originalEvent = src;
this.type = src.type;
this.isDefaultPrevented = src.defaultPrevented ||
src.defaultPrevented === undefined &&
src.returnValue === false ?
returnTrue :
returnFalse;
this.target = ( src.target && src.target.nodeType === 3 ) ?
src.target.parentNode :
src.target;
this.currentTarget = src.currentTarget;
this.relatedTarget = src.relatedTarget;
} else {
this.type = src;
}
if ( props ) {
jQuery.extend( this, props );
}
this.timeStamp = src && src.timeStamp || jQuery.now();
this[ jQuery.expando ] = true;
};
jQuery.Event.prototype = {
constructor: jQuery.Event,
isDefaultPrevented: returnFalse,
isPropagationStopped: returnFalse,
isImmediatePropagationStopped: returnFalse,
isSimulated: false,
preventDefault: function() {
var e = this.originalEvent;
this.isDefaultPrevented = returnTrue;
if ( e && !this.isSimulated ) {
e.preventDefault();
}
},
stopPropagation: function() {
var e = this.originalEvent;
this.isPropagationStopped = returnTrue;
if ( e && !this.isSimulated ) {
e.stopPropagation();
}
},
stopImmediatePropagation: function() {
var e = this.originalEvent;
this.isImmediatePropagationStopped = returnTrue;
if ( e && !this.isSimulated ) {
e.stopImmediatePropagation();
}
this.stopPropagation();
}
};
jQuery.each( {
altKey: true,
bubbles: true,
cancelable: true,
changedTouches: true,
ctrlKey: true,
detail: true,
eventPhase: true,
metaKey: true,
pageX: true,
pageY: true,
shiftKey: true,
view: true,
"char": true,
charCode: true,
key: true,
keyCode: true,
button: true,
buttons: true,
clientX: true,
clientY: true,
offsetX: true,
offsetY: true,
pointerId: true,
pointerType: true,
screenX: true,
screenY: true,
targetTouches: true,
toElement: true,
touches: true,
which: function( event ) {
var button = event.button;
if ( event.which == null && rkeyEvent.test( event.type ) ) {
return event.charCode != null ? event.charCode : event.keyCode;
}
if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
if ( button & 1 ) {
return 1;
}
if ( button & 2 ) {
return 3;
}
if ( button & 4 ) {
return 2;
}
return 0;
}
return event.which;
}
}, jQuery.event.addProp );
jQuery.each( {
mouseenter: "mouseover",
mouseleave: "mouseout",
pointerenter: "pointerover",
pointerleave: "pointerout"
}, function( orig, fix ) {
jQuery.event.special[ orig ] = {
delegateType: fix,
bindType: fix,
handle: function( event ) {
var ret,
target = this,
related = event.relatedTarget,
handleObj = event.handleObj;
if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
event.type = handleObj.origType;
ret = handleObj.handler.apply( this, arguments );
event.type = fix;
}
return ret;
}
};
} );
jQuery.fn.extend( {
on: function( types, selector, data, fn ) {
return on( this, types, selector, data, fn );
},
one: function( types, selector, data, fn ) {
return on( this, types, selector, data, fn, 1 );
},
off: function( types, selector, fn ) {
var handleObj, type;
if ( types && types.preventDefault && types.handleObj ) {
handleObj = types.handleObj;
jQuery( types.delegateTarget ).off(
handleObj.namespace ?
handleObj.origType + "." + handleObj.namespace :
handleObj.origType,
handleObj.selector,
handleObj.handler
);
return this;
}
if ( typeof types === "object" ) {
for ( type in types ) {
this.off( type, selector, types[ type ] );
}
return this;
}
if ( selector === false || typeof selector === "function" ) {
fn = selector;
selector = undefined;
}
if ( fn === false ) {
fn = returnFalse;
}
return this.each( function() {
jQuery.event.remove( this, types, fn, selector );
} );
}
} );
var
rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,
rnoInnerhtml = /<script|<style|<link/i,
rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
rscriptTypeMasked = /^true\/(.*)/,
rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
function manipulationTarget( elem, content ) {
if ( nodeName( elem, "table" ) &&
nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {
return jQuery( ">tbody", elem )[ 0 ] || elem;
}
return elem;
}
function disableScript( elem ) {
elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
return elem;
}
function restoreScript( elem ) {
var match = rscriptTypeMasked.exec( elem.type );
if ( match ) {
elem.type = match[ 1 ];
} else {
elem.removeAttribute( "type" );
}
return elem;
}
function cloneCopyEvent( src, dest ) {
var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
if ( dest.nodeType !== 1 ) {
return;
}
if ( dataPriv.hasData( src ) ) {
pdataOld = dataPriv.access( src );
pdataCur = dataPriv.set( dest, pdataOld );
events = pdataOld.events;
if ( events ) {
delete pdataCur.handle;
pdataCur.events = {};
for ( type in events ) {
for ( i = 0, l = events[ type ].length; i < l; i++ ) {
jQuery.event.add( dest, type, events[ type ][ i ] );
}
}
}
}
if ( dataUser.hasData( src ) ) {
udataOld = dataUser.access( src );
udataCur = jQuery.extend( {}, udataOld );
dataUser.set( dest, udataCur );
}
}
function fixInput( src, dest ) {
var nodeName = dest.nodeName.toLowerCase();
if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
dest.checked = src.checked;
} else if ( nodeName === "input" || nodeName === "textarea" ) {
dest.defaultValue = src.defaultValue;
}
}
function domManip( collection, args, callback, ignored ) {
args = concat.apply( [], args );
var fragment, first, scripts, hasScripts, node, doc,
i = 0,
l = collection.length,
iNoClone = l - 1,
value = args[ 0 ],
isFunction = jQuery.isFunction( value );
if ( isFunction ||
( l > 1 && typeof value === "string" &&
!support.checkClone && rchecked.test( value ) ) ) {
return collection.each( function( index ) {
var self = collection.eq( index );
if ( isFunction ) {
args[ 0 ] = value.call( this, index, self.html() );
}
domManip( self, args, callback, ignored );
} );
}
if ( l ) {
fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
first = fragment.firstChild;
if ( fragment.childNodes.length === 1 ) {
fragment = first;
}
if ( first || ignored ) {
scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
hasScripts = scripts.length;
for ( ; i < l; i++ ) {
node = fragment;
if ( i !== iNoClone ) {
node = jQuery.clone( node, true, true );
if ( hasScripts ) {
jQuery.merge( scripts, getAll( node, "script" ) );
}
}
callback.call( collection[ i ], node, i );
}
if ( hasScripts ) {
doc = scripts[ scripts.length - 1 ].ownerDocument;
jQuery.map( scripts, restoreScript );
for ( i = 0; i < hasScripts; i++ ) {
node = scripts[ i ];
if ( rscriptType.test( node.type || "" ) &&
!dataPriv.access( node, "globalEval" ) &&
jQuery.contains( doc, node ) ) {
if ( node.src ) {
if ( jQuery._evalUrl ) {
jQuery._evalUrl( node.src );
}
} else {
DOMEval( node.textContent.replace( rcleanScript, "" ), doc );
}
}
}
}
}
}
return collection;
}
function remove( elem, selector, keepData ) {
var node,
nodes = selector ? jQuery.filter( selector, elem ) : elem,
i = 0;
for ( ; ( node = nodes[ i ] ) != null; i++ ) {
if ( !keepData && node.nodeType === 1 ) {
jQuery.cleanData( getAll( node ) );
}
if ( node.parentNode ) {
if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
setGlobalEval( getAll( node, "script" ) );
}
node.parentNode.removeChild( node );
}
}
return elem;
}
jQuery.extend( {
htmlPrefilter: function( html ) {
return html.replace( rxhtmlTag, "<$1></$2>" );
},
clone: function( elem, dataAndEvents, deepDataAndEvents ) {
var i, l, srcElements, destElements,
clone = elem.cloneNode( true ),
inPage = jQuery.contains( elem.ownerDocument, elem );
if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
!jQuery.isXMLDoc( elem ) ) {
destElements = getAll( clone );
srcElements = getAll( elem );
for ( i = 0, l = srcElements.length; i < l; i++ ) {
fixInput( srcElements[ i ], destElements[ i ] );
}
}
if ( dataAndEvents ) {
if ( deepDataAndEvents ) {
srcElements = srcElements || getAll( elem );
destElements = destElements || getAll( clone );
for ( i = 0, l = srcElements.length; i < l; i++ ) {
cloneCopyEvent( srcElements[ i ], destElements[ i ] );
}
} else {
cloneCopyEvent( elem, clone );
}
}
destElements = getAll( clone, "script" );
if ( destElements.length > 0 ) {
setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
}
return clone;
},
cleanData: function( elems ) {
var data, elem, type,
special = jQuery.event.special,
i = 0;
for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
if ( acceptData( elem ) ) {
if ( ( data = elem[ dataPriv.expando ] ) ) {
if ( data.events ) {
for ( type in data.events ) {
if ( special[ type ] ) {
jQuery.event.remove( elem, type );
} else {
jQuery.removeEvent( elem, type, data.handle );
}
}
}
elem[ dataPriv.expando ] = undefined;
}
if ( elem[ dataUser.expando ] ) {
elem[ dataUser.expando ] = undefined;
}
}
}
}
} );
jQuery.fn.extend( {
detach: function( selector ) {
return remove( this, selector, true );
},
remove: function( selector ) {
return remove( this, selector );
},
text: function( value ) {
return access( this, function( value ) {
return value === undefined ?
jQuery.text( this ) :
this.empty().each( function() {
if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
this.textContent = value;
}
} );
}, null, value, arguments.length );
},
append: function() {
return domManip( this, arguments, function( elem ) {
if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
var target = manipulationTarget( this, elem );
target.appendChild( elem );
}
} );
},
prepend: function() {
return domManip( this, arguments, function( elem ) {
if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
var target = manipulationTarget( this, elem );
target.insertBefore( elem, target.firstChild );
}
} );
},
before: function() {
return domManip( this, arguments, function( elem ) {
if ( this.parentNode ) {
this.parentNode.insertBefore( elem, this );
}
} );
},
after: function() {
return domManip( this, arguments, function( elem ) {
if ( this.parentNode ) {
this.parentNode.insertBefore( elem, this.nextSibling );
}
} );
},
empty: function() {
var elem,
i = 0;
for ( ; ( elem = this[ i ] ) != null; i++ ) {
if ( elem.nodeType === 1 ) {
jQuery.cleanData( getAll( elem, false ) );
elem.textContent = "";
}
}
return this;
},
clone: function( dataAndEvents, deepDataAndEvents ) {
dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
return this.map( function() {
return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
} );
},
html: function( value ) {
return access( this, function( value ) {
var elem = this[ 0 ] || {},
i = 0,
l = this.length;
if ( value === undefined && elem.nodeType === 1 ) {
return elem.innerHTML;
}
if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {
value = jQuery.htmlPrefilter( value );
try {
for ( ; i < l; i++ ) {
elem = this[ i ] || {};
if ( elem.nodeType === 1 ) {
jQuery.cleanData( getAll( elem, false ) );
elem.innerHTML = value;
}
}
elem = 0;
} catch ( e ) {}
}
if ( elem ) {
this.empty().append( value );
}
}, null, value, arguments.length );
},
replaceWith: function() {
var ignored = [];
return domManip( this, arguments, function( elem ) {
var parent = this.parentNode;
if ( jQuery.inArray( this, ignored ) < 0 ) {
jQuery.cleanData( getAll( this ) );
if ( parent ) {
parent.replaceChild( elem, this );
}
}
}, ignored );
}
} );
jQuery.each( {
appendTo: "append",
prependTo: "prepend",
insertBefore: "before",
insertAfter: "after",
replaceAll: "replaceWith"
}, function( name, original ) {
jQuery.fn[ name ] = function( selector ) {
var elems,
ret = [],
insert = jQuery( selector ),
last = insert.length - 1,
i = 0;
for ( ; i <= last; i++ ) {
elems = i === last ? this : this.clone( true );
jQuery( insert[ i ] )[ original ]( elems );
push.apply( ret, elems.get() );
}
return this.pushStack( ret );
};
} );
var rmargin = ( /^margin/ );
var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );
var getStyles = function( elem ) {
var view = elem.ownerDocument.defaultView;
if ( !view || !view.opener ) {
view = window;
}
return view.getComputedStyle( elem );
};
( function() {
function computeStyleTests() {
if ( !div ) {
return;
}
div.style.cssText =
"box-sizing:border-box;" +
"position:relative;display:block;" +
"margin:auto;border:1px;padding:1px;" +
"top:1%;width:50%";
div.innerHTML = "";
documentElement.appendChild( container );
var divStyle = window.getComputedStyle( div );
pixelPositionVal = divStyle.top !== "1%";
reliableMarginLeftVal = divStyle.marginLeft === "2px";
boxSizingReliableVal = divStyle.width === "4px";
div.style.marginRight = "50%";
pixelMarginRightVal = divStyle.marginRight === "4px";
documentElement.removeChild( container );
div = null;
}
var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,
container = document.createElement( "div" ),
div = document.createElement( "div" );
if ( !div.style ) {
return;
}
div.style.backgroundClip = "content-box";
div.cloneNode( true ).style.backgroundClip = "";
support.clearCloneStyle = div.style.backgroundClip === "content-box";
container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" +
"padding:0;margin-top:1px;position:absolute";
container.appendChild( div );
jQuery.extend( support, {
pixelPosition: function() {
computeStyleTests();
return pixelPositionVal;
},
boxSizingReliable: function() {
computeStyleTests();
return boxSizingReliableVal;
},
pixelMarginRight: function() {
computeStyleTests();
return pixelMarginRightVal;
},
reliableMarginLeft: function() {
computeStyleTests();
return reliableMarginLeftVal;
}
} );
} )();
function curCSS( elem, name, computed ) {
var width, minWidth, maxWidth, ret,
style = elem.style;
computed = computed || getStyles( elem );
if ( computed ) {
ret = computed.getPropertyValue( name ) || computed[ name ];
if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
ret = jQuery.style( elem, name );
}
if ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {
width = style.width;
minWidth = style.minWidth;
maxWidth = style.maxWidth;
style.minWidth = style.maxWidth = style.width = ret;
ret = computed.width;
style.width = width;
style.minWidth = minWidth;
style.maxWidth = maxWidth;
}
}
return ret !== undefined ?
ret + "" :
ret;
}
function addGetHookIf( conditionFn, hookFn ) {
return {
get: function() {
if ( conditionFn() ) {
delete this.get;
return;
}
return ( this.get = hookFn ).apply( this, arguments );
}
};
}
var
rdisplayswap = /^(none|table(?!-c[ea]).+)/,
rcustomProp = /^--/,
cssShow = { position: "absolute", visibility: "hidden", display: "block" },
cssNormalTransform = {
letterSpacing: "0",
fontWeight: "400"
},
cssPrefixes = [ "Webkit", "Moz", "ms" ],
emptyStyle = document.createElement( "div" ).style;
function vendorPropName( name ) {
if ( name in emptyStyle ) {
return name;
}
var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
i = cssPrefixes.length;
while ( i-- ) {
name = cssPrefixes[ i ] + capName;
if ( name in emptyStyle ) {
return name;
}
}
}
function finalPropName( name ) {
var ret = jQuery.cssProps[ name ];
if ( !ret ) {
ret = jQuery.cssProps[ name ] = vendorPropName( name ) || name;
}
return ret;
}
function setPositiveNumber( elem, value, subtract ) {
var matches = rcssNum.exec( value );
return matches ?
Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
value;
}
function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
var i,
val = 0;
if ( extra === ( isBorderBox ? "border" : "content" ) ) {
i = 4;
} else {
i = name === "width" ? 1 : 0;
}
for ( ; i < 4; i += 2 ) {
if ( extra === "margin" ) {
val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
}
if ( isBorderBox ) {
if ( extra === "content" ) {
val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
}
if ( extra !== "margin" ) {
val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
}
} else {
val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
if ( extra !== "padding" ) {
val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
}
}
}
return val;
}
function getWidthOrHeight( elem, name, extra ) {
var valueIsBorderBox,
styles = getStyles( elem ),
val = curCSS( elem, name, styles ),
isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";
if ( rnumnonpx.test( val ) ) {
return val;
}
valueIsBorderBox = isBorderBox &&
( support.boxSizingReliable() || val === elem.style[ name ] );
if ( val === "auto" ) {
val = elem[ "offset" + name[ 0 ].toUpperCase() + name.slice( 1 ) ];
}
val = parseFloat( val ) || 0;
return ( val +
augmentWidthOrHeight(
elem,
name,
extra || ( isBorderBox ? "border" : "content" ),
valueIsBorderBox,
styles
)
) + "px";
}
jQuery.extend( {
cssHooks: {
opacity: {
get: function( elem, computed ) {
if ( computed ) {
var ret = curCSS( elem, "opacity" );
return ret === "" ? "1" : ret;
}
}
}
},
cssNumber: {
"animationIterationCount": true,
"columnCount": true,
"fillOpacity": true,
"flexGrow": true,
"flexShrink": true,
"fontWeight": true,
"lineHeight": true,
"opacity": true,
"order": true,
"orphans": true,
"widows": true,
"zIndex": true,
"zoom": true
},
cssProps: {
"float": "cssFloat"
},
style: function( elem, name, value, extra ) {
if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
return;
}
var ret, type, hooks,
origName = jQuery.camelCase( name ),
isCustomProp = rcustomProp.test( name ),
style = elem.style;
if ( !isCustomProp ) {
name = finalPropName( origName );
}
hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];
if ( value !== undefined ) {
type = typeof value;
if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
value = adjustCSS( elem, name, ret );
type = "number";
}
if ( value == null || value !== value ) {
return;
}
if ( type === "number" ) {
value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
}
if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
style[ name ] = "inherit";
}
if ( !hooks || !( "set" in hooks ) ||
( value = hooks.set( elem, value, extra ) ) !== undefined ) {
if ( isCustomProp ) {
style.setProperty( name, value );
} else {
style[ name ] = value;
}
}
} else {
if ( hooks && "get" in hooks &&
( ret = hooks.get( elem, false, extra ) ) !== undefined ) {
return ret;
}
return style[ name ];
}
},
css: function( elem, name, extra, styles ) {
var val, num, hooks,
origName = jQuery.camelCase( name ),
isCustomProp = rcustomProp.test( name );
if ( !isCustomProp ) {
name = finalPropName( origName );
}
hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];
if ( hooks && "get" in hooks ) {
val = hooks.get( elem, true, extra );
}
if ( val === undefined ) {
val = curCSS( elem, name, styles );
}
if ( val === "normal" && name in cssNormalTransform ) {
val = cssNormalTransform[ name ];
}
if ( extra === "" || extra ) {
num = parseFloat( val );
return extra === true || isFinite( num ) ? num || 0 : val;
}
return val;
}
} );
jQuery.each( [ "height", "width" ], function( i, name ) {
jQuery.cssHooks[ name ] = {
get: function( elem, computed, extra ) {
if ( computed ) {
return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&
( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
swap( elem, cssShow, function() {
return getWidthOrHeight( elem, name, extra );
} ) :
getWidthOrHeight( elem, name, extra );
}
},
set: function( elem, value, extra ) {
var matches,
styles = extra && getStyles( elem ),
subtract = extra && augmentWidthOrHeight(
elem,
name,
extra,
jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
styles
);
if ( subtract && ( matches = rcssNum.exec( value ) ) &&
( matches[ 3 ] || "px" ) !== "px" ) {
elem.style[ name ] = value;
value = jQuery.css( elem, name );
}
return setPositiveNumber( elem, value, subtract );
}
};
} );
jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
function( elem, computed ) {
if ( computed ) {
return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
elem.getBoundingClientRect().left -
swap( elem, { marginLeft: 0 }, function() {
return elem.getBoundingClientRect().left;
} )
) + "px";
}
}
);
jQuery.each( {
margin: "",
padding: "",
border: "Width"
}, function( prefix, suffix ) {
jQuery.cssHooks[ prefix + suffix ] = {
expand: function( value ) {
var i = 0,
expanded = {},
parts = typeof value === "string" ? value.split( " " ) : [ value ];
for ( ; i < 4; i++ ) {
expanded[ prefix + cssExpand[ i ] + suffix ] =
parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
}
return expanded;
}
};
if ( !rmargin.test( prefix ) ) {
jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
}
} );
jQuery.fn.extend( {
css: function( name, value ) {
return access( this, function( elem, name, value ) {
var styles, len,
map = {},
i = 0;
if ( Array.isArray( name ) ) {
styles = getStyles( elem );
len = name.length;
for ( ; i < len; i++ ) {
map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
}
return map;
}
return value !== undefined ?
jQuery.style( elem, name, value ) :
jQuery.css( elem, name );
}, name, value, arguments.length > 1 );
}
} );
function Tween( elem, options, prop, end, easing ) {
return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;
Tween.prototype = {
constructor: Tween,
init: function( elem, options, prop, end, easing, unit ) {
this.elem = elem;
this.prop = prop;
this.easing = easing || jQuery.easing._default;
this.options = options;
this.start = this.now = this.cur();
this.end = end;
this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
},
cur: function() {
var hooks = Tween.propHooks[ this.prop ];
return hooks && hooks.get ?
hooks.get( this ) :
Tween.propHooks._default.get( this );
},
run: function( percent ) {
var eased,
hooks = Tween.propHooks[ this.prop ];
if ( this.options.duration ) {
this.pos = eased = jQuery.easing[ this.easing ](
percent, this.options.duration * percent, 0, 1, this.options.duration
);
} else {
this.pos = eased = percent;
}
this.now = ( this.end - this.start ) * eased + this.start;
if ( this.options.step ) {
this.options.step.call( this.elem, this.now, this );
}
if ( hooks && hooks.set ) {
hooks.set( this );
} else {
Tween.propHooks._default.set( this );
}
return this;
}
};
Tween.prototype.init.prototype = Tween.prototype;
Tween.propHooks = {
_default: {
get: function( tween ) {
var result;
if ( tween.elem.nodeType !== 1 ||
tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
return tween.elem[ tween.prop ];
}
result = jQuery.css( tween.elem, tween.prop, "" );
return !result || result === "auto" ? 0 : result;
},
set: function( tween ) {
if ( jQuery.fx.step[ tween.prop ] ) {
jQuery.fx.step[ tween.prop ]( tween );
} else if ( tween.elem.nodeType === 1 &&
( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
jQuery.cssHooks[ tween.prop ] ) ) {
jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
} else {
tween.elem[ tween.prop ] = tween.now;
}
}
}
};
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
set: function( tween ) {
if ( tween.elem.nodeType && tween.elem.parentNode ) {
tween.elem[ tween.prop ] = tween.now;
}
}
};
jQuery.easing = {
linear: function( p ) {
return p;
},
swing: function( p ) {
return 0.5 - Math.cos( p * Math.PI ) / 2;
},
_default: "swing"
};
jQuery.fx = Tween.prototype.init;
jQuery.fx.step = {};
var
fxNow, inProgress,
rfxtypes = /^(?:toggle|show|hide)$/,
rrun = /queueHooks$/;
function schedule() {
if ( inProgress ) {
if ( document.hidden === false && window.requestAnimationFrame ) {
window.requestAnimationFrame( schedule );
} else {
window.setTimeout( schedule, jQuery.fx.interval );
}
jQuery.fx.tick();
}
}
function createFxNow() {
window.setTimeout( function() {
fxNow = undefined;
} );
return ( fxNow = jQuery.now() );
}
function genFx( type, includeWidth ) {
var which,
i = 0,
attrs = { height: type };
includeWidth = includeWidth ? 1 : 0;
for ( ; i < 4; i += 2 - includeWidth ) {
which = cssExpand[ i ];
attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
}
if ( includeWidth ) {
attrs.opacity = attrs.width = type;
}
return attrs;
}
function createTween( value, prop, animation ) {
var tween,
collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
index = 0,
length = collection.length;
for ( ; index < length; index++ ) {
if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {
return tween;
}
}
}
function defaultPrefilter( elem, props, opts ) {
var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
isBox = "width" in props || "height" in props,
anim = this,
orig = {},
style = elem.style,
hidden = elem.nodeType && isHiddenWithinTree( elem ),
dataShow = dataPriv.get( elem, "fxshow" );
if ( !opts.queue ) {
hooks = jQuery._queueHooks( elem, "fx" );
if ( hooks.unqueued == null ) {
hooks.unqueued = 0;
oldfire = hooks.empty.fire;
hooks.empty.fire = function() {
if ( !hooks.unqueued ) {
oldfire();
}
};
}
hooks.unqueued++;
anim.always( function() {
anim.always( function() {
hooks.unqueued--;
if ( !jQuery.queue( elem, "fx" ).length ) {
hooks.empty.fire();
}
} );
} );
}
for ( prop in props ) {
value = props[ prop ];
if ( rfxtypes.test( value ) ) {
delete props[ prop ];
toggle = toggle || value === "toggle";
if ( value === ( hidden ? "hide" : "show" ) ) {
if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
hidden = true;
} else {
continue;
}
}
orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
}
}
propTween = !jQuery.isEmptyObject( props );
if ( !propTween && jQuery.isEmptyObject( orig ) ) {
return;
}
if ( isBox && elem.nodeType === 1 ) {
opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];
restoreDisplay = dataShow && dataShow.display;
if ( restoreDisplay == null ) {
restoreDisplay = dataPriv.get( elem, "display" );
}
display = jQuery.css( elem, "display" );
if ( display === "none" ) {
if ( restoreDisplay ) {
display = restoreDisplay;
} else {
showHide( [ elem ], true );
restoreDisplay = elem.style.display || restoreDisplay;
display = jQuery.css( elem, "display" );
showHide( [ elem ] );
}
}
if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
if ( jQuery.css( elem, "float" ) === "none" ) {
if ( !propTween ) {
anim.done( function() {
style.display = restoreDisplay;
} );
if ( restoreDisplay == null ) {
display = style.display;
restoreDisplay = display === "none" ? "" : display;
}
}
style.display = "inline-block";
}
}
}
if ( opts.overflow ) {
style.overflow = "hidden";
anim.always( function() {
style.overflow = opts.overflow[ 0 ];
style.overflowX = opts.overflow[ 1 ];
style.overflowY = opts.overflow[ 2 ];
} );
}
propTween = false;
for ( prop in orig ) {
if ( !propTween ) {
if ( dataShow ) {
if ( "hidden" in dataShow ) {
hidden = dataShow.hidden;
}
} else {
dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
}
if ( toggle ) {
dataShow.hidden = !hidden;
}
if ( hidden ) {
showHide( [ elem ], true );
}
anim.done( function() {
if ( !hidden ) {
showHide( [ elem ] );
}
dataPriv.remove( elem, "fxshow" );
for ( prop in orig ) {
jQuery.style( elem, prop, orig[ prop ] );
}
} );
}
propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
if ( !( prop in dataShow ) ) {
dataShow[ prop ] = propTween.start;
if ( hidden ) {
propTween.end = propTween.start;
propTween.start = 0;
}
}
}
}
function propFilter( props, specialEasing ) {
var index, name, easing, value, hooks;
for ( index in props ) {
name = jQuery.camelCase( index );
easing = specialEasing[ name ];
value = props[ index ];
if ( Array.isArray( value ) ) {
easing = value[ 1 ];
value = props[ index ] = value[ 0 ];
}
if ( index !== name ) {
props[ name ] = value;
delete props[ index ];
}
hooks = jQuery.cssHooks[ name ];
if ( hooks && "expand" in hooks ) {
value = hooks.expand( value );
delete props[ name ];
for ( index in value ) {
if ( !( index in props ) ) {
props[ index ] = value[ index ];
specialEasing[ index ] = easing;
}
}
} else {
specialEasing[ name ] = easing;
}
}
}
function Animation( elem, properties, options ) {
var result,
stopped,
index = 0,
length = Animation.prefilters.length,
deferred = jQuery.Deferred().always( function() {
delete tick.elem;
} ),
tick = function() {
if ( stopped ) {
return false;
}
var currentTime = fxNow || createFxNow(),
remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
temp = remaining / animation.duration || 0,
percent = 1 - temp,
index = 0,
length = animation.tweens.length;
for ( ; index < length; index++ ) {
animation.tweens[ index ].run( percent );
}
deferred.notifyWith( elem, [ animation, percent, remaining ] );
if ( percent < 1 && length ) {
return remaining;
}
if ( !length ) {
deferred.notifyWith( elem, [ animation, 1, 0 ] );
}
deferred.resolveWith( elem, [ animation ] );
return false;
},
animation = deferred.promise( {
elem: elem,
props: jQuery.extend( {}, properties ),
opts: jQuery.extend( true, {
specialEasing: {},
easing: jQuery.easing._default
}, options ),
originalProperties: properties,
originalOptions: options,
startTime: fxNow || createFxNow(),
duration: options.duration,
tweens: [],
createTween: function( prop, end ) {
var tween = jQuery.Tween( elem, animation.opts, prop, end,
animation.opts.specialEasing[ prop ] || animation.opts.easing );
animation.tweens.push( tween );
return tween;
},
stop: function( gotoEnd ) {
var index = 0,
length = gotoEnd ? animation.tweens.length : 0;
if ( stopped ) {
return this;
}
stopped = true;
for ( ; index < length; index++ ) {
animation.tweens[ index ].run( 1 );
}
if ( gotoEnd ) {
deferred.notifyWith( elem, [ animation, 1, 0 ] );
deferred.resolveWith( elem, [ animation, gotoEnd ] );
} else {
deferred.rejectWith( elem, [ animation, gotoEnd ] );
}
return this;
}
} ),
props = animation.props;
propFilter( props, animation.opts.specialEasing );
for ( ; index < length; index++ ) {
result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
if ( result ) {
if ( jQuery.isFunction( result.stop ) ) {
jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
jQuery.proxy( result.stop, result );
}
return result;
}
}
jQuery.map( props, createTween, animation );
if ( jQuery.isFunction( animation.opts.start ) ) {
animation.opts.start.call( elem, animation );
}
animation
.progress( animation.opts.progress )
.done( animation.opts.done, animation.opts.complete )
.fail( animation.opts.fail )
.always( animation.opts.always );
jQuery.fx.timer(
jQuery.extend( tick, {
elem: elem,
anim: animation,
queue: animation.opts.queue
} )
);
return animation;
}
jQuery.Animation = jQuery.extend( Animation, {
tweeners: {
"*": [ function( prop, value ) {
var tween = this.createTween( prop, value );
adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
return tween;
} ]
},
tweener: function( props, callback ) {
if ( jQuery.isFunction( props ) ) {
callback = props;
props = [ "*" ];
} else {
props = props.match( rnothtmlwhite );
}
var prop,
index = 0,
length = props.length;
for ( ; index < length; index++ ) {
prop = props[ index ];
Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
Animation.tweeners[ prop ].unshift( callback );
}
},
prefilters: [ defaultPrefilter ],
prefilter: function( callback, prepend ) {
if ( prepend ) {
Animation.prefilters.unshift( callback );
} else {
Animation.prefilters.push( callback );
}
}
} );
jQuery.speed = function( speed, easing, fn ) {
var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
complete: fn || !fn && easing ||
jQuery.isFunction( speed ) && speed,
duration: speed,
easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
};
if ( jQuery.fx.off ) {
opt.duration = 0;
} else {
if ( typeof opt.duration !== "number" ) {
if ( opt.duration in jQuery.fx.speeds ) {
opt.duration = jQuery.fx.speeds[ opt.duration ];
} else {
opt.duration = jQuery.fx.speeds._default;
}
}
}
if ( opt.queue == null || opt.queue === true ) {
opt.queue = "fx";
}
opt.old = opt.complete;
opt.complete = function() {
if ( jQuery.isFunction( opt.old ) ) {
opt.old.call( this );
}
if ( opt.queue ) {
jQuery.dequeue( this, opt.queue );
}
};
return opt;
};
jQuery.fn.extend( {
fadeTo: function( speed, to, easing, callback ) {
return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()
.end().animate( { opacity: to }, speed, easing, callback );
},
animate: function( prop, speed, easing, callback ) {
var empty = jQuery.isEmptyObject( prop ),
optall = jQuery.speed( speed, easing, callback ),
doAnimation = function() {
var anim = Animation( this, jQuery.extend( {}, prop ), optall );
if ( empty || dataPriv.get( this, "finish" ) ) {
anim.stop( true );
}
};
doAnimation.finish = doAnimation;
return empty || optall.queue === false ?
this.each( doAnimation ) :
this.queue( optall.queue, doAnimation );
},
stop: function( type, clearQueue, gotoEnd ) {
var stopQueue = function( hooks ) {
var stop = hooks.stop;
delete hooks.stop;
stop( gotoEnd );
};
if ( typeof type !== "string" ) {
gotoEnd = clearQueue;
clearQueue = type;
type = undefined;
}
if ( clearQueue && type !== false ) {
this.queue( type || "fx", [] );
}
return this.each( function() {
var dequeue = true,
index = type != null && type + "queueHooks",
timers = jQuery.timers,
data = dataPriv.get( this );
if ( index ) {
if ( data[ index ] && data[ index ].stop ) {
stopQueue( data[ index ] );
}
} else {
for ( index in data ) {
if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
stopQueue( data[ index ] );
}
}
}
for ( index = timers.length; index--; ) {
if ( timers[ index ].elem === this &&
( type == null || timers[ index ].queue === type ) ) {
timers[ index ].anim.stop( gotoEnd );
dequeue = false;
timers.splice( index, 1 );
}
}
if ( dequeue || !gotoEnd ) {
jQuery.dequeue( this, type );
}
} );
},
finish: function( type ) {
if ( type !== false ) {
type = type || "fx";
}
return this.each( function() {
var index,
data = dataPriv.get( this ),
queue = data[ type + "queue" ],
hooks = data[ type + "queueHooks" ],
timers = jQuery.timers,
length = queue ? queue.length : 0;
data.finish = true;
jQuery.queue( this, type, [] );
if ( hooks && hooks.stop ) {
hooks.stop.call( this, true );
}
for ( index = timers.length; index--; ) {
if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
timers[ index ].anim.stop( true );
timers.splice( index, 1 );
}
}
for ( index = 0; index < length; index++ ) {
if ( queue[ index ] && queue[ index ].finish ) {
queue[ index ].finish.call( this );
}
}
delete data.finish;
} );
}
} );
jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
var cssFn = jQuery.fn[ name ];
jQuery.fn[ name ] = function( speed, easing, callback ) {
return speed == null || typeof speed === "boolean" ?
cssFn.apply( this, arguments ) :
this.animate( genFx( name, true ), speed, easing, callback );
};
} );
jQuery.each( {
slideDown: genFx( "show" ),
slideUp: genFx( "hide" ),
slideToggle: genFx( "toggle" ),
fadeIn: { opacity: "show" },
fadeOut: { opacity: "hide" },
fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
jQuery.fn[ name ] = function( speed, easing, callback ) {
return this.animate( props, speed, easing, callback );
};
} );
jQuery.timers = [];
jQuery.fx.tick = function() {
var timer,
i = 0,
timers = jQuery.timers;
fxNow = jQuery.now();
for ( ; i < timers.length; i++ ) {
timer = timers[ i ];
if ( !timer() && timers[ i ] === timer ) {
timers.splice( i--, 1 );
}
}
if ( !timers.length ) {
jQuery.fx.stop();
}
fxNow = undefined;
};
jQuery.fx.timer = function( timer ) {
jQuery.timers.push( timer );
jQuery.fx.start();
};
jQuery.fx.interval = 13;
jQuery.fx.start = function() {
if ( inProgress ) {
return;
}
inProgress = true;
schedule();
};
jQuery.fx.stop = function() {
inProgress = null;
};
jQuery.fx.speeds = {
slow: 600,
fast: 200,
_default: 400
};
jQuery.fn.delay = function( time, type ) {
time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
type = type || "fx";
return this.queue( type, function( next, hooks ) {
var timeout = window.setTimeout( next, time );
hooks.stop = function() {
window.clearTimeout( timeout );
};
} );
};
( function() {
var input = document.createElement( "input" ),
select = document.createElement( "select" ),
opt = select.appendChild( document.createElement( "option" ) );
input.type = "checkbox";
support.checkOn = input.value !== "";
support.optSelected = opt.selected;
input = document.createElement( "input" );
input.value = "t";
input.type = "radio";
support.radioValue = input.value === "t";
} )();
var boolHook,
attrHandle = jQuery.expr.attrHandle;
jQuery.fn.extend( {
attr: function( name, value ) {
return access( this, jQuery.attr, name, value, arguments.length > 1 );
},
removeAttr: function( name ) {
return this.each( function() {
jQuery.removeAttr( this, name );
} );
}
} );
jQuery.extend( {
attr: function( elem, name, value ) {
var ret, hooks,
nType = elem.nodeType;
if ( nType === 3 || nType === 8 || nType === 2 ) {
return;
}
if ( typeof elem.getAttribute === "undefined" ) {
return jQuery.prop( elem, name, value );
}
if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
}
if ( value !== undefined ) {
if ( value === null ) {
jQuery.removeAttr( elem, name );
return;
}
if ( hooks && "set" in hooks &&
( ret = hooks.set( elem, value, name ) ) !== undefined ) {
return ret;
}
elem.setAttribute( name, value + "" );
return value;
}
if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
return ret;
}
ret = jQuery.find.attr( elem, name );
return ret == null ? undefined : ret;
},
attrHooks: {
type: {
set: function( elem, value ) {
if ( !support.radioValue && value === "radio" &&
nodeName( elem, "input" ) ) {
var val = elem.value;
elem.setAttribute( "type", value );
if ( val ) {
elem.value = val;
}
return value;
}
}
}
},
removeAttr: function( elem, value ) {
var name,
i = 0,
attrNames = value && value.match( rnothtmlwhite );
if ( attrNames && elem.nodeType === 1 ) {
while ( ( name = attrNames[ i++ ] ) ) {
elem.removeAttribute( name );
}
}
}
} );
boolHook = {
set: function( elem, value, name ) {
if ( value === false ) {
jQuery.removeAttr( elem, name );
} else {
elem.setAttribute( name, name );
}
return name;
}
};
jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
var getter = attrHandle[ name ] || jQuery.find.attr;
attrHandle[ name ] = function( elem, name, isXML ) {
var ret, handle,
lowercaseName = name.toLowerCase();
if ( !isXML ) {
handle = attrHandle[ lowercaseName ];
attrHandle[ lowercaseName ] = ret;
ret = getter( elem, name, isXML ) != null ?
lowercaseName :
null;
attrHandle[ lowercaseName ] = handle;
}
return ret;
};
} );
var rfocusable = /^(?:input|select|textarea|button)$/i,
rclickable = /^(?:a|area)$/i;
jQuery.fn.extend( {
prop: function( name, value ) {
return access( this, jQuery.prop, name, value, arguments.length > 1 );
},
removeProp: function( name ) {
return this.each( function() {
delete this[ jQuery.propFix[ name ] || name ];
} );
}
} );
jQuery.extend( {
prop: function( elem, name, value ) {
var ret, hooks,
nType = elem.nodeType;
if ( nType === 3 || nType === 8 || nType === 2 ) {
return;
}
if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
name = jQuery.propFix[ name ] || name;
hooks = jQuery.propHooks[ name ];
}
if ( value !== undefined ) {
if ( hooks && "set" in hooks &&
( ret = hooks.set( elem, value, name ) ) !== undefined ) {
return ret;
}
return ( elem[ name ] = value );
}
if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
return ret;
}
return elem[ name ];
},
propHooks: {
tabIndex: {
get: function( elem ) {
var tabindex = jQuery.find.attr( elem, "tabindex" );
if ( tabindex ) {
return parseInt( tabindex, 10 );
}
if (
rfocusable.test( elem.nodeName ) ||
rclickable.test( elem.nodeName ) &&
elem.href
) {
return 0;
}
return -1;
}
}
},
propFix: {
"for": "htmlFor",
"class": "className"
}
} );
if ( !support.optSelected ) {
jQuery.propHooks.selected = {
get: function( elem ) {
var parent = elem.parentNode;
if ( parent && parent.parentNode ) {
parent.parentNode.selectedIndex;
}
return null;
},
set: function( elem ) {
var parent = elem.parentNode;
if ( parent ) {
parent.selectedIndex;
if ( parent.parentNode ) {
parent.parentNode.selectedIndex;
}
}
}
};
}
jQuery.each( [
"tabIndex",
"readOnly",
"maxLength",
"cellSpacing",
"cellPadding",
"rowSpan",
"colSpan",
"useMap",
"frameBorder",
"contentEditable"
], function() {
jQuery.propFix[ this.toLowerCase() ] = this;
} );
function stripAndCollapse( value ) {
var tokens = value.match( rnothtmlwhite ) || [];
return tokens.join( " " );
}
function getClass( elem ) {
return elem.getAttribute && elem.getAttribute( "class" ) || "";
}
jQuery.fn.extend( {
addClass: function( value ) {
var classes, elem, cur, curValue, clazz, j, finalValue,
i = 0;
if ( jQuery.isFunction( value ) ) {
return this.each( function( j ) {
jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
} );
}
if ( typeof value === "string" && value ) {
classes = value.match( rnothtmlwhite ) || [];
while ( ( elem = this[ i++ ] ) ) {
curValue = getClass( elem );
cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );
if ( cur ) {
j = 0;
while ( ( clazz = classes[ j++ ] ) ) {
if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
cur += clazz + " ";
}
}
finalValue = stripAndCollapse( cur );
if ( curValue !== finalValue ) {
elem.setAttribute( "class", finalValue );
}
}
}
}
return this;
},
removeClass: function( value ) {
var classes, elem, cur, curValue, clazz, j, finalValue,
i = 0;
if ( jQuery.isFunction( value ) ) {
return this.each( function( j ) {
jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
} );
}
if ( !arguments.length ) {
return this.attr( "class", "" );
}
if ( typeof value === "string" && value ) {
classes = value.match( rnothtmlwhite ) || [];
while ( ( elem = this[ i++ ] ) ) {
curValue = getClass( elem );
cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );
if ( cur ) {
j = 0;
while ( ( clazz = classes[ j++ ] ) ) {
while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
cur = cur.replace( " " + clazz + " ", " " );
}
}
finalValue = stripAndCollapse( cur );
if ( curValue !== finalValue ) {
elem.setAttribute( "class", finalValue );
}
}
}
}
return this;
},
toggleClass: function( value, stateVal ) {
var type = typeof value;
if ( typeof stateVal === "boolean" && type === "string" ) {
return stateVal ? this.addClass( value ) : this.removeClass( value );
}
if ( jQuery.isFunction( value ) ) {
return this.each( function( i ) {
jQuery( this ).toggleClass(
value.call( this, i, getClass( this ), stateVal ),
stateVal
);
} );
}
return this.each( function() {
var className, i, self, classNames;
if ( type === "string" ) {
i = 0;
self = jQuery( this );
classNames = value.match( rnothtmlwhite ) || [];
while ( ( className = classNames[ i++ ] ) ) {
if ( self.hasClass( className ) ) {
self.removeClass( className );
} else {
self.addClass( className );
}
}
} else if ( value === undefined || type === "boolean" ) {
className = getClass( this );
if ( className ) {
dataPriv.set( this, "__className__", className );
}
if ( this.setAttribute ) {
this.setAttribute( "class",
className || value === false ?
"" :
dataPriv.get( this, "__className__" ) || ""
);
}
}
} );
},
hasClass: function( selector ) {
var className, elem,
i = 0;
className = " " + selector + " ";
while ( ( elem = this[ i++ ] ) ) {
if ( elem.nodeType === 1 &&
( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
return true;
}
}
return false;
}
} );
var rreturn = /\r/g;
jQuery.fn.extend( {
val: function( value ) {
var hooks, ret, isFunction,
elem = this[ 0 ];
if ( !arguments.length ) {
if ( elem ) {
hooks = jQuery.valHooks[ elem.type ] ||
jQuery.valHooks[ elem.nodeName.toLowerCase() ];
if ( hooks &&
"get" in hooks &&
( ret = hooks.get( elem, "value" ) ) !== undefined
) {
return ret;
}
ret = elem.value;
if ( typeof ret === "string" ) {
return ret.replace( rreturn, "" );
}
return ret == null ? "" : ret;
}
return;
}
isFunction = jQuery.isFunction( value );
return this.each( function( i ) {
var val;
if ( this.nodeType !== 1 ) {
return;
}
if ( isFunction ) {
val = value.call( this, i, jQuery( this ).val() );
} else {
val = value;
}
if ( val == null ) {
val = "";
} else if ( typeof val === "number" ) {
val += "";
} else if ( Array.isArray( val ) ) {
val = jQuery.map( val, function( value ) {
return value == null ? "" : value + "";
} );
}
hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];
if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
this.value = val;
}
} );
}
} );
jQuery.extend( {
valHooks: {
option: {
get: function( elem ) {
var val = jQuery.find.attr( elem, "value" );
return val != null ?
val :
stripAndCollapse( jQuery.text( elem ) );
}
},
select: {
get: function( elem ) {
var value, option, i,
options = elem.options,
index = elem.selectedIndex,
one = elem.type === "select-one",
values = one ? null : [],
max = one ? index + 1 : options.length;
if ( index < 0 ) {
i = max;
} else {
i = one ? index : 0;
}
for ( ; i < max; i++ ) {
option = options[ i ];
if ( ( option.selected || i === index ) &&
!option.disabled &&
( !option.parentNode.disabled ||
!nodeName( option.parentNode, "optgroup" ) ) ) {
value = jQuery( option ).val();
if ( one ) {
return value;
}
values.push( value );
}
}
return values;
},
set: function( elem, value ) {
var optionSet, option,
options = elem.options,
values = jQuery.makeArray( value ),
i = options.length;
while ( i-- ) {
option = options[ i ];
if ( option.selected =
jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
) {
optionSet = true;
}
}
if ( !optionSet ) {
elem.selectedIndex = -1;
}
return values;
}
}
}
} );
jQuery.each( [ "radio", "checkbox" ], function() {
jQuery.valHooks[ this ] = {
set: function( elem, value ) {
if ( Array.isArray( value ) ) {
return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
}
}
};
if ( !support.checkOn ) {
jQuery.valHooks[ this ].get = function( elem ) {
return elem.getAttribute( "value" ) === null ? "on" : elem.value;
};
}
} );
var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;
jQuery.extend( jQuery.event, {
trigger: function( event, data, elem, onlyHandlers ) {
var i, cur, tmp, bubbleType, ontype, handle, special,
eventPath = [ elem || document ],
type = hasOwn.call( event, "type" ) ? event.type : event,
namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];
cur = tmp = elem = elem || document;
if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
return;
}
if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
return;
}
if ( type.indexOf( "." ) > -1 ) {
namespaces = type.split( "." );
type = namespaces.shift();
namespaces.sort();
}
ontype = type.indexOf( ":" ) < 0 && "on" + type;
event = event[ jQuery.expando ] ?
event :
new jQuery.Event( type, typeof event === "object" && event );
event.isTrigger = onlyHandlers ? 2 : 3;
event.namespace = namespaces.join( "." );
event.rnamespace = event.namespace ?
new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
null;
event.result = undefined;
if ( !event.target ) {
event.target = elem;
}
data = data == null ?
[ event ] :
jQuery.makeArray( data, [ event ] );
special = jQuery.event.special[ type ] || {};
if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
return;
}
if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {
bubbleType = special.delegateType || type;
if ( !rfocusMorph.test( bubbleType + type ) ) {
cur = cur.parentNode;
}
for ( ; cur; cur = cur.parentNode ) {
eventPath.push( cur );
tmp = cur;
}
if ( tmp === ( elem.ownerDocument || document ) ) {
eventPath.push( tmp.defaultView || tmp.parentWindow || window );
}
}
i = 0;
while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
event.type = i > 1 ?
bubbleType :
special.bindType || type;
handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
dataPriv.get( cur, "handle" );
if ( handle ) {
handle.apply( cur, data );
}
handle = ontype && cur[ ontype ];
if ( handle && handle.apply && acceptData( cur ) ) {
event.result = handle.apply( cur, data );
if ( event.result === false ) {
event.preventDefault();
}
}
}
event.type = type;
if ( !onlyHandlers && !event.isDefaultPrevented() ) {
if ( ( !special._default ||
special._default.apply( eventPath.pop(), data ) === false ) &&
acceptData( elem ) ) {
if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {
tmp = elem[ ontype ];
if ( tmp ) {
elem[ ontype ] = null;
}
jQuery.event.triggered = type;
elem[ type ]();
jQuery.event.triggered = undefined;
if ( tmp ) {
elem[ ontype ] = tmp;
}
}
}
}
return event.result;
},
simulate: function( type, elem, event ) {
var e = jQuery.extend(
new jQuery.Event(),
event,
{
type: type,
isSimulated: true
}
);
jQuery.event.trigger( e, null, elem );
}
} );
jQuery.fn.extend( {
trigger: function( type, data ) {
return this.each( function() {
jQuery.event.trigger( type, data, this );
} );
},
triggerHandler: function( type, data ) {
var elem = this[ 0 ];
if ( elem ) {
return jQuery.event.trigger( type, data, elem, true );
}
}
} );
jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
"change select submit keydown keypress keyup contextmenu" ).split( " " ),
function( i, name ) {
jQuery.fn[ name ] = function( data, fn ) {
return arguments.length > 0 ?
this.on( name, null, data, fn ) :
this.trigger( name );
};
} );
jQuery.fn.extend( {
hover: function( fnOver, fnOut ) {
return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
}
} );
support.focusin = "onfocusin" in window;
if ( !support.focusin ) {
jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {
var handler = function( event ) {
jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
};
jQuery.event.special[ fix ] = {
setup: function() {
var doc = this.ownerDocument || this,
attaches = dataPriv.access( doc, fix );
if ( !attaches ) {
doc.addEventListener( orig, handler, true );
}
dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
},
teardown: function() {
var doc = this.ownerDocument || this,
attaches = dataPriv.access( doc, fix ) - 1;
if ( !attaches ) {
doc.removeEventListener( orig, handler, true );
dataPriv.remove( doc, fix );
} else {
dataPriv.access( doc, fix, attaches );
}
}
};
} );
}
var location = window.location;
var nonce = jQuery.now();
var rquery = ( /\?/ );
jQuery.parseXML = function( data ) {
var xml;
if ( !data || typeof data !== "string" ) {
return null;
}
try {
xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
} catch ( e ) {
xml = undefined;
}
if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
jQuery.error( "Invalid XML: " + data );
}
return xml;
};
var
rbracket = /\[\]$/,
rCRLF = /\r?\n/g,
rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
rsubmittable = /^(?:input|select|textarea|keygen)/i;
function buildParams( prefix, obj, traditional, add ) {
var name;
if ( Array.isArray( obj ) ) {
jQuery.each( obj, function( i, v ) {
if ( traditional || rbracket.test( prefix ) ) {
add( prefix, v );
} else {
buildParams(
prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
v,
traditional,
add
);
}
} );
} else if ( !traditional && jQuery.type( obj ) === "object" ) {
for ( name in obj ) {
buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
}
} else {
add( prefix, obj );
}
}
jQuery.param = function( a, traditional ) {
var prefix,
s = [],
add = function( key, valueOrFunction ) {
var value = jQuery.isFunction( valueOrFunction ) ?
valueOrFunction() :
valueOrFunction;
s[ s.length ] = encodeURIComponent( key ) + "=" +
encodeURIComponent( value == null ? "" : value );
};
if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
jQuery.each( a, function() {
add( this.name, this.value );
} );
} else {
for ( prefix in a ) {
buildParams( prefix, a[ prefix ], traditional, add );
}
}
return s.join( "&" );
};
jQuery.fn.extend( {
serialize: function() {
return jQuery.param( this.serializeArray() );
},
serializeArray: function() {
return this.map( function() {
var elements = jQuery.prop( this, "elements" );
return elements ? jQuery.makeArray( elements ) : this;
} )
.filter( function() {
var type = this.type;
return this.name && !jQuery( this ).is( ":disabled" ) &&
rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
( this.checked || !rcheckableType.test( type ) );
} )
.map( function( i, elem ) {
var val = jQuery( this ).val();
if ( val == null ) {
return null;
}
if ( Array.isArray( val ) ) {
return jQuery.map( val, function( val ) {
return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
} );
}
return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
} ).get();
}
} );
var
r20 = /%20/g,
rhash = /#.*$/,
rantiCache = /([?&])_=[^&]*/,
rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
rnoContent = /^(?:GET|HEAD)$/,
rprotocol = /^\/\//,
prefilters = {},
transports = {},
allTypes = "*/".concat( "*" ),
originAnchor = document.createElement( "a" );
originAnchor.href = location.href;
function addToPrefiltersOrTransports( structure ) {
return function( dataTypeExpression, func ) {
if ( typeof dataTypeExpression !== "string" ) {
func = dataTypeExpression;
dataTypeExpression = "*";
}
var dataType,
i = 0,
dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];
if ( jQuery.isFunction( func ) ) {
while ( ( dataType = dataTypes[ i++ ] ) ) {
if ( dataType[ 0 ] === "+" ) {
dataType = dataType.slice( 1 ) || "*";
( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );
} else {
( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
}
}
}
};
}
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {
var inspected = {},
seekingTransport = ( structure === transports );
function inspect( dataType ) {
var selected;
inspected[ dataType ] = true;
jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
if ( typeof dataTypeOrTransport === "string" &&
!seekingTransport && !inspected[ dataTypeOrTransport ] ) {
options.dataTypes.unshift( dataTypeOrTransport );
inspect( dataTypeOrTransport );
return false;
} else if ( seekingTransport ) {
return !( selected = dataTypeOrTransport );
}
} );
return selected;
}
return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}
function ajaxExtend( target, src ) {
var key, deep,
flatOptions = jQuery.ajaxSettings.flatOptions || {};
for ( key in src ) {
if ( src[ key ] !== undefined ) {
( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
}
}
if ( deep ) {
jQuery.extend( true, target, deep );
}
return target;
}
function ajaxHandleResponses( s, jqXHR, responses ) {
var ct, type, finalDataType, firstDataType,
contents = s.contents,
dataTypes = s.dataTypes;
while ( dataTypes[ 0 ] === "*" ) {
dataTypes.shift();
if ( ct === undefined ) {
ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
}
}
if ( ct ) {
for ( type in contents ) {
if ( contents[ type ] && contents[ type ].test( ct ) ) {
dataTypes.unshift( type );
break;
}
}
}
if ( dataTypes[ 0 ] in responses ) {
finalDataType = dataTypes[ 0 ];
} else {
for ( type in responses ) {
if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
finalDataType = type;
break;
}
if ( !firstDataType ) {
firstDataType = type;
}
}
finalDataType = finalDataType || firstDataType;
}
if ( finalDataType ) {
if ( finalDataType !== dataTypes[ 0 ] ) {
dataTypes.unshift( finalDataType );
}
return responses[ finalDataType ];
}
}
function ajaxConvert( s, response, jqXHR, isSuccess ) {
var conv2, current, conv, tmp, prev,
converters = {},
dataTypes = s.dataTypes.slice();
if ( dataTypes[ 1 ] ) {
for ( conv in s.converters ) {
converters[ conv.toLowerCase() ] = s.converters[ conv ];
}
}
current = dataTypes.shift();
while ( current ) {
if ( s.responseFields[ current ] ) {
jqXHR[ s.responseFields[ current ] ] = response;
}
if ( !prev && isSuccess && s.dataFilter ) {
response = s.dataFilter( response, s.dataType );
}
prev = current;
current = dataTypes.shift();
if ( current ) {
if ( current === "*" ) {
current = prev;
} else if ( prev !== "*" && prev !== current ) {
conv = converters[ prev + " " + current ] || converters[ "* " + current ];
if ( !conv ) {
for ( conv2 in converters ) {
tmp = conv2.split( " " );
if ( tmp[ 1 ] === current ) {
conv = converters[ prev + " " + tmp[ 0 ] ] ||
converters[ "* " + tmp[ 0 ] ];
if ( conv ) {
if ( conv === true ) {
conv = converters[ conv2 ];
} else if ( converters[ conv2 ] !== true ) {
current = tmp[ 0 ];
dataTypes.unshift( tmp[ 1 ] );
}
break;
}
}
}
}
if ( conv !== true ) {
if ( conv && s.throws ) {
response = conv( response );
} else {
try {
response = conv( response );
} catch ( e ) {
return {
state: "parsererror",
error: conv ? e : "No conversion from " + prev + " to " + current
};
}
}
}
}
}
}
return { state: "success", data: response };
}
jQuery.extend( {
active: 0,
lastModified: {},
etag: {},
ajaxSettings: {
url: location.href,
type: "GET",
isLocal: rlocalProtocol.test( location.protocol ),
global: true,
processData: true,
async: true,
contentType: "application/x-www-form-urlencoded; charset=UTF-8",
accepts: {
"*": allTypes,
text: "text/plain",
html: "text/html",
xml: "application/xml, text/xml",
json: "application/json, text/javascript"
},
contents: {
xml: /\bxml\b/,
html: /\bhtml/,
json: /\bjson\b/
},
responseFields: {
xml: "responseXML",
text: "responseText",
json: "responseJSON"
},
converters: {
"* text": String,
"text html": true,
"text json": JSON.parse,
"text xml": jQuery.parseXML
},
flatOptions: {
url: true,
context: true
}
},
ajaxSetup: function( target, settings ) {
return settings ?
ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :
ajaxExtend( jQuery.ajaxSettings, target );
},
ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
ajaxTransport: addToPrefiltersOrTransports( transports ),
ajax: function( url, options ) {
if ( typeof url === "object" ) {
options = url;
url = undefined;
}
options = options || {};
var transport,
cacheURL,
responseHeadersString,
responseHeaders,
timeoutTimer,
urlAnchor,
completed,
fireGlobals,
i,
uncached,
s = jQuery.ajaxSetup( {}, options ),
callbackContext = s.context || s,
globalEventContext = s.context &&
( callbackContext.nodeType || callbackContext.jquery ) ?
jQuery( callbackContext ) :
jQuery.event,
deferred = jQuery.Deferred(),
completeDeferred = jQuery.Callbacks( "once memory" ),
statusCode = s.statusCode || {},
requestHeaders = {},
requestHeadersNames = {},
strAbort = "canceled",
jqXHR = {
readyState: 0,
getResponseHeader: function( key ) {
var match;
if ( completed ) {
if ( !responseHeaders ) {
responseHeaders = {};
while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
}
}
match = responseHeaders[ key.toLowerCase() ];
}
return match == null ? null : match;
},
getAllResponseHeaders: function() {
return completed ? responseHeadersString : null;
},
setRequestHeader: function( name, value ) {
if ( completed == null ) {
name = requestHeadersNames[ name.toLowerCase() ] =
requestHeadersNames[ name.toLowerCase() ] || name;
requestHeaders[ name ] = value;
}
return this;
},
overrideMimeType: function( type ) {
if ( completed == null ) {
s.mimeType = type;
}
return this;
},
statusCode: function( map ) {
var code;
if ( map ) {
if ( completed ) {
jqXHR.always( map[ jqXHR.status ] );
} else {
for ( code in map ) {
statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
}
}
}
return this;
},
abort: function( statusText ) {
var finalText = statusText || strAbort;
if ( transport ) {
transport.abort( finalText );
}
done( 0, finalText );
return this;
}
};
deferred.promise( jqXHR );
s.url = ( ( url || s.url || location.href ) + "" )
.replace( rprotocol, location.protocol + "//" );
s.type = options.method || options.type || s.method || s.type;
s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];
if ( s.crossDomain == null ) {
urlAnchor = document.createElement( "a" );
try {
urlAnchor.href = s.url;
urlAnchor.href = urlAnchor.href;
s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
urlAnchor.protocol + "//" + urlAnchor.host;
} catch ( e ) {
s.crossDomain = true;
}
}
if ( s.data && s.processData && typeof s.data !== "string" ) {
s.data = jQuery.param( s.data, s.traditional );
}
inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );
if ( completed ) {
return jqXHR;
}
fireGlobals = jQuery.event && s.global;
if ( fireGlobals && jQuery.active++ === 0 ) {
jQuery.event.trigger( "ajaxStart" );
}
s.type = s.type.toUpperCase();
s.hasContent = !rnoContent.test( s.type );
cacheURL = s.url.replace( rhash, "" );
if ( !s.hasContent ) {
uncached = s.url.slice( cacheURL.length );
if ( s.data ) {
cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;
delete s.data;
}
if ( s.cache === false ) {
cacheURL = cacheURL.replace( rantiCache, "$1" );
uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;
}
s.url = cacheURL + uncached;
} else if ( s.data && s.processData &&
( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
s.data = s.data.replace( r20, "+" );
}
if ( s.ifModified ) {
if ( jQuery.lastModified[ cacheURL ] ) {
jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
}
if ( jQuery.etag[ cacheURL ] ) {
jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
}
}
if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
jqXHR.setRequestHeader( "Content-Type", s.contentType );
}
jqXHR.setRequestHeader(
"Accept",
s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
s.accepts[ s.dataTypes[ 0 ] ] +
( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
s.accepts[ "*" ]
);
for ( i in s.headers ) {
jqXHR.setRequestHeader( i, s.headers[ i ] );
}
if ( s.beforeSend &&
( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {
return jqXHR.abort();
}
strAbort = "abort";
completeDeferred.add( s.complete );
jqXHR.done( s.success );
jqXHR.fail( s.error );
transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );
if ( !transport ) {
done( -1, "No Transport" );
} else {
jqXHR.readyState = 1;
if ( fireGlobals ) {
globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
}
if ( completed ) {
return jqXHR;
}
if ( s.async && s.timeout > 0 ) {
timeoutTimer = window.setTimeout( function() {
jqXHR.abort( "timeout" );
}, s.timeout );
}
try {
completed = false;
transport.send( requestHeaders, done );
} catch ( e ) {
if ( completed ) {
throw e;
}
done( -1, e );
}
}
function done( status, nativeStatusText, responses, headers ) {
var isSuccess, success, error, response, modified,
statusText = nativeStatusText;
if ( completed ) {
return;
}
completed = true;
if ( timeoutTimer ) {
window.clearTimeout( timeoutTimer );
}
transport = undefined;
responseHeadersString = headers || "";
jqXHR.readyState = status > 0 ? 4 : 0;
isSuccess = status >= 200 && status < 300 || status === 304;
if ( responses ) {
response = ajaxHandleResponses( s, jqXHR, responses );
}
response = ajaxConvert( s, response, jqXHR, isSuccess );
if ( isSuccess ) {
if ( s.ifModified ) {
modified = jqXHR.getResponseHeader( "Last-Modified" );
if ( modified ) {
jQuery.lastModified[ cacheURL ] = modified;
}
modified = jqXHR.getResponseHeader( "etag" );
if ( modified ) {
jQuery.etag[ cacheURL ] = modified;
}
}
if ( status === 204 || s.type === "HEAD" ) {
statusText = "nocontent";
} else if ( status === 304 ) {
statusText = "notmodified";
} else {
statusText = response.state;
success = response.data;
error = response.error;
isSuccess = !error;
}
} else {
error = statusText;
if ( status || !statusText ) {
statusText = "error";
if ( status < 0 ) {
status = 0;
}
}
}
jqXHR.status = status;
jqXHR.statusText = ( nativeStatusText || statusText ) + "";
if ( isSuccess ) {
deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
} else {
deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
}
jqXHR.statusCode( statusCode );
statusCode = undefined;
if ( fireGlobals ) {
globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
[ jqXHR, s, isSuccess ? success : error ] );
}
completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );
if ( fireGlobals ) {
globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
if ( !( --jQuery.active ) ) {
jQuery.event.trigger( "ajaxStop" );
}
}
}
return jqXHR;
},
getJSON: function( url, data, callback ) {
return jQuery.get( url, data, callback, "json" );
},
getScript: function( url, callback ) {
return jQuery.get( url, undefined, callback, "script" );
}
} );
jQuery.each( [ "get", "post" ], function( i, method ) {
jQuery[ method ] = function( url, data, callback, type ) {
if ( jQuery.isFunction( data ) ) {
type = type || callback;
callback = data;
data = undefined;
}
return jQuery.ajax( jQuery.extend( {
url: url,
type: method,
dataType: type,
data: data,
success: callback
}, jQuery.isPlainObject( url ) && url ) );
};
} );
jQuery._evalUrl = function( url ) {
return jQuery.ajax( {
url: url,
type: "GET",
dataType: "script",
cache: true,
async: false,
global: false,
"throws": true
} );
};
jQuery.fn.extend( {
wrapAll: function( html ) {
var wrap;
if ( this[ 0 ] ) {
if ( jQuery.isFunction( html ) ) {
html = html.call( this[ 0 ] );
}
wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );
if ( this[ 0 ].parentNode ) {
wrap.insertBefore( this[ 0 ] );
}
wrap.map( function() {
var elem = this;
while ( elem.firstElementChild ) {
elem = elem.firstElementChild;
}
return elem;
} ).append( this );
}
return this;
},
wrapInner: function( html ) {
if ( jQuery.isFunction( html ) ) {
return this.each( function( i ) {
jQuery( this ).wrapInner( html.call( this, i ) );
} );
}
return this.each( function() {
var self = jQuery( this ),
contents = self.contents();
if ( contents.length ) {
contents.wrapAll( html );
} else {
self.append( html );
}
} );
},
wrap: function( html ) {
var isFunction = jQuery.isFunction( html );
return this.each( function( i ) {
jQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );
} );
},
unwrap: function( selector ) {
this.parent( selector ).not( "body" ).each( function() {
jQuery( this ).replaceWith( this.childNodes );
} );
return this;
}
} );
jQuery.expr.pseudos.hidden = function( elem ) {
return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};
jQuery.ajaxSettings.xhr = function() {
try {
return new window.XMLHttpRequest();
} catch ( e ) {}
};
var xhrSuccessStatus = {
0: 200,
1223: 204
},
xhrSupported = jQuery.ajaxSettings.xhr();
support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;
jQuery.ajaxTransport( function( options ) {
var callback, errorCallback;
if ( support.cors || xhrSupported && !options.crossDomain ) {
return {
send: function( headers, complete ) {
var i,
xhr = options.xhr();
xhr.open(
options.type,
options.url,
options.async,
options.username,
options.password
);
if ( options.xhrFields ) {
for ( i in options.xhrFields ) {
xhr[ i ] = options.xhrFields[ i ];
}
}
if ( options.mimeType && xhr.overrideMimeType ) {
xhr.overrideMimeType( options.mimeType );
}
if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
headers[ "X-Requested-With" ] = "XMLHttpRequest";
}
for ( i in headers ) {
xhr.setRequestHeader( i, headers[ i ] );
}
callback = function( type ) {
return function() {
if ( callback ) {
callback = errorCallback = xhr.onload =
xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;
if ( type === "abort" ) {
xhr.abort();
} else if ( type === "error" ) {
if ( typeof xhr.status !== "number" ) {
complete( 0, "error" );
} else {
complete(
xhr.status,
xhr.statusText
);
}
} else {
complete(
xhrSuccessStatus[ xhr.status ] || xhr.status,
xhr.statusText,
( xhr.responseType || "text" ) !== "text"  ||
typeof xhr.responseText !== "string" ?
{ binary: xhr.response } :
{ text: xhr.responseText },
xhr.getAllResponseHeaders()
);
}
}
};
};
xhr.onload = callback();
errorCallback = xhr.onerror = callback( "error" );
if ( xhr.onabort !== undefined ) {
xhr.onabort = errorCallback;
} else {
xhr.onreadystatechange = function() {
if ( xhr.readyState === 4 ) {
window.setTimeout( function() {
if ( callback ) {
errorCallback();
}
} );
}
};
}
callback = callback( "abort" );
try {
xhr.send( options.hasContent && options.data || null );
} catch ( e ) {
if ( callback ) {
throw e;
}
}
},
abort: function() {
if ( callback ) {
callback();
}
}
};
}
} );
jQuery.ajaxPrefilter( function( s ) {
if ( s.crossDomain ) {
s.contents.script = false;
}
} );
jQuery.ajaxSetup( {
accepts: {
script: "text/javascript, application/javascript, " +
"application/ecmascript, application/x-ecmascript"
},
contents: {
script: /\b(?:java|ecma)script\b/
},
converters: {
"text script": function( text ) {
jQuery.globalEval( text );
return text;
}
}
} );
jQuery.ajaxPrefilter( "script", function( s ) {
if ( s.cache === undefined ) {
s.cache = false;
}
if ( s.crossDomain ) {
s.type = "GET";
}
} );
jQuery.ajaxTransport( "script", function( s ) {
if ( s.crossDomain ) {
var script, callback;
return {
send: function( _, complete ) {
script = jQuery( "<script>" ).prop( {
charset: s.scriptCharset,
src: s.url
} ).on(
"load error",
callback = function( evt ) {
script.remove();
callback = null;
if ( evt ) {
complete( evt.type === "error" ? 404 : 200, evt.type );
}
}
);
document.head.appendChild( script[ 0 ] );
},
abort: function() {
if ( callback ) {
callback();
}
}
};
}
} );
var oldCallbacks = [],
rjsonp = /(=)\?(?=&|$)|\?\?/;
jQuery.ajaxSetup( {
jsonp: "callback",
jsonpCallback: function() {
var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
this[ callback ] = true;
return callback;
}
} );
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {
var callbackName, overwritten, responseContainer,
jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
"url" :
typeof s.data === "string" &&
( s.contentType || "" )
.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
rjsonp.test( s.data ) && "data"
);
if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {
callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
s.jsonpCallback() :
s.jsonpCallback;
if ( jsonProp ) {
s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
} else if ( s.jsonp !== false ) {
s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
}
s.converters[ "script json" ] = function() {
if ( !responseContainer ) {
jQuery.error( callbackName + " was not called" );
}
return responseContainer[ 0 ];
};
s.dataTypes[ 0 ] = "json";
overwritten = window[ callbackName ];
window[ callbackName ] = function() {
responseContainer = arguments;
};
jqXHR.always( function() {
if ( overwritten === undefined ) {
jQuery( window ).removeProp( callbackName );
} else {
window[ callbackName ] = overwritten;
}
if ( s[ callbackName ] ) {
s.jsonpCallback = originalSettings.jsonpCallback;
oldCallbacks.push( callbackName );
}
if ( responseContainer && jQuery.isFunction( overwritten ) ) {
overwritten( responseContainer[ 0 ] );
}
responseContainer = overwritten = undefined;
} );
return "script";
}
} );
support.createHTMLDocument = ( function() {
var body = document.implementation.createHTMLDocument( "" ).body;
body.innerHTML = "<form></form><form></form>";
return body.childNodes.length === 2;
} )();
jQuery.parseHTML = function( data, context, keepScripts ) {
if ( typeof data !== "string" ) {
return [];
}
if ( typeof context === "boolean" ) {
keepScripts = context;
context = false;
}
var base, parsed, scripts;
if ( !context ) {
if ( support.createHTMLDocument ) {
context = document.implementation.createHTMLDocument( "" );
base = context.createElement( "base" );
base.href = document.location.href;
context.head.appendChild( base );
} else {
context = document;
}
}
parsed = rsingleTag.exec( data );
scripts = !keepScripts && [];
if ( parsed ) {
return [ context.createElement( parsed[ 1 ] ) ];
}
parsed = buildFragment( [ data ], context, scripts );
if ( scripts && scripts.length ) {
jQuery( scripts ).remove();
}
return jQuery.merge( [], parsed.childNodes );
};
jQuery.fn.load = function( url, params, callback ) {
var selector, type, response,
self = this,
off = url.indexOf( " " );
if ( off > -1 ) {
selector = stripAndCollapse( url.slice( off ) );
url = url.slice( 0, off );
}
if ( jQuery.isFunction( params ) ) {
callback = params;
params = undefined;
} else if ( params && typeof params === "object" ) {
type = "POST";
}
if ( self.length > 0 ) {
jQuery.ajax( {
url: url,
type: type || "GET",
dataType: "html",
data: params
} ).done( function( responseText ) {
response = arguments;
self.html( selector ?
jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :
responseText );
} ).always( callback && function( jqXHR, status ) {
self.each( function() {
callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
} );
} );
}
return this;
};
jQuery.each( [
"ajaxStart",
"ajaxStop",
"ajaxComplete",
"ajaxError",
"ajaxSuccess",
"ajaxSend"
], function( i, type ) {
jQuery.fn[ type ] = function( fn ) {
return this.on( type, fn );
};
} );
jQuery.expr.pseudos.animated = function( elem ) {
return jQuery.grep( jQuery.timers, function( fn ) {
return elem === fn.elem;
} ).length;
};
jQuery.offset = {
setOffset: function( elem, options, i ) {
var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
position = jQuery.css( elem, "position" ),
curElem = jQuery( elem ),
props = {};
if ( position === "static" ) {
elem.style.position = "relative";
}
curOffset = curElem.offset();
curCSSTop = jQuery.css( elem, "top" );
curCSSLeft = jQuery.css( elem, "left" );
calculatePosition = ( position === "absolute" || position === "fixed" ) &&
( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;
if ( calculatePosition ) {
curPosition = curElem.position();
curTop = curPosition.top;
curLeft = curPosition.left;
} else {
curTop = parseFloat( curCSSTop ) || 0;
curLeft = parseFloat( curCSSLeft ) || 0;
}
if ( jQuery.isFunction( options ) ) {
options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
}
if ( options.top != null ) {
props.top = ( options.top - curOffset.top ) + curTop;
}
if ( options.left != null ) {
props.left = ( options.left - curOffset.left ) + curLeft;
}
if ( "using" in options ) {
options.using.call( elem, props );
} else {
curElem.css( props );
}
}
};
jQuery.fn.extend( {
offset: function( options ) {
if ( arguments.length ) {
return options === undefined ?
this :
this.each( function( i ) {
jQuery.offset.setOffset( this, options, i );
} );
}
var doc, docElem, rect, win,
elem = this[ 0 ];
if ( !elem ) {
return;
}
if ( !elem.getClientRects().length ) {
return { top: 0, left: 0 };
}
rect = elem.getBoundingClientRect();
doc = elem.ownerDocument;
docElem = doc.documentElement;
win = doc.defaultView;
return {
top: rect.top + win.pageYOffset - docElem.clientTop,
left: rect.left + win.pageXOffset - docElem.clientLeft
};
},
position: function() {
if ( !this[ 0 ] ) {
return;
}
var offsetParent, offset,
elem = this[ 0 ],
parentOffset = { top: 0, left: 0 };
if ( jQuery.css( elem, "position" ) === "fixed" ) {
offset = elem.getBoundingClientRect();
} else {
offsetParent = this.offsetParent();
offset = this.offset();
if ( !nodeName( offsetParent[ 0 ], "html" ) ) {
parentOffset = offsetParent.offset();
}
parentOffset = {
top: parentOffset.top + jQuery.css( offsetParent[ 0 ], "borderTopWidth", true ),
left: parentOffset.left + jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true )
};
}
return {
top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
};
},
offsetParent: function() {
return this.map( function() {
var offsetParent = this.offsetParent;
while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
offsetParent = offsetParent.offsetParent;
}
return offsetParent || documentElement;
} );
}
} );
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
var top = "pageYOffset" === prop;
jQuery.fn[ method ] = function( val ) {
return access( this, function( elem, method, val ) {
var win;
if ( jQuery.isWindow( elem ) ) {
win = elem;
} else if ( elem.nodeType === 9 ) {
win = elem.defaultView;
}
if ( val === undefined ) {
return win ? win[ prop ] : elem[ method ];
}
if ( win ) {
win.scrollTo(
!top ? val : win.pageXOffset,
top ? val : win.pageYOffset
);
} else {
elem[ method ] = val;
}
}, method, val, arguments.length );
};
} );
jQuery.each( [ "top", "left" ], function( i, prop ) {
jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
function( elem, computed ) {
if ( computed ) {
computed = curCSS( elem, prop );
return rnumnonpx.test( computed ) ?
jQuery( elem ).position()[ prop ] + "px" :
computed;
}
}
);
} );
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
function( defaultExtra, funcName ) {
jQuery.fn[ funcName ] = function( margin, value ) {
var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );
return access( this, function( elem, type, value ) {
var doc;
if ( jQuery.isWindow( elem ) ) {
return funcName.indexOf( "outer" ) === 0 ?
elem[ "inner" + name ] :
elem.document.documentElement[ "client" + name ];
}
if ( elem.nodeType === 9 ) {
doc = elem.documentElement;
return Math.max(
elem.body[ "scroll" + name ], doc[ "scroll" + name ],
elem.body[ "offset" + name ], doc[ "offset" + name ],
doc[ "client" + name ]
);
}
return value === undefined ?
jQuery.css( elem, type, extra ) :
jQuery.style( elem, type, value, extra );
}, type, chainable ? margin : undefined, chainable );
};
} );
} );
jQuery.fn.extend( {
bind: function( types, data, fn ) {
return this.on( types, null, data, fn );
},
unbind: function( types, fn ) {
return this.off( types, null, fn );
},
delegate: function( selector, types, data, fn ) {
return this.on( types, selector, data, fn );
},
undelegate: function( selector, types, fn ) {
return arguments.length === 1 ?
this.off( selector, "**" ) :
this.off( types, selector || "**", fn );
}
} );
jQuery.holdReady = function( hold ) {
if ( hold ) {
jQuery.readyWait++;
} else {
jQuery.ready( true );
}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;
if ( typeof define === "function" && define.amd ) {
define( "jquery", [], function() {
return jQuery;
} );
}
var
_jQuery = window.jQuery,
_$ = window.$;
jQuery.noConflict = function( deep ) {
if ( window.$ === jQuery ) {
window.$ = _$;
}
if ( deep && window.jQuery === jQuery ) {
window.jQuery = _jQuery;
}
return jQuery;
};
if ( !noGlobal ) {
window.jQuery = window.$ = jQuery;
}
return jQuery;
} );
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
typeof define === 'function' && define.amd ? define(factory) :
(global.Popper = factory());
}(this, (function () { 'use strict';
var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';
var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];
var timeoutDuration = 0;
for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
timeoutDuration = 1;
break;
}
}
function microtaskDebounce(fn) {
var called = false;
return function () {
if (called) {
return;
}
called = true;
window.Promise.resolve().then(function () {
called = false;
fn();
});
};
}
function taskDebounce(fn) {
var scheduled = false;
return function () {
if (!scheduled) {
scheduled = true;
setTimeout(function () {
scheduled = false;
fn();
}, timeoutDuration);
}
};
}
var supportsMicroTasks = isBrowser && window.Promise;
var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;
function isFunction(functionToCheck) {
var getType = {};
return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
}
function getStyleComputedProperty(element, property) {
if (element.nodeType !== 1) {
return [];
}
var css = getComputedStyle(element, null);
return property ? css[property] : css;
}
function getParentNode(element) {
if (element.nodeName === 'HTML') {
return element;
}
return element.parentNode || element.host;
}
function getScrollParent(element) {
if (!element) {
return document.body;
}
switch (element.nodeName) {
case 'HTML':
case 'BODY':
return element.ownerDocument.body;
case '#document':
return element.body;
}
var _getStyleComputedProp = getStyleComputedProperty(element),
overflow = _getStyleComputedProp.overflow,
overflowX = _getStyleComputedProp.overflowX,
overflowY = _getStyleComputedProp.overflowY;
if (/(auto|scroll)/.test(overflow + overflowY + overflowX)) {
return element;
}
return getScrollParent(getParentNode(element));
}
function getOffsetParent(element) {
var offsetParent = element && element.offsetParent;
var nodeName = offsetParent && offsetParent.nodeName;
if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
if (element) {
return element.ownerDocument.documentElement;
}
return document.documentElement;
}
if (['TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {
return getOffsetParent(offsetParent);
}
return offsetParent;
}
function isOffsetContainer(element) {
var nodeName = element.nodeName;
if (nodeName === 'BODY') {
return false;
}
return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;
}
function getRoot(node) {
if (node.parentNode !== null) {
return getRoot(node.parentNode);
}
return node;
}
function findCommonOffsetParent(element1, element2) {
if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
return document.documentElement;
}
var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
var start = order ? element1 : element2;
var end = order ? element2 : element1;
var range = document.createRange();
range.setStart(start, 0);
range.setEnd(end, 0);
var commonAncestorContainer = range.commonAncestorContainer;
if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
if (isOffsetContainer(commonAncestorContainer)) {
return commonAncestorContainer;
}
return getOffsetParent(commonAncestorContainer);
}
var element1root = getRoot(element1);
if (element1root.host) {
return findCommonOffsetParent(element1root.host, element2);
} else {
return findCommonOffsetParent(element1, getRoot(element2).host);
}
}
function getScroll(element) {
var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';
var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
var nodeName = element.nodeName;
if (nodeName === 'BODY' || nodeName === 'HTML') {
var html = element.ownerDocument.documentElement;
var scrollingElement = element.ownerDocument.scrollingElement || html;
return scrollingElement[upperSide];
}
return element[upperSide];
}
function includeScroll(rect, element) {
var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
var scrollTop = getScroll(element, 'top');
var scrollLeft = getScroll(element, 'left');
var modifier = subtract ? -1 : 1;
rect.top += scrollTop * modifier;
rect.bottom += scrollTop * modifier;
rect.left += scrollLeft * modifier;
rect.right += scrollLeft * modifier;
return rect;
}
function getBordersSize(styles, axis) {
var sideA = axis === 'x' ? 'Left' : 'Top';
var sideB = sideA === 'Left' ? 'Right' : 'Bottom';
return parseFloat(styles['border' + sideA + 'Width'], 10) + parseFloat(styles['border' + sideB + 'Width'], 10);
}
var isIE10 = undefined;
var isIE10$1 = function () {
if (isIE10 === undefined) {
isIE10 = navigator.appVersion.indexOf('MSIE 10') !== -1;
}
return isIE10;
};
function getSize(axis, body, html, computedStyle) {
return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE10$1() ? html['offset' + axis] + computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')] + computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')] : 0);
}
function getWindowSizes() {
var body = document.body;
var html = document.documentElement;
var computedStyle = isIE10$1() && getComputedStyle(html);
return {
height: getSize('Height', body, html, computedStyle),
width: getSize('Width', body, html, computedStyle)
};
}
var classCallCheck = function (instance, Constructor) {
if (!(instance instanceof Constructor)) {
throw new TypeError("Cannot call a class as a function");
}
};
var createClass = function () {
function defineProperties(target, props) {
for (var i = 0; i < props.length; i++) {
var descriptor = props[i];
descriptor.enumerable = descriptor.enumerable || false;
descriptor.configurable = true;
if ("value" in descriptor) descriptor.writable = true;
Object.defineProperty(target, descriptor.key, descriptor);
}
}
return function (Constructor, protoProps, staticProps) {
if (protoProps) defineProperties(Constructor.prototype, protoProps);
if (staticProps) defineProperties(Constructor, staticProps);
return Constructor;
};
}();
var defineProperty = function (obj, key, value) {
if (key in obj) {
Object.defineProperty(obj, key, {
value: value,
enumerable: true,
configurable: true,
writable: true
});
} else {
obj[key] = value;
}
return obj;
};
var _extends = Object.assign || function (target) {
for (var i = 1; i < arguments.length; i++) {
var source = arguments[i];
for (var key in source) {
if (Object.prototype.hasOwnProperty.call(source, key)) {
target[key] = source[key];
}
}
}
return target;
};
function getClientRect(offsets) {
return _extends({}, offsets, {
right: offsets.left + offsets.width,
bottom: offsets.top + offsets.height
});
}
function getBoundingClientRect(element) {
var rect = {};
if (isIE10$1()) {
try {
rect = element.getBoundingClientRect();
var scrollTop = getScroll(element, 'top');
var scrollLeft = getScroll(element, 'left');
rect.top += scrollTop;
rect.left += scrollLeft;
rect.bottom += scrollTop;
rect.right += scrollLeft;
} catch (err) {}
} else {
rect = element.getBoundingClientRect();
}
var result = {
left: rect.left,
top: rect.top,
width: rect.right - rect.left,
height: rect.bottom - rect.top
};
var sizes = element.nodeName === 'HTML' ? getWindowSizes() : {};
var width = sizes.width || element.clientWidth || result.right - result.left;
var height = sizes.height || element.clientHeight || result.bottom - result.top;
var horizScrollbar = element.offsetWidth - width;
var vertScrollbar = element.offsetHeight - height;
if (horizScrollbar || vertScrollbar) {
var styles = getStyleComputedProperty(element);
horizScrollbar -= getBordersSize(styles, 'x');
vertScrollbar -= getBordersSize(styles, 'y');
result.width -= horizScrollbar;
result.height -= vertScrollbar;
}
return getClientRect(result);
}
function getOffsetRectRelativeToArbitraryNode(children, parent) {
var isIE10 = isIE10$1();
var isHTML = parent.nodeName === 'HTML';
var childrenRect = getBoundingClientRect(children);
var parentRect = getBoundingClientRect(parent);
var scrollParent = getScrollParent(children);
var styles = getStyleComputedProperty(parent);
var borderTopWidth = parseFloat(styles.borderTopWidth, 10);
var borderLeftWidth = parseFloat(styles.borderLeftWidth, 10);
var offsets = getClientRect({
top: childrenRect.top - parentRect.top - borderTopWidth,
left: childrenRect.left - parentRect.left - borderLeftWidth,
width: childrenRect.width,
height: childrenRect.height
});
offsets.marginTop = 0;
offsets.marginLeft = 0;
if (!isIE10 && isHTML) {
var marginTop = parseFloat(styles.marginTop, 10);
var marginLeft = parseFloat(styles.marginLeft, 10);
offsets.top -= borderTopWidth - marginTop;
offsets.bottom -= borderTopWidth - marginTop;
offsets.left -= borderLeftWidth - marginLeft;
offsets.right -= borderLeftWidth - marginLeft;
offsets.marginTop = marginTop;
offsets.marginLeft = marginLeft;
}
if (isIE10 ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
offsets = includeScroll(offsets, parent);
}
return offsets;
}
function getViewportOffsetRectRelativeToArtbitraryNode(element) {
var html = element.ownerDocument.documentElement;
var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
var width = Math.max(html.clientWidth, window.innerWidth || 0);
var height = Math.max(html.clientHeight, window.innerHeight || 0);
var scrollTop = getScroll(html);
var scrollLeft = getScroll(html, 'left');
var offset = {
top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
width: width,
height: height
};
return getClientRect(offset);
}
function isFixed(element) {
var nodeName = element.nodeName;
if (nodeName === 'BODY' || nodeName === 'HTML') {
return false;
}
if (getStyleComputedProperty(element, 'position') === 'fixed') {
return true;
}
return isFixed(getParentNode(element));
}
function getBoundaries(popper, reference, padding, boundariesElement) {
var boundaries = { top: 0, left: 0 };
var offsetParent = findCommonOffsetParent(popper, reference);
if (boundariesElement === 'viewport') {
boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent);
} else {
var boundariesNode = void 0;
if (boundariesElement === 'scrollParent') {
boundariesNode = getScrollParent(getParentNode(reference));
if (boundariesNode.nodeName === 'BODY') {
boundariesNode = popper.ownerDocument.documentElement;
}
} else if (boundariesElement === 'window') {
boundariesNode = popper.ownerDocument.documentElement;
} else {
boundariesNode = boundariesElement;
}
var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent);
if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
var _getWindowSizes = getWindowSizes(),
height = _getWindowSizes.height,
width = _getWindowSizes.width;
boundaries.top += offsets.top - offsets.marginTop;
boundaries.bottom = height + offsets.top;
boundaries.left += offsets.left - offsets.marginLeft;
boundaries.right = width + offsets.left;
} else {
boundaries = offsets;
}
}
boundaries.left += padding;
boundaries.top += padding;
boundaries.right -= padding;
boundaries.bottom -= padding;
return boundaries;
}
function getArea(_ref) {
var width = _ref.width,
height = _ref.height;
return width * height;
}
function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
if (placement.indexOf('auto') === -1) {
return placement;
}
var boundaries = getBoundaries(popper, reference, padding, boundariesElement);
var rects = {
top: {
width: boundaries.width,
height: refRect.top - boundaries.top
},
right: {
width: boundaries.right - refRect.right,
height: boundaries.height
},
bottom: {
width: boundaries.width,
height: boundaries.bottom - refRect.bottom
},
left: {
width: refRect.left - boundaries.left,
height: boundaries.height
}
};
var sortedAreas = Object.keys(rects).map(function (key) {
return _extends({
key: key
}, rects[key], {
area: getArea(rects[key])
});
}).sort(function (a, b) {
return b.area - a.area;
});
var filteredAreas = sortedAreas.filter(function (_ref2) {
var width = _ref2.width,
height = _ref2.height;
return width >= popper.clientWidth && height >= popper.clientHeight;
});
var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;
var variation = placement.split('-')[1];
return computedPlacement + (variation ? '-' + variation : '');
}
function getReferenceOffsets(state, popper, reference) {
var commonOffsetParent = findCommonOffsetParent(popper, reference);
return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent);
}
function getOuterSizes(element) {
var styles = getComputedStyle(element);
var x = parseFloat(styles.marginTop) + parseFloat(styles.marginBottom);
var y = parseFloat(styles.marginLeft) + parseFloat(styles.marginRight);
var result = {
width: element.offsetWidth + y,
height: element.offsetHeight + x
};
return result;
}
function getOppositePlacement(placement) {
var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };
return placement.replace(/left|right|bottom|top/g, function (matched) {
return hash[matched];
});
}
function getPopperOffsets(popper, referenceOffsets, placement) {
placement = placement.split('-')[0];
var popperRect = getOuterSizes(popper);
var popperOffsets = {
width: popperRect.width,
height: popperRect.height
};
var isHoriz = ['right', 'left'].indexOf(placement) !== -1;
var mainSide = isHoriz ? 'top' : 'left';
var secondarySide = isHoriz ? 'left' : 'top';
var measurement = isHoriz ? 'height' : 'width';
var secondaryMeasurement = !isHoriz ? 'height' : 'width';
popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
if (placement === secondarySide) {
popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
} else {
popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
}
return popperOffsets;
}
function find(arr, check) {
if (Array.prototype.find) {
return arr.find(check);
}
return arr.filter(check)[0];
}
function findIndex(arr, prop, value) {
if (Array.prototype.findIndex) {
return arr.findIndex(function (cur) {
return cur[prop] === value;
});
}
var match = find(arr, function (obj) {
return obj[prop] === value;
});
return arr.indexOf(match);
}
function runModifiers(modifiers, data, ends) {
var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));
modifiersToRun.forEach(function (modifier) {
if (modifier['function']) {
console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
}
var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation
if (modifier.enabled && isFunction(fn)) {
data.offsets.popper = getClientRect(data.offsets.popper);
data.offsets.reference = getClientRect(data.offsets.reference);
data = fn(data, modifier);
}
});
return data;
}
function update() {
if (this.state.isDestroyed) {
return;
}
var data = {
instance: this,
styles: {},
arrowStyles: {},
attributes: {},
flipped: false,
offsets: {}
};
data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference);
data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);
data.originalPlacement = data.placement;
data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);
data.offsets.popper.position = 'absolute';
data = runModifiers(this.modifiers, data);
if (!this.state.isCreated) {
this.state.isCreated = true;
this.options.onCreate(data);
} else {
this.options.onUpdate(data);
}
}
function isModifierEnabled(modifiers, modifierName) {
return modifiers.some(function (_ref) {
var name = _ref.name,
enabled = _ref.enabled;
return enabled && name === modifierName;
});
}
function getSupportedPropertyName(property) {
var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];
var upperProp = property.charAt(0).toUpperCase() + property.slice(1);
for (var i = 0; i < prefixes.length - 1; i++) {
var prefix = prefixes[i];
var toCheck = prefix ? '' + prefix + upperProp : property;
if (typeof document.body.style[toCheck] !== 'undefined') {
return toCheck;
}
}
return null;
}
function destroy() {
this.state.isDestroyed = true;
if (isModifierEnabled(this.modifiers, 'applyStyle')) {
this.popper.removeAttribute('x-placement');
this.popper.style.left = '';
this.popper.style.position = '';
this.popper.style.top = '';
this.popper.style[getSupportedPropertyName('transform')] = '';
}
this.disableEventListeners();
if (this.options.removeOnDestroy) {
this.popper.parentNode.removeChild(this.popper);
}
return this;
}
function getWindow(element) {
var ownerDocument = element.ownerDocument;
return ownerDocument ? ownerDocument.defaultView : window;
}
function attachToScrollParents(scrollParent, event, callback, scrollParents) {
var isBody = scrollParent.nodeName === 'BODY';
var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
target.addEventListener(event, callback, { passive: true });
if (!isBody) {
attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
}
scrollParents.push(target);
}
function setupEventListeners(reference, options, state, updateBound) {
state.updateBound = updateBound;
getWindow(reference).addEventListener('resize', state.updateBound, { passive: true });
var scrollElement = getScrollParent(reference);
attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);
state.scrollElement = scrollElement;
state.eventsEnabled = true;
return state;
}
function enableEventListeners() {
if (!this.state.eventsEnabled) {
this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
}
}
function removeEventListeners(reference, state) {
getWindow(reference).removeEventListener('resize', state.updateBound);
state.scrollParents.forEach(function (target) {
target.removeEventListener('scroll', state.updateBound);
});
state.updateBound = null;
state.scrollParents = [];
state.scrollElement = null;
state.eventsEnabled = false;
return state;
}
function disableEventListeners() {
if (this.state.eventsEnabled) {
cancelAnimationFrame(this.scheduleUpdate);
this.state = removeEventListeners(this.reference, this.state);
}
}
function isNumeric(n) {
return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
}
function setStyles(element, styles) {
Object.keys(styles).forEach(function (prop) {
var unit = '';
if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
unit = 'px';
}
element.style[prop] = styles[prop] + unit;
});
}
function setAttributes(element, attributes) {
Object.keys(attributes).forEach(function (prop) {
var value = attributes[prop];
if (value !== false) {
element.setAttribute(prop, attributes[prop]);
} else {
element.removeAttribute(prop);
}
});
}
function applyStyle(data) {
setStyles(data.instance.popper, data.styles);
setAttributes(data.instance.popper, data.attributes);
if (data.arrowElement && Object.keys(data.arrowStyles).length) {
setStyles(data.arrowElement, data.arrowStyles);
}
return data;
}
function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
var referenceOffsets = getReferenceOffsets(state, popper, reference);
var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);
popper.setAttribute('x-placement', placement);
setStyles(popper, { position: 'absolute' });
return options;
}
function computeStyle(data, options) {
var x = options.x,
y = options.y;
var popper = data.offsets.popper;
var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {
return modifier.name === 'applyStyle';
}).gpuAcceleration;
if (legacyGpuAccelerationOption !== undefined) {
console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');
}
var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;
var offsetParent = getOffsetParent(data.instance.popper);
var offsetParentRect = getBoundingClientRect(offsetParent);
var styles = {
position: popper.position
};
var offsets = {
left: Math.floor(popper.left),
top: Math.floor(popper.top),
bottom: Math.floor(popper.bottom),
right: Math.floor(popper.right)
};
var sideA = x === 'bottom' ? 'top' : 'bottom';
var sideB = y === 'right' ? 'left' : 'right';
var prefixedProperty = getSupportedPropertyName('transform');
var left = void 0,
top = void 0;
if (sideA === 'bottom') {
top = -offsetParentRect.height + offsets.bottom;
} else {
top = offsets.top;
}
if (sideB === 'right') {
left = -offsetParentRect.width + offsets.right;
} else {
left = offsets.left;
}
if (gpuAcceleration && prefixedProperty) {
styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
styles[sideA] = 0;
styles[sideB] = 0;
styles.willChange = 'transform';
} else {
var invertTop = sideA === 'bottom' ? -1 : 1;
var invertLeft = sideB === 'right' ? -1 : 1;
styles[sideA] = top * invertTop;
styles[sideB] = left * invertLeft;
styles.willChange = sideA + ', ' + sideB;
}
var attributes = {
'x-placement': data.placement
};
data.attributes = _extends({}, attributes, data.attributes);
data.styles = _extends({}, styles, data.styles);
data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);
return data;
}
function isModifierRequired(modifiers, requestingName, requestedName) {
var requesting = find(modifiers, function (_ref) {
var name = _ref.name;
return name === requestingName;
});
var isRequired = !!requesting && modifiers.some(function (modifier) {
return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
});
if (!isRequired) {
var _requesting = '`' + requestingName + '`';
var requested = '`' + requestedName + '`';
console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');
}
return isRequired;
}
function arrow(data, options) {
var _data$offsets$arrow;
if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {
return data;
}
var arrowElement = options.element;
if (typeof arrowElement === 'string') {
arrowElement = data.instance.popper.querySelector(arrowElement);
if (!arrowElement) {
return data;
}
} else {
if (!data.instance.popper.contains(arrowElement)) {
console.warn('WARNING: `arrow.element` must be child of its popper element!');
return data;
}
}
var placement = data.placement.split('-')[0];
var _data$offsets = data.offsets,
popper = _data$offsets.popper,
reference = _data$offsets.reference;
var isVertical = ['left', 'right'].indexOf(placement) !== -1;
var len = isVertical ? 'height' : 'width';
var sideCapitalized = isVertical ? 'Top' : 'Left';
var side = sideCapitalized.toLowerCase();
var altSide = isVertical ? 'left' : 'top';
var opSide = isVertical ? 'bottom' : 'right';
var arrowElementSize = getOuterSizes(arrowElement)[len];
if (reference[opSide] - arrowElementSize < popper[side]) {
data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
}
if (reference[side] + arrowElementSize > popper[opSide]) {
data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
}
data.offsets.popper = getClientRect(data.offsets.popper);
var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;
var css = getStyleComputedProperty(data.instance.popper);
var popperMarginSide = parseFloat(css['margin' + sideCapitalized], 10);
var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width'], 10);
var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;
sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);
data.arrowElement = arrowElement;
data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);
return data;
}
function getOppositeVariation(variation) {
if (variation === 'end') {
return 'start';
} else if (variation === 'start') {
return 'end';
}
return variation;
}
var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];
var validPlacements = placements.slice(3);
function clockwise(placement) {
var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
var index = validPlacements.indexOf(placement);
var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
return counter ? arr.reverse() : arr;
}
var BEHAVIORS = {
FLIP: 'flip',
CLOCKWISE: 'clockwise',
COUNTERCLOCKWISE: 'counterclockwise'
};
function flip(data, options) {
if (isModifierEnabled(data.instance.modifiers, 'inner')) {
return data;
}
if (data.flipped && data.placement === data.originalPlacement) {
return data;
}
var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement);
var placement = data.placement.split('-')[0];
var placementOpposite = getOppositePlacement(placement);
var variation = data.placement.split('-')[1] || '';
var flipOrder = [];
switch (options.behavior) {
case BEHAVIORS.FLIP:
flipOrder = [placement, placementOpposite];
break;
case BEHAVIORS.CLOCKWISE:
flipOrder = clockwise(placement);
break;
case BEHAVIORS.COUNTERCLOCKWISE:
flipOrder = clockwise(placement, true);
break;
default:
flipOrder = options.behavior;
}
flipOrder.forEach(function (step, index) {
if (placement !== step || flipOrder.length === index + 1) {
return data;
}
placement = data.placement.split('-')[0];
placementOpposite = getOppositePlacement(placement);
var popperOffsets = data.offsets.popper;
var refOffsets = data.offsets.reference;
var floor = Math.floor;
var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);
var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);
var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;
var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
var flippedVariation = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);
if (overlapsRef || overflowsBoundaries || flippedVariation) {
data.flipped = true;
if (overlapsRef || overflowsBoundaries) {
placement = flipOrder[index + 1];
}
if (flippedVariation) {
variation = getOppositeVariation(variation);
}
data.placement = placement + (variation ? '-' + variation : '');
data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));
data = runModifiers(data.instance.modifiers, data, 'flip');
}
});
return data;
}
function keepTogether(data) {
var _data$offsets = data.offsets,
popper = _data$offsets.popper,
reference = _data$offsets.reference;
var placement = data.placement.split('-')[0];
var floor = Math.floor;
var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
var side = isVertical ? 'right' : 'bottom';
var opSide = isVertical ? 'left' : 'top';
var measurement = isVertical ? 'width' : 'height';
if (popper[side] < floor(reference[opSide])) {
data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
}
if (popper[opSide] > floor(reference[side])) {
data.offsets.popper[opSide] = floor(reference[side]);
}
return data;
}
function toValue(str, measurement, popperOffsets, referenceOffsets) {
var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
var value = +split[1];
var unit = split[2];
if (!value) {
return str;
}
if (unit.indexOf('%') === 0) {
var element = void 0;
switch (unit) {
case '%p':
element = popperOffsets;
break;
case '%':
case '%r':
default:
element = referenceOffsets;
}
var rect = getClientRect(element);
return rect[measurement] / 100 * value;
} else if (unit === 'vh' || unit === 'vw') {
var size = void 0;
if (unit === 'vh') {
size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
} else {
size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
}
return size / 100 * value;
} else {
return value;
}
}
function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
var offsets = [0, 0];
var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;
var fragments = offset.split(/(\+|\-)/).map(function (frag) {
return frag.trim();
});
var divider = fragments.indexOf(find(fragments, function (frag) {
return frag.search(/,|\s/) !== -1;
}));
if (fragments[divider] && fragments[divider].indexOf(',') === -1) {
console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
}
var splitRegex = /\s*,\s*|\s+/;
var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];
ops = ops.map(function (op, index) {
var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';
var mergeWithPrevious = false;
return op
.reduce(function (a, b) {
if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {
a[a.length - 1] = b;
mergeWithPrevious = true;
return a;
} else if (mergeWithPrevious) {
a[a.length - 1] += b;
mergeWithPrevious = false;
return a;
} else {
return a.concat(b);
}
}, [])
.map(function (str) {
return toValue(str, measurement, popperOffsets, referenceOffsets);
});
});
ops.forEach(function (op, index) {
op.forEach(function (frag, index2) {
if (isNumeric(frag)) {
offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);
}
});
});
return offsets;
}
function offset(data, _ref) {
var offset = _ref.offset;
var placement = data.placement,
_data$offsets = data.offsets,
popper = _data$offsets.popper,
reference = _data$offsets.reference;
var basePlacement = placement.split('-')[0];
var offsets = void 0;
if (isNumeric(+offset)) {
offsets = [+offset, 0];
} else {
offsets = parseOffset(offset, popper, reference, basePlacement);
}
if (basePlacement === 'left') {
popper.top += offsets[0];
popper.left -= offsets[1];
} else if (basePlacement === 'right') {
popper.top += offsets[0];
popper.left += offsets[1];
} else if (basePlacement === 'top') {
popper.left += offsets[0];
popper.top -= offsets[1];
} else if (basePlacement === 'bottom') {
popper.left += offsets[0];
popper.top += offsets[1];
}
data.popper = popper;
return data;
}
function preventOverflow(data, options) {
var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);
if (data.instance.reference === boundariesElement) {
boundariesElement = getOffsetParent(boundariesElement);
}
var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement);
options.boundaries = boundaries;
var order = options.priority;
var popper = data.offsets.popper;
var check = {
primary: function primary(placement) {
var value = popper[placement];
if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
value = Math.max(popper[placement], boundaries[placement]);
}
return defineProperty({}, placement, value);
},
secondary: function secondary(placement) {
var mainSide = placement === 'right' ? 'left' : 'top';
var value = popper[mainSide];
if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));
}
return defineProperty({}, mainSide, value);
}
};
order.forEach(function (placement) {
var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';
popper = _extends({}, popper, check[side](placement));
});
data.offsets.popper = popper;
return data;
}
function shift(data) {
var placement = data.placement;
var basePlacement = placement.split('-')[0];
var shiftvariation = placement.split('-')[1];
if (shiftvariation) {
var _data$offsets = data.offsets,
reference = _data$offsets.reference,
popper = _data$offsets.popper;
var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;
var side = isVertical ? 'left' : 'top';
var measurement = isVertical ? 'width' : 'height';
var shiftOffsets = {
start: defineProperty({}, side, reference[side]),
end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
};
data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);
}
return data;
}
function hide(data) {
if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {
return data;
}
var refRect = data.offsets.reference;
var bound = find(data.instance.modifiers, function (modifier) {
return modifier.name === 'preventOverflow';
}).boundaries;
if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
if (data.hide === true) {
return data;
}
data.hide = true;
data.attributes['x-out-of-boundaries'] = '';
} else {
if (data.hide === false) {
return data;
}
data.hide = false;
data.attributes['x-out-of-boundaries'] = false;
}
return data;
}
function inner(data) {
var placement = data.placement;
var basePlacement = placement.split('-')[0];
var _data$offsets = data.offsets,
popper = _data$offsets.popper,
reference = _data$offsets.reference;
var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;
var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;
popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);
data.placement = getOppositePlacement(placement);
data.offsets.popper = getClientRect(popper);
return data;
}
var modifiers = {
shift: {
order: 100,
enabled: true,
fn: shift
},
offset: {
order: 200,
enabled: true,
fn: offset,
offset: 0
},
preventOverflow: {
order: 300,
enabled: true,
fn: preventOverflow,
priority: ['left', 'right', 'top', 'bottom'],
padding: 5,
boundariesElement: 'scrollParent'
},
keepTogether: {
order: 400,
enabled: true,
fn: keepTogether
},
arrow: {
order: 500,
enabled: true,
fn: arrow,
element: '[x-arrow]'
},
flip: {
order: 600,
enabled: true,
fn: flip,
behavior: 'flip',
padding: 5,
boundariesElement: 'viewport'
},
inner: {
order: 700,
enabled: false,
fn: inner
},
hide: {
order: 800,
enabled: true,
fn: hide
},
computeStyle: {
order: 850,
enabled: true,
fn: computeStyle,
gpuAcceleration: true,
x: 'bottom',
y: 'right'
},
applyStyle: {
order: 900,
enabled: true,
fn: applyStyle,
onLoad: applyStyleOnLoad,
gpuAcceleration: undefined
}
};
var Defaults = {
placement: 'bottom',
eventsEnabled: true,
removeOnDestroy: false,
onCreate: function onCreate() {},
onUpdate: function onUpdate() {},
modifiers: modifiers
};
var Popper = function () {
function Popper(reference, popper) {
var _this = this;
var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
classCallCheck(this, Popper);
this.scheduleUpdate = function () {
return requestAnimationFrame(_this.update);
};
this.update = debounce(this.update.bind(this));
this.options = _extends({}, Popper.Defaults, options);
this.state = {
isDestroyed: false,
isCreated: false,
scrollParents: []
};
this.reference = reference && reference.jquery ? reference[0] : reference;
this.popper = popper && popper.jquery ? popper[0] : popper;
this.options.modifiers = {};
Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
_this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
});
this.modifiers = Object.keys(this.options.modifiers).map(function (name) {
return _extends({
name: name
}, _this.options.modifiers[name]);
})
.sort(function (a, b) {
return a.order - b.order;
});
this.modifiers.forEach(function (modifierOptions) {
if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {
modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
}
});
this.update();
var eventsEnabled = this.options.eventsEnabled;
if (eventsEnabled) {
this.enableEventListeners();
}
this.state.eventsEnabled = eventsEnabled;
}
createClass(Popper, [{
key: 'update',
value: function update$$1() {
return update.call(this);
}
}, {
key: 'destroy',
value: function destroy$$1() {
return destroy.call(this);
}
}, {
key: 'enableEventListeners',
value: function enableEventListeners$$1() {
return enableEventListeners.call(this);
}
}, {
key: 'disableEventListeners',
value: function disableEventListeners$$1() {
return disableEventListeners.call(this);
}
}]);
return Popper;
}();
Popper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;
Popper.placements = placements;
Popper.Defaults = Defaults;
return Popper;
})));
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("jquery"),require("popper.js")):"function"==typeof define&&define.amd?define(["exports","jquery","popper.js"],e):e(t.bootstrap={},t.jQuery,t.Popper)}(this,function(t,e,n){"use strict";function i(t,e){for(var n=0;n<e.length;n++){var i=e[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}function s(t,e,n){return e&&i(t.prototype,e),n&&i(t,n),t}function r(){return(r=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var i in n)Object.prototype.hasOwnProperty.call(n,i)&&(t[i]=n[i])}return t}).apply(this,arguments)}e=e&&e.hasOwnProperty("default")?e.default:e,n=n&&n.hasOwnProperty("default")?n.default:n;var o=function(t){function e(t){return{}.toString.call(t).match(/\s([a-zA-Z]+)/)[1].toLowerCase()}function n(e){var n=this,i=!1;return t(this).one(s.TRANSITION_END,function(){i=!0}),setTimeout(function(){i||s.triggerTransitionEnd(n)},e),this}var i=!1,s={TRANSITION_END:"bsTransitionEnd",getUID:function(t){do{t+=~~(1e6*Math.random())}while(document.getElementById(t));return t},getSelectorFromElement:function(e){var n=e.getAttribute("data-target");n&&"#"!==n||(n=e.getAttribute("href")||""),"#"===n.charAt(0)&&(n=function(e){return e="function"==typeof t.escapeSelector?t.escapeSelector(e).substr(1):e.replace(/(:|\.|\[|\]|,|=|@)/g,"\\$1")}(n));try{return t(document).find(n).length>0?n:null}catch(t){return null}},reflow:function(t){return t.offsetHeight},triggerTransitionEnd:function(e){t(e).trigger(i.end)},supportsTransitionEnd:function(){return Boolean(i)},isElement:function(t){return(t[0]||t).nodeType},typeCheckConfig:function(t,n,i){for(var r in i)if(Object.prototype.hasOwnProperty.call(i,r)){var o=i[r],a=n[r],l=a&&s.isElement(a)?"element":e(a);if(!new RegExp(o).test(l))throw new Error(t.toUpperCase()+': Option "'+r+'" provided type "'+l+'" but expected type "'+o+'".')}}};return i=!window.QUnit&&{end:"transitionend"},t.fn.emulateTransitionEnd=n,s.supportsTransitionEnd()&&(t.event.special[s.TRANSITION_END]={bindType:i.end,delegateType:i.end,handle:function(e){if(t(e.target).is(this))return e.handleObj.handler.apply(this,arguments)}}),s}(e),a=function(t){var e="alert",n="bs.alert",i="."+n,r=t.fn[e],a={CLOSE:"close"+i,CLOSED:"closed"+i,CLICK_DATA_API:"click"+i+".data-api"},l="alert",h="fade",c="show",u=function(){function e(t){this._element=t}var i=e.prototype;return i.close=function(t){t=t||this._element;var e=this._getRootElement(t);this._triggerCloseEvent(e).isDefaultPrevented()||this._removeElement(e)},i.dispose=function(){t.removeData(this._element,n),this._element=null},i._getRootElement=function(e){var n=o.getSelectorFromElement(e),i=!1;return n&&(i=t(n)[0]),i||(i=t(e).closest("."+l)[0]),i},i._triggerCloseEvent=function(e){var n=t.Event(a.CLOSE);return t(e).trigger(n),n},i._removeElement=function(e){var n=this;t(e).removeClass(c),o.supportsTransitionEnd()&&t(e).hasClass(h)?t(e).one(o.TRANSITION_END,function(t){return n._destroyElement(e,t)}).emulateTransitionEnd(150):this._destroyElement(e)},i._destroyElement=function(e){t(e).detach().trigger(a.CLOSED).remove()},e._jQueryInterface=function(i){return this.each(function(){var s=t(this),r=s.data(n);r||(r=new e(this),s.data(n,r)),"close"===i&&r[i](this)})},e._handleDismiss=function(t){return function(e){e&&e.preventDefault(),t.close(this)}},s(e,null,[{key:"VERSION",get:function(){return"4.0.0-beta.3"}}]),e}();return t(document).on(a.CLICK_DATA_API,'[data-dismiss="alert"]',u._handleDismiss(new u)),t.fn[e]=u._jQueryInterface,t.fn[e].Constructor=u,t.fn[e].noConflict=function(){return t.fn[e]=r,u._jQueryInterface},u}(e),l=function(t){var e="button",n="bs.button",i="."+n,r=".data-api",o=t.fn[e],a="active",l="btn",h="focus",c='[data-toggle^="button"]',u='[data-toggle="buttons"]',f="input",d=".active",_=".btn",g={CLICK_DATA_API:"click"+i+r,FOCUS_BLUR_DATA_API:"focus"+i+r+" blur"+i+r},m=function(){function e(t){this._element=t}var i=e.prototype;return i.toggle=function(){var e=!0,n=!0,i=t(this._element).closest(u)[0];if(i){var s=t(this._element).find(f)[0];if(s){if("radio"===s.type)if(s.checked&&t(this._element).hasClass(a))e=!1;else{var r=t(i).find(d)[0];r&&t(r).removeClass(a)}if(e){if(s.hasAttribute("disabled")||i.hasAttribute("disabled")||s.classList.contains("disabled")||i.classList.contains("disabled"))return;s.checked=!t(this._element).hasClass(a),t(s).trigger("change")}s.focus(),n=!1}}n&&this._element.setAttribute("aria-pressed",!t(this._element).hasClass(a)),e&&t(this._element).toggleClass(a)},i.dispose=function(){t.removeData(this._element,n),this._element=null},e._jQueryInterface=function(i){return this.each(function(){var s=t(this).data(n);s||(s=new e(this),t(this).data(n,s)),"toggle"===i&&s[i]()})},s(e,null,[{key:"VERSION",get:function(){return"4.0.0-beta.3"}}]),e}();return t(document).on(g.CLICK_DATA_API,c,function(e){e.preventDefault();var n=e.target;t(n).hasClass(l)||(n=t(n).closest(_)),m._jQueryInterface.call(t(n),"toggle")}).on(g.FOCUS_BLUR_DATA_API,c,function(e){var n=t(e.target).closest(_)[0];t(n).toggleClass(h,/^focus(in)?$/.test(e.type))}),t.fn[e]=m._jQueryInterface,t.fn[e].Constructor=m,t.fn[e].noConflict=function(){return t.fn[e]=o,m._jQueryInterface},m}(e),h=function(t){var e="carousel",n="bs.carousel",i="."+n,a=t.fn[e],l={interval:5e3,keyboard:!0,slide:!1,pause:"hover",wrap:!0},h={interval:"(number|boolean)",keyboard:"boolean",slide:"(boolean|string)",pause:"(string|boolean)",wrap:"boolean"},c="next",u="prev",f="left",d="right",_={SLIDE:"slide"+i,SLID:"slid"+i,KEYDOWN:"keydown"+i,MOUSEENTER:"mouseenter"+i,MOUSELEAVE:"mouseleave"+i,TOUCHEND:"touchend"+i,LOAD_DATA_API:"load"+i+".data-api",CLICK_DATA_API:"click"+i+".data-api"},g="carousel",m="active",p="slide",v="carousel-item-right",E="carousel-item-left",T="carousel-item-next",y="carousel-item-prev",C={ACTIVE:".active",ACTIVE_ITEM:".active.carousel-item",ITEM:".carousel-item",NEXT_PREV:".carousel-item-next, .carousel-item-prev",INDICATORS:".carousel-indicators",DATA_SLIDE:"[data-slide], [data-slide-to]",DATA_RIDE:'[data-ride="carousel"]'},I=function(){function a(e,n){this._items=null,this._interval=null,this._activeElement=null,this._isPaused=!1,this._isSliding=!1,this.touchTimeout=null,this._config=this._getConfig(n),this._element=t(e)[0],this._indicatorsElement=t(this._element).find(C.INDICATORS)[0],this._addEventListeners()}var I=a.prototype;return I.next=function(){this._isSliding||this._slide(c)},I.nextWhenVisible=function(){!document.hidden&&t(this._element).is(":visible")&&"hidden"!==t(this._element).css("visibility")&&this.next()},I.prev=function(){this._isSliding||this._slide(u)},I.pause=function(e){e||(this._isPaused=!0),t(this._element).find(C.NEXT_PREV)[0]&&o.supportsTransitionEnd()&&(o.triggerTransitionEnd(this._element),this.cycle(!0)),clearInterval(this._interval),this._interval=null},I.cycle=function(t){t||(this._isPaused=!1),this._interval&&(clearInterval(this._interval),this._interval=null),this._config.interval&&!this._isPaused&&(this._interval=setInterval((document.visibilityState?this.nextWhenVisible:this.next).bind(this),this._config.interval))},I.to=function(e){var n=this;this._activeElement=t(this._element).find(C.ACTIVE_ITEM)[0];var i=this._getItemIndex(this._activeElement);if(!(e>this._items.length-1||e<0))if(this._isSliding)t(this._element).one(_.SLID,function(){return n.to(e)});else{if(i===e)return this.pause(),void this.cycle();var s=e>i?c:u;this._slide(s,this._items[e])}},I.dispose=function(){t(this._element).off(i),t.removeData(this._element,n),this._items=null,this._config=null,this._element=null,this._interval=null,this._isPaused=null,this._isSliding=null,this._activeElement=null,this._indicatorsElement=null},I._getConfig=function(t){return t=r({},l,t),o.typeCheckConfig(e,t,h),t},I._addEventListeners=function(){var e=this;this._config.keyboard&&t(this._element).on(_.KEYDOWN,function(t){return e._keydown(t)}),"hover"===this._config.pause&&(t(this._element).on(_.MOUSEENTER,function(t){return e.pause(t)}).on(_.MOUSELEAVE,function(t){return e.cycle(t)}),"ontouchstart"in document.documentElement&&t(this._element).on(_.TOUCHEND,function(){e.pause(),e.touchTimeout&&clearTimeout(e.touchTimeout),e.touchTimeout=setTimeout(function(t){return e.cycle(t)},500+e._config.interval)}))},I._keydown=function(t){if(!/input|textarea/i.test(t.target.tagName))switch(t.which){case 37:t.preventDefault(),this.prev();break;case 39:t.preventDefault(),this.next();break;default:return}},I._getItemIndex=function(e){return this._items=t.makeArray(t(e).parent().find(C.ITEM)),this._items.indexOf(e)},I._getItemByDirection=function(t,e){var n=t===c,i=t===u,s=this._getItemIndex(e),r=this._items.length-1;if((i&&0===s||n&&s===r)&&!this._config.wrap)return e;var o=(s+(t===u?-1:1))%this._items.length;return-1===o?this._items[this._items.length-1]:this._items[o]},I._triggerSlideEvent=function(e,n){var i=this._getItemIndex(e),s=this._getItemIndex(t(this._element).find(C.ACTIVE_ITEM)[0]),r=t.Event(_.SLIDE,{relatedTarget:e,direction:n,from:s,to:i});return t(this._element).trigger(r),r},I._setActiveIndicatorElement=function(e){if(this._indicatorsElement){t(this._indicatorsElement).find(C.ACTIVE).removeClass(m);var n=this._indicatorsElement.children[this._getItemIndex(e)];n&&t(n).addClass(m)}},I._slide=function(e,n){var i,s,r,a=this,l=t(this._element).find(C.ACTIVE_ITEM)[0],h=this._getItemIndex(l),u=n||l&&this._getItemByDirection(e,l),g=this._getItemIndex(u),I=Boolean(this._interval);if(e===c?(i=E,s=T,r=f):(i=v,s=y,r=d),u&&t(u).hasClass(m))this._isSliding=!1;else{if(!this._triggerSlideEvent(u,r).isDefaultPrevented()&&l&&u){this._isSliding=!0,I&&this.pause(),this._setActiveIndicatorElement(u);var A=t.Event(_.SLID,{relatedTarget:u,direction:r,from:h,to:g});o.supportsTransitionEnd()&&t(this._element).hasClass(p)?(t(u).addClass(s),o.reflow(u),t(l).addClass(i),t(u).addClass(i),t(l).one(o.TRANSITION_END,function(){t(u).removeClass(i+" "+s).addClass(m),t(l).removeClass(m+" "+s+" "+i),a._isSliding=!1,setTimeout(function(){return t(a._element).trigger(A)},0)}).emulateTransitionEnd(600)):(t(l).removeClass(m),t(u).addClass(m),this._isSliding=!1,t(this._element).trigger(A)),I&&this.cycle()}}},a._jQueryInterface=function(e){return this.each(function(){var i=t(this).data(n),s=r({},l,t(this).data());"object"==typeof e&&(s=r({},s,e));var o="string"==typeof e?e:s.slide;if(i||(i=new a(this,s),t(this).data(n,i)),"number"==typeof e)i.to(e);else if("string"==typeof o){if("undefined"==typeof i[o])throw new Error('No method named "'+o+'"');i[o]()}else s.interval&&(i.pause(),i.cycle())})},a._dataApiClickHandler=function(e){var i=o.getSelectorFromElement(this);if(i){var s=t(i)[0];if(s&&t(s).hasClass(g)){var l=r({},t(s).data(),t(this).data()),h=this.getAttribute("data-slide-to");h&&(l.interval=!1),a._jQueryInterface.call(t(s),l),h&&t(s).data(n).to(h),e.preventDefault()}}},s(a,null,[{key:"VERSION",get:function(){return"4.0.0-beta.3"}},{key:"Default",get:function(){return l}}]),a}();return t(document).on(_.CLICK_DATA_API,C.DATA_SLIDE,I._dataApiClickHandler),t(window).on(_.LOAD_DATA_API,function(){t(C.DATA_RIDE).each(function(){var e=t(this);I._jQueryInterface.call(e,e.data())})}),t.fn[e]=I._jQueryInterface,t.fn[e].Constructor=I,t.fn[e].noConflict=function(){return t.fn[e]=a,I._jQueryInterface},I}(e),c=function(t){var e="collapse",n="bs.collapse",i="."+n,a=t.fn[e],l={toggle:!0,parent:""},h={toggle:"boolean",parent:"(string|element)"},c={SHOW:"show"+i,SHOWN:"shown"+i,HIDE:"hide"+i,HIDDEN:"hidden"+i,CLICK_DATA_API:"click"+i+".data-api"},u="show",f="collapse",d="collapsing",_="collapsed",g="width",m="height",p={ACTIVES:".show, .collapsing",DATA_TOGGLE:'[data-toggle="collapse"]'},v=function(){function i(e,n){this._isTransitioning=!1,this._element=e,this._config=this._getConfig(n),this._triggerArray=t.makeArray(t('[data-toggle="collapse"][href="#'+e.id+'"],[data-toggle="collapse"][data-target="#'+e.id+'"]'));for(var i=t(p.DATA_TOGGLE),s=0;s<i.length;s++){var r=i[s],a=o.getSelectorFromElement(r);null!==a&&t(a).filter(e).length>0&&this._triggerArray.push(r)}this._parent=this._config.parent?this._getParent():null,this._config.parent||this._addAriaAndCollapsedClass(this._element,this._triggerArray),this._config.toggle&&this.toggle()}var a=i.prototype;return a.toggle=function(){t(this._element).hasClass(u)?this.hide():this.show()},a.show=function(){var e=this;if(!this._isTransitioning&&!t(this._element).hasClass(u)){var s,r;if(this._parent&&((s=t.makeArray(t(this._parent).children().children(p.ACTIVES))).length||(s=null)),!(s&&(r=t(s).data(n))&&r._isTransitioning)){var a=t.Event(c.SHOW);if(t(this._element).trigger(a),!a.isDefaultPrevented()){s&&(i._jQueryInterface.call(t(s),"hide"),r||t(s).data(n,null));var l=this._getDimension();t(this._element).removeClass(f).addClass(d),this._element.style[l]=0,this._triggerArray.length&&t(this._triggerArray).removeClass(_).attr("aria-expanded",!0),this.setTransitioning(!0);var h=function(){t(e._element).removeClass(d).addClass(f).addClass(u),e._element.style[l]="",e.setTransitioning(!1),t(e._element).trigger(c.SHOWN)};if(o.supportsTransitionEnd()){var g="scroll"+(l[0].toUpperCase()+l.slice(1));t(this._element).one(o.TRANSITION_END,h).emulateTransitionEnd(600),this._element.style[l]=this._element[g]+"px"}else h()}}}},a.hide=function(){var e=this;if(!this._isTransitioning&&t(this._element).hasClass(u)){var n=t.Event(c.HIDE);if(t(this._element).trigger(n),!n.isDefaultPrevented()){var i=this._getDimension();if(this._element.style[i]=this._element.getBoundingClientRect()[i]+"px",o.reflow(this._element),t(this._element).addClass(d).removeClass(f).removeClass(u),this._triggerArray.length)for(var s=0;s<this._triggerArray.length;s++){var r=this._triggerArray[s],a=o.getSelectorFromElement(r);if(null!==a){t(a).hasClass(u)||t(r).addClass(_).attr("aria-expanded",!1)}}this.setTransitioning(!0);var l=function(){e.setTransitioning(!1),t(e._element).removeClass(d).addClass(f).trigger(c.HIDDEN)};this._element.style[i]="",o.supportsTransitionEnd()?t(this._element).one(o.TRANSITION_END,l).emulateTransitionEnd(600):l()}}},a.setTransitioning=function(t){this._isTransitioning=t},a.dispose=function(){t.removeData(this._element,n),this._config=null,this._parent=null,this._element=null,this._triggerArray=null,this._isTransitioning=null},a._getConfig=function(t){return t=r({},l,t),t.toggle=Boolean(t.toggle),o.typeCheckConfig(e,t,h),t},a._getDimension=function(){return t(this._element).hasClass(g)?g:m},a._getParent=function(){var e=this,n=null;o.isElement(this._config.parent)?(n=this._config.parent,"undefined"!=typeof this._config.parent.jquery&&(n=this._config.parent[0])):n=t(this._config.parent)[0];var s='[data-toggle="collapse"][data-parent="'+this._config.parent+'"]';return t(n).find(s).each(function(t,n){e._addAriaAndCollapsedClass(i._getTargetFromElement(n),[n])}),n},a._addAriaAndCollapsedClass=function(e,n){if(e){var i=t(e).hasClass(u);n.length&&t(n).toggleClass(_,!i).attr("aria-expanded",i)}},i._getTargetFromElement=function(e){var n=o.getSelectorFromElement(e);return n?t(n)[0]:null},i._jQueryInterface=function(e){return this.each(function(){var s=t(this),o=s.data(n),a=r({},l,s.data(),"object"==typeof e&&e);if(!o&&a.toggle&&/show|hide/.test(e)&&(a.toggle=!1),o||(o=new i(this,a),s.data(n,o)),"string"==typeof e){if("undefined"==typeof o[e])throw new Error('No method named "'+e+'"');o[e]()}})},s(i,null,[{key:"VERSION",get:function(){return"4.0.0-beta.3"}},{key:"Default",get:function(){return l}}]),i}();return t(document).on(c.CLICK_DATA_API,p.DATA_TOGGLE,function(e){"A"===e.currentTarget.tagName&&e.preventDefault();var i=t(this),s=o.getSelectorFromElement(this);t(s).each(function(){var e=t(this),s=e.data(n)?"toggle":i.data();v._jQueryInterface.call(e,s)})}),t.fn[e]=v._jQueryInterface,t.fn[e].Constructor=v,t.fn[e].noConflict=function(){return t.fn[e]=a,v._jQueryInterface},v}(e),u=function(t){var e="dropdown",i="bs.dropdown",a="."+i,l=".data-api",h=t.fn[e],c=new RegExp("38|40|27"),u={HIDE:"hide"+a,HIDDEN:"hidden"+a,SHOW:"show"+a,SHOWN:"shown"+a,CLICK:"click"+a,CLICK_DATA_API:"click"+a+l,KEYDOWN_DATA_API:"keydown"+a+l,KEYUP_DATA_API:"keyup"+a+l},f="disabled",d="show",_="dropup",g="dropright",m="dropleft",p="dropdown-menu-right",v="dropdown-menu-left",E="position-static",T='[data-toggle="dropdown"]',y=".dropdown form",C=".dropdown-menu",I=".navbar-nav",A=".dropdown-menu .dropdown-item:not(.disabled)",b="top-start",D="top-end",S="bottom-start",w="bottom-end",N="right-start",O="left-start",k={offset:0,flip:!0,boundary:"scrollParent"},P={offset:"(number|string|function)",flip:"boolean",boundary:"(string|element)"},L=function(){function l(t,e){this._element=t,this._popper=null,this._config=this._getConfig(e),this._menu=this._getMenuElement(),this._inNavbar=this._detectNavbar(),this._addEventListeners()}var h=l.prototype;return h.toggle=function(){if(!this._element.disabled&&!t(this._element).hasClass(f)){var e=l._getParentFromElement(this._element),i=t(this._menu).hasClass(d);if(l._clearMenus(),!i){var s={relatedTarget:this._element},r=t.Event(u.SHOW,s);if(t(e).trigger(r),!r.isDefaultPrevented()){if(!this._inNavbar){if("undefined"==typeof n)throw new Error("Bootstrap dropdown require Popper.js (https://popper.js.org)");var o=this._element;t(e).hasClass(_)&&(t(this._menu).hasClass(v)||t(this._menu).hasClass(p))&&(o=e),"scrollParent"!==this._config.boundary&&t(e).addClass(E),this._popper=new n(o,this._menu,this._getPopperConfig())}"ontouchstart"in document.documentElement&&!t(e).closest(I).length&&t("body").children().on("mouseover",null,t.noop),this._element.focus(),this._element.setAttribute("aria-expanded",!0),t(this._menu).toggleClass(d),t(e).toggleClass(d).trigger(t.Event(u.SHOWN,s))}}}},h.dispose=function(){t.removeData(this._element,i),t(this._element).off(a),this._element=null,this._menu=null,null!==this._popper&&(this._popper.destroy(),this._popper=null)},h.update=function(){this._inNavbar=this._detectNavbar(),null!==this._popper&&this._popper.scheduleUpdate()},h._addEventListeners=function(){var e=this;t(this._element).on(u.CLICK,function(t){t.preventDefault(),t.stopPropagation(),e.toggle()})},h._getConfig=function(n){return n=r({},this.constructor.Default,t(this._element).data(),n),o.typeCheckConfig(e,n,this.constructor.DefaultType),n},h._getMenuElement=function(){if(!this._menu){var e=l._getParentFromElement(this._element);this._menu=t(e).find(C)[0]}return this._menu},h._getPlacement=function(){var e=t(this._element).parent(),n=S;return e.hasClass(_)?(n=b,t(this._menu).hasClass(p)&&(n=D)):e.hasClass(g)?n=N:e.hasClass(m)?n=O:t(this._menu).hasClass(p)&&(n=w),n},h._detectNavbar=function(){return t(this._element).closest(".navbar").length>0},h._getPopperConfig=function(){var t=this,e={};"function"==typeof this._config.offset?e.fn=function(e){return e.offsets=r({},e.offsets,t._config.offset(e.offsets)||{}),e}:e.offset=this._config.offset;return{placement:this._getPlacement(),modifiers:{offset:e,flip:{enabled:this._config.flip},preventOverflow:{boundariesElement:this._config.boundary}}}},l._jQueryInterface=function(e){return this.each(function(){var n=t(this).data(i);if(n||(n=new l(this,"object"==typeof e?e:null),t(this).data(i,n)),"string"==typeof e){if("undefined"==typeof n[e])throw new Error('No method named "'+e+'"');n[e]()}})},l._clearMenus=function(e){if(!e||3!==e.which&&("keyup"!==e.type||9===e.which))for(var n=t.makeArray(t(T)),s=0;s<n.length;s++){var r=l._getParentFromElement(n[s]),o=t(n[s]).data(i),a={relatedTarget:n[s]};if(o){var h=o._menu;if(t(r).hasClass(d)&&!(e&&("click"===e.type&&/input|textarea/i.test(e.target.tagName)||"keyup"===e.type&&9===e.which)&&t.contains(r,e.target))){var c=t.Event(u.HIDE,a);t(r).trigger(c),c.isDefaultPrevented()||("ontouchstart"in document.documentElement&&t("body").children().off("mouseover",null,t.noop),n[s].setAttribute("aria-expanded","false"),t(h).removeClass(d),t(r).removeClass(d).trigger(t.Event(u.HIDDEN,a)))}}}},l._getParentFromElement=function(e){var n,i=o.getSelectorFromElement(e);return i&&(n=t(i)[0]),n||e.parentNode},l._dataApiKeydownHandler=function(e){if((/input|textarea/i.test(e.target.tagName)?!(32===e.which||27!==e.which&&(40!==e.which&&38!==e.which||t(e.target).closest(C).length)):c.test(e.which))&&(e.preventDefault(),e.stopPropagation(),!this.disabled&&!t(this).hasClass(f))){var n=l._getParentFromElement(this),i=t(n).hasClass(d);if((i||27===e.which&&32===e.which)&&(!i||27!==e.which&&32!==e.which)){var s=t(n).find(A).get();if(s.length){var r=s.indexOf(e.target);38===e.which&&r>0&&r--,40===e.which&&r<s.length-1&&r++,r<0&&(r=0),s[r].focus()}}else{if(27===e.which){var o=t(n).find(T)[0];t(o).trigger("focus")}t(this).trigger("click")}}},s(l,null,[{key:"VERSION",get:function(){return"4.0.0-beta.3"}},{key:"Default",get:function(){return k}},{key:"DefaultType",get:function(){return P}}]),l}();return t(document).on(u.KEYDOWN_DATA_API,T,L._dataApiKeydownHandler).on(u.KEYDOWN_DATA_API,C,L._dataApiKeydownHandler).on(u.CLICK_DATA_API+" "+u.KEYUP_DATA_API,L._clearMenus).on(u.CLICK_DATA_API,T,function(e){e.preventDefault(),e.stopPropagation(),L._jQueryInterface.call(t(this),"toggle")}).on(u.CLICK_DATA_API,y,function(t){t.stopPropagation()}),t.fn[e]=L._jQueryInterface,t.fn[e].Constructor=L,t.fn[e].noConflict=function(){return t.fn[e]=h,L._jQueryInterface},L}(e),f=function(t){var e="modal",n="bs.modal",i="."+n,a=t.fn.modal,l={backdrop:!0,keyboard:!0,focus:!0,show:!0},h={backdrop:"(boolean|string)",keyboard:"boolean",focus:"boolean",show:"boolean"},c={HIDE:"hide"+i,HIDDEN:"hidden"+i,SHOW:"show"+i,SHOWN:"shown"+i,FOCUSIN:"focusin"+i,RESIZE:"resize"+i,CLICK_DISMISS:"click.dismiss"+i,KEYDOWN_DISMISS:"keydown.dismiss"+i,MOUSEUP_DISMISS:"mouseup.dismiss"+i,MOUSEDOWN_DISMISS:"mousedown.dismiss"+i,CLICK_DATA_API:"click"+i+".data-api"},u="modal-scrollbar-measure",f="modal-backdrop",d="modal-open",_="fade",g="show",m={DIALOG:".modal-dialog",DATA_TOGGLE:'[data-toggle="modal"]',DATA_DISMISS:'[data-dismiss="modal"]',FIXED_CONTENT:".fixed-top, .fixed-bottom, .is-fixed, .sticky-top",STICKY_CONTENT:".sticky-top",NAVBAR_TOGGLER:".navbar-toggler"},p=function(){function a(e,n){this._config=this._getConfig(n),this._element=e,this._dialog=t(e).find(m.DIALOG)[0],this._backdrop=null,this._isShown=!1,this._isBodyOverflowing=!1,this._ignoreBackdropClick=!1,this._originalBodyPadding=0,this._scrollbarWidth=0}var p=a.prototype;return p.toggle=function(t){return this._isShown?this.hide():this.show(t)},p.show=function(e){var n=this;if(!this._isTransitioning&&!this._isShown){o.supportsTransitionEnd()&&t(this._element).hasClass(_)&&(this._isTransitioning=!0);var i=t.Event(c.SHOW,{relatedTarget:e});t(this._element).trigger(i),this._isShown||i.isDefaultPrevented()||(this._isShown=!0,this._checkScrollbar(),this._setScrollbar(),this._adjustDialog(),t(document.body).addClass(d),this._setEscapeEvent(),this._setResizeEvent(),t(this._element).on(c.CLICK_DISMISS,m.DATA_DISMISS,function(t){return n.hide(t)}),t(this._dialog).on(c.MOUSEDOWN_DISMISS,function(){t(n._element).one(c.MOUSEUP_DISMISS,function(e){t(e.target).is(n._element)&&(n._ignoreBackdropClick=!0)})}),this._showBackdrop(function(){return n._showElement(e)}))}},p.hide=function(e){var n=this;if(e&&e.preventDefault(),!this._isTransitioning&&this._isShown){var i=t.Event(c.HIDE);if(t(this._element).trigger(i),this._isShown&&!i.isDefaultPrevented()){this._isShown=!1;var s=o.supportsTransitionEnd()&&t(this._element).hasClass(_);s&&(this._isTransitioning=!0),this._setEscapeEvent(),this._setResizeEvent(),t(document).off(c.FOCUSIN),t(this._element).removeClass(g),t(this._element).off(c.CLICK_DISMISS),t(this._dialog).off(c.MOUSEDOWN_DISMISS),s?t(this._element).one(o.TRANSITION_END,function(t){return n._hideModal(t)}).emulateTransitionEnd(300):this._hideModal()}}},p.dispose=function(){t.removeData(this._element,n),t(window,document,this._element,this._backdrop).off(i),this._config=null,this._element=null,this._dialog=null,this._backdrop=null,this._isShown=null,this._isBodyOverflowing=null,this._ignoreBackdropClick=null,this._scrollbarWidth=null},p.handleUpdate=function(){this._adjustDialog()},p._getConfig=function(t){return t=r({},l,t),o.typeCheckConfig(e,t,h),t},p._showElement=function(e){var n=this,i=o.supportsTransitionEnd()&&t(this._element).hasClass(_);this._element.parentNode&&this._element.parentNode.nodeType===Node.ELEMENT_NODE||document.body.appendChild(this._element),this._element.style.display="block",this._element.removeAttribute("aria-hidden"),this._element.scrollTop=0,i&&o.reflow(this._element),t(this._element).addClass(g),this._config.focus&&this._enforceFocus();var s=t.Event(c.SHOWN,{relatedTarget:e}),r=function(){n._config.focus&&n._element.focus(),n._isTransitioning=!1,t(n._element).trigger(s)};i?t(this._dialog).one(o.TRANSITION_END,r).emulateTransitionEnd(300):r()},p._enforceFocus=function(){var e=this;t(document).off(c.FOCUSIN).on(c.FOCUSIN,function(n){document===n.target||e._element===n.target||t(e._element).has(n.target).length||e._element.focus()})},p._setEscapeEvent=function(){var e=this;this._isShown&&this._config.keyboard?t(this._element).on(c.KEYDOWN_DISMISS,function(t){27===t.which&&(t.preventDefault(),e.hide())}):this._isShown||t(this._element).off(c.KEYDOWN_DISMISS)},p._setResizeEvent=function(){var e=this;this._isShown?t(window).on(c.RESIZE,function(t){return e.handleUpdate(t)}):t(window).off(c.RESIZE)},p._hideModal=function(){var e=this;this._element.style.display="none",this._element.setAttribute("aria-hidden",!0),this._isTransitioning=!1,this._showBackdrop(function(){t(document.body).removeClass(d),e._resetAdjustments(),e._resetScrollbar(),t(e._element).trigger(c.HIDDEN)})},p._removeBackdrop=function(){this._backdrop&&(t(this._backdrop).remove(),this._backdrop=null)},p._showBackdrop=function(e){var n=this,i=t(this._element).hasClass(_)?_:"";if(this._isShown&&this._config.backdrop){var s=o.supportsTransitionEnd()&&i;if(this._backdrop=document.createElement("div"),this._backdrop.className=f,i&&t(this._backdrop).addClass(i),t(this._backdrop).appendTo(document.body),t(this._element).on(c.CLICK_DISMISS,function(t){n._ignoreBackdropClick?n._ignoreBackdropClick=!1:t.target===t.currentTarget&&("static"===n._config.backdrop?n._element.focus():n.hide())}),s&&o.reflow(this._backdrop),t(this._backdrop).addClass(g),!e)return;if(!s)return void e();t(this._backdrop).one(o.TRANSITION_END,e).emulateTransitionEnd(150)}else if(!this._isShown&&this._backdrop){t(this._backdrop).removeClass(g);var r=function(){n._removeBackdrop(),e&&e()};o.supportsTransitionEnd()&&t(this._element).hasClass(_)?t(this._backdrop).one(o.TRANSITION_END,r).emulateTransitionEnd(150):r()}else e&&e()},p._adjustDialog=function(){var t=this._element.scrollHeight>document.documentElement.clientHeight;!this._isBodyOverflowing&&t&&(this._element.style.paddingLeft=this._scrollbarWidth+"px"),this._isBodyOverflowing&&!t&&(this._element.style.paddingRight=this._scrollbarWidth+"px")},p._resetAdjustments=function(){this._element.style.paddingLeft="",this._element.style.paddingRight=""},p._checkScrollbar=function(){var t=document.body.getBoundingClientRect();this._isBodyOverflowing=t.left+t.right<window.innerWidth,this._scrollbarWidth=this._getScrollbarWidth()},p._setScrollbar=function(){var e=this;if(this._isBodyOverflowing){t(m.FIXED_CONTENT).each(function(n,i){var s=t(i)[0].style.paddingRight,r=t(i).css("padding-right");t(i).data("padding-right",s).css("padding-right",parseFloat(r)+e._scrollbarWidth+"px")}),t(m.STICKY_CONTENT).each(function(n,i){var s=t(i)[0].style.marginRight,r=t(i).css("margin-right");t(i).data("margin-right",s).css("margin-right",parseFloat(r)-e._scrollbarWidth+"px")}),t(m.NAVBAR_TOGGLER).each(function(n,i){var s=t(i)[0].style.marginRight,r=t(i).css("margin-right");t(i).data("margin-right",s).css("margin-right",parseFloat(r)+e._scrollbarWidth+"px")});var n=document.body.style.paddingRight,i=t("body").css("padding-right");t("body").data("padding-right",n).css("padding-right",parseFloat(i)+this._scrollbarWidth+"px")}},p._resetScrollbar=function(){t(m.FIXED_CONTENT).each(function(e,n){var i=t(n).data("padding-right");"undefined"!=typeof i&&t(n).css("padding-right",i).removeData("padding-right")}),t(m.STICKY_CONTENT+", "+m.NAVBAR_TOGGLER).each(function(e,n){var i=t(n).data("margin-right");"undefined"!=typeof i&&t(n).css("margin-right",i).removeData("margin-right")});var e=t("body").data("padding-right");"undefined"!=typeof e&&t("body").css("padding-right",e).removeData("padding-right")},p._getScrollbarWidth=function(){var t=document.createElement("div");t.className=u,document.body.appendChild(t);var e=t.getBoundingClientRect().width-t.clientWidth;return document.body.removeChild(t),e},a._jQueryInterface=function(e,i){return this.each(function(){var s=t(this).data(n),o=r({},a.Default,t(this).data(),"object"==typeof e&&e);if(s||(s=new a(this,o),t(this).data(n,s)),"string"==typeof e){if("undefined"==typeof s[e])throw new Error('No method named "'+e+'"');s[e](i)}else o.show&&s.show(i)})},s(a,null,[{key:"VERSION",get:function(){return"4.0.0-beta.3"}},{key:"Default",get:function(){return l}}]),a}();return t(document).on(c.CLICK_DATA_API,m.DATA_TOGGLE,function(e){var i,s=this,a=o.getSelectorFromElement(this);a&&(i=t(a)[0]);var l=t(i).data(n)?"toggle":r({},t(i).data(),t(this).data());"A"!==this.tagName&&"AREA"!==this.tagName||e.preventDefault();var h=t(i).one(c.SHOW,function(e){e.isDefaultPrevented()||h.one(c.HIDDEN,function(){t(s).is(":visible")&&s.focus()})});p._jQueryInterface.call(t(i),l,this)}),t.fn.modal=p._jQueryInterface,t.fn.modal.Constructor=p,t.fn.modal.noConflict=function(){return t.fn.modal=a,p._jQueryInterface},p}(e),d=function(t){var e="tooltip",i="bs.tooltip",a="."+i,l=t.fn[e],h=new RegExp("(^|\\s)bs-tooltip\\S+","g"),c={animation:"boolean",template:"string",title:"(string|element|function)",trigger:"string",delay:"(number|object)",html:"boolean",selector:"(string|boolean)",placement:"(string|function)",offset:"(number|string)",container:"(string|element|boolean)",fallbackPlacement:"(string|array)",boundary:"(string|element)"},u={AUTO:"auto",TOP:"top",RIGHT:"right",BOTTOM:"bottom",LEFT:"left"},f={animation:!0,template:'<div class="tooltip" role="tooltip"><div class="arrow"></div><div class="tooltip-inner"></div></div>',trigger:"hover focus",title:"",delay:0,html:!1,selector:!1,placement:"top",offset:0,container:!1,fallbackPlacement:"flip",boundary:"scrollParent"},d="show",_="out",g={HIDE:"hide"+a,HIDDEN:"hidden"+a,SHOW:"show"+a,SHOWN:"shown"+a,INSERTED:"inserted"+a,CLICK:"click"+a,FOCUSIN:"focusin"+a,FOCUSOUT:"focusout"+a,MOUSEENTER:"mouseenter"+a,MOUSELEAVE:"mouseleave"+a},m="fade",p="show",v=".tooltip-inner",E=".arrow",T="hover",y="focus",C="click",I="manual",A=function(){function l(t,e){if("undefined"==typeof n)throw new Error("Bootstrap tooltips require Popper.js (https://popper.js.org)");this._isEnabled=!0,this._timeout=0,this._hoverState="",this._activeTrigger={},this._popper=null,this.element=t,this.config=this._getConfig(e),this.tip=null,this._setListeners()}var A=l.prototype;return A.enable=function(){this._isEnabled=!0},A.disable=function(){this._isEnabled=!1},A.toggleEnabled=function(){this._isEnabled=!this._isEnabled},A.toggle=function(e){if(this._isEnabled)if(e){var n=this.constructor.DATA_KEY,i=t(e.currentTarget).data(n);i||(i=new this.constructor(e.currentTarget,this._getDelegateConfig()),t(e.currentTarget).data(n,i)),i._activeTrigger.click=!i._activeTrigger.click,i._isWithActiveTrigger()?i._enter(null,i):i._leave(null,i)}else{if(t(this.getTipElement()).hasClass(p))return void this._leave(null,this);this._enter(null,this)}},A.dispose=function(){clearTimeout(this._timeout),t.removeData(this.element,this.constructor.DATA_KEY),t(this.element).off(this.constructor.EVENT_KEY),t(this.element).closest(".modal").off("hide.bs.modal"),this.tip&&t(this.tip).remove(),this._isEnabled=null,this._timeout=null,this._hoverState=null,this._activeTrigger=null,null!==this._popper&&this._popper.destroy(),this._popper=null,this.element=null,this.config=null,this.tip=null},A.show=function(){var e=this;if("none"===t(this.element).css("display"))throw new Error("Please use show on visible elements");var i=t.Event(this.constructor.Event.SHOW);if(this.isWithContent()&&this._isEnabled){t(this.element).trigger(i);var s=t.contains(this.element.ownerDocument.documentElement,this.element);if(i.isDefaultPrevented()||!s)return;var r=this.getTipElement(),a=o.getUID(this.constructor.NAME);r.setAttribute("id",a),this.element.setAttribute("aria-describedby",a),this.setContent(),this.config.animation&&t(r).addClass(m);var h="function"==typeof this.config.placement?this.config.placement.call(this,r,this.element):this.config.placement,c=this._getAttachment(h);this.addAttachmentClass(c);var u=!1===this.config.container?document.body:t(this.config.container);t(r).data(this.constructor.DATA_KEY,this),t.contains(this.element.ownerDocument.documentElement,this.tip)||t(r).appendTo(u),t(this.element).trigger(this.constructor.Event.INSERTED),this._popper=new n(this.element,r,{placement:c,modifiers:{offset:{offset:this.config.offset},flip:{behavior:this.config.fallbackPlacement},arrow:{element:E},preventOverflow:{boundariesElement:this.config.boundary}},onCreate:function(t){t.originalPlacement!==t.placement&&e._handlePopperPlacementChange(t)},onUpdate:function(t){e._handlePopperPlacementChange(t)}}),t(r).addClass(p),"ontouchstart"in document.documentElement&&t("body").children().on("mouseover",null,t.noop);var f=function(){e.config.animation&&e._fixTransition();var n=e._hoverState;e._hoverState=null,t(e.element).trigger(e.constructor.Event.SHOWN),n===_&&e._leave(null,e)};o.supportsTransitionEnd()&&t(this.tip).hasClass(m)?t(this.tip).one(o.TRANSITION_END,f).emulateTransitionEnd(l._TRANSITION_DURATION):f()}},A.hide=function(e){var n=this,i=this.getTipElement(),s=t.Event(this.constructor.Event.HIDE),r=function(){n._hoverState!==d&&i.parentNode&&i.parentNode.removeChild(i),n._cleanTipClass(),n.element.removeAttribute("aria-describedby"),t(n.element).trigger(n.constructor.Event.HIDDEN),null!==n._popper&&n._popper.destroy(),e&&e()};t(this.element).trigger(s),s.isDefaultPrevented()||(t(i).removeClass(p),"ontouchstart"in document.documentElement&&t("body").children().off("mouseover",null,t.noop),this._activeTrigger[C]=!1,this._activeTrigger[y]=!1,this._activeTrigger[T]=!1,o.supportsTransitionEnd()&&t(this.tip).hasClass(m)?t(i).one(o.TRANSITION_END,r).emulateTransitionEnd(150):r(),this._hoverState="")},A.update=function(){null!==this._popper&&this._popper.scheduleUpdate()},A.isWithContent=function(){return Boolean(this.getTitle())},A.addAttachmentClass=function(e){t(this.getTipElement()).addClass("bs-tooltip-"+e)},A.getTipElement=function(){return this.tip=this.tip||t(this.config.template)[0],this.tip},A.setContent=function(){var e=t(this.getTipElement());this.setElementContent(e.find(v),this.getTitle()),e.removeClass(m+" "+p)},A.setElementContent=function(e,n){var i=this.config.html;"object"==typeof n&&(n.nodeType||n.jquery)?i?t(n).parent().is(e)||e.empty().append(n):e.text(t(n).text()):e[i?"html":"text"](n)},A.getTitle=function(){var t=this.element.getAttribute("data-original-title");return t||(t="function"==typeof this.config.title?this.config.title.call(this.element):this.config.title),t},A._getAttachment=function(t){return u[t.toUpperCase()]},A._setListeners=function(){var e=this;this.config.trigger.split(" ").forEach(function(n){if("click"===n)t(e.element).on(e.constructor.Event.CLICK,e.config.selector,function(t){return e.toggle(t)});else if(n!==I){var i=n===T?e.constructor.Event.MOUSEENTER:e.constructor.Event.FOCUSIN,s=n===T?e.constructor.Event.MOUSELEAVE:e.constructor.Event.FOCUSOUT;t(e.element).on(i,e.config.selector,function(t){return e._enter(t)}).on(s,e.config.selector,function(t){return e._leave(t)})}t(e.element).closest(".modal").on("hide.bs.modal",function(){return e.hide()})}),this.config.selector?this.config=r({},this.config,{trigger:"manual",selector:""}):this._fixTitle()},A._fixTitle=function(){var t=typeof this.element.getAttribute("data-original-title");(this.element.getAttribute("title")||"string"!==t)&&(this.element.setAttribute("data-original-title",this.element.getAttribute("title")||""),this.element.setAttribute("title",""))},A._enter=function(e,n){var i=this.constructor.DATA_KEY;(n=n||t(e.currentTarget).data(i))||(n=new this.constructor(e.currentTarget,this._getDelegateConfig()),t(e.currentTarget).data(i,n)),e&&(n._activeTrigger["focusin"===e.type?y:T]=!0),t(n.getTipElement()).hasClass(p)||n._hoverState===d?n._hoverState=d:(clearTimeout(n._timeout),n._hoverState=d,n.config.delay&&n.config.delay.show?n._timeout=setTimeout(function(){n._hoverState===d&&n.show()},n.config.delay.show):n.show())},A._leave=function(e,n){var i=this.constructor.DATA_KEY;(n=n||t(e.currentTarget).data(i))||(n=new this.constructor(e.currentTarget,this._getDelegateConfig()),t(e.currentTarget).data(i,n)),e&&(n._activeTrigger["focusout"===e.type?y:T]=!1),n._isWithActiveTrigger()||(clearTimeout(n._timeout),n._hoverState=_,n.config.delay&&n.config.delay.hide?n._timeout=setTimeout(function(){n._hoverState===_&&n.hide()},n.config.delay.hide):n.hide())},A._isWithActiveTrigger=function(){for(var t in this._activeTrigger)if(this._activeTrigger[t])return!0;return!1},A._getConfig=function(n){return"number"==typeof(n=r({},this.constructor.Default,t(this.element).data(),n)).delay&&(n.delay={show:n.delay,hide:n.delay}),"number"==typeof n.title&&(n.title=n.title.toString()),"number"==typeof n.content&&(n.content=n.content.toString()),o.typeCheckConfig(e,n,this.constructor.DefaultType),n},A._getDelegateConfig=function(){var t={};if(this.config)for(var e in this.config)this.constructor.Default[e]!==this.config[e]&&(t[e]=this.config[e]);return t},A._cleanTipClass=function(){var e=t(this.getTipElement()),n=e.attr("class").match(h);null!==n&&n.length>0&&e.removeClass(n.join(""))},A._handlePopperPlacementChange=function(t){this._cleanTipClass(),this.addAttachmentClass(this._getAttachment(t.placement))},A._fixTransition=function(){var e=this.getTipElement(),n=this.config.animation;null===e.getAttribute("x-placement")&&(t(e).removeClass(m),this.config.animation=!1,this.hide(),this.show(),this.config.animation=n)},l._jQueryInterface=function(e){return this.each(function(){var n=t(this).data(i),s="object"==typeof e&&e;if((n||!/dispose|hide/.test(e))&&(n||(n=new l(this,s),t(this).data(i,n)),"string"==typeof e)){if("undefined"==typeof n[e])throw new Error('No method named "'+e+'"');n[e]()}})},s(l,null,[{key:"VERSION",get:function(){return"4.0.0-beta.3"}},{key:"Default",get:function(){return f}},{key:"NAME",get:function(){return e}},{key:"DATA_KEY",get:function(){return i}},{key:"Event",get:function(){return g}},{key:"EVENT_KEY",get:function(){return a}},{key:"DefaultType",get:function(){return c}}]),l}();return t.fn[e]=A._jQueryInterface,t.fn[e].Constructor=A,t.fn[e].noConflict=function(){return t.fn[e]=l,A._jQueryInterface},A}(e),_=function(t){var e="popover",n="bs.popover",i="."+n,o=t.fn[e],a=new RegExp("(^|\\s)bs-popover\\S+","g"),l=r({},d.Default,{placement:"right",trigger:"click",content:"",template:'<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>'}),h=r({},d.DefaultType,{content:"(string|element|function)"}),c="fade",u="show",f=".popover-header",_=".popover-body",g={HIDE:"hide"+i,HIDDEN:"hidden"+i,SHOW:"show"+i,SHOWN:"shown"+i,INSERTED:"inserted"+i,CLICK:"click"+i,FOCUSIN:"focusin"+i,FOCUSOUT:"focusout"+i,MOUSEENTER:"mouseenter"+i,MOUSELEAVE:"mouseleave"+i},m=function(r){function o(){return r.apply(this,arguments)||this}!function(t,e){t.prototype=Object.create(e.prototype),t.prototype.constructor=t,t.__proto__=e}(o,r);var d=o.prototype;return d.isWithContent=function(){return this.getTitle()||this._getContent()},d.addAttachmentClass=function(e){t(this.getTipElement()).addClass("bs-popover-"+e)},d.getTipElement=function(){return this.tip=this.tip||t(this.config.template)[0],this.tip},d.setContent=function(){var e=t(this.getTipElement());this.setElementContent(e.find(f),this.getTitle());var n=this._getContent();"function"==typeof n&&(n=n.call(this.element)),this.setElementContent(e.find(_),n),e.removeClass(c+" "+u)},d._getContent=function(){return this.element.getAttribute("data-content")||this.config.content},d._cleanTipClass=function(){var e=t(this.getTipElement()),n=e.attr("class").match(a);null!==n&&n.length>0&&e.removeClass(n.join(""))},o._jQueryInterface=function(e){return this.each(function(){var i=t(this).data(n),s="object"==typeof e?e:null;if((i||!/destroy|hide/.test(e))&&(i||(i=new o(this,s),t(this).data(n,i)),"string"==typeof e)){if("undefined"==typeof i[e])throw new Error('No method named "'+e+'"');i[e]()}})},s(o,null,[{key:"VERSION",get:function(){return"4.0.0-beta.3"}},{key:"Default",get:function(){return l}},{key:"NAME",get:function(){return e}},{key:"DATA_KEY",get:function(){return n}},{key:"Event",get:function(){return g}},{key:"EVENT_KEY",get:function(){return i}},{key:"DefaultType",get:function(){return h}}]),o}(d);return t.fn[e]=m._jQueryInterface,t.fn[e].Constructor=m,t.fn[e].noConflict=function(){return t.fn[e]=o,m._jQueryInterface},m}(e),g=function(t){var e="scrollspy",n="bs.scrollspy",i="."+n,a=t.fn[e],l={offset:10,method:"auto",target:""},h={offset:"number",method:"string",target:"(string|element)"},c={ACTIVATE:"activate"+i,SCROLL:"scroll"+i,LOAD_DATA_API:"load"+i+".data-api"},u="dropdown-item",f="active",d={DATA_SPY:'[data-spy="scroll"]',ACTIVE:".active",NAV_LIST_GROUP:".nav, .list-group",NAV_LINKS:".nav-link",NAV_ITEMS:".nav-item",LIST_ITEMS:".list-group-item",DROPDOWN:".dropdown",DROPDOWN_ITEMS:".dropdown-item",DROPDOWN_TOGGLE:".dropdown-toggle"},_="offset",g="position",m=function(){function a(e,n){var i=this;this._element=e,this._scrollElement="BODY"===e.tagName?window:e,this._config=this._getConfig(n),this._selector=this._config.target+" "+d.NAV_LINKS+","+this._config.target+" "+d.LIST_ITEMS+","+this._config.target+" "+d.DROPDOWN_ITEMS,this._offsets=[],this._targets=[],this._activeTarget=null,this._scrollHeight=0,t(this._scrollElement).on(c.SCROLL,function(t){return i._process(t)}),this.refresh(),this._process()}var m=a.prototype;return m.refresh=function(){var e=this,n=this._scrollElement!==this._scrollElement.window?g:_,i="auto"===this._config.method?n:this._config.method,s=i===g?this._getScrollTop():0;this._offsets=[],this._targets=[],this._scrollHeight=this._getScrollHeight();t.makeArray(t(this._selector)).map(function(e){var n,r=o.getSelectorFromElement(e);if(r&&(n=t(r)[0]),n){var a=n.getBoundingClientRect();if(a.width||a.height)return[t(n)[i]().top+s,r]}return null}).filter(function(t){return t}).sort(function(t,e){return t[0]-e[0]}).forEach(function(t){e._offsets.push(t[0]),e._targets.push(t[1])})},m.dispose=function(){t.removeData(this._element,n),t(this._scrollElement).off(i),this._element=null,this._scrollElement=null,this._config=null,this._selector=null,this._offsets=null,this._targets=null,this._activeTarget=null,this._scrollHeight=null},m._getConfig=function(n){if("string"!=typeof(n=r({},l,n)).target){var i=t(n.target).attr("id");i||(i=o.getUID(e),t(n.target).attr("id",i)),n.target="#"+i}return o.typeCheckConfig(e,n,h),n},m._getScrollTop=function(){return this._scrollElement===window?this._scrollElement.pageYOffset:this._scrollElement.scrollTop},m._getScrollHeight=function(){return this._scrollElement.scrollHeight||Math.max(document.body.scrollHeight,document.documentElement.scrollHeight)},m._getOffsetHeight=function(){return this._scrollElement===window?window.innerHeight:this._scrollElement.getBoundingClientRect().height},m._process=function(){var t=this._getScrollTop()+this._config.offset,e=this._getScrollHeight(),n=this._config.offset+e-this._getOffsetHeight();if(this._scrollHeight!==e&&this.refresh(),t>=n){var i=this._targets[this._targets.length-1];this._activeTarget!==i&&this._activate(i)}else{if(this._activeTarget&&t<this._offsets[0]&&this._offsets[0]>0)return this._activeTarget=null,void this._clear();for(var s=this._offsets.length;s--;){this._activeTarget!==this._targets[s]&&t>=this._offsets[s]&&("undefined"==typeof this._offsets[s+1]||t<this._offsets[s+1])&&this._activate(this._targets[s])}}},m._activate=function(e){this._activeTarget=e,this._clear();var n=this._selector.split(",");n=n.map(function(t){return t+'[data-target="'+e+'"],'+t+'[href="'+e+'"]'});var i=t(n.join(","));i.hasClass(u)?(i.closest(d.DROPDOWN).find(d.DROPDOWN_TOGGLE).addClass(f),i.addClass(f)):(i.addClass(f),i.parents(d.NAV_LIST_GROUP).prev(d.NAV_LINKS+", "+d.LIST_ITEMS).addClass(f),i.parents(d.NAV_LIST_GROUP).prev(d.NAV_ITEMS).children(d.NAV_LINKS).addClass(f)),t(this._scrollElement).trigger(c.ACTIVATE,{relatedTarget:e})},m._clear=function(){t(this._selector).filter(d.ACTIVE).removeClass(f)},a._jQueryInterface=function(e){return this.each(function(){var i=t(this).data(n);if(i||(i=new a(this,"object"==typeof e&&e),t(this).data(n,i)),"string"==typeof e){if("undefined"==typeof i[e])throw new Error('No method named "'+e+'"');i[e]()}})},s(a,null,[{key:"VERSION",get:function(){return"4.0.0-beta.3"}},{key:"Default",get:function(){return l}}]),a}();return t(window).on(c.LOAD_DATA_API,function(){for(var e=t.makeArray(t(d.DATA_SPY)),n=e.length;n--;){var i=t(e[n]);m._jQueryInterface.call(i,i.data())}}),t.fn[e]=m._jQueryInterface,t.fn[e].Constructor=m,t.fn[e].noConflict=function(){return t.fn[e]=a,m._jQueryInterface},m}(e),m=function(t){var e="bs.tab",n="."+e,i=t.fn.tab,r={HIDE:"hide"+n,HIDDEN:"hidden"+n,SHOW:"show"+n,SHOWN:"shown"+n,CLICK_DATA_API:"click.bs.tab.data-api"},a="dropdown-menu",l="active",h="disabled",c="fade",u="show",f=".dropdown",d=".nav, .list-group",_=".active",g="> li > .active",m='[data-toggle="tab"], [data-toggle="pill"], [data-toggle="list"]',p=".dropdown-toggle",v="> .dropdown-menu .active",E=function(){function n(t){this._element=t}var i=n.prototype;return i.show=function(){var e=this;if(!(this._element.parentNode&&this._element.parentNode.nodeType===Node.ELEMENT_NODE&&t(this._element).hasClass(l)||t(this._element).hasClass(h))){var n,i,s=t(this._element).closest(d)[0],a=o.getSelectorFromElement(this._element);if(s){var c="UL"===s.nodeName?g:_;i=(i=t.makeArray(t(s).find(c)))[i.length-1]}var u=t.Event(r.HIDE,{relatedTarget:this._element}),f=t.Event(r.SHOW,{relatedTarget:i});if(i&&t(i).trigger(u),t(this._element).trigger(f),!f.isDefaultPrevented()&&!u.isDefaultPrevented()){a&&(n=t(a)[0]),this._activate(this._element,s);var m=function(){var n=t.Event(r.HIDDEN,{relatedTarget:e._element}),s=t.Event(r.SHOWN,{relatedTarget:i});t(i).trigger(n),t(e._element).trigger(s)};n?this._activate(n,n.parentNode,m):m()}}},i.dispose=function(){t.removeData(this._element,e),this._element=null},i._activate=function(e,n,i){var s=this,r=("UL"===n.nodeName?t(n).find(g):t(n).children(_))[0],a=i&&o.supportsTransitionEnd()&&r&&t(r).hasClass(c),l=function(){return s._transitionComplete(e,r,i)};r&&a?t(r).one(o.TRANSITION_END,l).emulateTransitionEnd(150):l()},i._transitionComplete=function(e,n,i){if(n){t(n).removeClass(u+" "+l);var s=t(n.parentNode).find(v)[0];s&&t(s).removeClass(l),"tab"===n.getAttribute("role")&&n.setAttribute("aria-selected",!1)}if(t(e).addClass(l),"tab"===e.getAttribute("role")&&e.setAttribute("aria-selected",!0),o.reflow(e),t(e).addClass(u),e.parentNode&&t(e.parentNode).hasClass(a)){var r=t(e).closest(f)[0];r&&t(r).find(p).addClass(l),e.setAttribute("aria-expanded",!0)}i&&i()},n._jQueryInterface=function(i){return this.each(function(){var s=t(this),r=s.data(e);if(r||(r=new n(this),s.data(e,r)),"string"==typeof i){if("undefined"==typeof r[i])throw new Error('No method named "'+i+'"');r[i]()}})},s(n,null,[{key:"VERSION",get:function(){return"4.0.0-beta.3"}}]),n}();return t(document).on(r.CLICK_DATA_API,m,function(e){e.preventDefault(),E._jQueryInterface.call(t(this),"show")}),t.fn.tab=E._jQueryInterface,t.fn.tab.Constructor=E,t.fn.tab.noConflict=function(){return t.fn.tab=i,E._jQueryInterface},E}(e);!function(t){if("undefined"==typeof t)throw new Error("Bootstrap's JavaScript requires jQuery. jQuery must be included before Bootstrap's JavaScript.");var e=t.fn.jquery.split(" ")[0].split(".");if(e[0]<2&&e[1]<9||1===e[0]&&9===e[1]&&e[2]<1||e[0]>=4)throw new Error("Bootstrap's JavaScript requires at least jQuery v1.9.1 but less than v4.0.0")}(e),t.Util=o,t.Alert=a,t.Button=l,t.Carousel=h,t.Collapse=c,t.Dropdown=u,t.Modal=f,t.Popover=_,t.Scrollspy=g,t.Tab=m,t.Tooltip=d,Object.defineProperty(t,"__esModule",{value:!0})});
;(function (factory) {
var registeredInModuleLoader = false;
if (typeof define === 'function' && define.amd) {
define(factory);
registeredInModuleLoader = true;
}
if (typeof exports === 'object') {
module.exports = factory();
registeredInModuleLoader = true;
}
if (!registeredInModuleLoader) {
var OldCookies = window.Cookies;
var api = window.Cookies = factory();
api.noConflict = function () {
window.Cookies = OldCookies;
return api;
};
}
}(function () {
function extend () {
var i = 0;
var result = {};
for (; i < arguments.length; i++) {
var attributes = arguments[ i ];
for (var key in attributes) {
result[key] = attributes[key];
}
}
return result;
}
function init (converter) {
function api (key, value, attributes) {
var result;
if (typeof document === 'undefined') {
return;
}
if (arguments.length > 1) {
attributes = extend({
path: '/'
}, api.defaults, attributes);
if (typeof attributes.expires === 'number') {
var expires = new Date();
expires.setMilliseconds(expires.getMilliseconds() + attributes.expires * 864e+5);
attributes.expires = expires;
}
attributes.expires = attributes.expires ? attributes.expires.toUTCString() : '';
try {
result = JSON.stringify(value);
if (/^[\{\[]/.test(result)) {
value = result;
}
} catch (e) {}
if (!converter.write) {
value = encodeURIComponent(String(value))
.replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent);
} else {
value = converter.write(value, key);
}
key = encodeURIComponent(String(key));
key = key.replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent);
key = key.replace(/[\(\)]/g, escape);
var stringifiedAttributes = '';
for (var attributeName in attributes) {
if (!attributes[attributeName]) {
continue;
}
stringifiedAttributes += '; ' + attributeName;
if (attributes[attributeName] === true) {
continue;
}
stringifiedAttributes += '=' + attributes[attributeName];
}
return (document.cookie = key + '=' + value + stringifiedAttributes);
}
if (!key) {
result = {};
}
var cookies = document.cookie ? document.cookie.split('; ') : [];
var rdecode = /(%[0-9A-Z]{2})+/g;
var i = 0;
for (; i < cookies.length; i++) {
var parts = cookies[i].split('=');
var cookie = parts.slice(1).join('=');
if (!this.json && cookie.charAt(0) === '"') {
cookie = cookie.slice(1, -1);
}
try {
var name = parts[0].replace(rdecode, decodeURIComponent);
cookie = converter.read ?
converter.read(cookie, name) : converter(cookie, name) ||
cookie.replace(rdecode, decodeURIComponent);
if (this.json) {
try {
cookie = JSON.parse(cookie);
} catch (e) {}
}
if (key === name) {
result = cookie;
break;
}
if (!key) {
result[name] = cookie;
}
} catch (e) {}
}
return result;
}
api.set = api;
api.get = function (key) {
return api.call(api, key);
};
api.getJSON = function () {
return api.apply({
json: true
}, [].slice.call(arguments));
};
api.defaults = {};
api.remove = function (key, attributes) {
api(key, '', extend(attributes, {
expires: -1
}));
};
api.withConverter = init;
return api;
}
return init(function () {});
}));
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.moment=t()}(this,function(){"use strict";function e(){return Qe.apply(null,arguments)}function t(e){return e instanceof Array||"[object Array]"===Object.prototype.toString.call(e)}function n(e){return null!=e&&"[object Object]"===Object.prototype.toString.call(e)}function s(e){return void 0===e}function i(e){return"number"==typeof e||"[object Number]"===Object.prototype.toString.call(e)}function r(e){return e instanceof Date||"[object Date]"===Object.prototype.toString.call(e)}function a(e,t){var n,s=[];for(n=0;n<e.length;++n)s.push(t(e[n],n));return s}function o(e,t){return Object.prototype.hasOwnProperty.call(e,t)}function u(e,t){for(var n in t)o(t,n)&&(e[n]=t[n]);return o(t,"toString")&&(e.toString=t.toString),o(t,"valueOf")&&(e.valueOf=t.valueOf),e}function l(e,t,n,s){return ge(e,t,n,s,!0).utc()}function d(e){return null==e._pf&&(e._pf={empty:!1,unusedTokens:[],unusedInput:[],overflow:-2,charsLeftOver:0,nullInput:!1,invalidMonth:null,invalidFormat:!1,userInvalidated:!1,iso:!1,parsedDateParts:[],meridiem:null,rfc2822:!1,weekdayMismatch:!1}),e._pf}function h(e){if(null==e._isValid){var t=d(e),n=Xe.call(t.parsedDateParts,function(e){return null!=e}),s=!isNaN(e._d.getTime())&&t.overflow<0&&!t.empty&&!t.invalidMonth&&!t.invalidWeekday&&!t.weekdayMismatch&&!t.nullInput&&!t.invalidFormat&&!t.userInvalidated&&(!t.meridiem||t.meridiem&&n);if(e._strict&&(s=s&&0===t.charsLeftOver&&0===t.unusedTokens.length&&void 0===t.bigHour),null!=Object.isFrozen&&Object.isFrozen(e))return s;e._isValid=s}return e._isValid}function c(e){var t=l(NaN);return null!=e?u(d(t),e):d(t).userInvalidated=!0,t}function f(e,t){var n,i,r;if(s(t._isAMomentObject)||(e._isAMomentObject=t._isAMomentObject),s(t._i)||(e._i=t._i),s(t._f)||(e._f=t._f),s(t._l)||(e._l=t._l),s(t._strict)||(e._strict=t._strict),s(t._tzm)||(e._tzm=t._tzm),s(t._isUTC)||(e._isUTC=t._isUTC),s(t._offset)||(e._offset=t._offset),s(t._pf)||(e._pf=d(t)),s(t._locale)||(e._locale=t._locale),Ke.length>0)for(n=0;n<Ke.length;n++)s(r=t[i=Ke[n]])||(e[i]=r);return e}function m(t){f(this,t),this._d=new Date(null!=t._d?t._d.getTime():NaN),this.isValid()||(this._d=new Date(NaN)),!1===et&&(et=!0,e.updateOffset(this),et=!1)}function _(e){return e instanceof m||null!=e&&null!=e._isAMomentObject}function y(e){return e<0?Math.ceil(e)||0:Math.floor(e)}function g(e){var t=+e,n=0;return 0!==t&&isFinite(t)&&(n=y(t)),n}function p(e,t,n){var s,i=Math.min(e.length,t.length),r=Math.abs(e.length-t.length),a=0;for(s=0;s<i;s++)(n&&e[s]!==t[s]||!n&&g(e[s])!==g(t[s]))&&a++;return a+r}function w(t){!1===e.suppressDeprecationWarnings&&"undefined"!=typeof console&&console.warn&&console.warn("Deprecation warning: "+t)}function v(t,n){var s=!0;return u(function(){if(null!=e.deprecationHandler&&e.deprecationHandler(null,t),s){for(var i,r=[],a=0;a<arguments.length;a++){if(i="","object"==typeof arguments[a]){i+="\n["+a+"] ";for(var o in arguments[0])i+=o+": "+arguments[0][o]+", ";i=i.slice(0,-2)}else i=arguments[a];r.push(i)}w(t+"\nArguments: "+Array.prototype.slice.call(r).join("")+"\n"+(new Error).stack),s=!1}return n.apply(this,arguments)},n)}function M(t,n){null!=e.deprecationHandler&&e.deprecationHandler(t,n),tt[t]||(w(n),tt[t]=!0)}function S(e){return e instanceof Function||"[object Function]"===Object.prototype.toString.call(e)}function D(e,t){var s,i=u({},e);for(s in t)o(t,s)&&(n(e[s])&&n(t[s])?(i[s]={},u(i[s],e[s]),u(i[s],t[s])):null!=t[s]?i[s]=t[s]:delete i[s]);for(s in e)o(e,s)&&!o(t,s)&&n(e[s])&&(i[s]=u({},i[s]));return i}function k(e){null!=e&&this.set(e)}function Y(e,t){var n=e.toLowerCase();st[n]=st[n+"s"]=st[t]=e}function O(e){return"string"==typeof e?st[e]||st[e.toLowerCase()]:void 0}function T(e){var t,n,s={};for(n in e)o(e,n)&&(t=O(n))&&(s[t]=e[n]);return s}function x(e,t){it[e]=t}function b(e,t,n){var s=""+Math.abs(e),i=t-s.length;return(e>=0?n?"+":"":"-")+Math.pow(10,Math.max(0,i)).toString().substr(1)+s}function P(e,t,n,s){var i=s;"string"==typeof s&&(i=function(){return this[s]()}),e&&(ut[e]=i),t&&(ut[t[0]]=function(){return b(i.apply(this,arguments),t[1],t[2])}),n&&(ut[n]=function(){return this.localeData().ordinal(i.apply(this,arguments),e)})}function W(e){return e.match(/\[[\s\S]/)?e.replace(/^\[|\]$/g,""):e.replace(/\\/g,"")}function H(e,t){return e.isValid()?(t=R(t,e.localeData()),ot[t]=ot[t]||function(e){var t,n,s=e.match(rt);for(t=0,n=s.length;t<n;t++)ut[s[t]]?s[t]=ut[s[t]]:s[t]=W(s[t]);return function(t){var i,r="";for(i=0;i<n;i++)r+=S(s[i])?s[i].call(t,e):s[i];return r}}(t),ot[t](e)):e.localeData().invalidDate()}function R(e,t){function n(e){return t.longDateFormat(e)||e}var s=5;for(at.lastIndex=0;s>=0&&at.test(e);)e=e.replace(at,n),at.lastIndex=0,s-=1;return e}function C(e,t,n){Yt[e]=S(t)?t:function(e,s){return e&&n?n:t}}function F(e,t){return o(Yt,e)?Yt[e](t._strict,t._locale):new RegExp(function(e){return U(e.replace("\\","").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,function(e,t,n,s,i){return t||n||s||i}))}(e))}function U(e){return e.replace(/[-\/\\^$*+?.()|[\]{}]/g,"\\$&")}function L(e,t){var n,s=t;for("string"==typeof e&&(e=[e]),i(t)&&(s=function(e,n){n[t]=g(e)}),n=0;n<e.length;n++)Ot[e[n]]=s}function N(e,t){L(e,function(e,n,s,i){s._w=s._w||{},t(e,s._w,s,i)})}function G(e,t,n){null!=t&&o(Ot,e)&&Ot[e](t,n._a,n,e)}function V(e){return E(e)?366:365}function E(e){return e%4==0&&e%100!=0||e%400==0}function I(t,n){return function(s){return null!=s?(j(this,t,s),e.updateOffset(this,n),this):A(this,t)}}function A(e,t){return e.isValid()?e._d["get"+(e._isUTC?"UTC":"")+t]():NaN}function j(e,t,n){e.isValid()&&!isNaN(n)&&("FullYear"===t&&E(e.year())&&1===e.month()&&29===e.date()?e._d["set"+(e._isUTC?"UTC":"")+t](n,e.month(),Z(n,e.month())):e._d["set"+(e._isUTC?"UTC":"")+t](n))}function Z(e,t){if(isNaN(e)||isNaN(t))return NaN;var n=function(e,t){return(e%t+t)%t}(t,12);return e+=(t-n)/12,1===n?E(e)?29:28:31-n%7%2}function z(e,t){var n;if(!e.isValid())return e;if("string"==typeof t)if(/^\d+$/.test(t))t=g(t);else if(t=e.localeData().monthsParse(t),!i(t))return e;return n=Math.min(e.date(),Z(e.year(),t)),e._d["set"+(e._isUTC?"UTC":"")+"Month"](t,n),e}function $(t){return null!=t?(z(this,t),e.updateOffset(this,!0),this):A(this,"Month")}function q(){function e(e,t){return t.length-e.length}var t,n,s=[],i=[],r=[];for(t=0;t<12;t++)n=l([2e3,t]),s.push(this.monthsShort(n,"")),i.push(this.months(n,"")),r.push(this.months(n,"")),r.push(this.monthsShort(n,""));for(s.sort(e),i.sort(e),r.sort(e),t=0;t<12;t++)s[t]=U(s[t]),i[t]=U(i[t]);for(t=0;t<24;t++)r[t]=U(r[t]);this._monthsRegex=new RegExp("^("+r.join("|")+")","i"),this._monthsShortRegex=this._monthsRegex,this._monthsStrictRegex=new RegExp("^("+i.join("|")+")","i"),this._monthsShortStrictRegex=new RegExp("^("+s.join("|")+")","i")}function J(e){var t=new Date(Date.UTC.apply(null,arguments));return e<100&&e>=0&&isFinite(t.getUTCFullYear())&&t.setUTCFullYear(e),t}function B(e,t,n){var s=7+t-n;return-((7+J(e,0,s).getUTCDay()-t)%7)+s-1}function Q(e,t,n,s,i){var r,a,o=1+7*(t-1)+(7+n-s)%7+B(e,s,i);return o<=0?a=V(r=e-1)+o:o>V(e)?(r=e+1,a=o-V(e)):(r=e,a=o),{year:r,dayOfYear:a}}function X(e,t,n){var s,i,r=B(e.year(),t,n),a=Math.floor((e.dayOfYear()-r-1)/7)+1;return a<1?s=a+K(i=e.year()-1,t,n):a>K(e.year(),t,n)?(s=a-K(e.year(),t,n),i=e.year()+1):(i=e.year(),s=a),{week:s,year:i}}function K(e,t,n){var s=B(e,t,n),i=B(e+1,t,n);return(V(e)-s+i)/7}function ee(){function e(e,t){return t.length-e.length}var t,n,s,i,r,a=[],o=[],u=[],d=[];for(t=0;t<7;t++)n=l([2e3,1]).day(t),s=this.weekdaysMin(n,""),i=this.weekdaysShort(n,""),r=this.weekdays(n,""),a.push(s),o.push(i),u.push(r),d.push(s),d.push(i),d.push(r);for(a.sort(e),o.sort(e),u.sort(e),d.sort(e),t=0;t<7;t++)o[t]=U(o[t]),u[t]=U(u[t]),d[t]=U(d[t]);this._weekdaysRegex=new RegExp("^("+d.join("|")+")","i"),this._weekdaysShortRegex=this._weekdaysRegex,this._weekdaysMinRegex=this._weekdaysRegex,this._weekdaysStrictRegex=new RegExp("^("+u.join("|")+")","i"),this._weekdaysShortStrictRegex=new RegExp("^("+o.join("|")+")","i"),this._weekdaysMinStrictRegex=new RegExp("^("+a.join("|")+")","i")}function te(){return this.hours()%12||12}function ne(e,t){P(e,0,0,function(){return this.localeData().meridiem(this.hours(),this.minutes(),t)})}function se(e,t){return t._meridiemParse}function ie(e){return e?e.toLowerCase().replace("_","-"):e}function re(e){var t=null;if(!Xt[e]&&"undefined"!=typeof module&&module&&module.exports)try{t=Jt._abbr;require("./locale/"+e),ae(t)}catch(e){}return Xt[e]}function ae(e,t){var n;return e&&(n=s(t)?ue(e):oe(e,t))&&(Jt=n),Jt._abbr}function oe(e,t){if(null!==t){var n=Qt;if(t.abbr=e,null!=Xt[e])M("defineLocaleOverride","use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."),n=Xt[e]._config;else if(null!=t.parentLocale){if(null==Xt[t.parentLocale])return Kt[t.parentLocale]||(Kt[t.parentLocale]=[]),Kt[t.parentLocale].push({name:e,config:t}),null;n=Xt[t.parentLocale]._config}return Xt[e]=new k(D(n,t)),Kt[e]&&Kt[e].forEach(function(e){oe(e.name,e.config)}),ae(e),Xt[e]}return delete Xt[e],null}function ue(e){var n;if(e&&e._locale&&e._locale._abbr&&(e=e._locale._abbr),!e)return Jt;if(!t(e)){if(n=re(e))return n;e=[e]}return function(e){for(var t,n,s,i,r=0;r<e.length;){for(t=(i=ie(e[r]).split("-")).length,n=(n=ie(e[r+1]))?n.split("-"):null;t>0;){if(s=re(i.slice(0,t).join("-")))return s;if(n&&n.length>=t&&p(i,n,!0)>=t-1)break;t--}r++}return null}(e)}function le(e){var t,n=e._a;return n&&-2===d(e).overflow&&(t=n[xt]<0||n[xt]>11?xt:n[bt]<1||n[bt]>Z(n[Tt],n[xt])?bt:n[Pt]<0||n[Pt]>24||24===n[Pt]&&(0!==n[Wt]||0!==n[Ht]||0!==n[Rt])?Pt:n[Wt]<0||n[Wt]>59?Wt:n[Ht]<0||n[Ht]>59?Ht:n[Rt]<0||n[Rt]>999?Rt:-1,d(e)._overflowDayOfYear&&(t<Tt||t>bt)&&(t=bt),d(e)._overflowWeeks&&-1===t&&(t=Ct),d(e)._overflowWeekday&&-1===t&&(t=Ft),d(e).overflow=t),e}function de(e,t,n){return null!=e?e:null!=t?t:n}function he(t){var n,s,i,r,a,o=[];if(!t._d){for(i=function(t){var n=new Date(e.now());return t._useUTC?[n.getUTCFullYear(),n.getUTCMonth(),n.getUTCDate()]:[n.getFullYear(),n.getMonth(),n.getDate()]}(t),t._w&&null==t._a[bt]&&null==t._a[xt]&&function(e){var t,n,s,i,r,a,o,u;if(null!=(t=e._w).GG||null!=t.W||null!=t.E)r=1,a=4,n=de(t.GG,e._a[Tt],X(pe(),1,4).year),s=de(t.W,1),((i=de(t.E,1))<1||i>7)&&(u=!0);else{r=e._locale._week.dow,a=e._locale._week.doy;var l=X(pe(),r,a);n=de(t.gg,e._a[Tt],l.year),s=de(t.w,l.week),null!=t.d?((i=t.d)<0||i>6)&&(u=!0):null!=t.e?(i=t.e+r,(t.e<0||t.e>6)&&(u=!0)):i=r}s<1||s>K(n,r,a)?d(e)._overflowWeeks=!0:null!=u?d(e)._overflowWeekday=!0:(o=Q(n,s,i,r,a),e._a[Tt]=o.year,e._dayOfYear=o.dayOfYear)}(t),null!=t._dayOfYear&&(a=de(t._a[Tt],i[Tt]),(t._dayOfYear>V(a)||0===t._dayOfYear)&&(d(t)._overflowDayOfYear=!0),s=J(a,0,t._dayOfYear),t._a[xt]=s.getUTCMonth(),t._a[bt]=s.getUTCDate()),n=0;n<3&&null==t._a[n];++n)t._a[n]=o[n]=i[n];for(;n<7;n++)t._a[n]=o[n]=null==t._a[n]?2===n?1:0:t._a[n];24===t._a[Pt]&&0===t._a[Wt]&&0===t._a[Ht]&&0===t._a[Rt]&&(t._nextDay=!0,t._a[Pt]=0),t._d=(t._useUTC?J:function(e,t,n,s,i,r,a){var o=new Date(e,t,n,s,i,r,a);return e<100&&e>=0&&isFinite(o.getFullYear())&&o.setFullYear(e),o}).apply(null,o),r=t._useUTC?t._d.getUTCDay():t._d.getDay(),null!=t._tzm&&t._d.setUTCMinutes(t._d.getUTCMinutes()-t._tzm),t._nextDay&&(t._a[Pt]=24),t._w&&void 0!==t._w.d&&t._w.d!==r&&(d(t).weekdayMismatch=!0)}}function ce(e){var t,n,s,i,r,a,o=e._i,u=en.exec(o)||tn.exec(o);if(u){for(d(e).iso=!0,t=0,n=sn.length;t<n;t++)if(sn[t][1].exec(u[1])){i=sn[t][0],s=!1!==sn[t][2];break}if(null==i)return void(e._isValid=!1);if(u[3]){for(t=0,n=rn.length;t<n;t++)if(rn[t][1].exec(u[3])){r=(u[2]||" ")+rn[t][0];break}if(null==r)return void(e._isValid=!1)}if(!s&&null!=r)return void(e._isValid=!1);if(u[4]){if(!nn.exec(u[4]))return void(e._isValid=!1);a="Z"}e._f=i+(r||"")+(a||""),_e(e)}else e._isValid=!1}function fe(e,t,n,s,i,r){var a=[function(e){var t=parseInt(e,10);{if(t<=49)return 2e3+t;if(t<=999)return 1900+t}return t}(e),Vt.indexOf(t),parseInt(n,10),parseInt(s,10),parseInt(i,10)];return r&&a.push(parseInt(r,10)),a}function me(e){var t=on.exec(function(e){return e.replace(/\([^)]*\)|[\n\t]/g," ").replace(/(\s\s+)/g," ").trim()}(e._i));if(t){var n=fe(t[4],t[3],t[2],t[5],t[6],t[7]);if(!function(e,t,n){if(e&&jt.indexOf(e)!==new Date(t[0],t[1],t[2]).getDay())return d(n).weekdayMismatch=!0,n._isValid=!1,!1;return!0}(t[1],n,e))return;e._a=n,e._tzm=function(e,t,n){if(e)return un[e];if(t)return 0;var s=parseInt(n,10),i=s%100;return(s-i)/100*60+i}(t[8],t[9],t[10]),e._d=J.apply(null,e._a),e._d.setUTCMinutes(e._d.getUTCMinutes()-e._tzm),d(e).rfc2822=!0}else e._isValid=!1}function _e(t){if(t._f!==e.ISO_8601)if(t._f!==e.RFC_2822){t._a=[],d(t).empty=!0;var n,s,i,r,a,o=""+t._i,u=o.length,l=0;for(i=R(t._f,t._locale).match(rt)||[],n=0;n<i.length;n++)r=i[n],(s=(o.match(F(r,t))||[])[0])&&((a=o.substr(0,o.indexOf(s))).length>0&&d(t).unusedInput.push(a),o=o.slice(o.indexOf(s)+s.length),l+=s.length),ut[r]?(s?d(t).empty=!1:d(t).unusedTokens.push(r),G(r,s,t)):t._strict&&!s&&d(t).unusedTokens.push(r);d(t).charsLeftOver=u-l,o.length>0&&d(t).unusedInput.push(o),t._a[Pt]<=12&&!0===d(t).bigHour&&t._a[Pt]>0&&(d(t).bigHour=void 0),d(t).parsedDateParts=t._a.slice(0),d(t).meridiem=t._meridiem,t._a[Pt]=function(e,t,n){var s;if(null==n)return t;return null!=e.meridiemHour?e.meridiemHour(t,n):null!=e.isPM?((s=e.isPM(n))&&t<12&&(t+=12),s||12!==t||(t=0),t):t}(t._locale,t._a[Pt],t._meridiem),he(t),le(t)}else me(t);else ce(t)}function ye(o){var l=o._i,y=o._f;return o._locale=o._locale||ue(o._l),null===l||void 0===y&&""===l?c({nullInput:!0}):("string"==typeof l&&(o._i=l=o._locale.preparse(l)),_(l)?new m(le(l)):(r(l)?o._d=l:t(y)?function(e){var t,n,s,i,r;if(0===e._f.length)return d(e).invalidFormat=!0,void(e._d=new Date(NaN));for(i=0;i<e._f.length;i++)r=0,t=f({},e),null!=e._useUTC&&(t._useUTC=e._useUTC),t._f=e._f[i],_e(t),h(t)&&(r+=d(t).charsLeftOver,r+=10*d(t).unusedTokens.length,d(t).score=r,(null==s||r<s)&&(s=r,n=t));u(e,n||t)}(o):y?_e(o):function(o){var u=o._i;s(u)?o._d=new Date(e.now()):r(u)?o._d=new Date(u.valueOf()):"string"==typeof u?function(t){var n=an.exec(t._i);null===n?(ce(t),!1===t._isValid&&(delete t._isValid,me(t),!1===t._isValid&&(delete t._isValid,e.createFromInputFallback(t)))):t._d=new Date(+n[1])}(o):t(u)?(o._a=a(u.slice(0),function(e){return parseInt(e,10)}),he(o)):n(u)?function(e){if(!e._d){var t=T(e._i);e._a=a([t.year,t.month,t.day||t.date,t.hour,t.minute,t.second,t.millisecond],function(e){return e&&parseInt(e,10)}),he(e)}}(o):i(u)?o._d=new Date(u):e.createFromInputFallback(o)}(o),h(o)||(o._d=null),o))}function ge(e,s,i,r,a){var o={};return!0!==i&&!1!==i||(r=i,i=void 0),(n(e)&&function(e){if(Object.getOwnPropertyNames)return 0===Object.getOwnPropertyNames(e).length;var t;for(t in e)if(e.hasOwnProperty(t))return!1;return!0}(e)||t(e)&&0===e.length)&&(e=void 0),o._isAMomentObject=!0,o._useUTC=o._isUTC=a,o._l=i,o._i=e,o._f=s,o._strict=r,function(e){var t=new m(le(ye(e)));return t._nextDay&&(t.add(1,"d"),t._nextDay=void 0),t}(o)}function pe(e,t,n,s){return ge(e,t,n,s,!1)}function we(e,n){var s,i;if(1===n.length&&t(n[0])&&(n=n[0]),!n.length)return pe();for(s=n[0],i=1;i<n.length;++i)n[i].isValid()&&!n[i][e](s)||(s=n[i]);return s}function ve(e){var t=T(e),n=t.year||0,s=t.quarter||0,i=t.month||0,r=t.week||0,a=t.day||0,o=t.hour||0,u=t.minute||0,l=t.second||0,d=t.millisecond||0;this._isValid=function(e){for(var t in e)if(-1===Ut.call(hn,t)||null!=e[t]&&isNaN(e[t]))return!1;for(var n=!1,s=0;s<hn.length;++s)if(e[hn[s]]){if(n)return!1;parseFloat(e[hn[s]])!==g(e[hn[s]])&&(n=!0)}return!0}(t),this._milliseconds=+d+1e3*l+6e4*u+1e3*o*60*60,this._days=+a+7*r,this._months=+i+3*s+12*n,this._data={},this._locale=ue(),this._bubble()}function Me(e){return e instanceof ve}function Se(e){return e<0?-1*Math.round(-1*e):Math.round(e)}function De(e,t){P(e,0,0,function(){var e=this.utcOffset(),n="+";return e<0&&(e=-e,n="-"),n+b(~~(e/60),2)+t+b(~~e%60,2)})}function ke(e,t){var n=(t||"").match(e);if(null===n)return null;var s=((n[n.length-1]||[])+"").match(cn)||["-",0,0],i=60*s[1]+g(s[2]);return 0===i?0:"+"===s[0]?i:-i}function Ye(t,n){var s,i;return n._isUTC?(s=n.clone(),i=(_(t)||r(t)?t.valueOf():pe(t).valueOf())-s.valueOf(),s._d.setTime(s._d.valueOf()+i),e.updateOffset(s,!1),s):pe(t).local()}function Oe(e){return 15*-Math.round(e._d.getTimezoneOffset()/15)}function Te(){return!!this.isValid()&&(this._isUTC&&0===this._offset)}function xe(e,t){var n,s,r,a=e,u=null;return Me(e)?a={ms:e._milliseconds,d:e._days,M:e._months}:i(e)?(a={},t?a[t]=e:a.milliseconds=e):(u=fn.exec(e))?(n="-"===u[1]?-1:1,a={y:0,d:g(u[bt])*n,h:g(u[Pt])*n,m:g(u[Wt])*n,s:g(u[Ht])*n,ms:g(Se(1e3*u[Rt]))*n}):(u=mn.exec(e))?(n="-"===u[1]?-1:(u[1],1),a={y:be(u[2],n),M:be(u[3],n),w:be(u[4],n),d:be(u[5],n),h:be(u[6],n),m:be(u[7],n),s:be(u[8],n)}):null==a?a={}:"object"==typeof a&&("from"in a||"to"in a)&&(r=function(e,t){var n;if(!e.isValid()||!t.isValid())return{milliseconds:0,months:0};t=Ye(t,e),e.isBefore(t)?n=Pe(e,t):((n=Pe(t,e)).milliseconds=-n.milliseconds,n.months=-n.months);return n}(pe(a.from),pe(a.to)),(a={}).ms=r.milliseconds,a.M=r.months),s=new ve(a),Me(e)&&o(e,"_locale")&&(s._locale=e._locale),s}function be(e,t){var n=e&&parseFloat(e.replace(",","."));return(isNaN(n)?0:n)*t}function Pe(e,t){var n={milliseconds:0,months:0};return n.months=t.month()-e.month()+12*(t.year()-e.year()),e.clone().add(n.months,"M").isAfter(t)&&--n.months,n.milliseconds=+t-+e.clone().add(n.months,"M"),n}function We(e,t){return function(n,s){var i,r;return null===s||isNaN(+s)||(M(t,"moment()."+t+"(period, number) is deprecated. Please use moment()."+t+"(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."),r=n,n=s,s=r),n="string"==typeof n?+n:n,i=xe(n,s),He(this,i,e),this}}function He(t,n,s,i){var r=n._milliseconds,a=Se(n._days),o=Se(n._months);t.isValid()&&(i=null==i||i,o&&z(t,A(t,"Month")+o*s),a&&j(t,"Date",A(t,"Date")+a*s),r&&t._d.setTime(t._d.valueOf()+r*s),i&&e.updateOffset(t,a||o))}function Re(e,t){var n,s=12*(t.year()-e.year())+(t.month()-e.month()),i=e.clone().add(s,"months");return n=t-i<0?(t-i)/(i-e.clone().add(s-1,"months")):(t-i)/(e.clone().add(s+1,"months")-i),-(s+n)||0}function Ce(e){var t;return void 0===e?this._locale._abbr:(null!=(t=ue(e))&&(this._locale=t),this)}function Fe(){return this._locale}function Ue(e,t){P(0,[e,e.length],0,t)}function Le(e,t,n,s,i){var r;return null==e?X(this,s,i).year:(r=K(e,s,i),t>r&&(t=r),function(e,t,n,s,i){var r=Q(e,t,n,s,i),a=J(r.year,0,r.dayOfYear);return this.year(a.getUTCFullYear()),this.month(a.getUTCMonth()),this.date(a.getUTCDate()),this}.call(this,e,t,n,s,i))}function Ne(e,t){t[Rt]=g(1e3*("0."+e))}function Ge(e){return e}function Ve(e,t,n,s){var i=ue(),r=l().set(s,t);return i[n](r,e)}function Ee(e,t,n){if(i(e)&&(t=e,e=void 0),e=e||"",null!=t)return Ve(e,t,n,"month");var s,r=[];for(s=0;s<12;s++)r[s]=Ve(e,s,n,"month");return r}function Ie(e,t,n,s){"boolean"==typeof e?(i(t)&&(n=t,t=void 0),t=t||""):(n=t=e,e=!1,i(t)&&(n=t,t=void 0),t=t||"");var r=ue(),a=e?r._week.dow:0;if(null!=n)return Ve(t,(n+a)%7,s,"day");var o,u=[];for(o=0;o<7;o++)u[o]=Ve(t,(o+a)%7,s,"day");return u}function Ae(e,t,n,s){var i=xe(t,n);return e._milliseconds+=s*i._milliseconds,e._days+=s*i._days,e._months+=s*i._months,e._bubble()}function je(e){return e<0?Math.floor(e):Math.ceil(e)}function Ze(e){return 4800*e/146097}function ze(e){return 146097*e/4800}function $e(e){return function(){return this.as(e)}}function qe(e){return function(){return this.isValid()?this._data[e]:NaN}}function Je(e){return(e>0)-(e<0)||+e}function Be(){if(!this.isValid())return this.localeData().invalidDate();var e,t,n=An(this._milliseconds)/1e3,s=An(this._days),i=An(this._months);t=y((e=y(n/60))/60),n%=60,e%=60;var r=y(i/12),a=i%=12,o=s,u=t,l=e,d=n?n.toFixed(3).replace(/\.?0+$/,""):"",h=this.asSeconds();if(!h)return"P0D";var c=h<0?"-":"",f=Je(this._months)!==Je(h)?"-":"",m=Je(this._days)!==Je(h)?"-":"",_=Je(this._milliseconds)!==Je(h)?"-":"";return c+"P"+(r?f+r+"Y":"")+(a?f+a+"M":"")+(o?m+o+"D":"")+(u||l||d?"T":"")+(u?_+u+"H":"")+(l?_+l+"M":"")+(d?_+d+"S":"")}var Qe,Xe;Xe=Array.prototype.some?Array.prototype.some:function(e){for(var t=Object(this),n=t.length>>>0,s=0;s<n;s++)if(s in t&&e.call(this,t[s],s,t))return!0;return!1};var Ke=e.momentProperties=[],et=!1,tt={};e.suppressDeprecationWarnings=!1,e.deprecationHandler=null;var nt;nt=Object.keys?Object.keys:function(e){var t,n=[];for(t in e)o(e,t)&&n.push(t);return n};var st={},it={},rt=/(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,at=/(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,ot={},ut={},lt=/\d/,dt=/\d\d/,ht=/\d{3}/,ct=/\d{4}/,ft=/[+-]?\d{6}/,mt=/\d\d?/,_t=/\d\d\d\d?/,yt=/\d\d\d\d\d\d?/,gt=/\d{1,3}/,pt=/\d{1,4}/,wt=/[+-]?\d{1,6}/,vt=/\d+/,Mt=/[+-]?\d+/,St=/Z|[+-]\d\d:?\d\d/gi,Dt=/Z|[+-]\d\d(?::?\d\d)?/gi,kt=/[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,Yt={},Ot={},Tt=0,xt=1,bt=2,Pt=3,Wt=4,Ht=5,Rt=6,Ct=7,Ft=8;P("Y",0,0,function(){var e=this.year();return e<=9999?""+e:"+"+e}),P(0,["YY",2],0,function(){return this.year()%100}),P(0,["YYYY",4],0,"year"),P(0,["YYYYY",5],0,"year"),P(0,["YYYYYY",6,!0],0,"year"),Y("year","y"),x("year",1),C("Y",Mt),C("YY",mt,dt),C("YYYY",pt,ct),C("YYYYY",wt,ft),C("YYYYYY",wt,ft),L(["YYYYY","YYYYYY"],Tt),L("YYYY",function(t,n){n[Tt]=2===t.length?e.parseTwoDigitYear(t):g(t)}),L("YY",function(t,n){n[Tt]=e.parseTwoDigitYear(t)}),L("Y",function(e,t){t[Tt]=parseInt(e,10)}),e.parseTwoDigitYear=function(e){return g(e)+(g(e)>68?1900:2e3)};var Ut,Lt=I("FullYear",!0);Ut=Array.prototype.indexOf?Array.prototype.indexOf:function(e){var t;for(t=0;t<this.length;++t)if(this[t]===e)return t;return-1},P("M",["MM",2],"Mo",function(){return this.month()+1}),P("MMM",0,0,function(e){return this.localeData().monthsShort(this,e)}),P("MMMM",0,0,function(e){return this.localeData().months(this,e)}),Y("month","M"),x("month",8),C("M",mt),C("MM",mt,dt),C("MMM",function(e,t){return t.monthsShortRegex(e)}),C("MMMM",function(e,t){return t.monthsRegex(e)}),L(["M","MM"],function(e,t){t[xt]=g(e)-1}),L(["MMM","MMMM"],function(e,t,n,s){var i=n._locale.monthsParse(e,s,n._strict);null!=i?t[xt]=i:d(n).invalidMonth=e});var Nt=/D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,Gt="January_February_March_April_May_June_July_August_September_October_November_December".split("_"),Vt="Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),Et=kt,It=kt;P("w",["ww",2],"wo","week"),P("W",["WW",2],"Wo","isoWeek"),Y("week","w"),Y("isoWeek","W"),x("week",5),x("isoWeek",5),C("w",mt),C("ww",mt,dt),C("W",mt),C("WW",mt,dt),N(["w","ww","W","WW"],function(e,t,n,s){t[s.substr(0,1)]=g(e)});P("d",0,"do","day"),P("dd",0,0,function(e){return this.localeData().weekdaysMin(this,e)}),P("ddd",0,0,function(e){return this.localeData().weekdaysShort(this,e)}),P("dddd",0,0,function(e){return this.localeData().weekdays(this,e)}),P("e",0,0,"weekday"),P("E",0,0,"isoWeekday"),Y("day","d"),Y("weekday","e"),Y("isoWeekday","E"),x("day",11),x("weekday",11),x("isoWeekday",11),C("d",mt),C("e",mt),C("E",mt),C("dd",function(e,t){return t.weekdaysMinRegex(e)}),C("ddd",function(e,t){return t.weekdaysShortRegex(e)}),C("dddd",function(e,t){return t.weekdaysRegex(e)}),N(["dd","ddd","dddd"],function(e,t,n,s){var i=n._locale.weekdaysParse(e,s,n._strict);null!=i?t.d=i:d(n).invalidWeekday=e}),N(["d","e","E"],function(e,t,n,s){t[s]=g(e)});var At="Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),jt="Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),Zt="Su_Mo_Tu_We_Th_Fr_Sa".split("_"),zt=kt,$t=kt,qt=kt;P("H",["HH",2],0,"hour"),P("h",["hh",2],0,te),P("k",["kk",2],0,function(){return this.hours()||24}),P("hmm",0,0,function(){return""+te.apply(this)+b(this.minutes(),2)}),P("hmmss",0,0,function(){return""+te.apply(this)+b(this.minutes(),2)+b(this.seconds(),2)}),P("Hmm",0,0,function(){return""+this.hours()+b(this.minutes(),2)}),P("Hmmss",0,0,function(){return""+this.hours()+b(this.minutes(),2)+b(this.seconds(),2)}),ne("a",!0),ne("A",!1),Y("hour","h"),x("hour",13),C("a",se),C("A",se),C("H",mt),C("h",mt),C("k",mt),C("HH",mt,dt),C("hh",mt,dt),C("kk",mt,dt),C("hmm",_t),C("hmmss",yt),C("Hmm",_t),C("Hmmss",yt),L(["H","HH"],Pt),L(["k","kk"],function(e,t,n){var s=g(e);t[Pt]=24===s?0:s}),L(["a","A"],function(e,t,n){n._isPm=n._locale.isPM(e),n._meridiem=e}),L(["h","hh"],function(e,t,n){t[Pt]=g(e),d(n).bigHour=!0}),L("hmm",function(e,t,n){var s=e.length-2;t[Pt]=g(e.substr(0,s)),t[Wt]=g(e.substr(s)),d(n).bigHour=!0}),L("hmmss",function(e,t,n){var s=e.length-4,i=e.length-2;t[Pt]=g(e.substr(0,s)),t[Wt]=g(e.substr(s,2)),t[Ht]=g(e.substr(i)),d(n).bigHour=!0}),L("Hmm",function(e,t,n){var s=e.length-2;t[Pt]=g(e.substr(0,s)),t[Wt]=g(e.substr(s))}),L("Hmmss",function(e,t,n){var s=e.length-4,i=e.length-2;t[Pt]=g(e.substr(0,s)),t[Wt]=g(e.substr(s,2)),t[Ht]=g(e.substr(i))});var Jt,Bt=I("Hours",!0),Qt={calendar:{sameDay:"[Today at] LT",nextDay:"[Tomorrow at] LT",nextWeek:"dddd [at] LT",lastDay:"[Yesterday at] LT",lastWeek:"[Last] dddd [at] LT",sameElse:"L"},longDateFormat:{LTS:"h:mm:ss A",LT:"h:mm A",L:"MM/DD/YYYY",LL:"MMMM D, YYYY",LLL:"MMMM D, YYYY h:mm A",LLLL:"dddd, MMMM D, YYYY h:mm A"},invalidDate:"Invalid date",ordinal:"%d",dayOfMonthOrdinalParse:/\d{1,2}/,relativeTime:{future:"in %s",past:"%s ago",s:"a few seconds",ss:"%d seconds",m:"a minute",mm:"%d minutes",h:"an hour",hh:"%d hours",d:"a day",dd:"%d days",M:"a month",MM:"%d months",y:"a year",yy:"%d years"},months:Gt,monthsShort:Vt,week:{dow:0,doy:6},weekdays:At,weekdaysMin:Zt,weekdaysShort:jt,meridiemParse:/[ap]\.?m?\.?/i},Xt={},Kt={},en=/^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,tn=/^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,nn=/Z|[+-]\d\d(?::?\d\d)?/,sn=[["YYYYYY-MM-DD",/[+-]\d{6}-\d\d-\d\d/],["YYYY-MM-DD",/\d{4}-\d\d-\d\d/],["GGGG-[W]WW-E",/\d{4}-W\d\d-\d/],["GGGG-[W]WW",/\d{4}-W\d\d/,!1],["YYYY-DDD",/\d{4}-\d{3}/],["YYYY-MM",/\d{4}-\d\d/,!1],["YYYYYYMMDD",/[+-]\d{10}/],["YYYYMMDD",/\d{8}/],["GGGG[W]WWE",/\d{4}W\d{3}/],["GGGG[W]WW",/\d{4}W\d{2}/,!1],["YYYYDDD",/\d{7}/]],rn=[["HH:mm:ss.SSSS",/\d\d:\d\d:\d\d\.\d+/],["HH:mm:ss,SSSS",/\d\d:\d\d:\d\d,\d+/],["HH:mm:ss",/\d\d:\d\d:\d\d/],["HH:mm",/\d\d:\d\d/],["HHmmss.SSSS",/\d\d\d\d\d\d\.\d+/],["HHmmss,SSSS",/\d\d\d\d\d\d,\d+/],["HHmmss",/\d\d\d\d\d\d/],["HHmm",/\d\d\d\d/],["HH",/\d\d/]],an=/^\/?Date\((\-?\d+)/i,on=/^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/,un={UT:0,GMT:0,EDT:-240,EST:-300,CDT:-300,CST:-360,MDT:-360,MST:-420,PDT:-420,PST:-480};e.createFromInputFallback=v("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged and will be removed in an upcoming major release. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",function(e){e._d=new Date(e._i+(e._useUTC?" UTC":""))}),e.ISO_8601=function(){},e.RFC_2822=function(){};var ln=v("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",function(){var e=pe.apply(null,arguments);return this.isValid()&&e.isValid()?e<this?this:e:c()}),dn=v("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",function(){var e=pe.apply(null,arguments);return this.isValid()&&e.isValid()?e>this?this:e:c()}),hn=["year","quarter","month","week","day","hour","minute","second","millisecond"];De("Z",":"),De("ZZ",""),C("Z",Dt),C("ZZ",Dt),L(["Z","ZZ"],function(e,t,n){n._useUTC=!0,n._tzm=ke(Dt,e)});var cn=/([\+\-]|\d\d)/gi;e.updateOffset=function(){};var fn=/^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/,mn=/^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;xe.fn=ve.prototype,xe.invalid=function(){return xe(NaN)};var _n=We(1,"add"),yn=We(-1,"subtract");e.defaultFormat="YYYY-MM-DDTHH:mm:ssZ",e.defaultFormatUtc="YYYY-MM-DDTHH:mm:ss[Z]";var gn=v("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",function(e){return void 0===e?this.localeData():this.locale(e)});P(0,["gg",2],0,function(){return this.weekYear()%100}),P(0,["GG",2],0,function(){return this.isoWeekYear()%100}),Ue("gggg","weekYear"),Ue("ggggg","weekYear"),Ue("GGGG","isoWeekYear"),Ue("GGGGG","isoWeekYear"),Y("weekYear","gg"),Y("isoWeekYear","GG"),x("weekYear",1),x("isoWeekYear",1),C("G",Mt),C("g",Mt),C("GG",mt,dt),C("gg",mt,dt),C("GGGG",pt,ct),C("gggg",pt,ct),C("GGGGG",wt,ft),C("ggggg",wt,ft),N(["gggg","ggggg","GGGG","GGGGG"],function(e,t,n,s){t[s.substr(0,2)]=g(e)}),N(["gg","GG"],function(t,n,s,i){n[i]=e.parseTwoDigitYear(t)}),P("Q",0,"Qo","quarter"),Y("quarter","Q"),x("quarter",7),C("Q",lt),L("Q",function(e,t){t[xt]=3*(g(e)-1)}),P("D",["DD",2],"Do","date"),Y("date","D"),x("date",9),C("D",mt),C("DD",mt,dt),C("Do",function(e,t){return e?t._dayOfMonthOrdinalParse||t._ordinalParse:t._dayOfMonthOrdinalParseLenient}),L(["D","DD"],bt),L("Do",function(e,t){t[bt]=g(e.match(mt)[0])});var pn=I("Date",!0);P("DDD",["DDDD",3],"DDDo","dayOfYear"),Y("dayOfYear","DDD"),x("dayOfYear",4),C("DDD",gt),C("DDDD",ht),L(["DDD","DDDD"],function(e,t,n){n._dayOfYear=g(e)}),P("m",["mm",2],0,"minute"),Y("minute","m"),x("minute",14),C("m",mt),C("mm",mt,dt),L(["m","mm"],Wt);var wn=I("Minutes",!1);P("s",["ss",2],0,"second"),Y("second","s"),x("second",15),C("s",mt),C("ss",mt,dt),L(["s","ss"],Ht);var vn=I("Seconds",!1);P("S",0,0,function(){return~~(this.millisecond()/100)}),P(0,["SS",2],0,function(){return~~(this.millisecond()/10)}),P(0,["SSS",3],0,"millisecond"),P(0,["SSSS",4],0,function(){return 10*this.millisecond()}),P(0,["SSSSS",5],0,function(){return 100*this.millisecond()}),P(0,["SSSSSS",6],0,function(){return 1e3*this.millisecond()}),P(0,["SSSSSSS",7],0,function(){return 1e4*this.millisecond()}),P(0,["SSSSSSSS",8],0,function(){return 1e5*this.millisecond()}),P(0,["SSSSSSSSS",9],0,function(){return 1e6*this.millisecond()}),Y("millisecond","ms"),x("millisecond",16),C("S",gt,lt),C("SS",gt,dt),C("SSS",gt,ht);var Mn;for(Mn="SSSS";Mn.length<=9;Mn+="S")C(Mn,vt);for(Mn="S";Mn.length<=9;Mn+="S")L(Mn,Ne);var Sn=I("Milliseconds",!1);P("z",0,0,"zoneAbbr"),P("zz",0,0,"zoneName");var Dn=m.prototype;Dn.add=_n,Dn.calendar=function(t,n){var s=t||pe(),i=Ye(s,this).startOf("day"),r=e.calendarFormat(this,i)||"sameElse",a=n&&(S(n[r])?n[r].call(this,s):n[r]);return this.format(a||this.localeData().calendar(r,this,pe(s)))},Dn.clone=function(){return new m(this)},Dn.diff=function(e,t,n){var s,i,r;if(!this.isValid())return NaN;if(!(s=Ye(e,this)).isValid())return NaN;switch(i=6e4*(s.utcOffset()-this.utcOffset()),t=O(t)){case"year":r=Re(this,s)/12;break;case"month":r=Re(this,s);break;case"quarter":r=Re(this,s)/3;break;case"second":r=(this-s)/1e3;break;case"minute":r=(this-s)/6e4;break;case"hour":r=(this-s)/36e5;break;case"day":r=(this-s-i)/864e5;break;case"week":r=(this-s-i)/6048e5;break;default:r=this-s}return n?r:y(r)},Dn.endOf=function(e){return void 0===(e=O(e))||"millisecond"===e?this:("date"===e&&(e="day"),this.startOf(e).add(1,"isoWeek"===e?"week":e).subtract(1,"ms"))},Dn.format=function(t){t||(t=this.isUtc()?e.defaultFormatUtc:e.defaultFormat);var n=H(this,t);return this.localeData().postformat(n)},Dn.from=function(e,t){return this.isValid()&&(_(e)&&e.isValid()||pe(e).isValid())?xe({to:this,from:e}).locale(this.locale()).humanize(!t):this.localeData().invalidDate()},Dn.fromNow=function(e){return this.from(pe(),e)},Dn.to=function(e,t){return this.isValid()&&(_(e)&&e.isValid()||pe(e).isValid())?xe({from:this,to:e}).locale(this.locale()).humanize(!t):this.localeData().invalidDate()},Dn.toNow=function(e){return this.to(pe(),e)},Dn.get=function(e){return e=O(e),S(this[e])?this[e]():this},Dn.invalidAt=function(){return d(this).overflow},Dn.isAfter=function(e,t){var n=_(e)?e:pe(e);return!(!this.isValid()||!n.isValid())&&("millisecond"===(t=O(s(t)?"millisecond":t))?this.valueOf()>n.valueOf():n.valueOf()<this.clone().startOf(t).valueOf())},Dn.isBefore=function(e,t){var n=_(e)?e:pe(e);return!(!this.isValid()||!n.isValid())&&("millisecond"===(t=O(s(t)?"millisecond":t))?this.valueOf()<n.valueOf():this.clone().endOf(t).valueOf()<n.valueOf())},Dn.isBetween=function(e,t,n,s){return("("===(s=s||"()")[0]?this.isAfter(e,n):!this.isBefore(e,n))&&(")"===s[1]?this.isBefore(t,n):!this.isAfter(t,n))},Dn.isSame=function(e,t){var n,s=_(e)?e:pe(e);return!(!this.isValid()||!s.isValid())&&("millisecond"===(t=O(t||"millisecond"))?this.valueOf()===s.valueOf():(n=s.valueOf(),this.clone().startOf(t).valueOf()<=n&&n<=this.clone().endOf(t).valueOf()))},Dn.isSameOrAfter=function(e,t){return this.isSame(e,t)||this.isAfter(e,t)},Dn.isSameOrBefore=function(e,t){return this.isSame(e,t)||this.isBefore(e,t)},Dn.isValid=function(){return h(this)},Dn.lang=gn,Dn.locale=Ce,Dn.localeData=Fe,Dn.max=dn,Dn.min=ln,Dn.parsingFlags=function(){return u({},d(this))},Dn.set=function(e,t){if("object"==typeof e)for(var n=function(e){var t=[];for(var n in e)t.push({unit:n,priority:it[n]});return t.sort(function(e,t){return e.priority-t.priority}),t}(e=T(e)),s=0;s<n.length;s++)this[n[s].unit](e[n[s].unit]);else if(e=O(e),S(this[e]))return this[e](t);return this},Dn.startOf=function(e){switch(e=O(e)){case"year":this.month(0);case"quarter":case"month":this.date(1);case"week":case"isoWeek":case"day":case"date":this.hours(0);case"hour":this.minutes(0);case"minute":this.seconds(0);case"second":this.milliseconds(0)}return"week"===e&&this.weekday(0),"isoWeek"===e&&this.isoWeekday(1),"quarter"===e&&this.month(3*Math.floor(this.month()/3)),this},Dn.subtract=yn,Dn.toArray=function(){return[this.year(),this.month(),this.date(),this.hour(),this.minute(),this.second(),this.millisecond()]},Dn.toObject=function(){return{years:this.year(),months:this.month(),date:this.date(),hours:this.hours(),minutes:this.minutes(),seconds:this.seconds(),milliseconds:this.milliseconds()}},Dn.toDate=function(){return new Date(this.valueOf())},Dn.toISOString=function(e){if(!this.isValid())return null;var t=!0!==e,n=t?this.clone().utc():this;return n.year()<0||n.year()>9999?H(n,t?"YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]":"YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"):S(Date.prototype.toISOString)?t?this.toDate().toISOString():new Date(this._d.valueOf()).toISOString().replace("Z",H(n,"Z")):H(n,t?"YYYY-MM-DD[T]HH:mm:ss.SSS[Z]":"YYYY-MM-DD[T]HH:mm:ss.SSSZ")},Dn.inspect=function(){if(!this.isValid())return"moment.invalid(/* "+this._i+" */)";var e="moment",t="";this.isLocal()||(e=0===this.utcOffset()?"moment.utc":"moment.parseZone",t="Z");var n="["+e+'("]',s=0<=this.year()&&this.year()<=9999?"YYYY":"YYYYYY",i=t+'[")]';return this.format(n+s+"-MM-DD[T]HH:mm:ss.SSS"+i)},Dn.toJSON=function(){return this.isValid()?this.toISOString():null},Dn.toString=function(){return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ")},Dn.unix=function(){return Math.floor(this.valueOf()/1e3)},Dn.valueOf=function(){return this._d.valueOf()-6e4*(this._offset||0)},Dn.creationData=function(){return{input:this._i,format:this._f,locale:this._locale,isUTC:this._isUTC,strict:this._strict}},Dn.year=Lt,Dn.isLeapYear=function(){return E(this.year())},Dn.weekYear=function(e){return Le.call(this,e,this.week(),this.weekday(),this.localeData()._week.dow,this.localeData()._week.doy)},Dn.isoWeekYear=function(e){return Le.call(this,e,this.isoWeek(),this.isoWeekday(),1,4)},Dn.quarter=Dn.quarters=function(e){return null==e?Math.ceil((this.month()+1)/3):this.month(3*(e-1)+this.month()%3)},Dn.month=$,Dn.daysInMonth=function(){return Z(this.year(),this.month())},Dn.week=Dn.weeks=function(e){var t=this.localeData().week(this);return null==e?t:this.add(7*(e-t),"d")},Dn.isoWeek=Dn.isoWeeks=function(e){var t=X(this,1,4).week;return null==e?t:this.add(7*(e-t),"d")},Dn.weeksInYear=function(){var e=this.localeData()._week;return K(this.year(),e.dow,e.doy)},Dn.isoWeeksInYear=function(){return K(this.year(),1,4)},Dn.date=pn,Dn.day=Dn.days=function(e){if(!this.isValid())return null!=e?this:NaN;var t=this._isUTC?this._d.getUTCDay():this._d.getDay();return null!=e?(e=function(e,t){return"string"!=typeof e?e:isNaN(e)?"number"==typeof(e=t.weekdaysParse(e))?e:null:parseInt(e,10)}(e,this.localeData()),this.add(e-t,"d")):t},Dn.weekday=function(e){if(!this.isValid())return null!=e?this:NaN;var t=(this.day()+7-this.localeData()._week.dow)%7;return null==e?t:this.add(e-t,"d")},Dn.isoWeekday=function(e){if(!this.isValid())return null!=e?this:NaN;if(null!=e){var t=function(e,t){return"string"==typeof e?t.weekdaysParse(e)%7||7:isNaN(e)?null:e}(e,this.localeData());return this.day(this.day()%7?t:t-7)}return this.day()||7},Dn.dayOfYear=function(e){var t=Math.round((this.clone().startOf("day")-this.clone().startOf("year"))/864e5)+1;return null==e?t:this.add(e-t,"d")},Dn.hour=Dn.hours=Bt,Dn.minute=Dn.minutes=wn,Dn.second=Dn.seconds=vn,Dn.millisecond=Dn.milliseconds=Sn,Dn.utcOffset=function(t,n,s){var i,r=this._offset||0;if(!this.isValid())return null!=t?this:NaN;if(null!=t){if("string"==typeof t){if(null===(t=ke(Dt,t)))return this}else Math.abs(t)<16&&!s&&(t*=60);return!this._isUTC&&n&&(i=Oe(this)),this._offset=t,this._isUTC=!0,null!=i&&this.add(i,"m"),r!==t&&(!n||this._changeInProgress?He(this,xe(t-r,"m"),1,!1):this._changeInProgress||(this._changeInProgress=!0,e.updateOffset(this,!0),this._changeInProgress=null)),this}return this._isUTC?r:Oe(this)},Dn.utc=function(e){return this.utcOffset(0,e)},Dn.local=function(e){return this._isUTC&&(this.utcOffset(0,e),this._isUTC=!1,e&&this.subtract(Oe(this),"m")),this},Dn.parseZone=function(){if(null!=this._tzm)this.utcOffset(this._tzm,!1,!0);else if("string"==typeof this._i){var e=ke(St,this._i);null!=e?this.utcOffset(e):this.utcOffset(0,!0)}return this},Dn.hasAlignedHourOffset=function(e){return!!this.isValid()&&(e=e?pe(e).utcOffset():0,(this.utcOffset()-e)%60==0)},Dn.isDST=function(){return this.utcOffset()>this.clone().month(0).utcOffset()||this.utcOffset()>this.clone().month(5).utcOffset()},Dn.isLocal=function(){return!!this.isValid()&&!this._isUTC},Dn.isUtcOffset=function(){return!!this.isValid()&&this._isUTC},Dn.isUtc=Te,Dn.isUTC=Te,Dn.zoneAbbr=function(){return this._isUTC?"UTC":""},Dn.zoneName=function(){return this._isUTC?"Coordinated Universal Time":""},Dn.dates=v("dates accessor is deprecated. Use date instead.",pn),Dn.months=v("months accessor is deprecated. Use month instead",$),Dn.years=v("years accessor is deprecated. Use year instead",Lt),Dn.zone=v("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",function(e,t){return null!=e?("string"!=typeof e&&(e=-e),this.utcOffset(e,t),this):-this.utcOffset()}),Dn.isDSTShifted=v("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",function(){if(!s(this._isDSTShifted))return this._isDSTShifted;var e={};if(f(e,this),(e=ye(e))._a){var t=e._isUTC?l(e._a):pe(e._a);this._isDSTShifted=this.isValid()&&p(e._a,t.toArray())>0}else this._isDSTShifted=!1;return this._isDSTShifted});var kn=k.prototype;kn.calendar=function(e,t,n){var s=this._calendar[e]||this._calendar.sameElse;return S(s)?s.call(t,n):s},kn.longDateFormat=function(e){var t=this._longDateFormat[e],n=this._longDateFormat[e.toUpperCase()];return t||!n?t:(this._longDateFormat[e]=n.replace(/MMMM|MM|DD|dddd/g,function(e){return e.slice(1)}),this._longDateFormat[e])},kn.invalidDate=function(){return this._invalidDate},kn.ordinal=function(e){return this._ordinal.replace("%d",e)},kn.preparse=Ge,kn.postformat=Ge,kn.relativeTime=function(e,t,n,s){var i=this._relativeTime[n];return S(i)?i(e,t,n,s):i.replace(/%d/i,e)},kn.pastFuture=function(e,t){var n=this._relativeTime[e>0?"future":"past"];return S(n)?n(t):n.replace(/%s/i,t)},kn.set=function(e){var t,n;for(n in e)S(t=e[n])?this[n]=t:this["_"+n]=t;this._config=e,this._dayOfMonthOrdinalParseLenient=new RegExp((this._dayOfMonthOrdinalParse.source||this._ordinalParse.source)+"|"+/\d{1,2}/.source)},kn.months=function(e,n){return e?t(this._months)?this._months[e.month()]:this._months[(this._months.isFormat||Nt).test(n)?"format":"standalone"][e.month()]:t(this._months)?this._months:this._months.standalone},kn.monthsShort=function(e,n){return e?t(this._monthsShort)?this._monthsShort[e.month()]:this._monthsShort[Nt.test(n)?"format":"standalone"][e.month()]:t(this._monthsShort)?this._monthsShort:this._monthsShort.standalone},kn.monthsParse=function(e,t,n){var s,i,r;if(this._monthsParseExact)return function(e,t,n){var s,i,r,a=e.toLocaleLowerCase();if(!this._monthsParse)for(this._monthsParse=[],this._longMonthsParse=[],this._shortMonthsParse=[],s=0;s<12;++s)r=l([2e3,s]),this._shortMonthsParse[s]=this.monthsShort(r,"").toLocaleLowerCase(),this._longMonthsParse[s]=this.months(r,"").toLocaleLowerCase();return n?"MMM"===t?-1!==(i=Ut.call(this._shortMonthsParse,a))?i:null:-1!==(i=Ut.call(this._longMonthsParse,a))?i:null:"MMM"===t?-1!==(i=Ut.call(this._shortMonthsParse,a))?i:-1!==(i=Ut.call(this._longMonthsParse,a))?i:null:-1!==(i=Ut.call(this._longMonthsParse,a))?i:-1!==(i=Ut.call(this._shortMonthsParse,a))?i:null}.call(this,e,t,n);for(this._monthsParse||(this._monthsParse=[],this._longMonthsParse=[],this._shortMonthsParse=[]),s=0;s<12;s++){if(i=l([2e3,s]),n&&!this._longMonthsParse[s]&&(this._longMonthsParse[s]=new RegExp("^"+this.months(i,"").replace(".","")+"$","i"),this._shortMonthsParse[s]=new RegExp("^"+this.monthsShort(i,"").replace(".","")+"$","i")),n||this._monthsParse[s]||(r="^"+this.months(i,"")+"|^"+this.monthsShort(i,""),this._monthsParse[s]=new RegExp(r.replace(".",""),"i")),n&&"MMMM"===t&&this._longMonthsParse[s].test(e))return s;if(n&&"MMM"===t&&this._shortMonthsParse[s].test(e))return s;if(!n&&this._monthsParse[s].test(e))return s}},kn.monthsRegex=function(e){return this._monthsParseExact?(o(this,"_monthsRegex")||q.call(this),e?this._monthsStrictRegex:this._monthsRegex):(o(this,"_monthsRegex")||(this._monthsRegex=It),this._monthsStrictRegex&&e?this._monthsStrictRegex:this._monthsRegex)},kn.monthsShortRegex=function(e){return this._monthsParseExact?(o(this,"_monthsRegex")||q.call(this),e?this._monthsShortStrictRegex:this._monthsShortRegex):(o(this,"_monthsShortRegex")||(this._monthsShortRegex=Et),this._monthsShortStrictRegex&&e?this._monthsShortStrictRegex:this._monthsShortRegex)},kn.week=function(e){return X(e,this._week.dow,this._week.doy).week},kn.firstDayOfYear=function(){return this._week.doy},kn.firstDayOfWeek=function(){return this._week.dow},kn.weekdays=function(e,n){return e?t(this._weekdays)?this._weekdays[e.day()]:this._weekdays[this._weekdays.isFormat.test(n)?"format":"standalone"][e.day()]:t(this._weekdays)?this._weekdays:this._weekdays.standalone},kn.weekdaysMin=function(e){return e?this._weekdaysMin[e.day()]:this._weekdaysMin},kn.weekdaysShort=function(e){return e?this._weekdaysShort[e.day()]:this._weekdaysShort},kn.weekdaysParse=function(e,t,n){var s,i,r;if(this._weekdaysParseExact)return function(e,t,n){var s,i,r,a=e.toLocaleLowerCase();if(!this._weekdaysParse)for(this._weekdaysParse=[],this._shortWeekdaysParse=[],this._minWeekdaysParse=[],s=0;s<7;++s)r=l([2e3,1]).day(s),this._minWeekdaysParse[s]=this.weekdaysMin(r,"").toLocaleLowerCase(),this._shortWeekdaysParse[s]=this.weekdaysShort(r,"").toLocaleLowerCase(),this._weekdaysParse[s]=this.weekdays(r,"").toLocaleLowerCase();return n?"dddd"===t?-1!==(i=Ut.call(this._weekdaysParse,a))?i:null:"ddd"===t?-1!==(i=Ut.call(this._shortWeekdaysParse,a))?i:null:-1!==(i=Ut.call(this._minWeekdaysParse,a))?i:null:"dddd"===t?-1!==(i=Ut.call(this._weekdaysParse,a))?i:-1!==(i=Ut.call(this._shortWeekdaysParse,a))?i:-1!==(i=Ut.call(this._minWeekdaysParse,a))?i:null:"ddd"===t?-1!==(i=Ut.call(this._shortWeekdaysParse,a))?i:-1!==(i=Ut.call(this._weekdaysParse,a))?i:-1!==(i=Ut.call(this._minWeekdaysParse,a))?i:null:-1!==(i=Ut.call(this._minWeekdaysParse,a))?i:-1!==(i=Ut.call(this._weekdaysParse,a))?i:-1!==(i=Ut.call(this._shortWeekdaysParse,a))?i:null}.call(this,e,t,n);for(this._weekdaysParse||(this._weekdaysParse=[],this._minWeekdaysParse=[],this._shortWeekdaysParse=[],this._fullWeekdaysParse=[]),s=0;s<7;s++){if(i=l([2e3,1]).day(s),n&&!this._fullWeekdaysParse[s]&&(this._fullWeekdaysParse[s]=new RegExp("^"+this.weekdays(i,"").replace(".",".?")+"$","i"),this._shortWeekdaysParse[s]=new RegExp("^"+this.weekdaysShort(i,"").replace(".",".?")+"$","i"),this._minWeekdaysParse[s]=new RegExp("^"+this.weekdaysMin(i,"").replace(".",".?")+"$","i")),this._weekdaysParse[s]||(r="^"+this.weekdays(i,"")+"|^"+this.weekdaysShort(i,"")+"|^"+this.weekdaysMin(i,""),this._weekdaysParse[s]=new RegExp(r.replace(".",""),"i")),n&&"dddd"===t&&this._fullWeekdaysParse[s].test(e))return s;if(n&&"ddd"===t&&this._shortWeekdaysParse[s].test(e))return s;if(n&&"dd"===t&&this._minWeekdaysParse[s].test(e))return s;if(!n&&this._weekdaysParse[s].test(e))return s}},kn.weekdaysRegex=function(e){return this._weekdaysParseExact?(o(this,"_weekdaysRegex")||ee.call(this),e?this._weekdaysStrictRegex:this._weekdaysRegex):(o(this,"_weekdaysRegex")||(this._weekdaysRegex=zt),this._weekdaysStrictRegex&&e?this._weekdaysStrictRegex:this._weekdaysRegex)},kn.weekdaysShortRegex=function(e){return this._weekdaysParseExact?(o(this,"_weekdaysRegex")||ee.call(this),e?this._weekdaysShortStrictRegex:this._weekdaysShortRegex):(o(this,"_weekdaysShortRegex")||(this._weekdaysShortRegex=$t),this._weekdaysShortStrictRegex&&e?this._weekdaysShortStrictRegex:this._weekdaysShortRegex)},kn.weekdaysMinRegex=function(e){return this._weekdaysParseExact?(o(this,"_weekdaysRegex")||ee.call(this),e?this._weekdaysMinStrictRegex:this._weekdaysMinRegex):(o(this,"_weekdaysMinRegex")||(this._weekdaysMinRegex=qt),this._weekdaysMinStrictRegex&&e?this._weekdaysMinStrictRegex:this._weekdaysMinRegex)},kn.isPM=function(e){return"p"===(e+"").toLowerCase().charAt(0)},kn.meridiem=function(e,t,n){return e>11?n?"pm":"PM":n?"am":"AM"},ae("en",{dayOfMonthOrdinalParse:/\d{1,2}(th|st|nd|rd)/,ordinal:function(e){var t=e%10;return e+(1===g(e%100/10)?"th":1===t?"st":2===t?"nd":3===t?"rd":"th")}}),e.lang=v("moment.lang is deprecated. Use moment.locale instead.",ae),e.langData=v("moment.langData is deprecated. Use moment.localeData instead.",ue);var Yn=Math.abs,On=$e("ms"),Tn=$e("s"),xn=$e("m"),bn=$e("h"),Pn=$e("d"),Wn=$e("w"),Hn=$e("M"),Rn=$e("y"),Cn=qe("milliseconds"),Fn=qe("seconds"),Un=qe("minutes"),Ln=qe("hours"),Nn=qe("days"),Gn=qe("months"),Vn=qe("years"),En=Math.round,In={ss:44,s:45,m:45,h:22,d:26,M:11},An=Math.abs,jn=ve.prototype;return jn.isValid=function(){return this._isValid},jn.abs=function(){var e=this._data;return this._milliseconds=Yn(this._milliseconds),this._days=Yn(this._days),this._months=Yn(this._months),e.milliseconds=Yn(e.milliseconds),e.seconds=Yn(e.seconds),e.minutes=Yn(e.minutes),e.hours=Yn(e.hours),e.months=Yn(e.months),e.years=Yn(e.years),this},jn.add=function(e,t){return Ae(this,e,t,1)},jn.subtract=function(e,t){return Ae(this,e,t,-1)},jn.as=function(e){if(!this.isValid())return NaN;var t,n,s=this._milliseconds;if("month"===(e=O(e))||"year"===e)return t=this._days+s/864e5,n=this._months+Ze(t),"month"===e?n:n/12;switch(t=this._days+Math.round(ze(this._months)),e){case"week":return t/7+s/6048e5;case"day":return t+s/864e5;case"hour":return 24*t+s/36e5;case"minute":return 1440*t+s/6e4;case"second":return 86400*t+s/1e3;case"millisecond":return Math.floor(864e5*t)+s;default:throw new Error("Unknown unit "+e)}},jn.asMilliseconds=On,jn.asSeconds=Tn,jn.asMinutes=xn,jn.asHours=bn,jn.asDays=Pn,jn.asWeeks=Wn,jn.asMonths=Hn,jn.asYears=Rn,jn.valueOf=function(){return this.isValid()?this._milliseconds+864e5*this._days+this._months%12*2592e6+31536e6*g(this._months/12):NaN},jn._bubble=function(){var e,t,n,s,i,r=this._milliseconds,a=this._days,o=this._months,u=this._data;return r>=0&&a>=0&&o>=0||r<=0&&a<=0&&o<=0||(r+=864e5*je(ze(o)+a),a=0,o=0),u.milliseconds=r%1e3,e=y(r/1e3),u.seconds=e%60,t=y(e/60),u.minutes=t%60,n=y(t/60),u.hours=n%24,a+=y(n/24),i=y(Ze(a)),o+=i,a-=je(ze(i)),s=y(o/12),o%=12,u.days=a,u.months=o,u.years=s,this},jn.clone=function(){return xe(this)},jn.get=function(e){return e=O(e),this.isValid()?this[e+"s"]():NaN},jn.milliseconds=Cn,jn.seconds=Fn,jn.minutes=Un,jn.hours=Ln,jn.days=Nn,jn.weeks=function(){return y(this.days()/7)},jn.months=Gn,jn.years=Vn,jn.humanize=function(e){if(!this.isValid())return this.localeData().invalidDate();var t=this.localeData(),n=function(e,t,n){var s=xe(e).abs(),i=En(s.as("s")),r=En(s.as("m")),a=En(s.as("h")),o=En(s.as("d")),u=En(s.as("M")),l=En(s.as("y")),d=i<=In.ss&&["s",i]||i<In.s&&["ss",i]||r<=1&&["m"]||r<In.m&&["mm",r]||a<=1&&["h"]||a<In.h&&["hh",a]||o<=1&&["d"]||o<In.d&&["dd",o]||u<=1&&["M"]||u<In.M&&["MM",u]||l<=1&&["y"]||["yy",l];return d[2]=t,d[3]=+e>0,d[4]=n,function(e,t,n,s,i){return i.relativeTime(t||1,!!n,e,s)}.apply(null,d)}(this,!e,t);return e&&(n=t.pastFuture(+this,n)),t.postformat(n)},jn.toISOString=Be,jn.toString=Be,jn.toJSON=Be,jn.locale=Ce,jn.localeData=Fe,jn.toIsoString=v("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",Be),jn.lang=gn,P("X",0,0,"unix"),P("x",0,0,"valueOf"),C("x",Mt),C("X",/[+-]?\d+(\.\d{1,3})?/),L("X",function(e,t,n){n._d=new Date(1e3*parseFloat(e,10))}),L("x",function(e,t,n){n._d=new Date(g(e))}),e.version="2.20.1",function(e){Qe=e}(pe),e.fn=Dn,e.min=function(){return we("isBefore",[].slice.call(arguments,0))},e.max=function(){return we("isAfter",[].slice.call(arguments,0))},e.now=function(){return Date.now?Date.now():+new Date},e.utc=l,e.unix=function(e){return pe(1e3*e)},e.months=function(e,t){return Ee(e,t,"months")},e.isDate=r,e.locale=ae,e.invalid=c,e.duration=xe,e.isMoment=_,e.weekdays=function(e,t,n){return Ie(e,t,n,"weekdays")},e.parseZone=function(){return pe.apply(null,arguments).parseZone()},e.localeData=ue,e.isDuration=Me,e.monthsShort=function(e,t){return Ee(e,t,"monthsShort")},e.weekdaysMin=function(e,t,n){return Ie(e,t,n,"weekdaysMin")},e.defineLocale=oe,e.updateLocale=function(e,t){if(null!=t){var n,s,i=Qt;null!=(s=re(e))&&(i=s._config),(n=new k(t=D(i,t))).parentLocale=Xt[e],Xt[e]=n,ae(e)}else null!=Xt[e]&&(null!=Xt[e].parentLocale?Xt[e]=Xt[e].parentLocale:null!=Xt[e]&&delete Xt[e]);return Xt[e]},e.locales=function(){return nt(Xt)},e.weekdaysShort=function(e,t,n){return Ie(e,t,n,"weekdaysShort")},e.normalizeUnits=O,e.relativeTimeRounding=function(e){return void 0===e?En:"function"==typeof e&&(En=e,!0)},e.relativeTimeThreshold=function(e,t){return void 0!==In[e]&&(void 0===t?In[e]:(In[e]=t,"s"===e&&(In.ss=t-1),!0))},e.calendarFormat=function(e,t){var n=e.diff(t,"days",!0);return n<-6?"sameElse":n<-1?"lastWeek":n<0?"lastDay":n<1?"sameDay":n<2?"nextDay":n<7?"nextWeek":"sameElse"},e.prototype=Dn,e.HTML5_FMT={DATETIME_LOCAL:"YYYY-MM-DDTHH:mm",DATETIME_LOCAL_SECONDS:"YYYY-MM-DDTHH:mm:ss",DATETIME_LOCAL_MS:"YYYY-MM-DDTHH:mm:ss.SSS",DATE:"YYYY-MM-DD",TIME:"HH:mm",TIME_SECONDS:"HH:mm:ss",TIME_MS:"HH:mm:ss.SSS",WEEK:"YYYY-[W]WW",MONTH:"YYYY-MM"},e});
(function (factory) {
if ( typeof define === 'function' && define.amd ) {
define([], factory);
} else if ( typeof exports === 'object' ) {
module.exports = factory();
} else {
window.wNumb = factory();
}
}(function(){
'use strict';
var FormatOptions = [
'decimals',
'thousand',
'mark',
'prefix',
'suffix',
'encoder',
'decoder',
'negativeBefore',
'negative',
'edit',
'undo'
];
function strReverse ( a ) {
return a.split('').reverse().join('');
}
function strStartsWith ( input, match ) {
return input.substring(0, match.length) === match;
}
function strEndsWith ( input, match ) {
return input.slice(-1 * match.length) === match;
}
function throwEqualError( F, a, b ) {
if ( (F[a] || F[b]) && (F[a] === F[b]) ) {
throw new Error(a);
}
}
function isValidNumber ( input ) {
return typeof input === 'number' && isFinite( input );
}
function toFixed ( value, exp ) {
value = value.toString().split('e');
value = Math.round(+(value[0] + 'e' + (value[1] ? (+value[1] + exp) : exp)));
value = value.toString().split('e');
return (+(value[0] + 'e' + (value[1] ? (+value[1] - exp) : -exp))).toFixed(exp);
}
function formatTo ( decimals, thousand, mark, prefix, suffix, encoder, decoder, negativeBefore, negative, edit, undo, input ) {
var originalInput = input, inputIsNegative, inputPieces, inputBase, inputDecimals = '', output = '';
if ( encoder ) {
input = encoder(input);
}
if ( !isValidNumber(input) ) {
return false;
}
if ( decimals !== false && parseFloat(input.toFixed(decimals)) === 0 ) {
input = 0;
}
if ( input < 0 ) {
inputIsNegative = true;
input = Math.abs(input);
}
if ( decimals !== false ) {
input = toFixed( input, decimals );
}
input = input.toString();
if ( input.indexOf('.') !== -1 ) {
inputPieces = input.split('.');
inputBase = inputPieces[0];
if ( mark ) {
inputDecimals = mark + inputPieces[1];
}
} else {
inputBase = input;
}
if ( thousand ) {
inputBase = strReverse(inputBase).match(/.{1,3}/g);
inputBase = strReverse(inputBase.join( strReverse( thousand ) ));
}
if ( inputIsNegative && negativeBefore ) {
output += negativeBefore;
}
if ( prefix ) {
output += prefix;
}
if ( inputIsNegative && negative ) {
output += negative;
}
output += inputBase;
output += inputDecimals;
if ( suffix ) {
output += suffix;
}
if ( edit ) {
output = edit ( output, originalInput );
}
return output;
}
function formatFrom ( decimals, thousand, mark, prefix, suffix, encoder, decoder, negativeBefore, negative, edit, undo, input ) {
var originalInput = input, inputIsNegative, output = '';
if ( undo ) {
input = undo(input);
}
if ( !input || typeof input !== 'string' ) {
return false;
}
if ( negativeBefore && strStartsWith(input, negativeBefore) ) {
input = input.replace(negativeBefore, '');
inputIsNegative = true;
}
if ( prefix && strStartsWith(input, prefix) ) {
input = input.replace(prefix, '');
}
if ( negative && strStartsWith(input, negative) ) {
input = input.replace(negative, '');
inputIsNegative = true;
}
if ( suffix && strEndsWith(input, suffix) ) {
input = input.slice(0, -1 * suffix.length);
}
if ( thousand ) {
input = input.split(thousand).join('');
}
if ( mark ) {
input = input.replace(mark, '.');
}
if ( inputIsNegative ) {
output += '-';
}
output += input;
output = output.replace(/[^0-9\.\-.]/g, '');
if ( output === '' ) {
return false;
}
output = Number(output);
if ( decoder ) {
output = decoder(output);
}
if ( !isValidNumber(output) ) {
return false;
}
return output;
}
function validate ( inputOptions ) {
var i, optionName, optionValue,
filteredOptions = {};
if ( inputOptions['suffix'] === undefined ) {
inputOptions['suffix'] = inputOptions['postfix'];
}
for ( i = 0; i < FormatOptions.length; i+=1 ) {
optionName = FormatOptions[i];
optionValue = inputOptions[optionName];
if ( optionValue === undefined ) {
if ( optionName === 'negative' && !filteredOptions.negativeBefore ) {
filteredOptions[optionName] = '-';
} else if ( optionName === 'mark' && filteredOptions.thousand !== '.' ) {
filteredOptions[optionName] = '.';
} else {
filteredOptions[optionName] = false;
}
} else if ( optionName === 'decimals' ) {
if ( optionValue >= 0 && optionValue < 8 ) {
filteredOptions[optionName] = optionValue;
} else {
throw new Error(optionName);
}
} else if ( optionName === 'encoder' || optionName === 'decoder' || optionName === 'edit' || optionName === 'undo' ) {
if ( typeof optionValue === 'function' ) {
filteredOptions[optionName] = optionValue;
} else {
throw new Error(optionName);
}
} else {
if ( typeof optionValue === 'string' ) {
filteredOptions[optionName] = optionValue;
} else {
throw new Error(optionName);
}
}
}
throwEqualError(filteredOptions, 'mark', 'thousand');
throwEqualError(filteredOptions, 'prefix', 'negative');
throwEqualError(filteredOptions, 'prefix', 'negativeBefore');
return filteredOptions;
}
function passAll ( options, method, input ) {
var i, args = [];
for ( i = 0; i < FormatOptions.length; i+=1 ) {
args.push(options[FormatOptions[i]]);
}
args.push(input);
return method.apply('', args);
}
function wNumb ( options ) {
if ( !(this instanceof wNumb) ) {
return new wNumb ( options );
}
if ( typeof options !== "object" ) {
return;
}
options = validate(options);
this.to = function ( input ) {
return passAll(options, formatTo, input);
};
this.from = function ( input ) {
return passAll(options, formatFrom, input);
};
}
return wNumb;
}));
(function ($) {
'use strict';
var identity = function (x) {
return x;
};
var isArray = function (value) {
return $.isArray(value);
};
var isObject = function (value) {
return !isArray(value) && (value instanceof Object);
};
var isNumber = function (value) {
return value instanceof Number;
};
var isFunction = function (value) {
return value instanceof Function;
};
var indexOf = function (object, value) {
return $.inArray(value, object);
};
var inArray = function (array, value) {
return indexOf(array, value) !== -1;
};
var foreach = function (collection, callback) {
for(var i in collection) {
if(collection.hasOwnProperty(i)) {
callback(collection[i], i, collection);
}
}
};
var last = function (array) {
return array[array.length - 1];
};
var argumentsToArray = function (args) {
return Array.prototype.slice.call(args);
};
var extend = function () {
var extended = {};
foreach(argumentsToArray(arguments), function (o) {
foreach(o, function (val, key) {
extended[key] = val;
});
});
return extended;
};
var mapToArray = function (collection, callback) {
var mapped = [];
foreach(collection, function (value, key, coll) {
mapped.push(callback(value, key, coll));
});
return mapped;
};
var mapToObject = function (collection, callback, keyCallback) {
var mapped = {};
foreach(collection, function (value, key, coll) {
key = keyCallback ? keyCallback(key, value) : key;
mapped[key] = callback(value, key, coll);
});
return mapped;
};
var map = function (collection, callback, keyCallback) {
return isArray(collection) ?
mapToArray(collection, callback) :
mapToObject(collection, callback, keyCallback);
};
var pluck = function (arrayOfObjects, key) {
return map(arrayOfObjects, function (val) {
return val[key];
});
};
var filter = function (collection, callback) {
var filtered;
if(isArray(collection)) {
filtered = [];
foreach(collection, function (val, key, coll) {
if(callback(val, key, coll)) {
filtered.push(val);
}
});
}
else {
filtered = {};
foreach(collection, function (val, key, coll) {
if(callback(val, key, coll)) {
filtered[key] = val;
}
});
}
return filtered;
};
var call = function (collection, functionName, args) {
return map(collection, function (object, name) {
return object[functionName].apply(object, args || []);
});
};
var throttle = function (minimumInterval, callback) {
var timeout = null;
return function () {
var that = this, args = arguments;
if(timeout === null) {
timeout = setTimeout(function () {
timeout = null;
}, minimumInterval);
callback.apply(that, args);
}
};
};
var mixinPubSub = function (object) {
object = object || {};
var topics = {};
object.publish = function (topic, data) {
foreach(topics[topic], function (callback) {
callback(data);
});
};
object.subscribe = function (topic, callback) {
topics[topic] = topics[topic] || [];
topics[topic].push(callback);
};
object.unsubscribe = function (callback) {
foreach(topics, function (subscribers) {
var index = indexOf(subscribers, callback);
if(index !== -1) {
subscribers.splice(index, 1);
}
});
};
return object;
};
(function ($) {
'use strict';
var createBaseInput = function (fig, my) {
var self = mixinPubSub(),
$self = fig.$;
self.getType = function () {
throw 'implement me (return type. "text", "radio", etc.)';
};
self.$ = function (selector) {
return selector ? $self.find(selector) : $self;
};
self.disable = function () {
self.$().prop('disabled', true);
self.publish('isEnabled', false);
};
self.enable = function () {
self.$().prop('disabled', false);
self.publish('isEnabled', true);
};
my.equalTo = function (a, b) {
return a === b;
};
my.publishChange = (function () {
var oldValue;
return function (e, domElement) {
var newValue = self.get();
if(!my.equalTo(newValue, oldValue)) {
self.publish('change', { e: e, domElement: domElement });
}
oldValue = newValue;
};
}());
return self;
};
var createInput = function (fig, my) {
var self = createBaseInput(fig, my);
self.get = function () {
return self.$().val();
};
self.set = function (newValue) {
self.$().val(newValue);
};
self.clear = function () {
self.set('');
};
my.buildSetter = function (callback) {
return function (newValue) {
callback.call(self, newValue);
};
};
return self;
};
var inputEqualToArray = function (a, b) {
a = isArray(a) ? a : [a];
b = isArray(b) ? b : [b];
var isEqual = true;
if(a.length !== b.length) {
isEqual = false;
}
else {
foreach(a, function (value) {
if(!inArray(b, value)) {
isEqual = false;
}
});
}
return isEqual;
};
var createInputButton = function (fig) {
var my = {},
self = createInput(fig, my);
self.getType = function () {
return 'button';
};
self.$().on('change', function (e) {
my.publishChange(e, this);
});
return self;
};
var createInputCheckbox = function (fig) {
var my = {},
self = createInput(fig, my);
self.getType = function () {
return 'checkbox';
};
self.get = function () {
var values = [];
self.$().filter(':checked').each(function () {
values.push($(this).val());
});
return values;
};
self.set = function (newValues) {
newValues = isArray(newValues) ? newValues : [newValues];
self.$().each(function () {
$(this).prop('checked', false);
});
foreach(newValues, function (value) {
self.$().filter('[value="' + value + '"]')
.prop('checked', true);
});
};
my.equalTo = inputEqualToArray;
self.$().change(function (e) {
my.publishChange(e, this);
});
return self;
};
var createInputEmail = function (fig) {
var my = {},
self = createInputText(fig, my);
self.getType = function () {
return 'email';
};
return self;
};
var createInputFile = function (fig) {
var my = {},
self = createBaseInput(fig, my);
self.getType = function () {
return 'file';
};
self.get = function () {
return last(self.$().val().split('\\'));
};
self.clear = function () {
this.$().each(function () {
$(this).wrap('<form>').closest('form').get(0).reset();
$(this).unwrap();
});
};
self.$().change(function (e) {
my.publishChange(e, this);
});
return self;
};
var createInputHidden = function (fig) {
var my = {},
self = createInput(fig, my);
self.getType = function () {
return 'hidden';
};
self.$().change(function (e) {
my.publishChange(e, this);
});
return self;
};
var createInputMultipleFile = function (fig) {
var my = {},
self = createBaseInput(fig, my);
self.getType = function () {
return 'file[multiple]';
};
self.get = function () {
var fileListObject = self.$().get(0).files || [],
names = [], i;
for(i = 0; i < (fileListObject.length || 0); i += 1) {
names.push(fileListObject[i].name);
}
return names;
};
self.clear = function () {
this.$().each(function () {
$(this).wrap('<form>').closest('form').get(0).reset();
$(this).unwrap();
});
};
self.$().change(function (e) {
my.publishChange(e, this);
});
return self;
};
var createInputMultipleSelect = function (fig) {
var my = {},
self = createInput(fig, my);
self.getType = function () {
return 'select[multiple]';
};
self.get = function () {
return self.$().val() || [];
};
self.set = function (newValues) {
self.$().val(
newValues === '' ? [] : isArray(newValues) ? newValues : [newValues]
);
};
my.equalTo = inputEqualToArray;
self.$().change(function (e) {
my.publishChange(e, this);
});
return self;
};
var createInputPassword = function (fig) {
var my = {},
self = createInputText(fig, my);
self.getType = function () {
return 'password';
};
return self;
};
var createInputRadio = function (fig) {
var my = {},
self = createInput(fig, my);
self.getType = function () {
return 'radio';
};
self.get = function () {
return self.$().filter(':checked').val() || null;
};
self.set = function (newValue) {
if(!newValue) {
self.$().each(function () {
$(this).prop('checked', false);
});
}
else {
self.$().filter('[value="' + newValue + '"]').prop('checked', true);
}
};
self.$().change(function (e) {
my.publishChange(e, this);
});
return self;
};
var createInputRange = function (fig) {
var my = {},
self = createInput(fig, my);
self.getType = function () {
return 'range';
};
self.$().change(function (e) {
my.publishChange(e, this);
});
return self;
};
var createInputSelect = function (fig) {
var my = {},
self = createInput(fig, my);
self.getType = function () {
return 'select';
};
self.$().change(function (e) {
my.publishChange(e, this);
});
return self;
};
var createInputText = function (fig) {
var my = {},
self = createInput(fig, my);
self.getType = function () {
return 'text';
};
self.$().on('change keyup keydown', function (e) {
my.publishChange(e, this);
});
return self;
};
var createInputTextarea = function (fig) {
var my = {},
self = createInput(fig, my);
self.getType = function () {
return 'textarea';
};
self.$().on('change keyup keydown', function (e) {
my.publishChange(e, this);
});
return self;
};
var createInputURL = function (fig) {
var my = {},
self = createInputText(fig, my);
self.getType = function () {
return 'url';
};
return self;
};
var buildFormInputs = function (fig) {
var inputs = {},
$self = fig.$;
var constructor = fig.constructorOverride || {
button: createInputButton,
text: createInputText,
url: createInputURL,
email: createInputEmail,
password: createInputPassword,
range: createInputRange,
textarea: createInputTextarea,
select: createInputSelect,
'select[multiple]': createInputMultipleSelect,
radio: createInputRadio,
checkbox: createInputCheckbox,
file: createInputFile,
'file[multiple]': createInputMultipleFile,
hidden: createInputHidden
};
var addInputsBasic = function (type, selector) {
var $input = isObject(selector) ? selector : $self.find(selector);
$input.each(function () {
var name = $(this).attr('name');
inputs[name] = constructor[type]({
$: $(this)
});
});
};
var addInputsGroup = function (type, selector) {
var names = [],
$input = isObject(selector) ? selector : $self.find(selector);
if(isObject(selector)) {
inputs[$input.attr('name')] = constructor[type]({
$: $input
});
}
else {
$input.each(function () {
if(indexOf(names, $(this).attr('name')) === -1) {
names.push($(this).attr('name'));
}
});
foreach(names, function (name) {
inputs[name] = constructor[type]({
$: $self.find('input[name="' + name + '"]')
});
});
}
};
if($self.is('input, select, textarea')) {
if($self.is('input[type="button"], button, input[type="submit"]')) {
addInputsBasic('button', $self);
}
else if($self.is('textarea')) {
addInputsBasic('textarea', $self);
}
else if(
$self.is('input[type="text"]') ||
$self.is('input') && !$self.attr('type')
) {
addInputsBasic('text', $self);
}
else if($self.is('input[type="password"]')) {
addInputsBasic('password', $self);
}
else if($self.is('input[type="email"]')) {
addInputsBasic('email', $self);
}
else if($self.is('input[type="url"]')) {
addInputsBasic('url', $self);
}
else if($self.is('input[type="range"]')) {
addInputsBasic('range', $self);
}
else if($self.is('select')) {
if($self.is('[multiple]')) {
addInputsBasic('select[multiple]', $self);
}
else {
addInputsBasic('select', $self);
}
}
else if($self.is('input[type="file"]')) {
if($self.is('[multiple]')) {
addInputsBasic('file[multiple]', $self);
}
else {
addInputsBasic('file', $self);
}
}
else if($self.is('input[type="hidden"]')) {
addInputsBasic('hidden', $self);
}
else if($self.is('input[type="radio"]')) {
addInputsGroup('radio', $self);
}
else if($self.is('input[type="checkbox"]')) {
addInputsGroup('checkbox', $self);
}
else {
addInputsBasic('text', $self);
}
}
else {
addInputsBasic('button', 'input[type="button"], button, input[type="submit"]');
addInputsBasic('text', 'input[type="text"]');
addInputsBasic('password', 'input[type="password"]');
addInputsBasic('email', 'input[type="email"]');
addInputsBasic('url', 'input[type="url"]');
addInputsBasic('range', 'input[type="range"]');
addInputsBasic('textarea', 'textarea');
addInputsBasic('select', 'select:not([multiple])');
addInputsBasic('select[multiple]', 'select[multiple]');
addInputsBasic('file', 'input[type="file"]:not([multiple])');
addInputsBasic('file[multiple]', 'input[type="file"][multiple]');
addInputsBasic('hidden', 'input[type="hidden"]');
addInputsGroup('radio', 'input[type="radio"]');
addInputsGroup('checkbox', 'input[type="checkbox"]');
}
return inputs;
};
$.fn.inputVal = function (newValue) {
var $self = $(this);
var inputs = buildFormInputs({ $: $self });
if($self.is('input, textarea, select')) {
if(typeof newValue === 'undefined') {
return inputs[$self.attr('name')].get();
}
else {
inputs[$self.attr('name')].set(newValue);
return $self;
}
}
else {
if(typeof newValue === 'undefined') {
return call(inputs, 'get');
}
else {
foreach(newValue, function (value, inputName) {
inputs[inputName].set(value);
});
return $self;
}
}
};
$.fn.inputOnChange = function (callback) {
var $self = $(this);
var inputs = buildFormInputs({ $: $self });
foreach(inputs, function (input) {
input.subscribe('change', function (data) {
callback.call(data.domElement, data.e);
});
});
return $self;
};
$.fn.inputDisable = function () {
var $self = $(this);
call(buildFormInputs({ $: $self }), 'disable');
return $self;
};
$.fn.inputEnable = function () {
var $self = $(this);
call(buildFormInputs({ $: $self }), 'enable');
return $self;
};
$.fn.inputClear = function () {
var $self = $(this);
call(buildFormInputs({ $: $self }), 'clear');
return $self;
};
}(jQuery));
$.fn.repeaterVal = function () {
var parse = function (raw) {
var parsed = [];
foreach(raw, function (val, key) {
var parsedKey = [];
if(key !== "undefined") {
parsedKey.push(key.match(/^[^\[]*/)[0]);
parsedKey = parsedKey.concat(map(
key.match(/\[[^\]]*\]/g),
function (bracketed) {
return bracketed.replace(/[\[\]]/g, '');
}
));
parsed.push({
val: val,
key: parsedKey
});
}
});
return parsed;
};
var build = function (parsed) {
if(
parsed.length === 1 &&
(parsed[0].key.length === 0 || parsed[0].key.length === 1 && !parsed[0].key[0])
) {
return parsed[0].val;
}
foreach(parsed, function (p) {
p.head = p.key.shift();
});
var grouped = (function () {
var grouped = {};
foreach(parsed, function (p) {
if(!grouped[p.head]) {
grouped[p.head] = [];
}
grouped[p.head].push(p);
});
return grouped;
}());
var built;
if(/^[0-9]+$/.test(parsed[0].head)) {
built = [];
foreach(grouped, function (group) {
built.push(build(group));
});
}
else {
built = {};
foreach(grouped, function (group, key) {
built[key] = build(group);
});
}
return built;
};
return build(parse($(this).inputVal()));
};
$.fn.repeater = function (fig) {
fig = fig || {};
var setList;
$(this).each(function () {
var $self = $(this);
var show = fig.show || function () {
$(this).show();
};
var hide = fig.hide || function (removeElement) {
removeElement();
};
var $list = $self.find('[data-repeater-list]').first();
var $filterNested = function ($items, repeaters) {
return $items.filter(function () {
return repeaters ?
$(this).closest(
pluck(repeaters, 'selector').join(',')
).length === 0 : true;
});
};
var $items = function () {
return $filterNested($list.find('[data-repeater-item]'), fig.repeaters);
};
var $itemTemplate = $list.find('[data-repeater-item]')
.first().clone().hide();
var $firstDeleteButton = $filterNested(
$filterNested($(this).find('[data-repeater-item]'), fig.repeaters)
.first().find('[data-repeater-delete]'),
fig.repeaters
);
if(fig.isFirstItemUndeletable && $firstDeleteButton) {
$firstDeleteButton.remove();
}
var getGroupName = function () {
var groupName = $list.data('repeater-list');
return fig.$parent ?
fig.$parent.data('item-name') + '[' + groupName + ']' :
groupName;
};
var initNested = function ($listItems) {
if(fig.repeaters) {
$listItems.each(function () {
var $item = $(this);
foreach(fig.repeaters, function (nestedFig) {
$item.find(nestedFig.selector).repeater(extend(
nestedFig, { $parent: $item }
));
});
});
}
};
var $foreachRepeaterInItem = function (repeaters, $item, cb) {
if(repeaters) {
foreach(repeaters, function (nestedFig) {
cb.call($item.find(nestedFig.selector)[0], nestedFig);
});
}
};
var setIndexes = function ($items, groupName, repeaters) {
$items.each(function (index) {
var $item = $(this);
$item.data('item-name', groupName + '[' + index + ']');
$filterNested($item.find('[name]'), repeaters)
.each(function () {
var $input = $(this);
var matches = $input.attr('name').match(/\[[^\]]+\]/g);
var name = matches ?
last(matches).replace(/\[|\]/g, '') :
$input.attr('name');
var newName = groupName + '[' + index + '][' + name + ']' +
($input.is(':checkbox') || $input.attr('multiple') ? '[]' : '');
$input.attr('name', newName);
$foreachRepeaterInItem(repeaters, $item, function (nestedFig) {
var $repeater = $(this);
setIndexes(
$filterNested($repeater.find('[data-repeater-item]'), nestedFig.repeaters || []),
groupName + '[' + index + ']' +
'[' + $repeater.find('[data-repeater-list]').first().data('repeater-list') + ']',
nestedFig.repeaters
);
});
});
});
$list.find('input[name][checked]')
.removeAttr('checked')
.prop('checked', true);
};
setIndexes($items(), getGroupName(), fig.repeaters);
initNested($items());
if(fig.initEmpty) {
$items().remove();
}
if(fig.ready) {
fig.ready(function () {
setIndexes($items(), getGroupName(), fig.repeaters);
});
}
var appendItem = (function () {
var setItemsValues = function ($item, data, repeaters) {
if(data || fig.defaultValues) {
var inputNames = {};
$filterNested($item.find('[name]'), repeaters).each(function () {
var key = $(this).attr('name').match(/\[([^\]]*)(\]|\]\[\])$/)[1];
inputNames[key] = $(this).attr('name');
});
$item.inputVal(map(
filter(data || fig.defaultValues, function (val, name) {
return inputNames[name];
}),
identity,
function (name) {
return inputNames[name];
}
));
}
$foreachRepeaterInItem(repeaters, $item, function (nestedFig) {
var $repeater = $(this);
$filterNested(
$repeater.find('[data-repeater-item]'),
nestedFig.repeaters
)
.each(function () {
var fieldName = $repeater.find('[data-repeater-list]').data('repeater-list');
if(data && data[fieldName]) {
var $template = $(this).clone();
$repeater.find('[data-repeater-item]').remove();
foreach(data[fieldName], function (data) {
var $item = $template.clone();
setItemsValues(
$item,
data,
nestedFig.repeaters || []
);
$repeater.find('[data-repeater-list]').append($item);
});
}
else {
setItemsValues(
$(this),
nestedFig.defaultValues,
nestedFig.repeaters || []
);
}
});
});
};
return function ($item, data) {
$list.append($item);
setIndexes($items(), getGroupName(), fig.repeaters);
$item.find('[name]').each(function () {
$(this).inputClear();
});
setItemsValues($item, data || fig.defaultValues, fig.repeaters);
};
}());
var addItem = function (data) {
var $item = $itemTemplate.clone();
appendItem($item, data);
if(fig.repeaters) {
initNested($item);
}
show.call($item.get(0));
};
setList = function (rows) {
$items().remove();
foreach(rows, addItem);
};
$filterNested($self.find('[data-repeater-create]'), fig.repeaters).click(function () {
addItem();
});
$list.on('click', '[data-repeater-delete]', function () {
var self = $(this).closest('[data-repeater-item]').get(0);
hide.call(self, function () {
$(self).remove();
setIndexes($items(), getGroupName(), fig.repeaters);
});
});
});
this.setList = setList;
return this;
};
}(jQuery));
!function(e){"function"==typeof define&&define.amd?define(["jquery"],e):"object"==typeof module&&module.exports?module.exports=function(t,r){return void 0===r&&(r="undefined"!=typeof window?require("jquery"):require("jquery")(t)),e(r),r}:e(jQuery)}(function(e){"use strict";function t(t){var r=t.data;t.isDefaultPrevented()||(t.preventDefault(),e(t.target).closest("form").ajaxSubmit(r))}function r(t){var r=t.target,a=e(r);if(!a.is("[type=submit],[type=image]")){var n=a.closest("[type=submit]");if(0===n.length)return;r=n[0]}var i=r.form;if(i.clk=r,"image"===r.type)if(void 0!==t.offsetX)i.clk_x=t.offsetX,i.clk_y=t.offsetY;else if("function"==typeof e.fn.offset){var o=a.offset();i.clk_x=t.pageX-o.left,i.clk_y=t.pageY-o.top}else i.clk_x=t.pageX-r.offsetLeft,i.clk_y=t.pageY-r.offsetTop;setTimeout(function(){i.clk=i.clk_x=i.clk_y=null},100)}function a(){if(e.fn.ajaxSubmit.debug){var t="[jquery.form] "+Array.prototype.join.call(arguments,"");window.console&&window.console.log?window.console.log(t):window.opera&&window.opera.postError&&window.opera.postError(t)}}var n=/\r?\n/g,i={};i.fileapi=void 0!==e('<input type="file">').get(0).files,i.formdata=void 0!==window.FormData;var o=!!e.fn.prop;e.fn.attr2=function(){if(!o)return this.attr.apply(this,arguments);var e=this.prop.apply(this,arguments);return e&&e.jquery||"string"==typeof e?e:this.attr.apply(this,arguments)},e.fn.ajaxSubmit=function(t,r,n,s){function u(r){var a,n,i=e.param(r,t.traditional).split("&"),o=i.length,s=[];for(a=0;a<o;a++)i[a]=i[a].replace(/\+/g," "),n=i[a].split("="),s.push([decodeURIComponent(n[0]),decodeURIComponent(n[1])]);return s}function c(r){function n(e){var t=null;try{e.contentWindow&&(t=e.contentWindow.document)}catch(e){a("cannot get iframe.contentWindow document: "+e)}if(t)return t;try{t=e.contentDocument?e.contentDocument:e.document}catch(r){a("cannot get iframe.contentDocument: "+r),t=e.document}return t}function i(){function t(){try{var e=n(v).readyState;a("state = "+e),e&&"uninitialized"===e.toLowerCase()&&setTimeout(t,50)}catch(e){a("Server abort: ",e," (",e.name,")"),s(L),j&&clearTimeout(j),j=void 0}}var r=p.attr2("target"),i=p.attr2("action"),o=p.attr("enctype")||p.attr("encoding")||"multipart/form-data";w.setAttribute("target",m),l&&!/post/i.test(l)||w.setAttribute("method","POST"),i!==f.url&&w.setAttribute("action",f.url),f.skipEncodingOverride||l&&!/post/i.test(l)||p.attr({encoding:"multipart/form-data",enctype:"multipart/form-data"}),f.timeout&&(j=setTimeout(function(){T=!0,s(A)},f.timeout));var u=[];try{if(f.extraData)for(var c in f.extraData)f.extraData.hasOwnProperty(c)&&(e.isPlainObject(f.extraData[c])&&f.extraData[c].hasOwnProperty("name")&&f.extraData[c].hasOwnProperty("value")?u.push(e('<input type="hidden" name="'+f.extraData[c].name+'">',k).val(f.extraData[c].value).appendTo(w)[0]):u.push(e('<input type="hidden" name="'+c+'">',k).val(f.extraData[c]).appendTo(w)[0]));f.iframeTarget||h.appendTo(D),v.attachEvent?v.attachEvent("onload",s):v.addEventListener("load",s,!1),setTimeout(t,15);try{w.submit()}catch(e){document.createElement("form").submit.apply(w)}}finally{w.setAttribute("action",i),w.setAttribute("enctype",o),r?w.setAttribute("target",r):p.removeAttr("target"),e(u).remove()}}function s(t){if(!x.aborted&&!X){if((O=n(v))||(a("cannot access response document"),t=L),t===A&&x)return x.abort("timeout"),void S.reject(x,"timeout");if(t===L&&x)return x.abort("server abort"),void S.reject(x,"error","server abort");if(O&&O.location.href!==f.iframeSrc||T){v.detachEvent?v.detachEvent("onload",s):v.removeEventListener("load",s,!1);var r,i="success";try{if(T)throw"timeout";var o="xml"===f.dataType||O.XMLDocument||e.isXMLDoc(O);if(a("isXml="+o),!o&&window.opera&&(null===O.body||!O.body.innerHTML)&&--C)return a("requeing onLoad callback, DOM not available"),void setTimeout(s,250);var u=O.body?O.body:O.documentElement;x.responseText=u?u.innerHTML:null,x.responseXML=O.XMLDocument?O.XMLDocument:O,o&&(f.dataType="xml"),x.getResponseHeader=function(e){return{"content-type":f.dataType}[e.toLowerCase()]},u&&(x.status=Number(u.getAttribute("status"))||x.status,x.statusText=u.getAttribute("statusText")||x.statusText);var c=(f.dataType||"").toLowerCase(),l=/(json|script|text)/.test(c);if(l||f.textarea){var p=O.getElementsByTagName("textarea")[0];if(p)x.responseText=p.value,x.status=Number(p.getAttribute("status"))||x.status,x.statusText=p.getAttribute("statusText")||x.statusText;else if(l){var m=O.getElementsByTagName("pre")[0],g=O.getElementsByTagName("body")[0];m?x.responseText=m.textContent?m.textContent:m.innerText:g&&(x.responseText=g.textContent?g.textContent:g.innerText)}}else"xml"===c&&!x.responseXML&&x.responseText&&(x.responseXML=q(x.responseText));try{M=N(x,c,f)}catch(e){i="parsererror",x.error=r=e||i}}catch(e){a("error caught: ",e),i="error",x.error=r=e||i}x.aborted&&(a("upload aborted"),i=null),x.status&&(i=x.status>=200&&x.status<300||304===x.status?"success":"error"),"success"===i?(f.success&&f.success.call(f.context,M,"success",x),S.resolve(x.responseText,"success",x),d&&e.event.trigger("ajaxSuccess",[x,f])):i&&(void 0===r&&(r=x.statusText),f.error&&f.error.call(f.context,x,i,r),S.reject(x,"error",r),d&&e.event.trigger("ajaxError",[x,f,r])),d&&e.event.trigger("ajaxComplete",[x,f]),d&&!--e.active&&e.event.trigger("ajaxStop"),f.complete&&f.complete.call(f.context,x,i),X=!0,f.timeout&&clearTimeout(j),setTimeout(function(){f.iframeTarget?h.attr("src",f.iframeSrc):h.remove(),x.responseXML=null},100)}}}var u,c,f,d,m,h,v,x,y,b,T,j,w=p[0],S=e.Deferred();if(S.abort=function(e){x.abort(e)},r)for(c=0;c<g.length;c++)u=e(g[c]),o?u.prop("disabled",!1):u.removeAttr("disabled");(f=e.extend(!0,{},e.ajaxSettings,t)).context=f.context||f,m="jqFormIO"+(new Date).getTime();var k=w.ownerDocument,D=p.closest("body");if(f.iframeTarget?(b=(h=e(f.iframeTarget,k)).attr2("name"))?m=b:h.attr2("name",m):(h=e('<iframe name="'+m+'" src="'+f.iframeSrc+'" />',k)).css({position:"absolute",top:"-1000px",left:"-1000px"}),v=h[0],x={aborted:0,responseText:null,responseXML:null,status:0,statusText:"n/a",getAllResponseHeaders:function(){},getResponseHeader:function(){},setRequestHeader:function(){},abort:function(t){var r="timeout"===t?"timeout":"aborted";a("aborting upload... "+r),this.aborted=1;try{v.contentWindow.document.execCommand&&v.contentWindow.document.execCommand("Stop")}catch(e){}h.attr("src",f.iframeSrc),x.error=r,f.error&&f.error.call(f.context,x,r,t),d&&e.event.trigger("ajaxError",[x,f,r]),f.complete&&f.complete.call(f.context,x,r)}},(d=f.global)&&0==e.active++&&e.event.trigger("ajaxStart"),d&&e.event.trigger("ajaxSend",[x,f]),f.beforeSend&&!1===f.beforeSend.call(f.context,x,f))return f.global&&e.active--,S.reject(),S;if(x.aborted)return S.reject(),S;(y=w.clk)&&(b=y.name)&&!y.disabled&&(f.extraData=f.extraData||{},f.extraData[b]=y.value,"image"===y.type&&(f.extraData[b+".x"]=w.clk_x,f.extraData[b+".y"]=w.clk_y));var A=1,L=2,F=e("meta[name=csrf-token]").attr("content"),E=e("meta[name=csrf-param]").attr("content");E&&F&&(f.extraData=f.extraData||{},f.extraData[E]=F),f.forceSync?i():setTimeout(i,10);var M,O,X,C=50,q=e.parseXML||function(e,t){return window.ActiveXObject?((t=new ActiveXObject("Microsoft.XMLDOM")).async="false",t.loadXML(e)):t=(new DOMParser).parseFromString(e,"text/xml"),t&&t.documentElement&&"parsererror"!==t.documentElement.nodeName?t:null},_=e.parseJSON||function(e){return window.eval("("+e+")")},N=function(t,r,a){var n=t.getResponseHeader("content-type")||"",i=("xml"===r||!r)&&n.indexOf("xml")>=0,o=i?t.responseXML:t.responseText;return i&&"parsererror"===o.documentElement.nodeName&&e.error&&e.error("parsererror"),a&&a.dataFilter&&(o=a.dataFilter(o,r)),"string"==typeof o&&(("json"===r||!r)&&n.indexOf("json")>=0?o=_(o):("script"===r||!r)&&n.indexOf("javascript")>=0&&e.globalEval(o)),o};return S}if(!this.length)return a("ajaxSubmit: skipping submit process - no element selected"),this;var l,f,d,p=this;"function"==typeof t?t={success:t}:"string"==typeof t||!1===t&&arguments.length>0?(t={url:t,data:r,dataType:n},"function"==typeof s&&(t.success=s)):void 0===t&&(t={}),l=t.method||t.type||this.attr2("method"),(d=(d="string"==typeof(f=t.url||this.attr2("action"))?e.trim(f):"")||window.location.href||"")&&(d=(d.match(/^([^#]+)/)||[])[1]),t=e.extend(!0,{url:d,success:e.ajaxSettings.success,type:l||e.ajaxSettings.type,iframeSrc:/^https/i.test(window.location.href||"")?"javascript:false":"about:blank"},t);var m={};if(this.trigger("form-pre-serialize",[this,t,m]),m.veto)return a("ajaxSubmit: submit vetoed via form-pre-serialize trigger"),this;if(t.beforeSerialize&&!1===t.beforeSerialize(this,t))return a("ajaxSubmit: submit aborted via beforeSerialize callback"),this;var h=t.traditional;void 0===h&&(h=e.ajaxSettings.traditional);var v,g=[],x=this.formToArray(t.semantic,g,t.filtering);if(t.data){var y=e.isFunction(t.data)?t.data(x):t.data;t.extraData=y,v=e.param(y,h)}if(t.beforeSubmit&&!1===t.beforeSubmit(x,this,t))return a("ajaxSubmit: submit aborted via beforeSubmit callback"),this;if(this.trigger("form-submit-validate",[x,this,t,m]),m.veto)return a("ajaxSubmit: submit vetoed via form-submit-validate trigger"),this;var b=e.param(x,h);v&&(b=b?b+"&"+v:v),"GET"===t.type.toUpperCase()?(t.url+=(t.url.indexOf("?")>=0?"&":"?")+b,t.data=null):t.data=b;var T=[];if(t.resetForm&&T.push(function(){p.resetForm()}),t.clearForm&&T.push(function(){p.clearForm(t.includeHidden)}),!t.dataType&&t.target){var j=t.success||function(){};T.push(function(r,a,n){var i=arguments,o=t.replaceTarget?"replaceWith":"html";e(t.target)[o](r).each(function(){j.apply(this,i)})})}else t.success&&(e.isArray(t.success)?e.merge(T,t.success):T.push(t.success));if(t.success=function(e,r,a){for(var n=t.context||this,i=0,o=T.length;i<o;i++)T[i].apply(n,[e,r,a||p,p])},t.error){var w=t.error;t.error=function(e,r,a){var n=t.context||this;w.apply(n,[e,r,a,p])}}if(t.complete){var S=t.complete;t.complete=function(e,r){var a=t.context||this;S.apply(a,[e,r,p])}}var k=e("input[type=file]:enabled",this).filter(function(){return""!==e(this).val()}).length>0,D="multipart/form-data",A=p.attr("enctype")===D||p.attr("encoding")===D,L=i.fileapi&&i.formdata;a("fileAPI :"+L);var F,E=(k||A)&&!L;!1!==t.iframe&&(t.iframe||E)?t.closeKeepAlive?e.get(t.closeKeepAlive,function(){F=c(x)}):F=c(x):F=(k||A)&&L?function(r){for(var a=new FormData,n=0;n<r.length;n++)a.append(r[n].name,r[n].value);if(t.extraData){var i=u(t.extraData);for(n=0;n<i.length;n++)i[n]&&a.append(i[n][0],i[n][1])}t.data=null;var o=e.extend(!0,{},e.ajaxSettings,t,{contentType:!1,processData:!1,cache:!1,type:l||"POST"});t.uploadProgress&&(o.xhr=function(){var r=e.ajaxSettings.xhr();return r.upload&&r.upload.addEventListener("progress",function(e){var r=0,a=e.loaded||e.position,n=e.total;e.lengthComputable&&(r=Math.ceil(a/n*100)),t.uploadProgress(e,a,n,r)},!1),r}),o.data=null;var s=o.beforeSend;return o.beforeSend=function(e,r){t.formData?r.data=t.formData:r.data=a,s&&s.call(this,e,r)},e.ajax(o)}(x):e.ajax(t),p.removeData("jqxhr").data("jqxhr",F);for(var M=0;M<g.length;M++)g[M]=null;return this.trigger("form-submit-notify",[this,t]),this},e.fn.ajaxForm=function(n,i,o,s){if(("string"==typeof n||!1===n&&arguments.length>0)&&(n={url:n,data:i,dataType:o},"function"==typeof s&&(n.success=s)),n=n||{},n.delegation=n.delegation&&e.isFunction(e.fn.on),!n.delegation&&0===this.length){var u={s:this.selector,c:this.context};return!e.isReady&&u.s?(a("DOM not ready, queuing ajaxForm"),e(function(){e(u.s,u.c).ajaxForm(n)}),this):(a("terminating; zero elements found by selector"+(e.isReady?"":" (DOM not ready)")),this)}return n.delegation?(e(document).off("submit.form-plugin",this.selector,t).off("click.form-plugin",this.selector,r).on("submit.form-plugin",this.selector,n,t).on("click.form-plugin",this.selector,n,r),this):this.ajaxFormUnbind().on("submit.form-plugin",n,t).on("click.form-plugin",n,r)},e.fn.ajaxFormUnbind=function(){return this.off("submit.form-plugin click.form-plugin")},e.fn.formToArray=function(t,r,a){var n=[];if(0===this.length)return n;var o,s=this[0],u=this.attr("id"),c=t||void 0===s.elements?s.getElementsByTagName("*"):s.elements;if(c&&(c=e.makeArray(c)),u&&(t||/(Edge|Trident)\//.test(navigator.userAgent))&&(o=e(':input[form="'+u+'"]').get()).length&&(c=(c||[]).concat(o)),!c||!c.length)return n;e.isFunction(a)&&(c=e.map(c,a));var l,f,d,p,m,h,v;for(l=0,h=c.length;l<h;l++)if(m=c[l],(d=m.name)&&!m.disabled)if(t&&s.clk&&"image"===m.type)s.clk===m&&(n.push({name:d,value:e(m).val(),type:m.type}),n.push({name:d+".x",value:s.clk_x},{name:d+".y",value:s.clk_y}));else if((p=e.fieldValue(m,!0))&&p.constructor===Array)for(r&&r.push(m),f=0,v=p.length;f<v;f++)n.push({name:d,value:p[f]});else if(i.fileapi&&"file"===m.type){r&&r.push(m);var g=m.files;if(g.length)for(f=0;f<g.length;f++)n.push({name:d,value:g[f],type:m.type});else n.push({name:d,value:"",type:m.type})}else null!==p&&void 0!==p&&(r&&r.push(m),n.push({name:d,value:p,type:m.type,required:m.required}));if(!t&&s.clk){var x=e(s.clk),y=x[0];(d=y.name)&&!y.disabled&&"image"===y.type&&(n.push({name:d,value:x.val()}),n.push({name:d+".x",value:s.clk_x},{name:d+".y",value:s.clk_y}))}return n},e.fn.formSerialize=function(t){return e.param(this.formToArray(t))},e.fn.fieldSerialize=function(t){var r=[];return this.each(function(){var a=this.name;if(a){var n=e.fieldValue(this,t);if(n&&n.constructor===Array)for(var i=0,o=n.length;i<o;i++)r.push({name:a,value:n[i]});else null!==n&&void 0!==n&&r.push({name:this.name,value:n})}}),e.param(r)},e.fn.fieldValue=function(t){for(var r=[],a=0,n=this.length;a<n;a++){var i=this[a],o=e.fieldValue(i,t);null===o||void 0===o||o.constructor===Array&&!o.length||(o.constructor===Array?e.merge(r,o):r.push(o))}return r},e.fieldValue=function(t,r){var a=t.name,i=t.type,o=t.tagName.toLowerCase();if(void 0===r&&(r=!0),r&&(!a||t.disabled||"reset"===i||"button"===i||("checkbox"===i||"radio"===i)&&!t.checked||("submit"===i||"image"===i)&&t.form&&t.form.clk!==t||"select"===o&&-1===t.selectedIndex))return null;if("select"===o){var s=t.selectedIndex;if(s<0)return null;for(var u=[],c=t.options,l="select-one"===i,f=l?s+1:c.length,d=l?s:0;d<f;d++){var p=c[d];if(p.selected&&!p.disabled){var m=p.value;if(m||(m=p.attributes&&p.attributes.value&&!p.attributes.value.specified?p.text:p.value),l)return m;u.push(m)}}return u}return e(t).val().replace(n,"\r\n")},e.fn.clearForm=function(t){return this.each(function(){e("input,select,textarea",this).clearFields(t)})},e.fn.clearFields=e.fn.clearInputs=function(t){var r=/^(?:color|date|datetime|email|month|number|password|range|search|tel|text|time|url|week)$/i;return this.each(function(){var a=this.type,n=this.tagName.toLowerCase();r.test(a)||"textarea"===n?this.value="":"checkbox"===a||"radio"===a?this.checked=!1:"select"===n?this.selectedIndex=-1:"file"===a?/MSIE/.test(navigator.userAgent)?e(this).replaceWith(e(this).clone(!0)):e(this).val(""):t&&(!0===t&&/hidden/.test(a)||"string"==typeof t&&e(this).is(t))&&(this.value="")})},e.fn.resetForm=function(){return this.each(function(){var t=e(this),r=this.tagName.toLowerCase();switch(r){case"input":this.checked=this.defaultChecked;case"textarea":return this.value=this.defaultValue,!0;case"option":case"optgroup":var a=t.parents("select");return a.length&&a[0].multiple?"option"===r?this.selected=this.defaultSelected:t.find("option").resetForm():a.resetForm(),!0;case"select":return t.find("option").each(function(e){if(this.selected=this.defaultSelected,this.defaultSelected&&!t[0].multiple)return t[0].selectedIndex=e,!1}),!0;case"label":var n=e(t.attr("for")),i=t.find("input,select,textarea");return n[0]&&i.unshift(n[0]),i.resetForm(),!0;case"form":return("function"==typeof this.reset||"object"==typeof this.reset&&!this.reset.nodeType)&&this.reset(),!0;default:return t.find("form,input,label,select,textarea").resetForm(),!0}})},e.fn.enable=function(e){return void 0===e&&(e=!0),this.each(function(){this.disabled=!e})},e.fn.selected=function(t){return void 0===t&&(t=!0),this.each(function(){var r=this.type;if("checkbox"===r||"radio"===r)this.checked=t;else if("option"===this.tagName.toLowerCase()){var a=e(this).parent("select");t&&a[0]&&"select-one"===a[0].type&&a.find("option").selected(!1),this.selected=t}})},e.fn.ajaxSubmit.debug=!1});
(function(factory){
if(typeof define==="function" && define.amd){
define(["jquery"],factory);
}else if(typeof module!=="undefined" && module.exports){
module.exports=factory;
}else{
factory(jQuery,window,document);
}
}(function($){
(function(init){
var _rjs=typeof define==="function" && define.amd,
_njs=typeof module !== "undefined" && module.exports,
_dlp=("https:"==document.location.protocol) ? "https:" : "http:",
_url="cdnjs.cloudflare.com/ajax/libs/jquery-mousewheel/3.1.13/jquery.mousewheel.min.js";
if(!_rjs){
if(_njs){
require("jquery-mousewheel")($);
}else{
$.event.special.mousewheel || $("head").append(decodeURI("%3Cscript src="+_dlp+"//"+_url+"%3E%3C/script%3E"));
}
}
init();
}(function(){
var pluginNS="mCustomScrollbar",
pluginPfx="mCS",
defaultSelector=".mCustomScrollbar",
defaults={
setTop:0,
setLeft:0,
axis:"y",
scrollbarPosition:"inside",
scrollInertia:950,
autoDraggerLength:true,
alwaysShowScrollbar:0,
snapOffset:0,
mouseWheel:{
enable:true,
scrollAmount:"auto",
axis:"y",
deltaFactor:"auto",
disableOver:["select","option","keygen","datalist","textarea"]
},
scrollButtons:{
scrollType:"stepless",
scrollAmount:"auto"
},
keyboard:{
enable:true,
scrollType:"stepless",
scrollAmount:"auto"
},
contentTouchScroll:25,
documentTouchScroll:true,
advanced:{
autoScrollOnFocus:"input,textarea,select,button,datalist,keygen,a[tabindex],area,object,[contenteditable='true']",
updateOnContentResize:true,
updateOnImageLoad:"auto",
autoUpdateTimeout:60
},
theme:"light",
callbacks:{
onTotalScrollOffset:0,
onTotalScrollBackOffset:0,
alwaysTriggerOffsets:true
}
},
totalInstances=0,
liveTimers={},
oldIE=(window.attachEvent && !window.addEventListener) ? 1 : 0,
touchActive=false,touchable,
classes=[
"mCSB_dragger_onDrag","mCSB_scrollTools_onDrag","mCS_img_loaded","mCS_disabled","mCS_destroyed","mCS_no_scrollbar",
"mCS-autoHide","mCS-dir-rtl","mCS_no_scrollbar_y","mCS_no_scrollbar_x","mCS_y_hidden","mCS_x_hidden","mCSB_draggerContainer",
"mCSB_buttonUp","mCSB_buttonDown","mCSB_buttonLeft","mCSB_buttonRight"
],
methods={
init:function(options){
var options=$.extend(true,{},defaults,options),
selector=_selector.call(this);
if(options.live){
var liveSelector=options.liveSelector || this.selector || defaultSelector,
$liveSelector=$(liveSelector);
if(options.live==="off"){
removeLiveTimers(liveSelector);
return;
}
liveTimers[liveSelector]=setTimeout(function(){
$liveSelector.mCustomScrollbar(options);
if(options.live==="once" && $liveSelector.length){
removeLiveTimers(liveSelector);
}
},500);
}else{
removeLiveTimers(liveSelector);
}
options.setWidth=(options.set_width) ? options.set_width : options.setWidth;
options.setHeight=(options.set_height) ? options.set_height : options.setHeight;
options.axis=(options.horizontalScroll) ? "x" : _findAxis(options.axis);
options.scrollInertia=options.scrollInertia>0 && options.scrollInertia<17 ? 17 : options.scrollInertia;
if(typeof options.mouseWheel!=="object" &&  options.mouseWheel==true){
options.mouseWheel={enable:true,scrollAmount:"auto",axis:"y",preventDefault:false,deltaFactor:"auto",normalizeDelta:false,invert:false}
}
options.mouseWheel.scrollAmount=!options.mouseWheelPixels ? options.mouseWheel.scrollAmount : options.mouseWheelPixels;
options.mouseWheel.normalizeDelta=!options.advanced.normalizeMouseWheelDelta ? options.mouseWheel.normalizeDelta : options.advanced.normalizeMouseWheelDelta;
options.scrollButtons.scrollType=_findScrollButtonsType(options.scrollButtons.scrollType);
_theme(options);
return $(selector).each(function(){
var $this=$(this);
if(!$this.data(pluginPfx)){
$this.data(pluginPfx,{
idx:++totalInstances,
opt:options,
scrollRatio:{y:null,x:null},
overflowed:null,
contentReset:{y:null,x:null},
bindEvents:false,
tweenRunning:false,
sequential:{},
langDir:$this.css("direction"),
cbOffsets:null,
trigger:null,
poll:{size:{o:0,n:0},img:{o:0,n:0},change:{o:0,n:0}}
});
var d=$this.data(pluginPfx),o=d.opt,
htmlDataAxis=$this.data("mcs-axis"),htmlDataSbPos=$this.data("mcs-scrollbar-position"),htmlDataTheme=$this.data("mcs-theme");
if(htmlDataAxis){o.axis=htmlDataAxis;}
if(htmlDataSbPos){o.scrollbarPosition=htmlDataSbPos;}
if(htmlDataTheme){
o.theme=htmlDataTheme;
_theme(o);
}
_pluginMarkup.call(this);
if(d && o.callbacks.onCreate && typeof o.callbacks.onCreate==="function"){o.callbacks.onCreate.call(this);}
$("#mCSB_"+d.idx+"_container img:not(."+classes[2]+")").addClass(classes[2]);
methods.update.call(null,$this);
}
});
},
update:function(el,cb){
var selector=el || _selector.call(this);
return $(selector).each(function(){
var $this=$(this);
if($this.data(pluginPfx)){
var d=$this.data(pluginPfx),o=d.opt,
mCSB_container=$("#mCSB_"+d.idx+"_container"),
mCustomScrollBox=$("#mCSB_"+d.idx),
mCSB_dragger=[$("#mCSB_"+d.idx+"_dragger_vertical"),$("#mCSB_"+d.idx+"_dragger_horizontal")];
if(!mCSB_container.length){return;}
if(d.tweenRunning){_stop($this);}
if(cb && d && o.callbacks.onBeforeUpdate && typeof o.callbacks.onBeforeUpdate==="function"){o.callbacks.onBeforeUpdate.call(this);}
if($this.hasClass(classes[3])){$this.removeClass(classes[3]);}
if($this.hasClass(classes[4])){$this.removeClass(classes[4]);}
mCustomScrollBox.css("max-height","none");
if(mCustomScrollBox.height()!==$this.height()){mCustomScrollBox.css("max-height",$this.height());}
_expandContentHorizontally.call(this);
if(o.axis!=="y" && !o.advanced.autoExpandHorizontalScroll){
mCSB_container.css("width",_contentWidth(mCSB_container));
}
d.overflowed=_overflowed.call(this);
_scrollbarVisibility.call(this);
if(o.autoDraggerLength){_setDraggerLength.call(this);}
_scrollRatio.call(this);
_bindEvents.call(this);
var to=[Math.abs(mCSB_container[0].offsetTop),Math.abs(mCSB_container[0].offsetLeft)];
if(o.axis!=="x"){
if(!d.overflowed[0]){
_resetContentPosition.call(this);
if(o.axis==="y"){
_unbindEvents.call(this);
}else if(o.axis==="yx" && d.overflowed[1]){
_scrollTo($this,to[1].toString(),{dir:"x",dur:0,overwrite:"none"});
}
}else if(mCSB_dragger[0].height()>mCSB_dragger[0].parent().height()){
_resetContentPosition.call(this);
}else{
_scrollTo($this,to[0].toString(),{dir:"y",dur:0,overwrite:"none"});
d.contentReset.y=null;
}
}
if(o.axis!=="y"){
if(!d.overflowed[1]){
_resetContentPosition.call(this);
if(o.axis==="x"){
_unbindEvents.call(this);
}else if(o.axis==="yx" && d.overflowed[0]){
_scrollTo($this,to[0].toString(),{dir:"y",dur:0,overwrite:"none"});
}
}else if(mCSB_dragger[1].width()>mCSB_dragger[1].parent().width()){
_resetContentPosition.call(this);
}else{
_scrollTo($this,to[1].toString(),{dir:"x",dur:0,overwrite:"none"});
d.contentReset.x=null;
}
}
if(cb && d){
if(cb===2 && o.callbacks.onImageLoad && typeof o.callbacks.onImageLoad==="function"){
o.callbacks.onImageLoad.call(this);
}else if(cb===3 && o.callbacks.onSelectorChange && typeof o.callbacks.onSelectorChange==="function"){
o.callbacks.onSelectorChange.call(this);
}else if(o.callbacks.onUpdate && typeof o.callbacks.onUpdate==="function"){
o.callbacks.onUpdate.call(this);
}
}
_autoUpdate.call(this);
}
});
},
scrollTo:function(val,options){
if(typeof val=="undefined" || val==null){return;}
var selector=_selector.call(this);
return $(selector).each(function(){
var $this=$(this);
if($this.data(pluginPfx)){
var d=$this.data(pluginPfx),o=d.opt,
methodDefaults={
trigger:"external",
scrollInertia:o.scrollInertia,
scrollEasing:"mcsEaseInOut",
moveDragger:false,
timeout:60,
callbacks:true,
onStart:true,
onUpdate:true,
onComplete:true
},
methodOptions=$.extend(true,{},methodDefaults,options),
to=_arr.call(this,val),dur=methodOptions.scrollInertia>0 && methodOptions.scrollInertia<17 ? 17 : methodOptions.scrollInertia;
to[0]=_to.call(this,to[0],"y");
to[1]=_to.call(this,to[1],"x");
if(methodOptions.moveDragger){
to[0]*=d.scrollRatio.y;
to[1]*=d.scrollRatio.x;
}
methodOptions.dur=_isTabHidden() ? 0 : dur; //skip animations if browser tab is hidden
setTimeout(function(){
if(to[0]!==null && typeof to[0]!=="undefined" && o.axis!=="x" && d.overflowed[0]){
methodOptions.dir="y";
methodOptions.overwrite="all";
_scrollTo($this,to[0].toString(),methodOptions);
}
if(to[1]!==null && typeof to[1]!=="undefined" && o.axis!=="y" && d.overflowed[1]){
methodOptions.dir="x";
methodOptions.overwrite="none";
_scrollTo($this,to[1].toString(),methodOptions);
}
},methodOptions.timeout);
}
});
},
stop:function(){
var selector=_selector.call(this);
return $(selector).each(function(){
var $this=$(this);
if($this.data(pluginPfx)){
_stop($this);
}
});
},
disable:function(r){
var selector=_selector.call(this);
return $(selector).each(function(){
var $this=$(this);
if($this.data(pluginPfx)){
var d=$this.data(pluginPfx);
_autoUpdate.call(this,"remove");
_unbindEvents.call(this);
if(r){_resetContentPosition.call(this);}
_scrollbarVisibility.call(this,true);
$this.addClass(classes[3]);
}
});
},
destroy:function(){
var selector=_selector.call(this);
return $(selector).each(function(){
var $this=$(this);
if($this.data(pluginPfx)){
var d=$this.data(pluginPfx),o=d.opt,
mCustomScrollBox=$("#mCSB_"+d.idx),
mCSB_container=$("#mCSB_"+d.idx+"_container"),
scrollbar=$(".mCSB_"+d.idx+"_scrollbar");
if(o.live){removeLiveTimers(o.liveSelector || $(selector).selector);}
_autoUpdate.call(this,"remove");
_unbindEvents.call(this);
_resetContentPosition.call(this);
$this.removeData(pluginPfx);
_delete(this,"mcs");
scrollbar.remove();
mCSB_container.find("img."+classes[2]).removeClass(classes[2]);
mCustomScrollBox.replaceWith(mCSB_container.contents());
$this.removeClass(pluginNS+" _"+pluginPfx+"_"+d.idx+" "+classes[6]+" "+classes[7]+" "+classes[5]+" "+classes[3]).addClass(classes[4]);
}
});
}
},
_selector=function(){
return (typeof $(this)!=="object" || $(this).length<1) ? defaultSelector : this;
},
_theme=function(obj){
var fixedSizeScrollbarThemes=["rounded","rounded-dark","rounded-dots","rounded-dots-dark"],
nonExpandedScrollbarThemes=["rounded-dots","rounded-dots-dark","3d","3d-dark","3d-thick","3d-thick-dark","inset","inset-dark","inset-2","inset-2-dark","inset-3","inset-3-dark"],
disabledScrollButtonsThemes=["minimal","minimal-dark"],
enabledAutoHideScrollbarThemes=["minimal","minimal-dark"],
scrollbarPositionOutsideThemes=["minimal","minimal-dark"];
obj.autoDraggerLength=$.inArray(obj.theme,fixedSizeScrollbarThemes) > -1 ? false : obj.autoDraggerLength;
obj.autoExpandScrollbar=$.inArray(obj.theme,nonExpandedScrollbarThemes) > -1 ? false : obj.autoExpandScrollbar;
obj.scrollButtons.enable=$.inArray(obj.theme,disabledScrollButtonsThemes) > -1 ? false : obj.scrollButtons.enable;
obj.autoHideScrollbar=$.inArray(obj.theme,enabledAutoHideScrollbarThemes) > -1 ? true : obj.autoHideScrollbar;
obj.scrollbarPosition=$.inArray(obj.theme,scrollbarPositionOutsideThemes) > -1 ? "outside" : obj.scrollbarPosition;
},
removeLiveTimers=function(selector){
if(liveTimers[selector]){
clearTimeout(liveTimers[selector]);
_delete(liveTimers,selector);
}
},
_findAxis=function(val){
return (val==="yx" || val==="xy" || val==="auto") ? "yx" : (val==="x" || val==="horizontal") ? "x" : "y";
},
_findScrollButtonsType=function(val){
return (val==="stepped" || val==="pixels" || val==="step" || val==="click") ? "stepped" : "stepless";
},
_pluginMarkup=function(){
var $this=$(this),d=$this.data(pluginPfx),o=d.opt,
expandClass=o.autoExpandScrollbar ? " "+classes[1]+"_expand" : "",
scrollbar=["<div id='mCSB_"+d.idx+"_scrollbar_vertical' class='mCSB_scrollTools mCSB_"+d.idx+"_scrollbar mCS-"+o.theme+" mCSB_scrollTools_vertical"+expandClass+"'><div class='"+classes[12]+"'><div id='mCSB_"+d.idx+"_dragger_vertical' class='mCSB_dragger' style='position:absolute;'><div class='mCSB_dragger_bar' /></div><div class='mCSB_draggerRail' /></div></div>","<div id='mCSB_"+d.idx+"_scrollbar_horizontal' class='mCSB_scrollTools mCSB_"+d.idx+"_scrollbar mCS-"+o.theme+" mCSB_scrollTools_horizontal"+expandClass+"'><div class='"+classes[12]+"'><div id='mCSB_"+d.idx+"_dragger_horizontal' class='mCSB_dragger' style='position:absolute;'><div class='mCSB_dragger_bar' /></div><div class='mCSB_draggerRail' /></div></div>"],
wrapperClass=o.axis==="yx" ? "mCSB_vertical_horizontal" : o.axis==="x" ? "mCSB_horizontal" : "mCSB_vertical",
scrollbars=o.axis==="yx" ? scrollbar[0]+scrollbar[1] : o.axis==="x" ? scrollbar[1] : scrollbar[0],
contentWrapper=o.axis==="yx" ? "<div id='mCSB_"+d.idx+"_container_wrapper' class='mCSB_container_wrapper' />" : "",
autoHideClass=o.autoHideScrollbar ? " "+classes[6] : "",
scrollbarDirClass=(o.axis!=="x" && d.langDir==="rtl") ? " "+classes[7] : "";
if(o.setWidth){$this.css("width",o.setWidth);}
if(o.setHeight){$this.css("height",o.setHeight);}
o.setLeft=(o.axis!=="y" && d.langDir==="rtl") ? "989999px" : o.setLeft;
$this.addClass(pluginNS+" _"+pluginPfx+"_"+d.idx+autoHideClass+scrollbarDirClass).wrapInner("<div id='mCSB_"+d.idx+"' class='mCustomScrollBox mCS-"+o.theme+" "+wrapperClass+"'><div id='mCSB_"+d.idx+"_container' class='mCSB_container' style='position:relative; top:"+o.setTop+"; left:"+o.setLeft+";' dir='"+d.langDir+"' /></div>");
var mCustomScrollBox=$("#mCSB_"+d.idx),
mCSB_container=$("#mCSB_"+d.idx+"_container");
if(o.axis!=="y" && !o.advanced.autoExpandHorizontalScroll){
mCSB_container.css("width",_contentWidth(mCSB_container));
}
if(o.scrollbarPosition==="outside"){
if($this.css("position")==="static"){
$this.css("position","relative");
}
$this.css("overflow","visible");
mCustomScrollBox.addClass("mCSB_outside").after(scrollbars);
}else{
mCustomScrollBox.addClass("mCSB_inside").append(scrollbars);
mCSB_container.wrap(contentWrapper);
}
_scrollButtons.call(this);
var mCSB_dragger=[$("#mCSB_"+d.idx+"_dragger_vertical"),$("#mCSB_"+d.idx+"_dragger_horizontal")];
mCSB_dragger[0].css("min-height",mCSB_dragger[0].height());
mCSB_dragger[1].css("min-width",mCSB_dragger[1].width());
},
_contentWidth=function(el){
var val=[el[0].scrollWidth,Math.max.apply(Math,el.children().map(function(){return $(this).outerWidth(true);}).get())],w=el.parent().width();
return val[0]>w ? val[0] : val[1]>w ? val[1] : "100%";
},
_expandContentHorizontally=function(){
var $this=$(this),d=$this.data(pluginPfx),o=d.opt,
mCSB_container=$("#mCSB_"+d.idx+"_container");
if(o.advanced.autoExpandHorizontalScroll && o.axis!=="y"){
mCSB_container.css({"width":"auto","min-width":0,"overflow-x":"scroll"});
var w=Math.ceil(mCSB_container[0].scrollWidth);
if(o.advanced.autoExpandHorizontalScroll===3 || (o.advanced.autoExpandHorizontalScroll!==2 && w>mCSB_container.parent().width())){
mCSB_container.css({"width":w,"min-width":"100%","overflow-x":"inherit"});
}else{
mCSB_container.css({"overflow-x":"inherit","position":"absolute"})
.wrap("<div class='mCSB_h_wrapper' style='position:relative; left:0; width:999999px;' />")
.css({
"width":(Math.ceil(mCSB_container[0].getBoundingClientRect().right+0.4)-Math.floor(mCSB_container[0].getBoundingClientRect().left)),
"min-width":"100%",
"position":"relative"
}).unwrap();
}
}
},
_scrollButtons=function(){
var $this=$(this),d=$this.data(pluginPfx),o=d.opt,
mCSB_scrollTools=$(".mCSB_"+d.idx+"_scrollbar:first"),
tabindex=!_isNumeric(o.scrollButtons.tabindex) ? "" : "tabindex='"+o.scrollButtons.tabindex+"'",
btnHTML=[
"<a href='#' class='"+classes[13]+"' "+tabindex+" />",
"<a href='#' class='"+classes[14]+"' "+tabindex+" />",
"<a href='#' class='"+classes[15]+"' "+tabindex+" />",
"<a href='#' class='"+classes[16]+"' "+tabindex+" />"
],
btn=[(o.axis==="x" ? btnHTML[2] : btnHTML[0]),(o.axis==="x" ? btnHTML[3] : btnHTML[1]),btnHTML[2],btnHTML[3]];
if(o.scrollButtons.enable){
mCSB_scrollTools.prepend(btn[0]).append(btn[1]).next(".mCSB_scrollTools").prepend(btn[2]).append(btn[3]);
}
},
_setDraggerLength=function(){
var $this=$(this),d=$this.data(pluginPfx),
mCustomScrollBox=$("#mCSB_"+d.idx),
mCSB_container=$("#mCSB_"+d.idx+"_container"),
mCSB_dragger=[$("#mCSB_"+d.idx+"_dragger_vertical"),$("#mCSB_"+d.idx+"_dragger_horizontal")],
ratio=[mCustomScrollBox.height()/mCSB_container.outerHeight(false),mCustomScrollBox.width()/mCSB_container.outerWidth(false)],
l=[
parseInt(mCSB_dragger[0].css("min-height")),Math.round(ratio[0]*mCSB_dragger[0].parent().height()),
parseInt(mCSB_dragger[1].css("min-width")),Math.round(ratio[1]*mCSB_dragger[1].parent().width())
],
h=oldIE && (l[1]<l[0]) ? l[0] : l[1],w=oldIE && (l[3]<l[2]) ? l[2] : l[3];
mCSB_dragger[0].css({
"height":h,"max-height":(mCSB_dragger[0].parent().height()-10)
}).find(".mCSB_dragger_bar").css({"line-height":l[0]+"px"});
mCSB_dragger[1].css({
"width":w,"max-width":(mCSB_dragger[1].parent().width()-10)
});
},
_scrollRatio=function(){
var $this=$(this),d=$this.data(pluginPfx),
mCustomScrollBox=$("#mCSB_"+d.idx),
mCSB_container=$("#mCSB_"+d.idx+"_container"),
mCSB_dragger=[$("#mCSB_"+d.idx+"_dragger_vertical"),$("#mCSB_"+d.idx+"_dragger_horizontal")],
scrollAmount=[mCSB_container.outerHeight(false)-mCustomScrollBox.height(),mCSB_container.outerWidth(false)-mCustomScrollBox.width()],
ratio=[
scrollAmount[0]/(mCSB_dragger[0].parent().height()-mCSB_dragger[0].height()),
scrollAmount[1]/(mCSB_dragger[1].parent().width()-mCSB_dragger[1].width())
];
d.scrollRatio={y:ratio[0],x:ratio[1]};
},
_onDragClasses=function(el,action,xpnd){
var expandClass=xpnd ? classes[0]+"_expanded" : "",
scrollbar=el.closest(".mCSB_scrollTools");
if(action==="active"){
el.toggleClass(classes[0]+" "+expandClass); scrollbar.toggleClass(classes[1]);
el[0]._draggable=el[0]._draggable ? 0 : 1;
}else{
if(!el[0]._draggable){
if(action==="hide"){
el.removeClass(classes[0]); scrollbar.removeClass(classes[1]);
}else{
el.addClass(classes[0]); scrollbar.addClass(classes[1]);
}
}
}
},
_overflowed=function(){
var $this=$(this),d=$this.data(pluginPfx),
mCustomScrollBox=$("#mCSB_"+d.idx),
mCSB_container=$("#mCSB_"+d.idx+"_container"),
contentHeight=d.overflowed==null ? mCSB_container.height() : mCSB_container.outerHeight(false),
contentWidth=d.overflowed==null ? mCSB_container.width() : mCSB_container.outerWidth(false),
h=mCSB_container[0].scrollHeight,w=mCSB_container[0].scrollWidth;
if(h>contentHeight){contentHeight=h;}
if(w>contentWidth){contentWidth=w;}
return [contentHeight>mCustomScrollBox.height(),contentWidth>mCustomScrollBox.width()];
},
_resetContentPosition=function(){
var $this=$(this),d=$this.data(pluginPfx),o=d.opt,
mCustomScrollBox=$("#mCSB_"+d.idx),
mCSB_container=$("#mCSB_"+d.idx+"_container"),
mCSB_dragger=[$("#mCSB_"+d.idx+"_dragger_vertical"),$("#mCSB_"+d.idx+"_dragger_horizontal")];
_stop($this);
if((o.axis!=="x" && !d.overflowed[0]) || (o.axis==="y" && d.overflowed[0])){
mCSB_dragger[0].add(mCSB_container).css("top",0);
_scrollTo($this,"_resetY");
}
if((o.axis!=="y" && !d.overflowed[1]) || (o.axis==="x" && d.overflowed[1])){
var cx=dx=0;
if(d.langDir==="rtl"){
cx=mCustomScrollBox.width()-mCSB_container.outerWidth(false);
dx=Math.abs(cx/d.scrollRatio.x);
}
mCSB_container.css("left",cx);
mCSB_dragger[1].css("left",dx);
_scrollTo($this,"_resetX");
}
},
_bindEvents=function(){
var $this=$(this),d=$this.data(pluginPfx),o=d.opt;
if(!d.bindEvents){
_draggable.call(this);
if(o.contentTouchScroll){_contentDraggable.call(this);}
_selectable.call(this);
if(o.mouseWheel.enable){
function _mwt(){
mousewheelTimeout=setTimeout(function(){
if(!$.event.special.mousewheel){
_mwt();
}else{
clearTimeout(mousewheelTimeout);
_mousewheel.call($this[0]);
}
},100);
}
var mousewheelTimeout;
_mwt();
}
_draggerRail.call(this);
_wrapperScroll.call(this);
if(o.advanced.autoScrollOnFocus){_focus.call(this);}
if(o.scrollButtons.enable){_buttons.call(this);}
if(o.keyboard.enable){_keyboard.call(this);}
d.bindEvents=true;
}
},
_unbindEvents=function(){
var $this=$(this),d=$this.data(pluginPfx),o=d.opt,
namespace=pluginPfx+"_"+d.idx,
sb=".mCSB_"+d.idx+"_scrollbar",
sel=$("#mCSB_"+d.idx+",#mCSB_"+d.idx+"_container,#mCSB_"+d.idx+"_container_wrapper,"+sb+" ."+classes[12]+",#mCSB_"+d.idx+"_dragger_vertical,#mCSB_"+d.idx+"_dragger_horizontal,"+sb+">a"),
mCSB_container=$("#mCSB_"+d.idx+"_container");
if(o.advanced.releaseDraggableSelectors){sel.add($(o.advanced.releaseDraggableSelectors));}
if(o.advanced.extraDraggableSelectors){sel.add($(o.advanced.extraDraggableSelectors));}
if(d.bindEvents){
$(document).add($(!_canAccessIFrame() || top.document)).unbind("."+namespace);
sel.each(function(){
$(this).unbind("."+namespace);
});
clearTimeout($this[0]._focusTimeout); _delete($this[0],"_focusTimeout");
clearTimeout(d.sequential.step); _delete(d.sequential,"step");
clearTimeout(mCSB_container[0].onCompleteTimeout); _delete(mCSB_container[0],"onCompleteTimeout");
d.bindEvents=false;
}
},
_scrollbarVisibility=function(disabled){
var $this=$(this),d=$this.data(pluginPfx),o=d.opt,
contentWrapper=$("#mCSB_"+d.idx+"_container_wrapper"),
content=contentWrapper.length ? contentWrapper : $("#mCSB_"+d.idx+"_container"),
scrollbar=[$("#mCSB_"+d.idx+"_scrollbar_vertical"),$("#mCSB_"+d.idx+"_scrollbar_horizontal")],
mCSB_dragger=[scrollbar[0].find(".mCSB_dragger"),scrollbar[1].find(".mCSB_dragger")];
if(o.axis!=="x"){
if(d.overflowed[0] && !disabled){
scrollbar[0].add(mCSB_dragger[0]).add(scrollbar[0].children("a")).css("display","block");
content.removeClass(classes[8]+" "+classes[10]);
}else{
if(o.alwaysShowScrollbar){
if(o.alwaysShowScrollbar!==2){mCSB_dragger[0].css("display","none");}
content.removeClass(classes[10]);
}else{
scrollbar[0].css("display","none");
content.addClass(classes[10]);
}
content.addClass(classes[8]);
}
}
if(o.axis!=="y"){
if(d.overflowed[1] && !disabled){
scrollbar[1].add(mCSB_dragger[1]).add(scrollbar[1].children("a")).css("display","block");
content.removeClass(classes[9]+" "+classes[11]);
}else{
if(o.alwaysShowScrollbar){
if(o.alwaysShowScrollbar!==2){mCSB_dragger[1].css("display","none");}
content.removeClass(classes[11]);
}else{
scrollbar[1].css("display","none");
content.addClass(classes[11]);
}
content.addClass(classes[9]);
}
}
if(!d.overflowed[0] && !d.overflowed[1]){
$this.addClass(classes[5]);
}else{
$this.removeClass(classes[5]);
}
},
_coordinates=function(e){
var t=e.type,o=e.target.ownerDocument!==document && frameElement!==null ? [$(frameElement).offset().top,$(frameElement).offset().left] : null,
io=_canAccessIFrame() && e.target.ownerDocument!==top.document && frameElement!==null ? [$(e.view.frameElement).offset().top,$(e.view.frameElement).offset().left] : [0,0];
switch(t){
case "pointerdown": case "MSPointerDown": case "pointermove": case "MSPointerMove": case "pointerup": case "MSPointerUp":
return o ? [e.originalEvent.pageY-o[0]+io[0],e.originalEvent.pageX-o[1]+io[1],false] : [e.originalEvent.pageY,e.originalEvent.pageX,false];
break;
case "touchstart": case "touchmove": case "touchend":
var touch=e.originalEvent.touches[0] || e.originalEvent.changedTouches[0],
touches=e.originalEvent.touches.length || e.originalEvent.changedTouches.length;
return e.target.ownerDocument!==document ? [touch.screenY,touch.screenX,touches>1] : [touch.pageY,touch.pageX,touches>1];
break;
default:
return o ? [e.pageY-o[0]+io[0],e.pageX-o[1]+io[1],false] : [e.pageY,e.pageX,false];
}
},
_draggable=function(){
var $this=$(this),d=$this.data(pluginPfx),o=d.opt,
namespace=pluginPfx+"_"+d.idx,
draggerId=["mCSB_"+d.idx+"_dragger_vertical","mCSB_"+d.idx+"_dragger_horizontal"],
mCSB_container=$("#mCSB_"+d.idx+"_container"),
mCSB_dragger=$("#"+draggerId[0]+",#"+draggerId[1]),
draggable,dragY,dragX,
rds=o.advanced.releaseDraggableSelectors ? mCSB_dragger.add($(o.advanced.releaseDraggableSelectors)) : mCSB_dragger,
eds=o.advanced.extraDraggableSelectors ? $(!_canAccessIFrame() || top.document).add($(o.advanced.extraDraggableSelectors)) : $(!_canAccessIFrame() || top.document);
mCSB_dragger.bind("contextmenu."+namespace,function(e){
e.preventDefault(); //prevent right click
}).bind("mousedown."+namespace+" touchstart."+namespace+" pointerdown."+namespace+" MSPointerDown."+namespace,function(e){
e.stopImmediatePropagation();
e.preventDefault();
if(!_mouseBtnLeft(e)){return;}
touchActive=true;
if(oldIE){document.onselectstart=function(){return false;}}
_iframe.call(mCSB_container,false);
_stop($this);
draggable=$(this);
var offset=draggable.offset(),y=_coordinates(e)[0]-offset.top,x=_coordinates(e)[1]-offset.left,
h=draggable.height()+offset.top,w=draggable.width()+offset.left;
if(y<h && y>0 && x<w && x>0){
dragY=y;
dragX=x;
}
_onDragClasses(draggable,"active",o.autoExpandScrollbar);
}).bind("touchmove."+namespace,function(e){
e.stopImmediatePropagation();
e.preventDefault();
var offset=draggable.offset(),y=_coordinates(e)[0]-offset.top,x=_coordinates(e)[1]-offset.left;
_drag(dragY,dragX,y,x);
});
$(document).add(eds).bind("mousemove."+namespace+" pointermove."+namespace+" MSPointerMove."+namespace,function(e){
if(draggable){
var offset=draggable.offset(),y=_coordinates(e)[0]-offset.top,x=_coordinates(e)[1]-offset.left;
if(dragY===y && dragX===x){return;}
_drag(dragY,dragX,y,x);
}
}).add(rds).bind("mouseup."+namespace+" touchend."+namespace+" pointerup."+namespace+" MSPointerUp."+namespace,function(e){
if(draggable){
_onDragClasses(draggable,"active",o.autoExpandScrollbar);
draggable=null;
}
touchActive=false;
if(oldIE){document.onselectstart=null;}
_iframe.call(mCSB_container,true);
});
function _drag(dragY,dragX,y,x){
mCSB_container[0].idleTimer=o.scrollInertia<233 ? 250 : 0;
if(draggable.attr("id")===draggerId[1]){
var dir="x",to=((draggable[0].offsetLeft-dragX)+x)*d.scrollRatio.x;
}else{
var dir="y",to=((draggable[0].offsetTop-dragY)+y)*d.scrollRatio.y;
}
_scrollTo($this,to.toString(),{dir:dir,drag:true});
}
},
_contentDraggable=function(){
var $this=$(this),d=$this.data(pluginPfx),o=d.opt,
namespace=pluginPfx+"_"+d.idx,
mCustomScrollBox=$("#mCSB_"+d.idx),
mCSB_container=$("#mCSB_"+d.idx+"_container"),
mCSB_dragger=[$("#mCSB_"+d.idx+"_dragger_vertical"),$("#mCSB_"+d.idx+"_dragger_horizontal")],
draggable,dragY,dragX,touchStartY,touchStartX,touchMoveY=[],touchMoveX=[],startTime,runningTime,endTime,distance,speed,amount,
durA=0,durB,overwrite=o.axis==="yx" ? "none" : "all",touchIntent=[],touchDrag,docDrag,
iframe=mCSB_container.find("iframe"),
events=[
"touchstart."+namespace+" pointerdown."+namespace+" MSPointerDown."+namespace, //start
"touchmove."+namespace+" pointermove."+namespace+" MSPointerMove."+namespace, //move
"touchend."+namespace+" pointerup."+namespace+" MSPointerUp."+namespace //end
],
touchAction=document.body.style.touchAction!==undefined && document.body.style.touchAction!=="";
mCSB_container.bind(events[0],function(e){
_onTouchstart(e);
}).bind(events[1],function(e){
_onTouchmove(e);
});
mCustomScrollBox.bind(events[0],function(e){
_onTouchstart2(e);
}).bind(events[2],function(e){
_onTouchend(e);
});
if(iframe.length){
iframe.each(function(){
$(this).bind("load",function(){
if(_canAccessIFrame(this)){
$(this.contentDocument || this.contentWindow.document).bind(events[0],function(e){
_onTouchstart(e);
_onTouchstart2(e);
}).bind(events[1],function(e){
_onTouchmove(e);
}).bind(events[2],function(e){
_onTouchend(e);
});
}
});
});
}
function _onTouchstart(e){
if(!_pointerTouch(e) || touchActive || _coordinates(e)[2]){touchable=0; return;}
touchable=1; touchDrag=0; docDrag=0; draggable=1;
$this.removeClass("mCS_touch_action");
var offset=mCSB_container.offset();
dragY=_coordinates(e)[0]-offset.top;
dragX=_coordinates(e)[1]-offset.left;
touchIntent=[_coordinates(e)[0],_coordinates(e)[1]];
}
function _onTouchmove(e){
if(!_pointerTouch(e) || touchActive || _coordinates(e)[2]){return;}
if(!o.documentTouchScroll){e.preventDefault();}
e.stopImmediatePropagation();
if(docDrag && !touchDrag){return;}
if(draggable){
runningTime=_getTime();
var offset=mCustomScrollBox.offset(),y=_coordinates(e)[0]-offset.top,x=_coordinates(e)[1]-offset.left,
easing="mcsLinearOut";
touchMoveY.push(y);
touchMoveX.push(x);
touchIntent[2]=Math.abs(_coordinates(e)[0]-touchIntent[0]); touchIntent[3]=Math.abs(_coordinates(e)[1]-touchIntent[1]);
if(d.overflowed[0]){
var limit=mCSB_dragger[0].parent().height()-mCSB_dragger[0].height(),
prevent=((dragY-y)>0 && (y-dragY)>-(limit*d.scrollRatio.y) && (touchIntent[3]*2<touchIntent[2] || o.axis==="yx"));
}
if(d.overflowed[1]){
var limitX=mCSB_dragger[1].parent().width()-mCSB_dragger[1].width(),
preventX=((dragX-x)>0 && (x-dragX)>-(limitX*d.scrollRatio.x) && (touchIntent[2]*2<touchIntent[3] || o.axis==="yx"));
}
if(prevent || preventX){
if(!touchAction){e.preventDefault();}
touchDrag=1;
}else{
docDrag=1;
$this.addClass("mCS_touch_action");
}
if(touchAction){e.preventDefault();}
amount=o.axis==="yx" ? [(dragY-y),(dragX-x)] : o.axis==="x" ? [null,(dragX-x)] : [(dragY-y),null];
mCSB_container[0].idleTimer=250;
if(d.overflowed[0]){_drag(amount[0],durA,easing,"y","all",true);}
if(d.overflowed[1]){_drag(amount[1],durA,easing,"x",overwrite,true);}
}
}
function _onTouchstart2(e){
if(!_pointerTouch(e) || touchActive || _coordinates(e)[2]){touchable=0; return;}
touchable=1;
e.stopImmediatePropagation();
_stop($this);
startTime=_getTime();
var offset=mCustomScrollBox.offset();
touchStartY=_coordinates(e)[0]-offset.top;
touchStartX=_coordinates(e)[1]-offset.left;
touchMoveY=[]; touchMoveX=[];
}
function _onTouchend(e){
if(!_pointerTouch(e) || touchActive || _coordinates(e)[2]){return;}
draggable=0;
e.stopImmediatePropagation();
touchDrag=0; docDrag=0;
endTime=_getTime();
var offset=mCustomScrollBox.offset(),y=_coordinates(e)[0]-offset.top,x=_coordinates(e)[1]-offset.left;
if((endTime-runningTime)>30){return;}
speed=1000/(endTime-startTime);
var easing="mcsEaseOut",slow=speed<2.5,
diff=slow ? [touchMoveY[touchMoveY.length-2],touchMoveX[touchMoveX.length-2]] : [0,0];
distance=slow ? [(y-diff[0]),(x-diff[1])] : [y-touchStartY,x-touchStartX];
var absDistance=[Math.abs(distance[0]),Math.abs(distance[1])];
speed=slow ? [Math.abs(distance[0]/4),Math.abs(distance[1]/4)] : [speed,speed];
var a=[
Math.abs(mCSB_container[0].offsetTop)-(distance[0]*_m((absDistance[0]/speed[0]),speed[0])),
Math.abs(mCSB_container[0].offsetLeft)-(distance[1]*_m((absDistance[1]/speed[1]),speed[1]))
];
amount=o.axis==="yx" ? [a[0],a[1]] : o.axis==="x" ? [null,a[1]] : [a[0],null];
durB=[(absDistance[0]*4)+o.scrollInertia,(absDistance[1]*4)+o.scrollInertia];
var md=parseInt(o.contentTouchScroll) || 0;
amount[0]=absDistance[0]>md ? amount[0] : 0;
amount[1]=absDistance[1]>md ? amount[1] : 0;
if(d.overflowed[0]){_drag(amount[0],durB[0],easing,"y",overwrite,false);}
if(d.overflowed[1]){_drag(amount[1],durB[1],easing,"x",overwrite,false);}
}
function _m(ds,s){
var r=[s*1.5,s*2,s/1.5,s/2];
if(ds>90){
return s>4 ? r[0] : r[3];
}else if(ds>60){
return s>3 ? r[3] : r[2];
}else if(ds>30){
return s>8 ? r[1] : s>6 ? r[0] : s>4 ? s : r[2];
}else{
return s>8 ? s : r[3];
}
}
function _drag(amount,dur,easing,dir,overwrite,drag){
if(!amount){return;}
_scrollTo($this,amount.toString(),{dur:dur,scrollEasing:easing,dir:dir,overwrite:overwrite,drag:drag});
}
},
_selectable=function(){
var $this=$(this),d=$this.data(pluginPfx),o=d.opt,seq=d.sequential,
namespace=pluginPfx+"_"+d.idx,
mCSB_container=$("#mCSB_"+d.idx+"_container"),
wrapper=mCSB_container.parent(),
action;
mCSB_container.bind("mousedown."+namespace,function(e){
if(touchable){return;}
if(!action){action=1; touchActive=true;}
}).add(document).bind("mousemove."+namespace,function(e){
if(!touchable && action && _sel()){
var offset=mCSB_container.offset(),
y=_coordinates(e)[0]-offset.top+mCSB_container[0].offsetTop,x=_coordinates(e)[1]-offset.left+mCSB_container[0].offsetLeft;
if(y>0 && y<wrapper.height() && x>0 && x<wrapper.width()){
if(seq.step){_seq("off",null,"stepped");}
}else{
if(o.axis!=="x" && d.overflowed[0]){
if(y<0){
_seq("on",38);
}else if(y>wrapper.height()){
_seq("on",40);
}
}
if(o.axis!=="y" && d.overflowed[1]){
if(x<0){
_seq("on",37);
}else if(x>wrapper.width()){
_seq("on",39);
}
}
}
}
}).bind("mouseup."+namespace+" dragend."+namespace,function(e){
if(touchable){return;}
if(action){action=0; _seq("off",null);}
touchActive=false;
});
function _sel(){
return 	window.getSelection ? window.getSelection().toString() :
document.selection && document.selection.type!="Control" ? document.selection.createRange().text : 0;
}
function _seq(a,c,s){
seq.type=s && action ? "stepped" : "stepless";
seq.scrollAmount=10;
_sequentialScroll($this,a,c,"mcsLinearOut",s ? 60 : null);
}
},
_mousewheel=function(){
if(!$(this).data(pluginPfx)){return;}
var $this=$(this),d=$this.data(pluginPfx),o=d.opt,
namespace=pluginPfx+"_"+d.idx,
mCustomScrollBox=$("#mCSB_"+d.idx),
mCSB_dragger=[$("#mCSB_"+d.idx+"_dragger_vertical"),$("#mCSB_"+d.idx+"_dragger_horizontal")],
iframe=$("#mCSB_"+d.idx+"_container").find("iframe");
if(iframe.length){
iframe.each(function(){
$(this).bind("load",function(){
if(_canAccessIFrame(this)){
$(this.contentDocument || this.contentWindow.document).bind("mousewheel."+namespace,function(e,delta){
_onMousewheel(e,delta);
});
}
});
});
}
mCustomScrollBox.bind("mousewheel."+namespace,function(e,delta){
_onMousewheel(e,delta);
});
function _onMousewheel(e,delta){
_stop($this);
if(_disableMousewheel($this,e.target)){return;}
var deltaFactor=o.mouseWheel.deltaFactor!=="auto" ? parseInt(o.mouseWheel.deltaFactor) : (oldIE && e.deltaFactor<100) ? 100 : e.deltaFactor || 100,
dur=o.scrollInertia;
if(o.axis==="x" || o.mouseWheel.axis==="x"){
var dir="x",
px=[Math.round(deltaFactor*d.scrollRatio.x),parseInt(o.mouseWheel.scrollAmount)],
amount=o.mouseWheel.scrollAmount!=="auto" ? px[1] : px[0]>=mCustomScrollBox.width() ? mCustomScrollBox.width()*0.9 : px[0],
contentPos=Math.abs($("#mCSB_"+d.idx+"_container")[0].offsetLeft),
draggerPos=mCSB_dragger[1][0].offsetLeft,
limit=mCSB_dragger[1].parent().width()-mCSB_dragger[1].width(),
dlt=o.mouseWheel.axis==="y" ? (e.deltaY || delta) : e.deltaX;
}else{
var dir="y",
px=[Math.round(deltaFactor*d.scrollRatio.y),parseInt(o.mouseWheel.scrollAmount)],
amount=o.mouseWheel.scrollAmount!=="auto" ? px[1] : px[0]>=mCustomScrollBox.height() ? mCustomScrollBox.height()*0.9 : px[0],
contentPos=Math.abs($("#mCSB_"+d.idx+"_container")[0].offsetTop),
draggerPos=mCSB_dragger[0][0].offsetTop,
limit=mCSB_dragger[0].parent().height()-mCSB_dragger[0].height(),
dlt=e.deltaY || delta;
}
if((dir==="y" && !d.overflowed[0]) || (dir==="x" && !d.overflowed[1])){return;}
if(o.mouseWheel.invert || e.webkitDirectionInvertedFromDevice){dlt=-dlt;}
if(o.mouseWheel.normalizeDelta){dlt=dlt<0 ? -1 : 1;}
if((dlt>0 && draggerPos!==0) || (dlt<0 && draggerPos!==limit) || o.mouseWheel.preventDefault){
e.stopImmediatePropagation();
e.preventDefault();
}
if(e.deltaFactor<5 && !o.mouseWheel.normalizeDelta){
amount=e.deltaFactor; dur=17;
}
_scrollTo($this,(contentPos-(dlt*amount)).toString(),{dir:dir,dur:dur});
}
},
_canAccessIFrameCache=new Object(),
_canAccessIFrame=function(iframe){
var result=false,cacheKey=false,html=null;
if(iframe===undefined){
cacheKey="#empty";
}else if($(iframe).attr("id")!==undefined){
cacheKey=$(iframe).attr("id");
}
if(cacheKey!==false && _canAccessIFrameCache[cacheKey]!==undefined){
return _canAccessIFrameCache[cacheKey];
}
if(!iframe){
try{
var doc=top.document;
html=doc.body.innerHTML;
}catch(err){/* do nothing */}
result=(html!==null);
}else{
try{
var doc=iframe.contentDocument || iframe.contentWindow.document;
html=doc.body.innerHTML;
}catch(err){/* do nothing */}
result=(html!==null);
}
if(cacheKey!==false){_canAccessIFrameCache[cacheKey]=result;}
return result;
},
_iframe=function(evt){
var el=this.find("iframe");
if(!el.length){return;}
var val=!evt ? "none" : "auto";
el.css("pointer-events",val);
},
_disableMousewheel=function(el,target){
var tag=target.nodeName.toLowerCase(),
tags=el.data(pluginPfx).opt.mouseWheel.disableOver,
focusTags=["select","textarea"];
return $.inArray(tag,tags) > -1 && !($.inArray(tag,focusTags) > -1 && !$(target).is(":focus"));
},
_draggerRail=function(){
var $this=$(this),d=$this.data(pluginPfx),
namespace=pluginPfx+"_"+d.idx,
mCSB_container=$("#mCSB_"+d.idx+"_container"),
wrapper=mCSB_container.parent(),
mCSB_draggerContainer=$(".mCSB_"+d.idx+"_scrollbar ."+classes[12]),
clickable;
mCSB_draggerContainer.bind("mousedown."+namespace+" touchstart."+namespace+" pointerdown."+namespace+" MSPointerDown."+namespace,function(e){
touchActive=true;
if(!$(e.target).hasClass("mCSB_dragger")){clickable=1;}
}).bind("touchend."+namespace+" pointerup."+namespace+" MSPointerUp."+namespace,function(e){
touchActive=false;
}).bind("click."+namespace,function(e){
if(!clickable){return;}
clickable=0;
if($(e.target).hasClass(classes[12]) || $(e.target).hasClass("mCSB_draggerRail")){
_stop($this);
var el=$(this),mCSB_dragger=el.find(".mCSB_dragger");
if(el.parent(".mCSB_scrollTools_horizontal").length>0){
if(!d.overflowed[1]){return;}
var dir="x",
clickDir=e.pageX>mCSB_dragger.offset().left ? -1 : 1,
to=Math.abs(mCSB_container[0].offsetLeft)-(clickDir*(wrapper.width()*0.9));
}else{
if(!d.overflowed[0]){return;}
var dir="y",
clickDir=e.pageY>mCSB_dragger.offset().top ? -1 : 1,
to=Math.abs(mCSB_container[0].offsetTop)-(clickDir*(wrapper.height()*0.9));
}
_scrollTo($this,to.toString(),{dir:dir,scrollEasing:"mcsEaseInOut"});
}
});
},
_focus=function(){
var $this=$(this),d=$this.data(pluginPfx),o=d.opt,
namespace=pluginPfx+"_"+d.idx,
mCSB_container=$("#mCSB_"+d.idx+"_container"),
wrapper=mCSB_container.parent();
mCSB_container.bind("focusin."+namespace,function(e){
var el=$(document.activeElement),
nested=mCSB_container.find(".mCustomScrollBox").length,
dur=0;
if(!el.is(o.advanced.autoScrollOnFocus)){return;}
_stop($this);
clearTimeout($this[0]._focusTimeout);
$this[0]._focusTimer=nested ? (dur+17)*nested : 0;
$this[0]._focusTimeout=setTimeout(function(){
var	to=[_childPos(el)[0],_childPos(el)[1]],
contentPos=[mCSB_container[0].offsetTop,mCSB_container[0].offsetLeft],
isVisible=[
(contentPos[0]+to[0]>=0 && contentPos[0]+to[0]<wrapper.height()-el.outerHeight(false)),
(contentPos[1]+to[1]>=0 && contentPos[0]+to[1]<wrapper.width()-el.outerWidth(false))
],
overwrite=(o.axis==="yx" && !isVisible[0] && !isVisible[1]) ? "none" : "all";
if(o.axis!=="x" && !isVisible[0]){
_scrollTo($this,to[0].toString(),{dir:"y",scrollEasing:"mcsEaseInOut",overwrite:overwrite,dur:dur});
}
if(o.axis!=="y" && !isVisible[1]){
_scrollTo($this,to[1].toString(),{dir:"x",scrollEasing:"mcsEaseInOut",overwrite:overwrite,dur:dur});
}
},$this[0]._focusTimer);
});
},
_wrapperScroll=function(){
var $this=$(this),d=$this.data(pluginPfx),
namespace=pluginPfx+"_"+d.idx,
wrapper=$("#mCSB_"+d.idx+"_container").parent();
wrapper.bind("scroll."+namespace,function(e){
if(wrapper.scrollTop()!==0 || wrapper.scrollLeft()!==0){
$(".mCSB_"+d.idx+"_scrollbar").css("visibility","hidden");
}
});
},
_buttons=function(){
var $this=$(this),d=$this.data(pluginPfx),o=d.opt,seq=d.sequential,
namespace=pluginPfx+"_"+d.idx,
sel=".mCSB_"+d.idx+"_scrollbar",
btn=$(sel+">a");
btn.bind("contextmenu."+namespace,function(e){
e.preventDefault(); //prevent right click
}).bind("mousedown."+namespace+" touchstart."+namespace+" pointerdown."+namespace+" MSPointerDown."+namespace+" mouseup."+namespace+" touchend."+namespace+" pointerup."+namespace+" MSPointerUp."+namespace+" mouseout."+namespace+" pointerout."+namespace+" MSPointerOut."+namespace+" click."+namespace,function(e){
e.preventDefault();
if(!_mouseBtnLeft(e)){return;}
var btnClass=$(this).attr("class");
seq.type=o.scrollButtons.scrollType;
switch(e.type){
case "mousedown": case "touchstart": case "pointerdown": case "MSPointerDown":
if(seq.type==="stepped"){return;}
touchActive=true;
d.tweenRunning=false;
_seq("on",btnClass);
break;
case "mouseup": case "touchend": case "pointerup": case "MSPointerUp":
case "mouseout": case "pointerout": case "MSPointerOut":
if(seq.type==="stepped"){return;}
touchActive=false;
if(seq.dir){_seq("off",btnClass);}
break;
case "click":
if(seq.type!=="stepped" || d.tweenRunning){return;}
_seq("on",btnClass);
break;
}
function _seq(a,c){
seq.scrollAmount=o.scrollButtons.scrollAmount;
_sequentialScroll($this,a,c);
}
});
},
_keyboard=function(){
var $this=$(this),d=$this.data(pluginPfx),o=d.opt,seq=d.sequential,
namespace=pluginPfx+"_"+d.idx,
mCustomScrollBox=$("#mCSB_"+d.idx),
mCSB_container=$("#mCSB_"+d.idx+"_container"),
wrapper=mCSB_container.parent(),
editables="input,textarea,select,datalist,keygen,[contenteditable='true']",
iframe=mCSB_container.find("iframe"),
events=["blur."+namespace+" keydown."+namespace+" keyup."+namespace];
if(iframe.length){
iframe.each(function(){
$(this).bind("load",function(){
if(_canAccessIFrame(this)){
$(this.contentDocument || this.contentWindow.document).bind(events[0],function(e){
_onKeyboard(e);
});
}
});
});
}
mCustomScrollBox.attr("tabindex","0").bind(events[0],function(e){
_onKeyboard(e);
});
function _onKeyboard(e){
switch(e.type){
case "blur":
if(d.tweenRunning && seq.dir){_seq("off",null);}
break;
case "keydown": case "keyup":
var code=e.keyCode ? e.keyCode : e.which,action="on";
if((o.axis!=="x" && (code===38 || code===40)) || (o.axis!=="y" && (code===37 || code===39))){
if(((code===38 || code===40) && !d.overflowed[0]) || ((code===37 || code===39) && !d.overflowed[1])){return;}
if(e.type==="keyup"){action="off";}
if(!$(document.activeElement).is(editables)){
e.preventDefault();
e.stopImmediatePropagation();
_seq(action,code);
}
}else if(code===33 || code===34){
if(d.overflowed[0] || d.overflowed[1]){
e.preventDefault();
e.stopImmediatePropagation();
}
if(e.type==="keyup"){
_stop($this);
var keyboardDir=code===34 ? -1 : 1;
if(o.axis==="x" || (o.axis==="yx" && d.overflowed[1] && !d.overflowed[0])){
var dir="x",to=Math.abs(mCSB_container[0].offsetLeft)-(keyboardDir*(wrapper.width()*0.9));
}else{
var dir="y",to=Math.abs(mCSB_container[0].offsetTop)-(keyboardDir*(wrapper.height()*0.9));
}
_scrollTo($this,to.toString(),{dir:dir,scrollEasing:"mcsEaseInOut"});
}
}else if(code===35 || code===36){
if(!$(document.activeElement).is(editables)){
if(d.overflowed[0] || d.overflowed[1]){
e.preventDefault();
e.stopImmediatePropagation();
}
if(e.type==="keyup"){
if(o.axis==="x" || (o.axis==="yx" && d.overflowed[1] && !d.overflowed[0])){
var dir="x",to=code===35 ? Math.abs(wrapper.width()-mCSB_container.outerWidth(false)) : 0;
}else{
var dir="y",to=code===35 ? Math.abs(wrapper.height()-mCSB_container.outerHeight(false)) : 0;
}
_scrollTo($this,to.toString(),{dir:dir,scrollEasing:"mcsEaseInOut"});
}
}
}
break;
}
function _seq(a,c){
seq.type=o.keyboard.scrollType;
seq.scrollAmount=o.keyboard.scrollAmount;
if(seq.type==="stepped" && d.tweenRunning){return;}
_sequentialScroll($this,a,c);
}
}
},
_sequentialScroll=function(el,action,trigger,e,s){
var d=el.data(pluginPfx),o=d.opt,seq=d.sequential,
mCSB_container=$("#mCSB_"+d.idx+"_container"),
once=seq.type==="stepped" ? true : false,
steplessSpeed=o.scrollInertia < 26 ? 26 : o.scrollInertia,
steppedSpeed=o.scrollInertia < 1 ? 17 : o.scrollInertia;
switch(action){
case "on":
seq.dir=[
(trigger===classes[16] || trigger===classes[15] || trigger===39 || trigger===37 ? "x" : "y"),
(trigger===classes[13] || trigger===classes[15] || trigger===38 || trigger===37 ? -1 : 1)
];
_stop(el);
if(_isNumeric(trigger) && seq.type==="stepped"){return;}
_on(once);
break;
case "off":
_off();
if(once || (d.tweenRunning && seq.dir)){
_on(true);
}
break;
}
function _on(once){
if(o.snapAmount){seq.scrollAmount=!(o.snapAmount instanceof Array) ? o.snapAmount : seq.dir[0]==="x" ? o.snapAmount[1] : o.snapAmount[0];}
var c=seq.type!=="stepped",
t=s ? s : !once ? 1000/60 : c ? steplessSpeed/1.5 : steppedSpeed,
m=!once ? 2.5 : c ? 7.5 : 40,
contentPos=[Math.abs(mCSB_container[0].offsetTop),Math.abs(mCSB_container[0].offsetLeft)],
ratio=[d.scrollRatio.y>10 ? 10 : d.scrollRatio.y,d.scrollRatio.x>10 ? 10 : d.scrollRatio.x],
amount=seq.dir[0]==="x" ? contentPos[1]+(seq.dir[1]*(ratio[1]*m)) : contentPos[0]+(seq.dir[1]*(ratio[0]*m)),
px=seq.dir[0]==="x" ? contentPos[1]+(seq.dir[1]*parseInt(seq.scrollAmount)) : contentPos[0]+(seq.dir[1]*parseInt(seq.scrollAmount)),
to=seq.scrollAmount!=="auto" ? px : amount,
easing=e ? e : !once ? "mcsLinear" : c ? "mcsLinearOut" : "mcsEaseInOut",
onComplete=!once ? false : true;
if(once && t<17){
to=seq.dir[0]==="x" ? contentPos[1] : contentPos[0];
}
_scrollTo(el,to.toString(),{dir:seq.dir[0],scrollEasing:easing,dur:t,onComplete:onComplete});
if(once){
seq.dir=false;
return;
}
clearTimeout(seq.step);
seq.step=setTimeout(function(){
_on();
},t);
}
function _off(){
clearTimeout(seq.step);
_delete(seq,"step");
_stop(el);
}
},
_arr=function(val){
var o=$(this).data(pluginPfx).opt,vals=[];
if(typeof val==="function"){val=val();}
if(!(val instanceof Array)){
vals[0]=val.y ? val.y : val.x || o.axis==="x" ? null : val;
vals[1]=val.x ? val.x : val.y || o.axis==="y" ? null : val;
}else{
vals=val.length>1 ? [val[0],val[1]] : o.axis==="x" ? [null,val[0]] : [val[0],null];
}
if(typeof vals[0]==="function"){vals[0]=vals[0]();}
if(typeof vals[1]==="function"){vals[1]=vals[1]();}
return vals;
},
_to=function(val,dir){
if(val==null || typeof val=="undefined"){return;}
var $this=$(this),d=$this.data(pluginPfx),o=d.opt,
mCSB_container=$("#mCSB_"+d.idx+"_container"),
wrapper=mCSB_container.parent(),
t=typeof val;
if(!dir){dir=o.axis==="x" ? "x" : "y";}
var contentLength=dir==="x" ? mCSB_container.outerWidth(false)-wrapper.width() : mCSB_container.outerHeight(false)-wrapper.height(),
contentPos=dir==="x" ? mCSB_container[0].offsetLeft : mCSB_container[0].offsetTop,
cssProp=dir==="x" ? "left" : "top";
switch(t){
case "function":
return val();
break;
case "object":
var obj=val.jquery ? val : $(val);
if(!obj.length){return;}
return dir==="x" ? _childPos(obj)[1] : _childPos(obj)[0];
break;
case "string": case "number":
if(_isNumeric(val)){
return Math.abs(val);
}else if(val.indexOf("%")!==-1){
return Math.abs(contentLength*parseInt(val)/100);
}else if(val.indexOf("-=")!==-1){
return Math.abs(contentPos-parseInt(val.split("-=")[1]));
}else if(val.indexOf("+=")!==-1){
var p=(contentPos+parseInt(val.split("+=")[1]));
return p>=0 ? 0 : Math.abs(p);
}else if(val.indexOf("px")!==-1 && _isNumeric(val.split("px")[0])){
return Math.abs(val.split("px")[0]);
}else{
if(val==="top" || val==="left"){
return 0;
}else if(val==="bottom"){
return Math.abs(wrapper.height()-mCSB_container.outerHeight(false));
}else if(val==="right"){
return Math.abs(wrapper.width()-mCSB_container.outerWidth(false));
}else if(val==="first" || val==="last"){
var obj=mCSB_container.find(":"+val);
return dir==="x" ? _childPos(obj)[1] : _childPos(obj)[0];
}else{
if($(val).length){
return dir==="x" ? _childPos($(val))[1] : _childPos($(val))[0];
}else{
mCSB_container.css(cssProp,val);
methods.update.call(null,$this[0]);
return;
}
}
}
break;
}
},
_autoUpdate=function(rem){
var $this=$(this),d=$this.data(pluginPfx),o=d.opt,
mCSB_container=$("#mCSB_"+d.idx+"_container");
if(rem){
clearTimeout(mCSB_container[0].autoUpdate);
_delete(mCSB_container[0],"autoUpdate");
return;
}
upd();
function upd(){
clearTimeout(mCSB_container[0].autoUpdate);
if($this.parents("html").length===0){
$this=null;
return;
}
mCSB_container[0].autoUpdate=setTimeout(function(){
if(o.advanced.updateOnSelectorChange){
d.poll.change.n=sizesSum();
if(d.poll.change.n!==d.poll.change.o){
d.poll.change.o=d.poll.change.n;
doUpd(3);
return;
}
}
if(o.advanced.updateOnContentResize){
d.poll.size.n=$this[0].scrollHeight+$this[0].scrollWidth+mCSB_container[0].offsetHeight+$this[0].offsetHeight+$this[0].offsetWidth;
if(d.poll.size.n!==d.poll.size.o){
d.poll.size.o=d.poll.size.n;
doUpd(1);
return;
}
}
if(o.advanced.updateOnImageLoad){
if(!(o.advanced.updateOnImageLoad==="auto" && o.axis==="y")){ //by default, it doesn't run on vertical content
d.poll.img.n=mCSB_container.find("img").length;
if(d.poll.img.n!==d.poll.img.o){
d.poll.img.o=d.poll.img.n;
mCSB_container.find("img").each(function(){
imgLoader(this);
});
return;
}
}
}
if(o.advanced.updateOnSelectorChange || o.advanced.updateOnContentResize || o.advanced.updateOnImageLoad){upd();}
},o.advanced.autoUpdateTimeout);
}
function imgLoader(el){
if($(el).hasClass(classes[2])){doUpd(); return;}
var img=new Image();
function createDelegate(contextObject,delegateMethod){
return function(){return delegateMethod.apply(contextObject,arguments);}
}
function imgOnLoad(){
this.onload=null;
$(el).addClass(classes[2]);
doUpd(2);
}
img.onload=createDelegate(img,imgOnLoad);
img.src=el.src;
}
function sizesSum(){
if(o.advanced.updateOnSelectorChange===true){o.advanced.updateOnSelectorChange="*";}
var total=0,sel=mCSB_container.find(o.advanced.updateOnSelectorChange);
if(o.advanced.updateOnSelectorChange && sel.length>0){sel.each(function(){total+=this.offsetHeight+this.offsetWidth;});}
return total;
}
function doUpd(cb){
clearTimeout(mCSB_container[0].autoUpdate);
methods.update.call(null,$this[0],cb);
}
},
_snapAmount=function(to,amount,offset){
return (Math.round(to/amount)*amount-offset);
},
_stop=function(el){
var d=el.data(pluginPfx),
sel=$("#mCSB_"+d.idx+"_container,#mCSB_"+d.idx+"_container_wrapper,#mCSB_"+d.idx+"_dragger_vertical,#mCSB_"+d.idx+"_dragger_horizontal");
sel.each(function(){
_stopTween.call(this);
});
},
_scrollTo=function(el,to,options){
var d=el.data(pluginPfx),o=d.opt,
defaults={
trigger:"internal",
dir:"y",
scrollEasing:"mcsEaseOut",
drag:false,
dur:o.scrollInertia,
overwrite:"all",
callbacks:true,
onStart:true,
onUpdate:true,
onComplete:true
},
options=$.extend(defaults,options),
dur=[options.dur,(options.drag ? 0 : options.dur)],
mCustomScrollBox=$("#mCSB_"+d.idx),
mCSB_container=$("#mCSB_"+d.idx+"_container"),
wrapper=mCSB_container.parent(),
totalScrollOffsets=o.callbacks.onTotalScrollOffset ? _arr.call(el,o.callbacks.onTotalScrollOffset) : [0,0],
totalScrollBackOffsets=o.callbacks.onTotalScrollBackOffset ? _arr.call(el,o.callbacks.onTotalScrollBackOffset) : [0,0];
d.trigger=options.trigger;
if(wrapper.scrollTop()!==0 || wrapper.scrollLeft()!==0){
$(".mCSB_"+d.idx+"_scrollbar").css("visibility","visible");
wrapper.scrollTop(0).scrollLeft(0);
}
if(to==="_resetY" && !d.contentReset.y){
if(_cb("onOverflowYNone")){o.callbacks.onOverflowYNone.call(el[0]);}
d.contentReset.y=1;
}
if(to==="_resetX" && !d.contentReset.x){
if(_cb("onOverflowXNone")){o.callbacks.onOverflowXNone.call(el[0]);}
d.contentReset.x=1;
}
if(to==="_resetY" || to==="_resetX"){return;}
if((d.contentReset.y || !el[0].mcs) && d.overflowed[0]){
if(_cb("onOverflowY")){o.callbacks.onOverflowY.call(el[0]);}
d.contentReset.x=null;
}
if((d.contentReset.x || !el[0].mcs) && d.overflowed[1]){
if(_cb("onOverflowX")){o.callbacks.onOverflowX.call(el[0]);}
d.contentReset.x=null;
}
if(o.snapAmount){
var snapAmount=!(o.snapAmount instanceof Array) ? o.snapAmount : options.dir==="x" ? o.snapAmount[1] : o.snapAmount[0];
to=_snapAmount(to,snapAmount,o.snapOffset);
}
switch(options.dir){
case "x":
var mCSB_dragger=$("#mCSB_"+d.idx+"_dragger_horizontal"),
property="left",
contentPos=mCSB_container[0].offsetLeft,
limit=[
mCustomScrollBox.width()-mCSB_container.outerWidth(false),
mCSB_dragger.parent().width()-mCSB_dragger.width()
],
scrollTo=[to,to===0 ? 0 : (to/d.scrollRatio.x)],
tso=totalScrollOffsets[1],
tsbo=totalScrollBackOffsets[1],
totalScrollOffset=tso>0 ? tso/d.scrollRatio.x : 0,
totalScrollBackOffset=tsbo>0 ? tsbo/d.scrollRatio.x : 0;
break;
case "y":
var mCSB_dragger=$("#mCSB_"+d.idx+"_dragger_vertical"),
property="top",
contentPos=mCSB_container[0].offsetTop,
limit=[
mCustomScrollBox.height()-mCSB_container.outerHeight(false),
mCSB_dragger.parent().height()-mCSB_dragger.height()
],
scrollTo=[to,to===0 ? 0 : (to/d.scrollRatio.y)],
tso=totalScrollOffsets[0],
tsbo=totalScrollBackOffsets[0],
totalScrollOffset=tso>0 ? tso/d.scrollRatio.y : 0,
totalScrollBackOffset=tsbo>0 ? tsbo/d.scrollRatio.y : 0;
break;
}
if(scrollTo[1]<0 || (scrollTo[0]===0 && scrollTo[1]===0)){
scrollTo=[0,0];
}else if(scrollTo[1]>=limit[1]){
scrollTo=[limit[0],limit[1]];
}else{
scrollTo[0]=-scrollTo[0];
}
if(!el[0].mcs){
_mcs();
if(_cb("onInit")){o.callbacks.onInit.call(el[0]);}
}
clearTimeout(mCSB_container[0].onCompleteTimeout);
_tweenTo(mCSB_dragger[0],property,Math.round(scrollTo[1]),dur[1],options.scrollEasing);
if(!d.tweenRunning && ((contentPos===0 && scrollTo[0]>=0) || (contentPos===limit[0] && scrollTo[0]<=limit[0]))){return;}
_tweenTo(mCSB_container[0],property,Math.round(scrollTo[0]),dur[0],options.scrollEasing,options.overwrite,{
onStart:function(){
if(options.callbacks && options.onStart && !d.tweenRunning){
if(_cb("onScrollStart")){_mcs(); o.callbacks.onScrollStart.call(el[0]);}
d.tweenRunning=true;
_onDragClasses(mCSB_dragger);
d.cbOffsets=_cbOffsets();
}
},onUpdate:function(){
if(options.callbacks && options.onUpdate){
if(_cb("whileScrolling")){_mcs(); o.callbacks.whileScrolling.call(el[0]);}
}
},onComplete:function(){
if(options.callbacks && options.onComplete){
if(o.axis==="yx"){clearTimeout(mCSB_container[0].onCompleteTimeout);}
var t=mCSB_container[0].idleTimer || 0;
mCSB_container[0].onCompleteTimeout=setTimeout(function(){
if(_cb("onScroll")){_mcs(); o.callbacks.onScroll.call(el[0]);}
if(_cb("onTotalScroll") && scrollTo[1]>=limit[1]-totalScrollOffset && d.cbOffsets[0]){_mcs(); o.callbacks.onTotalScroll.call(el[0]);}
if(_cb("onTotalScrollBack") && scrollTo[1]<=totalScrollBackOffset && d.cbOffsets[1]){_mcs(); o.callbacks.onTotalScrollBack.call(el[0]);}
d.tweenRunning=false;
mCSB_container[0].idleTimer=0;
_onDragClasses(mCSB_dragger,"hide");
},t);
}
}
});
function _cb(cb){
return d && o.callbacks[cb] && typeof o.callbacks[cb]==="function";
}
function _cbOffsets(){
return [o.callbacks.alwaysTriggerOffsets || contentPos>=limit[0]+tso,o.callbacks.alwaysTriggerOffsets || contentPos<=-tsbo];
}
function _mcs(){
var cp=[mCSB_container[0].offsetTop,mCSB_container[0].offsetLeft],
dp=[mCSB_dragger[0].offsetTop,mCSB_dragger[0].offsetLeft],
cl=[mCSB_container.outerHeight(false),mCSB_container.outerWidth(false)],
pl=[mCustomScrollBox.height(),mCustomScrollBox.width()];
el[0].mcs={
content:mCSB_container,
top:cp[0],left:cp[1],draggerTop:dp[0],draggerLeft:dp[1],
topPct:Math.round((100*Math.abs(cp[0]))/(Math.abs(cl[0])-pl[0])),leftPct:Math.round((100*Math.abs(cp[1]))/(Math.abs(cl[1])-pl[1])),
direction:options.dir
};
}
},
_tweenTo=function(el,prop,to,duration,easing,overwrite,callbacks){
if(!el._mTween){el._mTween={top:{},left:{}};}
var callbacks=callbacks || {},
onStart=callbacks.onStart || function(){},onUpdate=callbacks.onUpdate || function(){},onComplete=callbacks.onComplete || function(){},
startTime=_getTime(),_delay,progress=0,from=el.offsetTop,elStyle=el.style,_request,tobj=el._mTween[prop];
if(prop==="left"){from=el.offsetLeft;}
var diff=to-from;
tobj.stop=0;
if(overwrite!=="none"){_cancelTween();}
_startTween();
function _step(){
if(tobj.stop){return;}
if(!progress){onStart.call();}
progress=_getTime()-startTime;
_tween();
if(progress>=tobj.time){
tobj.time=(progress>tobj.time) ? progress+_delay-(progress-tobj.time) : progress+_delay-1;
if(tobj.time<progress+1){tobj.time=progress+1;}
}
if(tobj.time<duration){tobj.id=_request(_step);}else{onComplete.call();}
}
function _tween(){
if(duration>0){
tobj.currVal=_ease(tobj.time,from,diff,duration,easing);
elStyle[prop]=Math.round(tobj.currVal)+"px";
}else{
elStyle[prop]=to+"px";
}
onUpdate.call();
}
function _startTween(){
_delay=1000/60;
tobj.time=progress+_delay;
_request=(!window.requestAnimationFrame) ? function(f){_tween(); return setTimeout(f,0.01);} : window.requestAnimationFrame;
tobj.id=_request(_step);
}
function _cancelTween(){
if(tobj.id==null){return;}
if(!window.requestAnimationFrame){clearTimeout(tobj.id);
}else{window.cancelAnimationFrame(tobj.id);}
tobj.id=null;
}
function _ease(t,b,c,d,type){
switch(type){
case "linear": case "mcsLinear":
return c*t/d + b;
break;
case "mcsLinearOut":
t/=d; t--; return c * Math.sqrt(1 - t*t) + b;
break;
case "easeInOutSmooth":
t/=d/2;
if(t<1) return c/2*t*t + b;
t--;
return -c/2 * (t*(t-2) - 1) + b;
break;
case "easeInOutStrong":
t/=d/2;
if(t<1) return c/2 * Math.pow( 2, 10 * (t - 1) ) + b;
t--;
return c/2 * ( -Math.pow( 2, -10 * t) + 2 ) + b;
break;
case "easeInOut": case "mcsEaseInOut":
t/=d/2;
if(t<1) return c/2*t*t*t + b;
t-=2;
return c/2*(t*t*t + 2) + b;
break;
case "easeOutSmooth":
t/=d; t--;
return -c * (t*t*t*t - 1) + b;
break;
case "easeOutStrong":
return c * ( -Math.pow( 2, -10 * t/d ) + 1 ) + b;
break;
case "easeOut": case "mcsEaseOut": default:
var ts=(t/=d)*t,tc=ts*t;
return b+c*(0.499999999999997*tc*ts + -2.5*ts*ts + 5.5*tc + -6.5*ts + 4*t);
}
}
},
_getTime=function(){
if(window.performance && window.performance.now){
return window.performance.now();
}else{
if(window.performance && window.performance.webkitNow){
return window.performance.webkitNow();
}else{
if(Date.now){return Date.now();}else{return new Date().getTime();}
}
}
},
_stopTween=function(){
var el=this;
if(!el._mTween){el._mTween={top:{},left:{}};}
var props=["top","left"];
for(var i=0; i<props.length; i++){
var prop=props[i];
if(el._mTween[prop].id){
if(!window.requestAnimationFrame){clearTimeout(el._mTween[prop].id);
}else{window.cancelAnimationFrame(el._mTween[prop].id);}
el._mTween[prop].id=null;
el._mTween[prop].stop=1;
}
}
},
_delete=function(c,m){
try{delete c[m];}catch(e){c[m]=null;}
},
_mouseBtnLeft=function(e){
return !(e.which && e.which!==1);
},
_pointerTouch=function(e){
var t=e.originalEvent.pointerType;
return !(t && t!=="touch" && t!==2);
},
_isNumeric=function(val){
return !isNaN(parseFloat(val)) && isFinite(val);
},
_childPos=function(el){
var p=el.parents(".mCSB_container");
return [el.offset().top-p.offset().top,el.offset().left-p.offset().left];
},
_isTabHidden=function(){
var prop=_getHiddenProp();
if(!prop) return false;
return document[prop];
function _getHiddenProp(){
var pfx=["webkit","moz","ms","o"];
if("hidden" in document) return "hidden"; //natively supported
for(var i=0; i<pfx.length; i++){ //prefixed
if((pfx[i]+"Hidden") in document)
return pfx[i]+"Hidden";
}
return null; //not supported
}
};
$.fn[pluginNS]=function(method){
if(methods[method]){
return methods[method].apply(this,Array.prototype.slice.call(arguments,1));
}else if(typeof method==="object" || !method){
return methods.init.apply(this,arguments);
}else{
$.error("Method "+method+" does not exist");
}
};
$[pluginNS]=function(method){
if(methods[method]){
return methods[method].apply(this,Array.prototype.slice.call(arguments,1));
}else if(typeof method==="object" || !method){
return methods.init.apply(this,arguments);
}else{
$.error("Method "+method+" does not exist");
}
};
$[pluginNS].defaults=defaults;
window[pluginNS]=true;
$(window).bind("load",function(){
$(defaultSelector)[pluginNS]();
$.extend($.expr[":"],{
mcsInView:$.expr[":"].mcsInView || function(el){
var $el=$(el),content=$el.parents(".mCSB_container"),wrapper,cPos;
if(!content.length){return;}
wrapper=content.parent();
cPos=[content[0].offsetTop,content[0].offsetLeft];
return 	cPos[0]+_childPos($el)[0]>=0 && cPos[0]+_childPos($el)[0]<wrapper.height()-$el.outerHeight(false) &&
cPos[1]+_childPos($el)[1]>=0 && cPos[1]+_childPos($el)[1]<wrapper.width()-$el.outerWidth(false);
},
mcsInSight:$.expr[":"].mcsInSight || function(el,i,m){
var $el=$(el),elD,content=$el.parents(".mCSB_container"),wrapperView,pos,wrapperViewPct,
pctVals=m[3]==="exact" ? [[1,0],[1,0]] : [[0.9,0.1],[0.6,0.4]];
if(!content.length){return;}
elD=[$el.outerHeight(false),$el.outerWidth(false)];
pos=[content[0].offsetTop+_childPos($el)[0],content[0].offsetLeft+_childPos($el)[1]];
wrapperView=[content.parent()[0].offsetHeight,content.parent()[0].offsetWidth];
wrapperViewPct=[elD[0]<wrapperView[0] ? pctVals[0] : pctVals[1],elD[1]<wrapperView[1] ? pctVals[0] : pctVals[1]];
return 	pos[0]-(wrapperView[0]*wrapperViewPct[0][0])<0 && pos[0]+elD[0]-(wrapperView[0]*wrapperViewPct[0][1])>=0 &&
pos[1]-(wrapperView[1]*wrapperViewPct[1][0])<0 && pos[1]+elD[1]-(wrapperView[1]*wrapperViewPct[1][1])>=0;
},
mcsOverflow:$.expr[":"].mcsOverflow || function(el){
var d=$(el).data(pluginPfx);
if(!d){return;}
return d.overflowed[0] || d.overflowed[1];
}
});
});
}))}));
;(function() {
"use strict";
function setup($) {
$.fn._fadeIn = $.fn.fadeIn;
var noOp = $.noop || function() {};
var msie = /MSIE/.test(navigator.userAgent);
var ie6  = /MSIE 6.0/.test(navigator.userAgent) && ! /MSIE 8.0/.test(navigator.userAgent);
var mode = document.documentMode || 0;
var setExpr = $.isFunction( document.createElement('div').style.setExpression );
$.blockUI   = function(opts) { install(window, opts); };
$.unblockUI = function(opts) { remove(window, opts); };
$.growlUI = function(title, message, timeout, onClose) {
var $m = $('<div class="growlUI"></div>');
if (title) $m.append('<h1>'+title+'</h1>');
if (message) $m.append('<h2>'+message+'</h2>');
if (timeout === undefined) timeout = 3000;
var callBlock = function(opts) {
opts = opts || {};
$.blockUI({
message: $m,
fadeIn : typeof opts.fadeIn  !== 'undefined' ? opts.fadeIn  : 700,
fadeOut: typeof opts.fadeOut !== 'undefined' ? opts.fadeOut : 1000,
timeout: typeof opts.timeout !== 'undefined' ? opts.timeout : timeout,
centerY: false,
showOverlay: false,
onUnblock: onClose,
css: $.blockUI.defaults.growlCSS
});
};
callBlock();
var nonmousedOpacity = $m.css('opacity');
$m.mouseover(function() {
callBlock({
fadeIn: 0,
timeout: 30000
});
var displayBlock = $('.blockMsg');
displayBlock.stop(); // cancel fadeout if it has started
displayBlock.fadeTo(300, 1); // make it easier to read the message by removing transparency
}).mouseout(function() {
$('.blockMsg').fadeOut(1000);
});
};
$.fn.block = function(opts) {
if ( this[0] === window ) {
$.blockUI( opts );
return this;
}
var fullOpts = $.extend({}, $.blockUI.defaults, opts || {});
this.each(function() {
var $el = $(this);
if (fullOpts.ignoreIfBlocked && $el.data('blockUI.isBlocked'))
return;
$el.unblock({ fadeOut: 0 });
});
return this.each(function() {
if ($.css(this,'position') == 'static') {
this.style.position = 'relative';
$(this).data('blockUI.static', true);
}
this.style.zoom = 1; // force 'hasLayout' in ie
install(this, opts);
});
};
$.fn.unblock = function(opts) {
if ( this[0] === window ) {
$.unblockUI( opts );
return this;
}
return this.each(function() {
remove(this, opts);
});
};
$.blockUI.version = 2.70; // 2nd generation blocking at no extra cost!
$.blockUI.defaults = {
message:  '<h1>Please wait...</h1>',
title: null,		// title string; only used when theme == true
draggable: true,	// only used when theme == true (requires jquery-ui.js to be loaded)
theme: false, // set to true to use with jQuery UI themes
css: {
padding:	0,
margin:		0,
width:		'30%',
top:		'40%',
left:		'35%',
textAlign:	'center',
color:		'#000',
border:		'3px solid #aaa',
backgroundColor:'#fff',
cursor:		'wait'
},
themedCSS: {
width:	'30%',
top:	'40%',
left:	'35%'
},
overlayCSS:  {
backgroundColor:	'#000',
opacity:			0.6,
cursor:				'wait'
},
cursorReset: 'default',
growlCSS: {
width:		'350px',
top:		'10px',
left:		'',
right:		'10px',
border:		'none',
padding:	'5px',
opacity:	0.6,
cursor:		'default',
color:		'#fff',
backgroundColor: '#000',
'-webkit-border-radius':'10px',
'-moz-border-radius':	'10px',
'border-radius':		'10px'
},
iframeSrc: /^https/i.test(window.location.href || '') ? 'javascript:false' : 'about:blank',
forceIframe: false,
baseZ: 1000,
centerX: true, // <-- only effects element blocking (page block controlled via css above)
centerY: true,
allowBodyStretch: true,
bindEvents: true,
constrainTabKey: true,
fadeIn:  200,
fadeOut:  400,
timeout: 0,
showOverlay: true,
focusInput: true,
focusableElements: ':input:enabled:visible',
onBlock: null,
onUnblock: null,
onOverlayClick: null,
quirksmodeOffsetHack: 4,
blockMsgClass: 'blockMsg',
ignoreIfBlocked: false
};
var pageBlock = null;
var pageBlockEls = [];
function install(el, opts) {
var css, themedCSS;
var full = (el == window);
var msg = (opts && opts.message !== undefined ? opts.message : undefined);
opts = $.extend({}, $.blockUI.defaults, opts || {});
if (opts.ignoreIfBlocked && $(el).data('blockUI.isBlocked'))
return;
opts.overlayCSS = $.extend({}, $.blockUI.defaults.overlayCSS, opts.overlayCSS || {});
css = $.extend({}, $.blockUI.defaults.css, opts.css || {});
if (opts.onOverlayClick)
opts.overlayCSS.cursor = 'pointer';
themedCSS = $.extend({}, $.blockUI.defaults.themedCSS, opts.themedCSS || {});
msg = msg === undefined ? opts.message : msg;
if (full && pageBlock)
remove(window, {fadeOut:0});
if (msg && typeof msg != 'string' && (msg.parentNode || msg.jquery)) {
var node = msg.jquery ? msg[0] : msg;
var data = {};
$(el).data('blockUI.history', data);
data.el = node;
data.parent = node.parentNode;
data.display = node.style.display;
data.position = node.style.position;
if (data.parent)
data.parent.removeChild(node);
}
$(el).data('blockUI.onUnblock', opts.onUnblock);
var z = opts.baseZ;
var lyr1, lyr2, lyr3, s;
if (msie || opts.forceIframe)
lyr1 = $('<iframe class="blockUI" style="z-index:'+ (z++) +';display:none;border:none;margin:0;padding:0;position:absolute;width:100%;height:100%;top:0;left:0" src="'+opts.iframeSrc+'"></iframe>');
else
lyr1 = $('<div class="blockUI" style="display:none"></div>');
if (opts.theme)
lyr2 = $('<div class="blockUI blockOverlay ui-widget-overlay" style="z-index:'+ (z++) +';display:none"></div>');
else
lyr2 = $('<div class="blockUI blockOverlay" style="z-index:'+ (z++) +';display:none;border:none;margin:0;padding:0;width:100%;height:100%;top:0;left:0"></div>');
if (opts.theme && full) {
s = '<div class="blockUI ' + opts.blockMsgClass + ' blockPage ui-dialog ui-widget ui-corner-all" style="z-index:'+(z+10)+';display:none;position:fixed">';
if ( opts.title ) {
s += '<div class="ui-widget-header ui-dialog-titlebar ui-corner-all blockTitle">'+(opts.title || '&nbsp;')+'</div>';
}
s += '<div class="ui-widget-content ui-dialog-content"></div>';
s += '</div>';
}
else if (opts.theme) {
s = '<div class="blockUI ' + opts.blockMsgClass + ' blockElement ui-dialog ui-widget ui-corner-all" style="z-index:'+(z+10)+';display:none;position:absolute">';
if ( opts.title ) {
s += '<div class="ui-widget-header ui-dialog-titlebar ui-corner-all blockTitle">'+(opts.title || '&nbsp;')+'</div>';
}
s += '<div class="ui-widget-content ui-dialog-content"></div>';
s += '</div>';
}
else if (full) {
s = '<div class="blockUI ' + opts.blockMsgClass + ' blockPage" style="z-index:'+(z+10)+';display:none;position:fixed"></div>';
}
else {
s = '<div class="blockUI ' + opts.blockMsgClass + ' blockElement" style="z-index:'+(z+10)+';display:none;position:absolute"></div>';
}
lyr3 = $(s);
if (msg) {
if (opts.theme) {
lyr3.css(themedCSS);
lyr3.addClass('ui-widget-content');
}
else
lyr3.css(css);
}
if (!opts.theme)
lyr2.css(opts.overlayCSS);
lyr2.css('position', full ? 'fixed' : 'absolute');
if (msie || opts.forceIframe)
lyr1.css('opacity',0.0);
var layers = [lyr1,lyr2,lyr3], $par = full ? $('body') : $(el);
$.each(layers, function() {
this.appendTo($par);
});
if (opts.theme && opts.draggable && $.fn.draggable) {
lyr3.draggable({
handle: '.ui-dialog-titlebar',
cancel: 'li'
});
}
var expr = setExpr && (!$.support.boxModel || $('object,embed', full ? null : el).length > 0);
if (ie6 || expr) {
if (full && opts.allowBodyStretch && $.support.boxModel)
$('html,body').css('height','100%');
if ((ie6 || !$.support.boxModel) && !full) {
var t = sz(el,'borderTopWidth'), l = sz(el,'borderLeftWidth');
var fixT = t ? '(0 - '+t+')' : 0;
var fixL = l ? '(0 - '+l+')' : 0;
}
$.each(layers, function(i,o) {
var s = o[0].style;
s.position = 'absolute';
if (i < 2) {
if (full)
s.setExpression('height','Math.max(document.body.scrollHeight, document.body.offsetHeight) - (jQuery.support.boxModel?0:'+opts.quirksmodeOffsetHack+') + "px"');
else
s.setExpression('height','this.parentNode.offsetHeight + "px"');
if (full)
s.setExpression('width','jQuery.support.boxModel && document.documentElement.clientWidth || document.body.clientWidth + "px"');
else
s.setExpression('width','this.parentNode.offsetWidth + "px"');
if (fixL) s.setExpression('left', fixL);
if (fixT) s.setExpression('top', fixT);
}
else if (opts.centerY) {
if (full) s.setExpression('top','(document.documentElement.clientHeight || document.body.clientHeight) / 2 - (this.offsetHeight / 2) + (blah = document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop) + "px"');
s.marginTop = 0;
}
else if (!opts.centerY && full) {
var top = (opts.css && opts.css.top) ? parseInt(opts.css.top, 10) : 0;
var expression = '((document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop) + '+top+') + "px"';
s.setExpression('top',expression);
}
});
}
if (msg) {
if (opts.theme)
lyr3.find('.ui-widget-content').append(msg);
else
lyr3.append(msg);
if (msg.jquery || msg.nodeType)
$(msg).show();
}
if ((msie || opts.forceIframe) && opts.showOverlay)
lyr1.show(); // opacity is zero
if (opts.fadeIn) {
var cb = opts.onBlock ? opts.onBlock : noOp;
var cb1 = (opts.showOverlay && !msg) ? cb : noOp;
var cb2 = msg ? cb : noOp;
if (opts.showOverlay)
lyr2._fadeIn(opts.fadeIn, cb1);
if (msg)
lyr3._fadeIn(opts.fadeIn, cb2);
}
else {
if (opts.showOverlay)
lyr2.show();
if (msg)
lyr3.show();
if (opts.onBlock)
opts.onBlock.bind(lyr3)();
}
bind(1, el, opts);
if (full) {
pageBlock = lyr3[0];
pageBlockEls = $(opts.focusableElements,pageBlock);
if (opts.focusInput)
setTimeout(focus, 20);
}
else
center(lyr3[0], opts.centerX, opts.centerY);
if (opts.timeout) {
var to = setTimeout(function() {
if (full)
$.unblockUI(opts);
else
$(el).unblock(opts);
}, opts.timeout);
$(el).data('blockUI.timeout', to);
}
}
function remove(el, opts) {
var count;
var full = (el == window);
var $el = $(el);
var data = $el.data('blockUI.history');
var to = $el.data('blockUI.timeout');
if (to) {
clearTimeout(to);
$el.removeData('blockUI.timeout');
}
opts = $.extend({}, $.blockUI.defaults, opts || {});
bind(0, el, opts); // unbind events
if (opts.onUnblock === null) {
opts.onUnblock = $el.data('blockUI.onUnblock');
$el.removeData('blockUI.onUnblock');
}
var els;
if (full) // crazy selector to handle odd field errors in ie6/7
els = $('body').children().filter('.blockUI').add('body > .blockUI');
else
els = $el.find('>.blockUI');
if ( opts.cursorReset ) {
if ( els.length > 1 )
els[1].style.cursor = opts.cursorReset;
if ( els.length > 2 )
els[2].style.cursor = opts.cursorReset;
}
if (full)
pageBlock = pageBlockEls = null;
if (opts.fadeOut) {
count = els.length;
els.stop().fadeOut(opts.fadeOut, function() {
if ( --count === 0)
reset(els,data,opts,el);
});
}
else
reset(els, data, opts, el);
}
function reset(els,data,opts,el) {
var $el = $(el);
if ( $el.data('blockUI.isBlocked') )
return;
els.each(function(i,o) {
if (this.parentNode)
this.parentNode.removeChild(this);
});
if (data && data.el) {
data.el.style.display = data.display;
data.el.style.position = data.position;
data.el.style.cursor = 'default'; // #59
if (data.parent)
data.parent.appendChild(data.el);
$el.removeData('blockUI.history');
}
if ($el.data('blockUI.static')) {
$el.css('position', 'static'); // #22
}
if (typeof opts.onUnblock == 'function')
opts.onUnblock(el,opts);
var body = $(document.body), w = body.width(), cssW = body[0].style.width;
body.width(w-1).width(w);
body[0].style.width = cssW;
}
function bind(b, el, opts) {
var full = el == window, $el = $(el);
if (!b && (full && !pageBlock || !full && !$el.data('blockUI.isBlocked')))
return;
$el.data('blockUI.isBlocked', b);
if (!full || !opts.bindEvents || (b && !opts.showOverlay))
return;
var events = 'mousedown mouseup keydown keypress keyup touchstart touchend touchmove';
if (b)
$(document).bind(events, opts, handler);
else
$(document).unbind(events, handler);
}
function handler(e) {
if (e.type === 'keydown' && e.keyCode && e.keyCode == 9) {
if (pageBlock && e.data.constrainTabKey) {
var els = pageBlockEls;
var fwd = !e.shiftKey && e.target === els[els.length-1];
var back = e.shiftKey && e.target === els[0];
if (fwd || back) {
setTimeout(function(){focus(back);},10);
return false;
}
}
}
var opts = e.data;
var target = $(e.target);
if (target.hasClass('blockOverlay') && opts.onOverlayClick)
opts.onOverlayClick(e);
if (target.parents('div.' + opts.blockMsgClass).length > 0)
return true;
return target.parents().children().filter('div.blockUI').length === 0;
}
function focus(back) {
if (!pageBlockEls)
return;
var e = pageBlockEls[back===true ? pageBlockEls.length-1 : 0];
if (e)
e.focus();
}
function center(el, x, y) {
var p = el.parentNode, s = el.style;
var l = ((p.offsetWidth - el.offsetWidth)/2) - sz(p,'borderLeftWidth');
var t = ((p.offsetHeight - el.offsetHeight)/2) - sz(p,'borderTopWidth');
if (x) s.left = l > 0 ? (l+'px') : '0';
if (y) s.top  = t > 0 ? (t+'px') : '0';
}
function sz(el, p) {
return parseInt($.css(el,p),10)||0;
}
}
if (typeof define === 'function' && define.amd) {
define(['jquery'], setup);
} else if (typeof exports === 'object') {
setup(require('jquery'));
} else {
setup(jQuery);
}
})();
!function(a){"function"==typeof define&&define.amd?define(["jquery"],a):a("object"==typeof exports?require("jquery"):jQuery)}(function(a,b){function c(){return new Date(Date.UTC.apply(Date,arguments))}function d(){var a=new Date;return c(a.getFullYear(),a.getMonth(),a.getDate())}function e(a,b){return a.getUTCFullYear()===b.getUTCFullYear()&&a.getUTCMonth()===b.getUTCMonth()&&a.getUTCDate()===b.getUTCDate()}function f(c,d){return function(){return d!==b&&a.fn.datepicker.deprecated(d),this[c].apply(this,arguments)}}function g(a){return a&&!isNaN(a.getTime())}function h(b,c){function d(a,b){return b.toLowerCase()}var e,f=a(b).data(),g={},h=new RegExp("^"+c.toLowerCase()+"([A-Z])");c=new RegExp("^"+c.toLowerCase());for(var i in f)c.test(i)&&(e=i.replace(h,d),g[e]=f[i]);return g}function i(b){var c={};if(q[b]||(b=b.split("-")[0],q[b])){var d=q[b];return a.each(p,function(a,b){b in d&&(c[b]=d[b])}),c}}var j=function(){var b={get:function(a){return this.slice(a)[0]},contains:function(a){for(var b=a&&a.valueOf(),c=0,d=this.length;c<d;c++)if(0<=this[c].valueOf()-b&&this[c].valueOf()-b<864e5)return c;return-1},remove:function(a){this.splice(a,1)},replace:function(b){b&&(a.isArray(b)||(b=[b]),this.clear(),this.push.apply(this,b))},clear:function(){this.length=0},copy:function(){var a=new j;return a.replace(this),a}};return function(){var c=[];return c.push.apply(c,arguments),a.extend(c,b),c}}(),k=function(b,c){a.data(b,"datepicker",this),this._process_options(c),this.dates=new j,this.viewDate=this.o.defaultViewDate,this.focusDate=null,this.element=a(b),this.isInput=this.element.is("input"),this.inputField=this.isInput?this.element:this.element.find("input"),this.component=!!this.element.hasClass("date")&&this.element.find(".add-on, .input-group-addon, .btn"),this.component&&0===this.component.length&&(this.component=!1),this.isInline=!this.component&&this.element.is("div"),this.picker=a(r.template),this._check_template(this.o.templates.leftArrow)&&this.picker.find(".prev").html(this.o.templates.leftArrow),this._check_template(this.o.templates.rightArrow)&&this.picker.find(".next").html(this.o.templates.rightArrow),this._buildEvents(),this._attachEvents(),this.isInline?this.picker.addClass("datepicker-inline").appendTo(this.element):this.picker.addClass("datepicker-dropdown dropdown-menu"),this.o.rtl&&this.picker.addClass("datepicker-rtl"),this.o.calendarWeeks&&this.picker.find(".datepicker-days .datepicker-switch, thead .datepicker-title, tfoot .today, tfoot .clear").attr("colspan",function(a,b){return Number(b)+1}),this._process_options({startDate:this._o.startDate,endDate:this._o.endDate,daysOfWeekDisabled:this.o.daysOfWeekDisabled,daysOfWeekHighlighted:this.o.daysOfWeekHighlighted,datesDisabled:this.o.datesDisabled}),this._allow_update=!1,this.setViewMode(this.o.startView),this._allow_update=!0,this.fillDow(),this.fillMonths(),this.update(),this.isInline&&this.show()};k.prototype={constructor:k,_resolveViewName:function(b){return a.each(r.viewModes,function(c,d){if(b===c||a.inArray(b,d.names)!==-1)return b=c,!1}),b},_resolveDaysOfWeek:function(b){return a.isArray(b)||(b=b.split(/[,\s]*/)),a.map(b,Number)},_check_template:function(c){try{if(c===b||""===c)return!1;if((c.match(/[<>]/g)||[]).length<=0)return!0;var d=a(c);return d.length>0}catch(a){return!1}},_process_options:function(b){this._o=a.extend({},this._o,b);var e=this.o=a.extend({},this._o),f=e.language;q[f]||(f=f.split("-")[0],q[f]||(f=o.language)),e.language=f,e.startView=this._resolveViewName(e.startView),e.minViewMode=this._resolveViewName(e.minViewMode),e.maxViewMode=this._resolveViewName(e.maxViewMode),e.startView=Math.max(this.o.minViewMode,Math.min(this.o.maxViewMode,e.startView)),e.multidate!==!0&&(e.multidate=Number(e.multidate)||!1,e.multidate!==!1&&(e.multidate=Math.max(0,e.multidate))),e.multidateSeparator=String(e.multidateSeparator),e.weekStart%=7,e.weekEnd=(e.weekStart+6)%7;var g=r.parseFormat(e.format);e.startDate!==-(1/0)&&(e.startDate?e.startDate instanceof Date?e.startDate=this._local_to_utc(this._zero_time(e.startDate)):e.startDate=r.parseDate(e.startDate,g,e.language,e.assumeNearbyYear):e.startDate=-(1/0)),e.endDate!==1/0&&(e.endDate?e.endDate instanceof Date?e.endDate=this._local_to_utc(this._zero_time(e.endDate)):e.endDate=r.parseDate(e.endDate,g,e.language,e.assumeNearbyYear):e.endDate=1/0),e.daysOfWeekDisabled=this._resolveDaysOfWeek(e.daysOfWeekDisabled||[]),e.daysOfWeekHighlighted=this._resolveDaysOfWeek(e.daysOfWeekHighlighted||[]),e.datesDisabled=e.datesDisabled||[],a.isArray(e.datesDisabled)||(e.datesDisabled=e.datesDisabled.split(",")),e.datesDisabled=a.map(e.datesDisabled,function(a){return r.parseDate(a,g,e.language,e.assumeNearbyYear)});var h=String(e.orientation).toLowerCase().split(/\s+/g),i=e.orientation.toLowerCase();if(h=a.grep(h,function(a){return/^auto|left|right|top|bottom$/.test(a)}),e.orientation={x:"auto",y:"auto"},i&&"auto"!==i)if(1===h.length)switch(h[0]){case"top":case"bottom":e.orientation.y=h[0];break;case"left":case"right":e.orientation.x=h[0]}else i=a.grep(h,function(a){return/^left|right$/.test(a)}),e.orientation.x=i[0]||"auto",i=a.grep(h,function(a){return/^top|bottom$/.test(a)}),e.orientation.y=i[0]||"auto";else;if(e.defaultViewDate instanceof Date||"string"==typeof e.defaultViewDate)e.defaultViewDate=r.parseDate(e.defaultViewDate,g,e.language,e.assumeNearbyYear);else if(e.defaultViewDate){var j=e.defaultViewDate.year||(new Date).getFullYear(),k=e.defaultViewDate.month||0,l=e.defaultViewDate.day||1;e.defaultViewDate=c(j,k,l)}else e.defaultViewDate=d()},_events:[],_secondaryEvents:[],_applyEvents:function(a){for(var c,d,e,f=0;f<a.length;f++)c=a[f][0],2===a[f].length?(d=b,e=a[f][1]):3===a[f].length&&(d=a[f][1],e=a[f][2]),c.on(e,d)},_unapplyEvents:function(a){for(var c,d,e,f=0;f<a.length;f++)c=a[f][0],2===a[f].length?(e=b,d=a[f][1]):3===a[f].length&&(e=a[f][1],d=a[f][2]),c.off(d,e)},_buildEvents:function(){var b={keyup:a.proxy(function(b){a.inArray(b.keyCode,[27,37,39,38,40,32,13,9])===-1&&this.update()},this),keydown:a.proxy(this.keydown,this),paste:a.proxy(this.paste,this)};this.o.showOnFocus===!0&&(b.focus=a.proxy(this.show,this)),this.isInput?this._events=[[this.element,b]]:this.component&&this.inputField.length?this._events=[[this.inputField,b],[this.component,{click:a.proxy(this.show,this)}]]:this._events=[[this.element,{click:a.proxy(this.show,this),keydown:a.proxy(this.keydown,this)}]],this._events.push([this.element,"*",{blur:a.proxy(function(a){this._focused_from=a.target},this)}],[this.element,{blur:a.proxy(function(a){this._focused_from=a.target},this)}]),this.o.immediateUpdates&&this._events.push([this.element,{"changeYear changeMonth":a.proxy(function(a){this.update(a.date)},this)}]),this._secondaryEvents=[[this.picker,{click:a.proxy(this.click,this)}],[this.picker,".prev, .next",{click:a.proxy(this.navArrowsClick,this)}],[this.picker,".day:not(.disabled)",{click:a.proxy(this.dayCellClick,this)}],[a(window),{resize:a.proxy(this.place,this)}],[a(document),{"mousedown touchstart":a.proxy(function(a){this.element.is(a.target)||this.element.find(a.target).length||this.picker.is(a.target)||this.picker.find(a.target).length||this.isInline||this.hide()},this)}]]},_attachEvents:function(){this._detachEvents(),this._applyEvents(this._events)},_detachEvents:function(){this._unapplyEvents(this._events)},_attachSecondaryEvents:function(){this._detachSecondaryEvents(),this._applyEvents(this._secondaryEvents)},_detachSecondaryEvents:function(){this._unapplyEvents(this._secondaryEvents)},_trigger:function(b,c){var d=c||this.dates.get(-1),e=this._utc_to_local(d);this.element.trigger({type:b,date:e,viewMode:this.viewMode,dates:a.map(this.dates,this._utc_to_local),format:a.proxy(function(a,b){0===arguments.length?(a=this.dates.length-1,b=this.o.format):"string"==typeof a&&(b=a,a=this.dates.length-1),b=b||this.o.format;var c=this.dates.get(a);return r.formatDate(c,b,this.o.language)},this)})},show:function(){if(!(this.inputField.prop("disabled")||this.inputField.prop("readonly")&&this.o.enableOnReadonly===!1))return this.isInline||this.picker.appendTo(this.o.container),this.place(),this.picker.show(),this._attachSecondaryEvents(),this._trigger("show"),(window.navigator.msMaxTouchPoints||"ontouchstart"in document)&&this.o.disableTouchKeyboard&&a(this.element).blur(),this},hide:function(){return this.isInline||!this.picker.is(":visible")?this:(this.focusDate=null,this.picker.hide().detach(),this._detachSecondaryEvents(),this.setViewMode(this.o.startView),this.o.forceParse&&this.inputField.val()&&this.setValue(),this._trigger("hide"),this)},destroy:function(){return this.hide(),this._detachEvents(),this._detachSecondaryEvents(),this.picker.remove(),delete this.element.data().datepicker,this.isInput||delete this.element.data().date,this},paste:function(b){var c;if(b.originalEvent.clipboardData&&b.originalEvent.clipboardData.types&&a.inArray("text/plain",b.originalEvent.clipboardData.types)!==-1)c=b.originalEvent.clipboardData.getData("text/plain");else{if(!window.clipboardData)return;c=window.clipboardData.getData("Text")}this.setDate(c),this.update(),b.preventDefault()},_utc_to_local:function(a){if(!a)return a;var b=new Date(a.getTime()+6e4*a.getTimezoneOffset());return b.getTimezoneOffset()!==a.getTimezoneOffset()&&(b=new Date(a.getTime()+6e4*b.getTimezoneOffset())),b},_local_to_utc:function(a){return a&&new Date(a.getTime()-6e4*a.getTimezoneOffset())},_zero_time:function(a){return a&&new Date(a.getFullYear(),a.getMonth(),a.getDate())},_zero_utc_time:function(a){return a&&c(a.getUTCFullYear(),a.getUTCMonth(),a.getUTCDate())},getDates:function(){return a.map(this.dates,this._utc_to_local)},getUTCDates:function(){return a.map(this.dates,function(a){return new Date(a)})},getDate:function(){return this._utc_to_local(this.getUTCDate())},getUTCDate:function(){var a=this.dates.get(-1);return a!==b?new Date(a):null},clearDates:function(){this.inputField.val(""),this.update(),this._trigger("changeDate"),this.o.autoclose&&this.hide()},setDates:function(){var b=a.isArray(arguments[0])?arguments[0]:arguments;return this.update.apply(this,b),this._trigger("changeDate"),this.setValue(),this},setUTCDates:function(){var b=a.isArray(arguments[0])?arguments[0]:arguments;return this.setDates.apply(this,a.map(b,this._utc_to_local)),this},setDate:f("setDates"),setUTCDate:f("setUTCDates"),remove:f("destroy","Method `remove` is deprecated and will be removed in version 2.0. Use `destroy` instead"),setValue:function(){var a=this.getFormattedDate();return this.inputField.val(a),this},getFormattedDate:function(c){c===b&&(c=this.o.format);var d=this.o.language;return a.map(this.dates,function(a){return r.formatDate(a,c,d)}).join(this.o.multidateSeparator)},getStartDate:function(){return this.o.startDate},setStartDate:function(a){return this._process_options({startDate:a}),this.update(),this.updateNavArrows(),this},getEndDate:function(){return this.o.endDate},setEndDate:function(a){return this._process_options({endDate:a}),this.update(),this.updateNavArrows(),this},setDaysOfWeekDisabled:function(a){return this._process_options({daysOfWeekDisabled:a}),this.update(),this},setDaysOfWeekHighlighted:function(a){return this._process_options({daysOfWeekHighlighted:a}),this.update(),this},setDatesDisabled:function(a){return this._process_options({datesDisabled:a}),this.update(),this},place:function(){if(this.isInline)return this;var b=this.picker.outerWidth(),c=this.picker.outerHeight(),d=10,e=a(this.o.container),f=e.width(),g="body"===this.o.container?a(document).scrollTop():e.scrollTop(),h=e.offset(),i=[0];this.element.parents().each(function(){var b=a(this).css("z-index");"auto"!==b&&0!==Number(b)&&i.push(Number(b))});var j=Math.max.apply(Math,i)+this.o.zIndexOffset,k=this.component?this.component.parent().offset():this.element.offset(),l=this.component?this.component.outerHeight(!0):this.element.outerHeight(!1),m=this.component?this.component.outerWidth(!0):this.element.outerWidth(!1),n=k.left-h.left,o=k.top-h.top;"body"!==this.o.container&&(o+=g),this.picker.removeClass("datepicker-orient-top datepicker-orient-bottom datepicker-orient-right datepicker-orient-left"),"auto"!==this.o.orientation.x?(this.picker.addClass("datepicker-orient-"+this.o.orientation.x),"right"===this.o.orientation.x&&(n-=b-m)):k.left<0?(this.picker.addClass("datepicker-orient-left"),n-=k.left-d):n+b>f?(this.picker.addClass("datepicker-orient-right"),n+=m-b):this.o.rtl?this.picker.addClass("datepicker-orient-right"):this.picker.addClass("datepicker-orient-left");var p,q=this.o.orientation.y;if("auto"===q&&(p=-g+o-c,q=p<0?"bottom":"top"),this.picker.addClass("datepicker-orient-"+q),"top"===q?o-=c+parseInt(this.picker.css("padding-top")):o+=l,this.o.rtl){var r=f-(n+m);this.picker.css({top:o,right:r,zIndex:j})}else this.picker.css({top:o,left:n,zIndex:j});return this},_allow_update:!0,update:function(){if(!this._allow_update)return this;var b=this.dates.copy(),c=[],d=!1;return arguments.length?(a.each(arguments,a.proxy(function(a,b){b instanceof Date&&(b=this._local_to_utc(b)),c.push(b)},this)),d=!0):(c=this.isInput?this.element.val():this.element.data("date")||this.inputField.val(),c=c&&this.o.multidate?c.split(this.o.multidateSeparator):[c],delete this.element.data().date),c=a.map(c,a.proxy(function(a){return r.parseDate(a,this.o.format,this.o.language,this.o.assumeNearbyYear)},this)),c=a.grep(c,a.proxy(function(a){return!this.dateWithinRange(a)||!a},this),!0),this.dates.replace(c),this.o.updateViewDate&&(this.dates.length?this.viewDate=new Date(this.dates.get(-1)):this.viewDate<this.o.startDate?this.viewDate=new Date(this.o.startDate):this.viewDate>this.o.endDate?this.viewDate=new Date(this.o.endDate):this.viewDate=this.o.defaultViewDate),d?(this.setValue(),this.element.change()):this.dates.length&&String(b)!==String(this.dates)&&d&&(this._trigger("changeDate"),this.element.change()),!this.dates.length&&b.length&&(this._trigger("clearDate"),this.element.change()),this.fill(),this},fillDow:function(){if(this.o.showWeekDays){var b=this.o.weekStart,c="<tr>";for(this.o.calendarWeeks&&(c+='<th class="cw">&#160;</th>');b<this.o.weekStart+7;)c+='<th class="dow',a.inArray(b,this.o.daysOfWeekDisabled)!==-1&&(c+=" disabled"),c+='">'+q[this.o.language].daysMin[b++%7]+"</th>";c+="</tr>",this.picker.find(".datepicker-days thead").append(c)}},fillMonths:function(){for(var a,b=this._utc_to_local(this.viewDate),c="",d=0;d<12;d++)a=b&&b.getMonth()===d?" focused":"",c+='<span class="month'+a+'">'+q[this.o.language].monthsShort[d]+"</span>";this.picker.find(".datepicker-months td").html(c)},setRange:function(b){b&&b.length?this.range=a.map(b,function(a){return a.valueOf()}):delete this.range,this.fill()},getClassNames:function(b){var c=[],f=this.viewDate.getUTCFullYear(),g=this.viewDate.getUTCMonth(),h=d();return b.getUTCFullYear()<f||b.getUTCFullYear()===f&&b.getUTCMonth()<g?c.push("old"):(b.getUTCFullYear()>f||b.getUTCFullYear()===f&&b.getUTCMonth()>g)&&c.push("new"),this.focusDate&&b.valueOf()===this.focusDate.valueOf()&&c.push("focused"),this.o.todayHighlight&&e(b,h)&&c.push("today"),this.dates.contains(b)!==-1&&c.push("active"),this.dateWithinRange(b)||c.push("disabled"),this.dateIsDisabled(b)&&c.push("disabled","disabled-date"),a.inArray(b.getUTCDay(),this.o.daysOfWeekHighlighted)!==-1&&c.push("highlighted"),this.range&&(b>this.range[0]&&b<this.range[this.range.length-1]&&c.push("range"),a.inArray(b.valueOf(),this.range)!==-1&&c.push("selected"),b.valueOf()===this.range[0]&&c.push("range-start"),b.valueOf()===this.range[this.range.length-1]&&c.push("range-end")),c},_fill_yearsView:function(c,d,e,f,g,h,i){for(var j,k,l,m="",n=e/10,o=this.picker.find(c),p=Math.floor(f/e)*e,q=p+9*n,r=Math.floor(this.viewDate.getFullYear()/n)*n,s=a.map(this.dates,function(a){return Math.floor(a.getUTCFullYear()/n)*n}),t=p-n;t<=q+n;t+=n)j=[d],k=null,t===p-n?j.push("old"):t===q+n&&j.push("new"),a.inArray(t,s)!==-1&&j.push("active"),(t<g||t>h)&&j.push("disabled"),t===r&&j.push("focused"),i!==a.noop&&(l=i(new Date(t,0,1)),l===b?l={}:"boolean"==typeof l?l={enabled:l}:"string"==typeof l&&(l={classes:l}),l.enabled===!1&&j.push("disabled"),l.classes&&(j=j.concat(l.classes.split(/\s+/))),l.tooltip&&(k=l.tooltip)),m+='<span class="'+j.join(" ")+'"'+(k?' title="'+k+'"':"")+">"+t+"</span>";o.find(".datepicker-switch").text(p+"-"+q),o.find("td").html(m)},fill:function(){var d,e,f=new Date(this.viewDate),g=f.getUTCFullYear(),h=f.getUTCMonth(),i=this.o.startDate!==-(1/0)?this.o.startDate.getUTCFullYear():-(1/0),j=this.o.startDate!==-(1/0)?this.o.startDate.getUTCMonth():-(1/0),k=this.o.endDate!==1/0?this.o.endDate.getUTCFullYear():1/0,l=this.o.endDate!==1/0?this.o.endDate.getUTCMonth():1/0,m=q[this.o.language].today||q.en.today||"",n=q[this.o.language].clear||q.en.clear||"",o=q[this.o.language].titleFormat||q.en.titleFormat;if(!isNaN(g)&&!isNaN(h)){this.picker.find(".datepicker-days .datepicker-switch").text(r.formatDate(f,o,this.o.language)),this.picker.find("tfoot .today").text(m).css("display",this.o.todayBtn===!0||"linked"===this.o.todayBtn?"table-cell":"none"),this.picker.find("tfoot .clear").text(n).css("display",this.o.clearBtn===!0?"table-cell":"none"),this.picker.find("thead .datepicker-title").text(this.o.title).css("display","string"==typeof this.o.title&&""!==this.o.title?"table-cell":"none"),this.updateNavArrows(),this.fillMonths();var p=c(g,h,0),s=p.getUTCDate();p.setUTCDate(s-(p.getUTCDay()-this.o.weekStart+7)%7);var t=new Date(p);p.getUTCFullYear()<100&&t.setUTCFullYear(p.getUTCFullYear()),t.setUTCDate(t.getUTCDate()+42),t=t.valueOf();for(var u,v,w=[];p.valueOf()<t;){if(u=p.getUTCDay(),u===this.o.weekStart&&(w.push("<tr>"),this.o.calendarWeeks)){var x=new Date(+p+(this.o.weekStart-u-7)%7*864e5),y=new Date(Number(x)+(11-x.getUTCDay())%7*864e5),z=new Date(Number(z=c(y.getUTCFullYear(),0,1))+(11-z.getUTCDay())%7*864e5),A=(y-z)/864e5/7+1;w.push('<td class="cw">'+A+"</td>")}v=this.getClassNames(p),v.push("day");var B=p.getUTCDate();this.o.beforeShowDay!==a.noop&&(e=this.o.beforeShowDay(this._utc_to_local(p)),e===b?e={}:"boolean"==typeof e?e={enabled:e}:"string"==typeof e&&(e={classes:e}),e.enabled===!1&&v.push("disabled"),e.classes&&(v=v.concat(e.classes.split(/\s+/))),e.tooltip&&(d=e.tooltip),e.content&&(B=e.content)),v=a.isFunction(a.uniqueSort)?a.uniqueSort(v):a.unique(v),w.push('<td class="'+v.join(" ")+'"'+(d?' title="'+d+'"':"")+' data-date="'+p.getTime().toString()+'">'+B+"</td>"),d=null,u===this.o.weekEnd&&w.push("</tr>"),p.setUTCDate(p.getUTCDate()+1)}this.picker.find(".datepicker-days tbody").html(w.join(""));var C=q[this.o.language].monthsTitle||q.en.monthsTitle||"Months",D=this.picker.find(".datepicker-months").find(".datepicker-switch").text(this.o.maxViewMode<2?C:g).end().find("tbody span").removeClass("active");if(a.each(this.dates,function(a,b){b.getUTCFullYear()===g&&D.eq(b.getUTCMonth()).addClass("active")}),(g<i||g>k)&&D.addClass("disabled"),g===i&&D.slice(0,j).addClass("disabled"),g===k&&D.slice(l+1).addClass("disabled"),this.o.beforeShowMonth!==a.noop){var E=this;a.each(D,function(c,d){var e=new Date(g,c,1),f=E.o.beforeShowMonth(e);f===b?f={}:"boolean"==typeof f?f={enabled:f}:"string"==typeof f&&(f={classes:f}),f.enabled!==!1||a(d).hasClass("disabled")||a(d).addClass("disabled"),f.classes&&a(d).addClass(f.classes),f.tooltip&&a(d).prop("title",f.tooltip)})}this._fill_yearsView(".datepicker-years","year",10,g,i,k,this.o.beforeShowYear),this._fill_yearsView(".datepicker-decades","decade",100,g,i,k,this.o.beforeShowDecade),this._fill_yearsView(".datepicker-centuries","century",1e3,g,i,k,this.o.beforeShowCentury)}},updateNavArrows:function(){if(this._allow_update){var a,b,c=new Date(this.viewDate),d=c.getUTCFullYear(),e=c.getUTCMonth(),f=this.o.startDate!==-(1/0)?this.o.startDate.getUTCFullYear():-(1/0),g=this.o.startDate!==-(1/0)?this.o.startDate.getUTCMonth():-(1/0),h=this.o.endDate!==1/0?this.o.endDate.getUTCFullYear():1/0,i=this.o.endDate!==1/0?this.o.endDate.getUTCMonth():1/0,j=1;switch(this.viewMode){case 0:a=d<=f&&e<=g,b=d>=h&&e>=i;break;case 4:j*=10;case 3:j*=10;case 2:j*=10;case 1:a=Math.floor(d/j)*j<=f,b=Math.floor(d/j)*j+j>=h}this.picker.find(".prev").toggleClass("disabled",a),this.picker.find(".next").toggleClass("disabled",b)}},click:function(b){b.preventDefault(),b.stopPropagation();var e,f,g,h;e=a(b.target),e.hasClass("datepicker-switch")&&this.viewMode!==this.o.maxViewMode&&this.setViewMode(this.viewMode+1),e.hasClass("today")&&!e.hasClass("day")&&(this.setViewMode(0),this._setDate(d(),"linked"===this.o.todayBtn?null:"view")),e.hasClass("clear")&&this.clearDates(),e.hasClass("disabled")||(e.hasClass("month")||e.hasClass("year")||e.hasClass("decade")||e.hasClass("century"))&&(this.viewDate.setUTCDate(1),f=1,1===this.viewMode?(h=e.parent().find("span").index(e),g=this.viewDate.getUTCFullYear(),this.viewDate.setUTCMonth(h)):(h=0,g=Number(e.text()),this.viewDate.setUTCFullYear(g)),this._trigger(r.viewModes[this.viewMode-1].e,this.viewDate),this.viewMode===this.o.minViewMode?this._setDate(c(g,h,f)):(this.setViewMode(this.viewMode-1),this.fill())),this.picker.is(":visible")&&this._focused_from&&this._focused_from.focus(),delete this._focused_from},dayCellClick:function(b){var c=a(b.currentTarget),d=c.data("date"),e=new Date(d);this.o.updateViewDate&&(e.getUTCFullYear()!==this.viewDate.getUTCFullYear()&&this._trigger("changeYear",this.viewDate),e.getUTCMonth()!==this.viewDate.getUTCMonth()&&this._trigger("changeMonth",this.viewDate)),this._setDate(e)},navArrowsClick:function(b){var c=a(b.currentTarget),d=c.hasClass("prev")?-1:1;0!==this.viewMode&&(d*=12*r.viewModes[this.viewMode].navStep),this.viewDate=this.moveMonth(this.viewDate,d),this._trigger(r.viewModes[this.viewMode].e,this.viewDate),this.fill()},_toggle_multidate:function(a){var b=this.dates.contains(a);if(a||this.dates.clear(),b!==-1?(this.o.multidate===!0||this.o.multidate>1||this.o.toggleActive)&&this.dates.remove(b):this.o.multidate===!1?(this.dates.clear(),this.dates.push(a)):this.dates.push(a),"number"==typeof this.o.multidate)for(;this.dates.length>this.o.multidate;)this.dates.remove(0)},_setDate:function(a,b){b&&"date"!==b||this._toggle_multidate(a&&new Date(a)),(!b&&this.o.updateViewDate||"view"===b)&&(this.viewDate=a&&new Date(a)),this.fill(),this.setValue(),b&&"view"===b||this._trigger("changeDate"),this.inputField.trigger("change"),!this.o.autoclose||b&&"date"!==b||this.hide()},moveDay:function(a,b){var c=new Date(a);return c.setUTCDate(a.getUTCDate()+b),c},moveWeek:function(a,b){return this.moveDay(a,7*b)},moveMonth:function(a,b){if(!g(a))return this.o.defaultViewDate;if(!b)return a;var c,d,e=new Date(a.valueOf()),f=e.getUTCDate(),h=e.getUTCMonth(),i=Math.abs(b);if(b=b>0?1:-1,1===i)d=b===-1?function(){return e.getUTCMonth()===h}:function(){return e.getUTCMonth()!==c},c=h+b,e.setUTCMonth(c),c=(c+12)%12;else{for(var j=0;j<i;j++)e=this.moveMonth(e,b);c=e.getUTCMonth(),e.setUTCDate(f),d=function(){return c!==e.getUTCMonth()}}for(;d();)e.setUTCDate(--f),e.setUTCMonth(c);return e},moveYear:function(a,b){return this.moveMonth(a,12*b)},moveAvailableDate:function(a,b,c){do{if(a=this[c](a,b),!this.dateWithinRange(a))return!1;c="moveDay"}while(this.dateIsDisabled(a));return a},weekOfDateIsDisabled:function(b){return a.inArray(b.getUTCDay(),this.o.daysOfWeekDisabled)!==-1},dateIsDisabled:function(b){return this.weekOfDateIsDisabled(b)||a.grep(this.o.datesDisabled,function(a){return e(b,a)}).length>0},dateWithinRange:function(a){return a>=this.o.startDate&&a<=this.o.endDate},keydown:function(a){if(!this.picker.is(":visible"))return void(40!==a.keyCode&&27!==a.keyCode||(this.show(),a.stopPropagation()));var b,c,d=!1,e=this.focusDate||this.viewDate;switch(a.keyCode){case 27:this.focusDate?(this.focusDate=null,this.viewDate=this.dates.get(-1)||this.viewDate,this.fill()):this.hide(),a.preventDefault(),a.stopPropagation();break;case 37:case 38:case 39:case 40:if(!this.o.keyboardNavigation||7===this.o.daysOfWeekDisabled.length)break;b=37===a.keyCode||38===a.keyCode?-1:1,0===this.viewMode?a.ctrlKey?(c=this.moveAvailableDate(e,b,"moveYear"),c&&this._trigger("changeYear",this.viewDate)):a.shiftKey?(c=this.moveAvailableDate(e,b,"moveMonth"),c&&this._trigger("changeMonth",this.viewDate)):37===a.keyCode||39===a.keyCode?c=this.moveAvailableDate(e,b,"moveDay"):this.weekOfDateIsDisabled(e)||(c=this.moveAvailableDate(e,b,"moveWeek")):1===this.viewMode?(38!==a.keyCode&&40!==a.keyCode||(b*=4),c=this.moveAvailableDate(e,b,"moveMonth")):2===this.viewMode&&(38!==a.keyCode&&40!==a.keyCode||(b*=4),c=this.moveAvailableDate(e,b,"moveYear")),c&&(this.focusDate=this.viewDate=c,this.setValue(),this.fill(),a.preventDefault());break;case 13:if(!this.o.forceParse)break;e=this.focusDate||this.dates.get(-1)||this.viewDate,this.o.keyboardNavigation&&(this._toggle_multidate(e),d=!0),this.focusDate=null,this.viewDate=this.dates.get(-1)||this.viewDate,this.setValue(),this.fill(),this.picker.is(":visible")&&(a.preventDefault(),a.stopPropagation(),this.o.autoclose&&this.hide());break;case 9:this.focusDate=null,this.viewDate=this.dates.get(-1)||this.viewDate,this.fill(),this.hide()}d&&(this.dates.length?this._trigger("changeDate"):this._trigger("clearDate"),this.inputField.trigger("change"))},setViewMode:function(a){this.viewMode=a,this.picker.children("div").hide().filter(".datepicker-"+r.viewModes[this.viewMode].clsName).show(),this.updateNavArrows(),this._trigger("changeViewMode",new Date(this.viewDate))}};var l=function(b,c){a.data(b,"datepicker",this),this.element=a(b),this.inputs=a.map(c.inputs,function(a){return a.jquery?a[0]:a}),delete c.inputs,this.keepEmptyValues=c.keepEmptyValues,delete c.keepEmptyValues,n.call(a(this.inputs),c).on("changeDate",a.proxy(this.dateUpdated,this)),this.pickers=a.map(this.inputs,function(b){return a.data(b,"datepicker")}),this.updateDates()};l.prototype={updateDates:function(){this.dates=a.map(this.pickers,function(a){return a.getUTCDate()}),this.updateRanges()},updateRanges:function(){var b=a.map(this.dates,function(a){return a.valueOf()});a.each(this.pickers,function(a,c){c.setRange(b)})},dateUpdated:function(c){if(!this.updating){this.updating=!0;var d=a.data(c.target,"datepicker");if(d!==b){var e=d.getUTCDate(),f=this.keepEmptyValues,g=a.inArray(c.target,this.inputs),h=g-1,i=g+1,j=this.inputs.length;if(g!==-1){if(a.each(this.pickers,function(a,b){b.getUTCDate()||b!==d&&f||b.setUTCDate(e)}),e<this.dates[h])for(;h>=0&&e<this.dates[h];)this.pickers[h--].setUTCDate(e);else if(e>this.dates[i])for(;i<j&&e>this.dates[i];)this.pickers[i++].setUTCDate(e);this.updateDates(),delete this.updating}}}},destroy:function(){a.map(this.pickers,function(a){a.destroy()}),a(this.inputs).off("changeDate",this.dateUpdated),delete this.element.data().datepicker},remove:f("destroy","Method `remove` is deprecated and will be removed in version 2.0. Use `destroy` instead")};var m=a.fn.datepicker,n=function(c){var d=Array.apply(null,arguments);d.shift();var e;if(this.each(function(){var b=a(this),f=b.data("datepicker"),g="object"==typeof c&&c;if(!f){var j=h(this,"date"),m=a.extend({},o,j,g),n=i(m.language),p=a.extend({},o,n,j,g);b.hasClass("input-daterange")||p.inputs?(a.extend(p,{inputs:p.inputs||b.find("input").toArray()}),f=new l(this,p)):f=new k(this,p),b.data("datepicker",f)}"string"==typeof c&&"function"==typeof f[c]&&(e=f[c].apply(f,d))}),e===b||e instanceof k||e instanceof l)return this;if(this.length>1)throw new Error("Using only allowed for the collection of a single element ("+c+" function)");return e};a.fn.datepicker=n;var o=a.fn.datepicker.defaults={assumeNearbyYear:!1,autoclose:!1,beforeShowDay:a.noop,beforeShowMonth:a.noop,beforeShowYear:a.noop,beforeShowDecade:a.noop,beforeShowCentury:a.noop,calendarWeeks:!1,clearBtn:!1,toggleActive:!1,daysOfWeekDisabled:[],daysOfWeekHighlighted:[],datesDisabled:[],endDate:1/0,forceParse:!0,format:"mm/dd/yyyy",keepEmptyValues:!1,keyboardNavigation:!0,language:"en",minViewMode:0,maxViewMode:4,multidate:!1,multidateSeparator:",",orientation:"auto",rtl:!1,startDate:-(1/0),startView:0,todayBtn:!1,todayHighlight:!1,updateViewDate:!0,weekStart:0,disableTouchKeyboard:!1,enableOnReadonly:!0,showOnFocus:!0,zIndexOffset:10,container:"body",immediateUpdates:!1,title:"",templates:{leftArrow:"&#x00AB;",rightArrow:"&#x00BB;"},showWeekDays:!0},p=a.fn.datepicker.locale_opts=["format","rtl","weekStart"];a.fn.datepicker.Constructor=k;var q=a.fn.datepicker.dates={en:{days:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],daysShort:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],daysMin:["Su","Mo","Tu","We","Th","Fr","Sa"],months:["January","February","March","April","May","June","July","August","September","October","November","December"],monthsShort:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],today:"Today",clear:"Clear",titleFormat:"MM yyyy"}},r={viewModes:[{names:["days","month"],clsName:"days",e:"changeMonth"},{names:["months","year"],clsName:"months",e:"changeYear",navStep:1},{names:["years","decade"],clsName:"years",e:"changeDecade",navStep:10},{names:["decades","century"],clsName:"decades",e:"changeCentury",navStep:100},{names:["centuries","millennium"],clsName:"centuries",e:"changeMillennium",navStep:1e3}],validParts:/dd?|DD?|mm?|MM?|yy(?:yy)?/g,nonpunctuation:/[^ -\/:-@\u5e74\u6708\u65e5\[-`{-~\t\n\r]+/g,parseFormat:function(a){if("function"==typeof a.toValue&&"function"==typeof a.toDisplay)return a;var b=a.replace(this.validParts,"\0").split("\0"),c=a.match(this.validParts);if(!b||!b.length||!c||0===c.length)throw new Error("Invalid date format.");return{separators:b,parts:c}},parseDate:function(c,e,f,g){function h(a,b){return b===!0&&(b=10),a<100&&(a+=2e3,a>(new Date).getFullYear()+b&&(a-=100)),a}function i(){var a=this.slice(0,j[n].length),b=j[n].slice(0,a.length);return a.toLowerCase()===b.toLowerCase()}if(!c)return b;if(c instanceof Date)return c;if("string"==typeof e&&(e=r.parseFormat(e)),e.toValue)return e.toValue(c,e,f);var j,l,m,n,o,p={d:"moveDay",m:"moveMonth",w:"moveWeek",y:"moveYear"},s={yesterday:"-1d",today:"+0d",tomorrow:"+1d"};if(c in s&&(c=s[c]),/^[\-+]\d+[dmwy]([\s,]+[\-+]\d+[dmwy])*$/i.test(c)){for(j=c.match(/([\-+]\d+)([dmwy])/gi),c=new Date,n=0;n<j.length;n++)l=j[n].match(/([\-+]\d+)([dmwy])/i),m=Number(l[1]),o=p[l[2].toLowerCase()],c=k.prototype[o](c,m);return k.prototype._zero_utc_time(c)}j=c&&c.match(this.nonpunctuation)||[];var t,u,v={},w=["yyyy","yy","M","MM","m","mm","d","dd"],x={yyyy:function(a,b){return a.setUTCFullYear(g?h(b,g):b)},m:function(a,b){if(isNaN(a))return a;for(b-=1;b<0;)b+=12;for(b%=12,a.setUTCMonth(b);a.getUTCMonth()!==b;)a.setUTCDate(a.getUTCDate()-1);return a},d:function(a,b){return a.setUTCDate(b)}};x.yy=x.yyyy,x.M=x.MM=x.mm=x.m,x.dd=x.d,c=d();var y=e.parts.slice();if(j.length!==y.length&&(y=a(y).filter(function(b,c){return a.inArray(c,w)!==-1}).toArray()),j.length===y.length){var z;for(n=0,z=y.length;n<z;n++){if(t=parseInt(j[n],10),l=y[n],isNaN(t))switch(l){case"MM":u=a(q[f].months).filter(i),t=a.inArray(u[0],q[f].months)+1;break;case"M":u=a(q[f].monthsShort).filter(i),t=a.inArray(u[0],q[f].monthsShort)+1}v[l]=t}var A,B;for(n=0;n<w.length;n++)B=w[n],B in v&&!isNaN(v[B])&&(A=new Date(c),x[B](A,v[B]),isNaN(A)||(c=A))}return c},formatDate:function(b,c,d){if(!b)return"";if("string"==typeof c&&(c=r.parseFormat(c)),c.toDisplay)return c.toDisplay(b,c,d);var e={d:b.getUTCDate(),D:q[d].daysShort[b.getUTCDay()],DD:q[d].days[b.getUTCDay()],m:b.getUTCMonth()+1,M:q[d].monthsShort[b.getUTCMonth()],MM:q[d].months[b.getUTCMonth()],yy:b.getUTCFullYear().toString().substring(2),yyyy:b.getUTCFullYear()};e.dd=(e.d<10?"0":"")+e.d,e.mm=(e.m<10?"0":"")+e.m,b=[];for(var f=a.extend([],c.separators),g=0,h=c.parts.length;g<=h;g++)f.length&&b.push(f.shift()),b.push(e[c.parts[g]]);return b.join("")},headTemplate:'<thead><tr><th colspan="7" class="datepicker-title"></th></tr><tr><th class="prev">'+o.templates.leftArrow+'</th><th colspan="5" class="datepicker-switch"></th><th class="next">'+o.templates.rightArrow+"</th></tr></thead>",
contTemplate:'<tbody><tr><td colspan="7"></td></tr></tbody>',footTemplate:'<tfoot><tr><th colspan="7" class="today"></th></tr><tr><th colspan="7" class="clear"></th></tr></tfoot>'};r.template='<div class="datepicker"><div class="datepicker-days"><table class="table-condensed">'+r.headTemplate+"<tbody></tbody>"+r.footTemplate+'</table></div><div class="datepicker-months"><table class="table-condensed">'+r.headTemplate+r.contTemplate+r.footTemplate+'</table></div><div class="datepicker-years"><table class="table-condensed">'+r.headTemplate+r.contTemplate+r.footTemplate+'</table></div><div class="datepicker-decades"><table class="table-condensed">'+r.headTemplate+r.contTemplate+r.footTemplate+'</table></div><div class="datepicker-centuries"><table class="table-condensed">'+r.headTemplate+r.contTemplate+r.footTemplate+"</table></div></div>",a.fn.datepicker.DPGlobal=r,a.fn.datepicker.noConflict=function(){return a.fn.datepicker=m,this},a.fn.datepicker.version="1.7.1",a.fn.datepicker.deprecated=function(a){var b=window.console;b&&b.warn&&b.warn("DEPRECATED: "+a)},a(document).on("focus.datepicker.data-api click.datepicker.data-api",'[data-provide="datepicker"]',function(b){var c=a(this);c.data("datepicker")||(b.preventDefault(),n.call(c,"show"))}),a(function(){n.call(a('[data-provide="datepicker-inline"]'))})});
(function(a){if(typeof define==="function"&&define.amd){define(["jquery"],a)}else{if(typeof exports==="object"){a(require("jquery"))}else{a(jQuery)}}}(function(d,f){if(!("indexOf" in Array.prototype)){Array.prototype.indexOf=function(k,j){if(j===f){j=0}if(j<0){j+=this.length}if(j<0){j=0}for(var l=this.length;j<l;j++){if(j in this&&this[j]===k){return j}}return -1}}function a(){var q,k,p,l,j,n,m,o;k=(new Date()).toString();p=((m=k.split("(")[1])!=null?m.slice(0,-1):0)||k.split(" ");if(p instanceof Array){n=[];for(var l=0,j=p.length;l<j;l++){o=p[l];if((q=(m=o.match(/\b[A-Z]+\b/))!==null)?m[0]:0){n.push(q)}}p=n.pop()}return p}function h(){return new Date(Date.UTC.apply(Date,arguments))}var g=function(k,j){var m=this;this.element=d(k);this.container=j.container||"body";this.language=j.language||this.element.data("date-language")||"en";this.language=this.language in e?this.language:this.language.split("-")[0];this.language=this.language in e?this.language:"en";this.isRTL=e[this.language].rtl||false;this.formatType=j.formatType||this.element.data("format-type")||"standard";this.format=c.parseFormat(j.format||this.element.data("date-format")||e[this.language].format||c.getDefaultFormat(this.formatType,"input"),this.formatType);this.isInline=false;this.isVisible=false;this.isInput=this.element.is("input");this.fontAwesome=j.fontAwesome||this.element.data("font-awesome")||false;this.bootcssVer=j.bootcssVer||(this.isInput?(this.element.is(".form-control")?3:2):(this.bootcssVer=this.element.is(".input-group")?3:2));this.component=this.element.is(".date")?(this.bootcssVer===3?this.element.find(".input-group-addon .glyphicon-th, .input-group-addon .glyphicon-time, .input-group-addon .glyphicon-remove, .input-group-addon .glyphicon-calendar, .input-group-addon .fa-calendar, .input-group-addon .fa-clock-o").parent():this.element.find(".add-on .icon-th, .add-on .icon-time, .add-on .icon-calendar, .add-on .fa-calendar, .add-on .fa-clock-o").parent()):false;this.componentReset=this.element.is(".date")?(this.bootcssVer===3?this.element.find(".input-group-addon .glyphicon-remove, .input-group-addon .fa-times").parent():this.element.find(".add-on .icon-remove, .add-on .fa-times").parent()):false;this.hasInput=this.component&&this.element.find("input").length;if(this.component&&this.component.length===0){this.component=false}this.linkField=j.linkField||this.element.data("link-field")||false;this.linkFormat=c.parseFormat(j.linkFormat||this.element.data("link-format")||c.getDefaultFormat(this.formatType,"link"),this.formatType);this.minuteStep=j.minuteStep||this.element.data("minute-step")||5;this.pickerPosition=j.pickerPosition||this.element.data("picker-position")||"bottom-right";this.showMeridian=j.showMeridian||this.element.data("show-meridian")||false;this.initialDate=j.initialDate||new Date();this.zIndex=j.zIndex||this.element.data("z-index")||f;this.title=typeof j.title==="undefined"?false:j.title;this.timezone=j.timezone||a();this.icons={leftArrow:this.fontAwesome?"fa-arrow-left":(this.bootcssVer===3?"glyphicon-arrow-left":"icon-arrow-left"),rightArrow:this.fontAwesome?"fa-arrow-right":(this.bootcssVer===3?"glyphicon-arrow-right":"icon-arrow-right")};this.icontype=this.fontAwesome?"fa":"glyphicon";this._attachEvents();this.clickedOutside=function(n){if(d(n.target).closest(".datetimepicker").length===0){m.hide()}};this.formatViewType="datetime";if("formatViewType" in j){this.formatViewType=j.formatViewType}else{if("formatViewType" in this.element.data()){this.formatViewType=this.element.data("formatViewType")}}this.minView=0;if("minView" in j){this.minView=j.minView}else{if("minView" in this.element.data()){this.minView=this.element.data("min-view")}}this.minView=c.convertViewMode(this.minView);this.maxView=c.modes.length-1;if("maxView" in j){this.maxView=j.maxView}else{if("maxView" in this.element.data()){this.maxView=this.element.data("max-view")}}this.maxView=c.convertViewMode(this.maxView);this.wheelViewModeNavigation=false;if("wheelViewModeNavigation" in j){this.wheelViewModeNavigation=j.wheelViewModeNavigation}else{if("wheelViewModeNavigation" in this.element.data()){this.wheelViewModeNavigation=this.element.data("view-mode-wheel-navigation")}}this.wheelViewModeNavigationInverseDirection=false;if("wheelViewModeNavigationInverseDirection" in j){this.wheelViewModeNavigationInverseDirection=j.wheelViewModeNavigationInverseDirection}else{if("wheelViewModeNavigationInverseDirection" in this.element.data()){this.wheelViewModeNavigationInverseDirection=this.element.data("view-mode-wheel-navigation-inverse-dir")}}this.wheelViewModeNavigationDelay=100;if("wheelViewModeNavigationDelay" in j){this.wheelViewModeNavigationDelay=j.wheelViewModeNavigationDelay}else{if("wheelViewModeNavigationDelay" in this.element.data()){this.wheelViewModeNavigationDelay=this.element.data("view-mode-wheel-navigation-delay")}}this.startViewMode=2;if("startView" in j){this.startViewMode=j.startView}else{if("startView" in this.element.data()){this.startViewMode=this.element.data("start-view")}}this.startViewMode=c.convertViewMode(this.startViewMode);this.viewMode=this.startViewMode;this.viewSelect=this.minView;if("viewSelect" in j){this.viewSelect=j.viewSelect}else{if("viewSelect" in this.element.data()){this.viewSelect=this.element.data("view-select")}}this.viewSelect=c.convertViewMode(this.viewSelect);this.forceParse=true;if("forceParse" in j){this.forceParse=j.forceParse}else{if("dateForceParse" in this.element.data()){this.forceParse=this.element.data("date-force-parse")}}var l=this.bootcssVer===3?c.templateV3:c.template;while(l.indexOf("{iconType}")!==-1){l=l.replace("{iconType}",this.icontype)}while(l.indexOf("{leftArrow}")!==-1){l=l.replace("{leftArrow}",this.icons.leftArrow)}while(l.indexOf("{rightArrow}")!==-1){l=l.replace("{rightArrow}",this.icons.rightArrow)}this.picker=d(l).appendTo(this.isInline?this.element:this.container).on({click:d.proxy(this.click,this),mousedown:d.proxy(this.mousedown,this)});if(this.wheelViewModeNavigation){if(d.fn.mousewheel){this.picker.on({mousewheel:d.proxy(this.mousewheel,this)})}else{console.log("Mouse Wheel event is not supported. Please include the jQuery Mouse Wheel plugin before enabling this option")}}if(this.isInline){this.picker.addClass("datetimepicker-inline")}else{this.picker.addClass("datetimepicker-dropdown-"+this.pickerPosition+" dropdown-menu")}if(this.isRTL){this.picker.addClass("datetimepicker-rtl");var i=this.bootcssVer===3?".prev span, .next span":".prev i, .next i";this.picker.find(i).toggleClass(this.icons.leftArrow+" "+this.icons.rightArrow)}d(document).on("mousedown touchend",this.clickedOutside);this.autoclose=false;if("autoclose" in j){this.autoclose=j.autoclose}else{if("dateAutoclose" in this.element.data()){this.autoclose=this.element.data("date-autoclose")}}this.keyboardNavigation=true;if("keyboardNavigation" in j){this.keyboardNavigation=j.keyboardNavigation}else{if("dateKeyboardNavigation" in this.element.data()){this.keyboardNavigation=this.element.data("date-keyboard-navigation")}}this.todayBtn=(j.todayBtn||this.element.data("date-today-btn")||false);this.clearBtn=(j.clearBtn||this.element.data("date-clear-btn")||false);this.todayHighlight=(j.todayHighlight||this.element.data("date-today-highlight")||false);this.weekStart=0;if(typeof j.weekStart!=="undefined"){this.weekStart=j.weekStart}else{if(typeof this.element.data("date-weekstart")!=="undefined"){this.weekStart=this.element.data("date-weekstart")}else{if(typeof e[this.language].weekStart!=="undefined"){this.weekStart=e[this.language].weekStart}}}this.weekStart=this.weekStart%7;this.weekEnd=((this.weekStart+6)%7);this.onRenderDay=function(n){var p=(j.onRenderDay||function(){return[]})(n);if(typeof p==="string"){p=[p]}var o=["day"];return o.concat((p?p:[]))};this.onRenderHour=function(n){var p=(j.onRenderHour||function(){return[]})(n);var o=["hour"];if(typeof p==="string"){p=[p]}return o.concat((p?p:[]))};this.onRenderMinute=function(n){var p=(j.onRenderMinute||function(){return[]})(n);var o=["minute"];if(typeof p==="string"){p=[p]}if(n<this.startDate||n>this.endDate){o.push("disabled")}else{if(Math.floor(this.date.getUTCMinutes()/this.minuteStep)===Math.floor(n.getUTCMinutes()/this.minuteStep)){o.push("active")}}return o.concat((p?p:[]))};this.onRenderYear=function(o){var q=(j.onRenderYear||function(){return[]})(o);var p=["year"];if(typeof q==="string"){q=[q]}if(this.date.getUTCFullYear()===o.getUTCFullYear()){p.push("active")}var n=o.getUTCFullYear();var r=this.endDate.getUTCFullYear();if(o<this.startDate||n>r){p.push("disabled")}return p.concat((q?q:[]))};this.onRenderMonth=function(n){var p=(j.onRenderMonth||function(){return[]})(n);var o=["month"];if(typeof p==="string"){p=[p]}return o.concat((p?p:[]))};this.startDate=new Date(-8639968443048000);this.endDate=new Date(8639968443048000);this.datesDisabled=[];this.daysOfWeekDisabled=[];this.setStartDate(j.startDate||this.element.data("date-startdate"));this.setEndDate(j.endDate||this.element.data("date-enddate"));this.setDatesDisabled(j.datesDisabled||this.element.data("date-dates-disabled"));this.setDaysOfWeekDisabled(j.daysOfWeekDisabled||this.element.data("date-days-of-week-disabled"));this.setMinutesDisabled(j.minutesDisabled||this.element.data("date-minute-disabled"));this.setHoursDisabled(j.hoursDisabled||this.element.data("date-hour-disabled"));this.fillDow();this.fillMonths();this.update();this.showMode();if(this.isInline){this.show()}};g.prototype={constructor:g,_events:[],_attachEvents:function(){this._detachEvents();if(this.isInput){this._events=[[this.element,{focus:d.proxy(this.show,this),keyup:d.proxy(this.update,this),keydown:d.proxy(this.keydown,this)}]]}else{if(this.component&&this.hasInput){this._events=[[this.element.find("input"),{focus:d.proxy(this.show,this),keyup:d.proxy(this.update,this),keydown:d.proxy(this.keydown,this)}],[this.component,{click:d.proxy(this.show,this)}]];if(this.componentReset){this._events.push([this.componentReset,{click:d.proxy(this.reset,this)}])}}else{if(this.element.is("div")){this.isInline=true}else{this._events=[[this.element,{click:d.proxy(this.show,this)}]]}}}for(var j=0,k,l;j<this._events.length;j++){k=this._events[j][0];l=this._events[j][1];k.on(l)}},_detachEvents:function(){for(var j=0,k,l;j<this._events.length;j++){k=this._events[j][0];l=this._events[j][1];k.off(l)}this._events=[]},show:function(i){this.picker.show();this.height=this.component?this.component.outerHeight():this.element.outerHeight();if(this.forceParse){this.update()}this.place();d(window).on("resize",d.proxy(this.place,this));if(i){i.stopPropagation();i.preventDefault()}this.isVisible=true;this.element.trigger({type:"show",date:this.date})},hide:function(){if(!this.isVisible){return}if(this.isInline){return}this.picker.hide();d(window).off("resize",this.place);this.viewMode=this.startViewMode;this.showMode();if(!this.isInput){d(document).off("mousedown",this.hide)}if(this.forceParse&&(this.isInput&&this.element.val()||this.hasInput&&this.element.find("input").val())){this.setValue()}this.isVisible=false;this.element.trigger({type:"hide",date:this.date})},remove:function(){this._detachEvents();d(document).off("mousedown",this.clickedOutside);this.picker.remove();delete this.picker;delete this.element.data().datetimepicker},getDate:function(){var i=this.getUTCDate();if(i===null){return null}return new Date(i.getTime()+(i.getTimezoneOffset()*60000))},getUTCDate:function(){return this.date},getInitialDate:function(){return this.initialDate},setInitialDate:function(i){this.initialDate=i},setDate:function(i){this.setUTCDate(new Date(i.getTime()-(i.getTimezoneOffset()*60000)))},setUTCDate:function(i){if(i>=this.startDate&&i<=this.endDate){this.date=i;this.setValue();this.viewDate=this.date;this.fill()}else{this.element.trigger({type:"outOfRange",date:i,startDate:this.startDate,endDate:this.endDate})}},setFormat:function(j){this.format=c.parseFormat(j,this.formatType);var i;if(this.isInput){i=this.element}else{if(this.component){i=this.element.find("input")}}if(i&&i.val()){this.setValue()}},setValue:function(){var i=this.getFormattedDate();if(!this.isInput){if(this.component){this.element.find("input").val(i)}this.element.data("date",i)}else{this.element.val(i)}if(this.linkField){d("#"+this.linkField).val(this.getFormattedDate(this.linkFormat))}},getFormattedDate:function(i){i=i||this.format;return c.formatDate(this.date,i,this.language,this.formatType,this.timezone)},setStartDate:function(i){this.startDate=i||this.startDate;if(this.startDate.valueOf()!==8639968443048000){this.startDate=c.parseDate(this.startDate,this.format,this.language,this.formatType,this.timezone)}this.update();this.updateNavArrows()},setEndDate:function(i){this.endDate=i||this.endDate;if(this.endDate.valueOf()!==8639968443048000){this.endDate=c.parseDate(this.endDate,this.format,this.language,this.formatType,this.timezone)}this.update();this.updateNavArrows()},setDatesDisabled:function(j){this.datesDisabled=j||[];if(!d.isArray(this.datesDisabled)){this.datesDisabled=this.datesDisabled.split(/,\s*/)}var i=this;this.datesDisabled=d.map(this.datesDisabled,function(k){return c.parseDate(k,i.format,i.language,i.formatType,i.timezone).toDateString()});this.update();this.updateNavArrows()},setTitle:function(i,j){return this.picker.find(i).find("th:eq(1)").text(this.title===false?j:this.title)},setDaysOfWeekDisabled:function(i){this.daysOfWeekDisabled=i||[];if(!d.isArray(this.daysOfWeekDisabled)){this.daysOfWeekDisabled=this.daysOfWeekDisabled.split(/,\s*/)}this.daysOfWeekDisabled=d.map(this.daysOfWeekDisabled,function(j){return parseInt(j,10)});this.update();this.updateNavArrows()},setMinutesDisabled:function(i){this.minutesDisabled=i||[];if(!d.isArray(this.minutesDisabled)){this.minutesDisabled=this.minutesDisabled.split(/,\s*/)}this.minutesDisabled=d.map(this.minutesDisabled,function(j){return parseInt(j,10)});this.update();this.updateNavArrows()},setHoursDisabled:function(i){this.hoursDisabled=i||[];if(!d.isArray(this.hoursDisabled)){this.hoursDisabled=this.hoursDisabled.split(/,\s*/)}this.hoursDisabled=d.map(this.hoursDisabled,function(j){return parseInt(j,10)});this.update();this.updateNavArrows()},place:function(){if(this.isInline){return}if(!this.zIndex){var j=0;d("div").each(function(){var o=parseInt(d(this).css("zIndex"),10);if(o>j){j=o}});this.zIndex=j+10}var n,m,l,k;if(this.container instanceof d){k=this.container.offset()}else{k=d(this.container).offset()}if(this.component){n=this.component.offset();l=n.left;if(this.pickerPosition==="bottom-left"||this.pickerPosition==="top-left"){l+=this.component.outerWidth()-this.picker.outerWidth()}}else{n=this.element.offset();l=n.left;if(this.pickerPosition==="bottom-left"||this.pickerPosition==="top-left"){l+=this.element.outerWidth()-this.picker.outerWidth()}}var i=document.body.clientWidth||window.innerWidth;if(l+220>i){l=i-220}if(this.pickerPosition==="top-left"||this.pickerPosition==="top-right"){m=n.top-this.picker.outerHeight()}else{m=n.top+this.height}m=m-k.top;l=l-k.left;this.picker.css({top:m,left:l,zIndex:this.zIndex})},hour_minute:"^([0-9]|0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]",update:function(){var i,j=false;if(arguments&&arguments.length&&(typeof arguments[0]==="string"||arguments[0] instanceof Date)){i=arguments[0];j=true}else{i=(this.isInput?this.element.val():this.element.find("input").val())||this.element.data("date")||this.initialDate;if(typeof i==="string"){i=i.replace(/^\s+|\s+$/g,"")}}if(!i){i=new Date();j=false}if(typeof i==="string"){if(new RegExp(this.hour_minute).test(i)||new RegExp(this.hour_minute+":[0-5][0-9]").test(i)){i=this.getDate()}}this.date=c.parseDate(i,this.format,this.language,this.formatType,this.timezone);if(j){this.setValue()}if(this.date<this.startDate){this.viewDate=new Date(this.startDate)}else{if(this.date>this.endDate){this.viewDate=new Date(this.endDate)}else{this.viewDate=new Date(this.date)}}this.fill()},fillDow:function(){var i=this.weekStart,j="<tr>";while(i<this.weekStart+7){j+='<th class="dow">'+e[this.language].daysMin[(i++)%7]+"</th>"}j+="</tr>";this.picker.find(".datetimepicker-days thead").append(j)},fillMonths:function(){var l="";var m=new Date(this.viewDate);for(var k=0;k<12;k++){m.setUTCMonth(k);var j=this.onRenderMonth(m);l+='<span class="'+j.join(" ")+'">'+e[this.language].monthsShort[k]+"</span>"}this.picker.find(".datetimepicker-months td").html(l)},fill:function(){if(!this.date||!this.viewDate){return}var E=new Date(this.viewDate),t=E.getUTCFullYear(),G=E.getUTCMonth(),n=E.getUTCDate(),A=E.getUTCHours(),w=this.startDate.getUTCFullYear(),B=this.startDate.getUTCMonth(),p=this.endDate.getUTCFullYear(),x=this.endDate.getUTCMonth()+1,q=(new h(this.date.getUTCFullYear(),this.date.getUTCMonth(),this.date.getUTCDate())).valueOf(),D=new Date();this.setTitle(".datetimepicker-days",e[this.language].months[G]+" "+t);if(this.formatViewType==="time"){var k=this.getFormattedDate();this.setTitle(".datetimepicker-hours",k);this.setTitle(".datetimepicker-minutes",k)}else{this.setTitle(".datetimepicker-hours",n+" "+e[this.language].months[G]+" "+t);this.setTitle(".datetimepicker-minutes",n+" "+e[this.language].months[G]+" "+t)}this.picker.find("tfoot th.today").text(e[this.language].today||e.en.today).toggle(this.todayBtn!==false);this.picker.find("tfoot th.clear").text(e[this.language].clear||e.en.clear).toggle(this.clearBtn!==false);this.updateNavArrows();this.fillMonths();var I=h(t,G-1,28,0,0,0,0),z=c.getDaysInMonth(I.getUTCFullYear(),I.getUTCMonth());I.setUTCDate(z);I.setUTCDate(z-(I.getUTCDay()-this.weekStart+7)%7);var j=new Date(I);j.setUTCDate(j.getUTCDate()+42);j=j.valueOf();var r=[];var F;while(I.valueOf()<j){if(I.getUTCDay()===this.weekStart){r.push("<tr>")}F=this.onRenderDay(I);if(I.getUTCFullYear()<t||(I.getUTCFullYear()===t&&I.getUTCMonth()<G)){F.push("old")}else{if(I.getUTCFullYear()>t||(I.getUTCFullYear()===t&&I.getUTCMonth()>G)){F.push("new")}}if(this.todayHighlight&&I.getUTCFullYear()===D.getFullYear()&&I.getUTCMonth()===D.getMonth()&&I.getUTCDate()===D.getDate()){F.push("today")}if(I.valueOf()===q){F.push("active")}if((I.valueOf()+86400000)<=this.startDate||I.valueOf()>this.endDate||d.inArray(I.getUTCDay(),this.daysOfWeekDisabled)!==-1||d.inArray(I.toDateString(),this.datesDisabled)!==-1){F.push("disabled")}r.push('<td class="'+F.join(" ")+'">'+I.getUTCDate()+"</td>");if(I.getUTCDay()===this.weekEnd){r.push("</tr>")}I.setUTCDate(I.getUTCDate()+1)}this.picker.find(".datetimepicker-days tbody").empty().append(r.join(""));r=[];var u="",C="",s="";var l=this.hoursDisabled||[];E=new Date(this.viewDate);for(var y=0;y<24;y++){E.setUTCHours(y);F=this.onRenderHour(E);if(l.indexOf(y)!==-1){F.push("disabled")}var v=h(t,G,n,y);if((v.valueOf()+3600000)<=this.startDate||v.valueOf()>this.endDate){F.push("disabled")}else{if(A===y){F.push("active")}}if(this.showMeridian&&e[this.language].meridiem.length===2){C=(y<12?e[this.language].meridiem[0]:e[this.language].meridiem[1]);if(C!==s){if(s!==""){r.push("</fieldset>")}r.push('<fieldset class="hour"><legend>'+C.toUpperCase()+"</legend>")}s=C;u=(y%12?y%12:12);if(y<12){F.push("hour_am")}else{F.push("hour_pm")}r.push('<span class="'+F.join(" ")+'">'+u+"</span>");if(y===23){r.push("</fieldset>")}}else{u=y+":00";r.push('<span class="'+F.join(" ")+'">'+u+"</span>")}}this.picker.find(".datetimepicker-hours td").html(r.join(""));r=[];u="";C="";s="";var m=this.minutesDisabled||[];E=new Date(this.viewDate);for(var y=0;y<60;y+=this.minuteStep){if(m.indexOf(y)!==-1){continue}E.setUTCMinutes(y);E.setUTCSeconds(0);F=this.onRenderMinute(E);if(this.showMeridian&&e[this.language].meridiem.length===2){C=(A<12?e[this.language].meridiem[0]:e[this.language].meridiem[1]);if(C!==s){if(s!==""){r.push("</fieldset>")}r.push('<fieldset class="minute"><legend>'+C.toUpperCase()+"</legend>")}s=C;u=(A%12?A%12:12);r.push('<span class="'+F.join(" ")+'">'+u+":"+(y<10?"0"+y:y)+"</span>");if(y===59){r.push("</fieldset>")}}else{u=y+":00";r.push('<span class="'+F.join(" ")+'">'+A+":"+(y<10?"0"+y:y)+"</span>")}}this.picker.find(".datetimepicker-minutes td").html(r.join(""));var J=this.date.getUTCFullYear();var o=this.setTitle(".datetimepicker-months",t).end().find(".month").removeClass("active");if(J===t){o.eq(this.date.getUTCMonth()).addClass("active")}if(t<w||t>p){o.addClass("disabled")}if(t===w){o.slice(0,B).addClass("disabled")}if(t===p){o.slice(x).addClass("disabled")}r="";t=parseInt(t/10,10)*10;var H=this.setTitle(".datetimepicker-years",t+"-"+(t+9)).end().find("td");t-=1;E=new Date(this.viewDate);for(var y=-1;y<11;y++){E.setUTCFullYear(t);F=this.onRenderYear(E);if(y===-1||y===10){F.push(b)}r+='<span class="'+F.join(" ")+'">'+t+"</span>";t+=1}H.html(r);this.place()},updateNavArrows:function(){var m=new Date(this.viewDate),k=m.getUTCFullYear(),l=m.getUTCMonth(),j=m.getUTCDate(),i=m.getUTCHours();switch(this.viewMode){case 0:if(k<=this.startDate.getUTCFullYear()&&l<=this.startDate.getUTCMonth()&&j<=this.startDate.getUTCDate()&&i<=this.startDate.getUTCHours()){this.picker.find(".prev").css({visibility:"hidden"})}else{this.picker.find(".prev").css({visibility:"visible"})}if(k>=this.endDate.getUTCFullYear()&&l>=this.endDate.getUTCMonth()&&j>=this.endDate.getUTCDate()&&i>=this.endDate.getUTCHours()){this.picker.find(".next").css({visibility:"hidden"})}else{this.picker.find(".next").css({visibility:"visible"})}break;case 1:if(k<=this.startDate.getUTCFullYear()&&l<=this.startDate.getUTCMonth()&&j<=this.startDate.getUTCDate()){this.picker.find(".prev").css({visibility:"hidden"})}else{this.picker.find(".prev").css({visibility:"visible"})}if(k>=this.endDate.getUTCFullYear()&&l>=this.endDate.getUTCMonth()&&j>=this.endDate.getUTCDate()){this.picker.find(".next").css({visibility:"hidden"})}else{this.picker.find(".next").css({visibility:"visible"})}break;case 2:if(k<=this.startDate.getUTCFullYear()&&l<=this.startDate.getUTCMonth()){this.picker.find(".prev").css({visibility:"hidden"})}else{this.picker.find(".prev").css({visibility:"visible"})}if(k>=this.endDate.getUTCFullYear()&&l>=this.endDate.getUTCMonth()){this.picker.find(".next").css({visibility:"hidden"})}else{this.picker.find(".next").css({visibility:"visible"})}break;case 3:case 4:if(k<=this.startDate.getUTCFullYear()){this.picker.find(".prev").css({visibility:"hidden"})}else{this.picker.find(".prev").css({visibility:"visible"})}if(k>=this.endDate.getUTCFullYear()){this.picker.find(".next").css({visibility:"hidden"})}else{this.picker.find(".next").css({visibility:"visible"})}break}},mousewheel:function(j){j.preventDefault();j.stopPropagation();if(this.wheelPause){return}this.wheelPause=true;var i=j.originalEvent;var l=i.wheelDelta;var k=l>0?1:(l===0)?0:-1;if(this.wheelViewModeNavigationInverseDirection){k=-k}this.showMode(k);setTimeout(d.proxy(function(){this.wheelPause=false},this),this.wheelViewModeNavigationDelay)},click:function(m){m.stopPropagation();m.preventDefault();var n=d(m.target).closest("span, td, th, legend");if(n.is("."+this.icontype)){n=d(n).parent().closest("span, td, th, legend")}if(n.length===1){if(n.is(".disabled")){this.element.trigger({type:"outOfRange",date:this.viewDate,startDate:this.startDate,endDate:this.endDate});return}switch(n[0].nodeName.toLowerCase()){case"th":switch(n[0].className){case"switch":this.showMode(1);break;case"prev":case"next":var i=c.modes[this.viewMode].navStep*(n[0].className==="prev"?-1:1);switch(this.viewMode){case 0:this.viewDate=this.moveHour(this.viewDate,i);break;case 1:this.viewDate=this.moveDate(this.viewDate,i);break;case 2:this.viewDate=this.moveMonth(this.viewDate,i);break;case 3:case 4:this.viewDate=this.moveYear(this.viewDate,i);break}this.fill();this.element.trigger({type:n[0].className+":"+this.convertViewModeText(this.viewMode),date:this.viewDate,startDate:this.startDate,endDate:this.endDate});break;case"clear":this.reset();if(this.autoclose){this.hide()}break;case"today":var j=new Date();j=h(j.getFullYear(),j.getMonth(),j.getDate(),j.getHours(),j.getMinutes(),j.getSeconds(),0);if(j<this.startDate){j=this.startDate}else{if(j>this.endDate){j=this.endDate}}this.viewMode=this.startViewMode;this.showMode(0);this._setDate(j);this.fill();if(this.autoclose){this.hide()}break}break;case"span":if(!n.is(".disabled")){var p=this.viewDate.getUTCFullYear(),o=this.viewDate.getUTCMonth(),q=this.viewDate.getUTCDate(),r=this.viewDate.getUTCHours(),k=this.viewDate.getUTCMinutes(),s=this.viewDate.getUTCSeconds();if(n.is(".month")){this.viewDate.setUTCDate(1);o=n.parent().find("span").index(n);q=this.viewDate.getUTCDate();this.viewDate.setUTCMonth(o);this.element.trigger({type:"changeMonth",date:this.viewDate});if(this.viewSelect>=3){this._setDate(h(p,o,q,r,k,s,0))}}else{if(n.is(".year")){this.viewDate.setUTCDate(1);p=parseInt(n.text(),10)||0;this.viewDate.setUTCFullYear(p);this.element.trigger({type:"changeYear",date:this.viewDate});if(this.viewSelect>=4){this._setDate(h(p,o,q,r,k,s,0))}}else{if(n.is(".hour")){r=parseInt(n.text(),10)||0;if(n.hasClass("hour_am")||n.hasClass("hour_pm")){if(r===12&&n.hasClass("hour_am")){r=0}else{if(r!==12&&n.hasClass("hour_pm")){r+=12}}}this.viewDate.setUTCHours(r);this.element.trigger({type:"changeHour",date:this.viewDate});if(this.viewSelect>=1){this._setDate(h(p,o,q,r,k,s,0))}}else{if(n.is(".minute")){k=parseInt(n.text().substr(n.text().indexOf(":")+1),10)||0;this.viewDate.setUTCMinutes(k);this.element.trigger({type:"changeMinute",date:this.viewDate});if(this.viewSelect>=0){this._setDate(h(p,o,q,r,k,s,0))}}}}}if(this.viewMode!==0){var l=this.viewMode;this.showMode(-1);this.fill();if(l===this.viewMode&&this.autoclose){this.hide()}}else{this.fill();if(this.autoclose){this.hide()}}}break;case"td":if(n.is(".day")&&!n.is(".disabled")){var q=parseInt(n.text(),10)||1;var p=this.viewDate.getUTCFullYear(),o=this.viewDate.getUTCMonth(),r=this.viewDate.getUTCHours(),k=this.viewDate.getUTCMinutes(),s=this.viewDate.getUTCSeconds();if(n.is(".old")){if(o===0){o=11;p-=1}else{o-=1}}else{if(n.is(".new")){if(o===11){o=0;p+=1}else{o+=1}}}this.viewDate.setUTCFullYear(p);this.viewDate.setUTCMonth(o,q);this.element.trigger({type:"changeDay",date:this.viewDate});if(this.viewSelect>=2){this._setDate(h(p,o,q,r,k,s,0))}}var l=this.viewMode;this.showMode(-1);this.fill();if(l===this.viewMode&&this.autoclose){this.hide()}break}}},_setDate:function(i,k){if(!k||k==="date"){this.date=i}if(!k||k==="view"){this.viewDate=i}this.fill();this.setValue();var j;if(this.isInput){j=this.element}else{if(this.component){j=this.element.find("input")}}if(j){j.change()}this.element.trigger({type:"changeDate",date:this.getDate()});if(i===null){this.date=this.viewDate}},moveMinute:function(j,i){if(!i){return j}var k=new Date(j.valueOf());k.setUTCMinutes(k.getUTCMinutes()+(i*this.minuteStep));return k},moveHour:function(j,i){if(!i){return j}var k=new Date(j.valueOf());k.setUTCHours(k.getUTCHours()+i);return k},moveDate:function(j,i){if(!i){return j}var k=new Date(j.valueOf());k.setUTCDate(k.getUTCDate()+i);return k},moveMonth:function(j,k){if(!k){return j}var n=new Date(j.valueOf()),r=n.getUTCDate(),o=n.getUTCMonth(),m=Math.abs(k),q,p;k=k>0?1:-1;if(m===1){p=k===-1?function(){return n.getUTCMonth()===o}:function(){return n.getUTCMonth()!==q};q=o+k;n.setUTCMonth(q);if(q<0||q>11){q=(q+12)%12}}else{for(var l=0;l<m;l++){n=this.moveMonth(n,k)}q=n.getUTCMonth();n.setUTCDate(r);p=function(){return q!==n.getUTCMonth()}}while(p()){n.setUTCDate(--r);n.setUTCMonth(q)}return n},moveYear:function(j,i){return this.moveMonth(j,i*12)},dateWithinRange:function(i){return i>=this.startDate&&i<=this.endDate},keydown:function(o){if(this.picker.is(":not(:visible)")){if(o.keyCode===27){this.show()}return}var k=false,j,i,n;switch(o.keyCode){case 27:this.hide();o.preventDefault();break;case 37:case 39:if(!this.keyboardNavigation){break}j=o.keyCode===37?-1:1;var m=this.viewMode;if(o.ctrlKey){m+=2}else{if(o.shiftKey){m+=1}}if(m===4){i=this.moveYear(this.date,j);n=this.moveYear(this.viewDate,j)}else{if(m===3){i=this.moveMonth(this.date,j);n=this.moveMonth(this.viewDate,j)}else{if(m===2){i=this.moveDate(this.date,j);n=this.moveDate(this.viewDate,j)}else{if(m===1){i=this.moveHour(this.date,j);n=this.moveHour(this.viewDate,j)}else{if(m===0){i=this.moveMinute(this.date,j);n=this.moveMinute(this.viewDate,j)}}}}}if(this.dateWithinRange(i)){this.date=i;this.viewDate=n;this.setValue();this.update();o.preventDefault();k=true}break;case 38:case 40:if(!this.keyboardNavigation){break}j=o.keyCode===38?-1:1;m=this.viewMode;if(o.ctrlKey){m+=2}else{if(o.shiftKey){m+=1}}if(m===4){i=this.moveYear(this.date,j);n=this.moveYear(this.viewDate,j)}else{if(m===3){i=this.moveMonth(this.date,j);n=this.moveMonth(this.viewDate,j)}else{if(m===2){i=this.moveDate(this.date,j*7);n=this.moveDate(this.viewDate,j*7)}else{if(m===1){if(this.showMeridian){i=this.moveHour(this.date,j*6);n=this.moveHour(this.viewDate,j*6)}else{i=this.moveHour(this.date,j*4);n=this.moveHour(this.viewDate,j*4)}}else{if(m===0){i=this.moveMinute(this.date,j*4);n=this.moveMinute(this.viewDate,j*4)}}}}}if(this.dateWithinRange(i)){this.date=i;this.viewDate=n;this.setValue();this.update();o.preventDefault();k=true}break;case 13:if(this.viewMode!==0){var p=this.viewMode;this.showMode(-1);this.fill();if(p===this.viewMode&&this.autoclose){this.hide()}}else{this.fill();if(this.autoclose){this.hide()}}o.preventDefault();break;case 9:this.hide();break}if(k){var l;if(this.isInput){l=this.element}else{if(this.component){l=this.element.find("input")}}if(l){l.change()}this.element.trigger({type:"changeDate",date:this.getDate()})}},showMode:function(i){if(i){var j=Math.max(0,Math.min(c.modes.length-1,this.viewMode+i));if(j>=this.minView&&j<=this.maxView){this.element.trigger({type:"changeMode",date:this.viewDate,oldViewMode:this.viewMode,newViewMode:j});this.viewMode=j}}this.picker.find(">div").hide().filter(".datetimepicker-"+c.modes[this.viewMode].clsName).css("display","block");this.updateNavArrows()},reset:function(){this._setDate(null,"date")},convertViewModeText:function(i){switch(i){case 4:return"decade";case 3:return"year";case 2:return"month";case 1:return"day";case 0:return"hour"}}};var b=d.fn.datetimepicker;d.fn.datetimepicker=function(k){var i=Array.apply(null,arguments);i.shift();var j;this.each(function(){var n=d(this),m=n.data("datetimepicker"),l=typeof k==="object"&&k;if(!m){n.data("datetimepicker",(m=new g(this,d.extend({},d.fn.datetimepicker.defaults,l))))}if(typeof k==="string"&&typeof m[k]==="function"){j=m[k].apply(m,i);if(j!==f){return false}}});if(j!==f){return j}else{return this}};d.fn.datetimepicker.defaults={};d.fn.datetimepicker.Constructor=g;var e=d.fn.datetimepicker.dates={en:{days:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday","Sunday"],daysShort:["Sun","Mon","Tue","Wed","Thu","Fri","Sat","Sun"],daysMin:["Su","Mo","Tu","We","Th","Fr","Sa","Su"],months:["January","February","March","April","May","June","July","August","September","October","November","December"],monthsShort:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],meridiem:["am","pm"],suffix:["st","nd","rd","th"],today:"Today",clear:"Clear"}};var c={modes:[{clsName:"minutes",navFnc:"Hours",navStep:1},{clsName:"hours",navFnc:"Date",navStep:1},{clsName:"days",navFnc:"Month",navStep:1},{clsName:"months",navFnc:"FullYear",navStep:1},{clsName:"years",navFnc:"FullYear",navStep:10}],isLeapYear:function(i){return(((i%4===0)&&(i%100!==0))||(i%400===0))},getDaysInMonth:function(i,j){return[31,(c.isLeapYear(i)?29:28),31,30,31,30,31,31,30,31,30,31][j]},getDefaultFormat:function(i,j){if(i==="standard"){if(j==="input"){return"yyyy-mm-dd hh:ii"}else{return"yyyy-mm-dd hh:ii:ss"}}else{if(i==="php"){if(j==="input"){return"Y-m-d H:i"}else{return"Y-m-d H:i:s"}}else{throw new Error("Invalid format type.")}}},validParts:function(i){if(i==="standard"){return/t|hh?|HH?|p|P|z|Z|ii?|ss?|dd?|DD?|mm?|MM?|yy(?:yy)?/g}else{if(i==="php"){return/[dDjlNwzFmMnStyYaABgGhHis]/g}else{throw new Error("Invalid format type.")}}},nonpunctuation:/[^ -\/:-@\[-`{-~\t\n\rTZ]+/g,parseFormat:function(l,j){var i=l.replace(this.validParts(j),"\0").split("\0"),k=l.match(this.validParts(j));if(!i||!i.length||!k||k.length===0){throw new Error("Invalid date format.")}return{separators:i,parts:k}},parseDate:function(A,y,v,j,r){if(A instanceof Date){var u=new Date(A.valueOf()-A.getTimezoneOffset()*60000);u.setMilliseconds(0);return u}if(/^\d{4}\-\d{1,2}\-\d{1,2}$/.test(A)){y=this.parseFormat("yyyy-mm-dd",j)}if(/^\d{4}\-\d{1,2}\-\d{1,2}[T ]\d{1,2}\:\d{1,2}$/.test(A)){y=this.parseFormat("yyyy-mm-dd hh:ii",j)}if(/^\d{4}\-\d{1,2}\-\d{1,2}[T ]\d{1,2}\:\d{1,2}\:\d{1,2}[Z]{0,1}$/.test(A)){y=this.parseFormat("yyyy-mm-dd hh:ii:ss",j)}if(/^[-+]\d+[dmwy]([\s,]+[-+]\d+[dmwy])*$/.test(A)){var l=/([-+]\d+)([dmwy])/,q=A.match(/([-+]\d+)([dmwy])/g),t,p;A=new Date();for(var x=0;x<q.length;x++){t=l.exec(q[x]);p=parseInt(t[1]);switch(t[2]){case"d":A.setUTCDate(A.getUTCDate()+p);break;case"m":A=g.prototype.moveMonth.call(g.prototype,A,p);break;case"w":A.setUTCDate(A.getUTCDate()+p*7);break;case"y":A=g.prototype.moveYear.call(g.prototype,A,p);break}}return h(A.getUTCFullYear(),A.getUTCMonth(),A.getUTCDate(),A.getUTCHours(),A.getUTCMinutes(),A.getUTCSeconds(),0)}var q=A&&A.toString().match(this.nonpunctuation)||[],A=new Date(0,0,0,0,0,0,0),m={},z=["hh","h","ii","i","ss","s","yyyy","yy","M","MM","m","mm","D","DD","d","dd","H","HH","p","P","z","Z"],o={hh:function(s,i){return s.setUTCHours(i)},h:function(s,i){return s.setUTCHours(i)},HH:function(s,i){return s.setUTCHours(i===12?0:i)},H:function(s,i){return s.setUTCHours(i===12?0:i)},ii:function(s,i){return s.setUTCMinutes(i)},i:function(s,i){return s.setUTCMinutes(i)},ss:function(s,i){return s.setUTCSeconds(i)},s:function(s,i){return s.setUTCSeconds(i)},yyyy:function(s,i){return s.setUTCFullYear(i)},yy:function(s,i){return s.setUTCFullYear(2000+i)},m:function(s,i){i-=1;while(i<0){i+=12}i%=12;s.setUTCMonth(i);while(s.getUTCMonth()!==i){if(isNaN(s.getUTCMonth())){return s}else{s.setUTCDate(s.getUTCDate()-1)}}return s},d:function(s,i){return s.setUTCDate(i)},p:function(s,i){return s.setUTCHours(i===1?s.getUTCHours()+12:s.getUTCHours())},z:function(){return r}},B,k,t;o.M=o.MM=o.mm=o.m;o.dd=o.d;o.P=o.p;o.Z=o.z;A=h(A.getFullYear(),A.getMonth(),A.getDate(),A.getHours(),A.getMinutes(),A.getSeconds());if(q.length===y.parts.length){for(var x=0,w=y.parts.length;x<w;x++){B=parseInt(q[x],10);t=y.parts[x];if(isNaN(B)){switch(t){case"MM":k=d(e[v].months).filter(function(){var i=this.slice(0,q[x].length),s=q[x].slice(0,i.length);return i===s});B=d.inArray(k[0],e[v].months)+1;break;case"M":k=d(e[v].monthsShort).filter(function(){var i=this.slice(0,q[x].length),s=q[x].slice(0,i.length);return i.toLowerCase()===s.toLowerCase()});B=d.inArray(k[0],e[v].monthsShort)+1;break;case"p":case"P":B=d.inArray(q[x].toLowerCase(),e[v].meridiem);break;case"z":case"Z":r;break}}m[t]=B}for(var x=0,n;x<z.length;x++){n=z[x];if(n in m&&!isNaN(m[n])){o[n](A,m[n])}}}return A},formatDate:function(l,q,m,p,o){if(l===null){return""}var k;if(p==="standard"){k={t:l.getTime(),yy:l.getUTCFullYear().toString().substring(2),yyyy:l.getUTCFullYear(),m:l.getUTCMonth()+1,M:e[m].monthsShort[l.getUTCMonth()],MM:e[m].months[l.getUTCMonth()],d:l.getUTCDate(),D:e[m].daysShort[l.getUTCDay()],DD:e[m].days[l.getUTCDay()],p:(e[m].meridiem.length===2?e[m].meridiem[l.getUTCHours()<12?0:1]:""),h:l.getUTCHours(),i:l.getUTCMinutes(),s:l.getUTCSeconds(),z:o};if(e[m].meridiem.length===2){k.H=(k.h%12===0?12:k.h%12)}else{k.H=k.h}k.HH=(k.H<10?"0":"")+k.H;k.P=k.p.toUpperCase();k.Z=k.z;k.hh=(k.h<10?"0":"")+k.h;k.ii=(k.i<10?"0":"")+k.i;k.ss=(k.s<10?"0":"")+k.s;k.dd=(k.d<10?"0":"")+k.d;k.mm=(k.m<10?"0":"")+k.m}else{if(p==="php"){k={y:l.getUTCFullYear().toString().substring(2),Y:l.getUTCFullYear(),F:e[m].months[l.getUTCMonth()],M:e[m].monthsShort[l.getUTCMonth()],n:l.getUTCMonth()+1,t:c.getDaysInMonth(l.getUTCFullYear(),l.getUTCMonth()),j:l.getUTCDate(),l:e[m].days[l.getUTCDay()],D:e[m].daysShort[l.getUTCDay()],w:l.getUTCDay(),N:(l.getUTCDay()===0?7:l.getUTCDay()),S:(l.getUTCDate()%10<=e[m].suffix.length?e[m].suffix[l.getUTCDate()%10-1]:""),a:(e[m].meridiem.length===2?e[m].meridiem[l.getUTCHours()<12?0:1]:""),g:(l.getUTCHours()%12===0?12:l.getUTCHours()%12),G:l.getUTCHours(),i:l.getUTCMinutes(),s:l.getUTCSeconds()};k.m=(k.n<10?"0":"")+k.n;k.d=(k.j<10?"0":"")+k.j;k.A=k.a.toString().toUpperCase();k.h=(k.g<10?"0":"")+k.g;k.H=(k.G<10?"0":"")+k.G;k.i=(k.i<10?"0":"")+k.i;k.s=(k.s<10?"0":"")+k.s}else{throw new Error("Invalid format type.")}}var l=[],r=d.extend([],q.separators);for(var n=0,j=q.parts.length;n<j;n++){if(r.length){l.push(r.shift())}l.push(k[q.parts[n]])}if(r.length){l.push(r.shift())}return l.join("")},convertViewMode:function(i){switch(i){case 4:case"decade":i=4;break;case 3:case"year":i=3;break;case 2:case"month":i=2;break;case 1:case"day":i=1;break;case 0:case"hour":i=0;break}return i},headTemplate:'<thead><tr><th class="prev"><i class="{iconType} {leftArrow}"/></th><th colspan="5" class="switch"></th><th class="next"><i class="{iconType} {rightArrow}"/></th></tr></thead>',headTemplateV3:'<thead><tr><th class="prev"><span class="{iconType} {leftArrow}"></span> </th><th colspan="5" class="switch"></th><th class="next"><span class="{iconType} {rightArrow}"></span> </th></tr></thead>',contTemplate:'<tbody><tr><td colspan="7"></td></tr></tbody>',footTemplate:'<tfoot><tr><th colspan="7" class="today"></th></tr><tr><th colspan="7" class="clear"></th></tr></tfoot>'};c.template='<div class="datetimepicker"><div class="datetimepicker-minutes"><table class=" table-condensed">'+c.headTemplate+c.contTemplate+c.footTemplate+'</table></div><div class="datetimepicker-hours"><table class=" table-condensed">'+c.headTemplate+c.contTemplate+c.footTemplate+'</table></div><div class="datetimepicker-days"><table class=" table-condensed">'+c.headTemplate+"<tbody></tbody>"+c.footTemplate+'</table></div><div class="datetimepicker-months"><table class="table-condensed">'+c.headTemplate+c.contTemplate+c.footTemplate+'</table></div><div class="datetimepicker-years"><table class="table-condensed">'+c.headTemplate+c.contTemplate+c.footTemplate+"</table></div></div>";c.templateV3='<div class="datetimepicker"><div class="datetimepicker-minutes"><table class=" table-condensed">'+c.headTemplateV3+c.contTemplate+c.footTemplate+'</table></div><div class="datetimepicker-hours"><table class=" table-condensed">'+c.headTemplateV3+c.contTemplate+c.footTemplate+'</table></div><div class="datetimepicker-days"><table class=" table-condensed">'+c.headTemplateV3+"<tbody></tbody>"+c.footTemplate+'</table></div><div class="datetimepicker-months"><table class="table-condensed">'+c.headTemplateV3+c.contTemplate+c.footTemplate+'</table></div><div class="datetimepicker-years"><table class="table-condensed">'+c.headTemplateV3+c.contTemplate+c.footTemplate+"</table></div></div>";d.fn.datetimepicker.DPGlobal=c;d.fn.datetimepicker.noConflict=function(){d.fn.datetimepicker=b;return this};d(document).on("focus.datetimepicker.data-api click.datetimepicker.data-api",'[data-provide="datetimepicker"]',function(j){var i=d(this);if(i.data("datetimepicker")){return}j.preventDefault();i.datetimepicker("show")});d(function(){d('[data-provide="datetimepicker-inline"]').datetimepicker()})}));!function(a,b,c){"use strict";var d=function(b,c){this.widget="",this.$element=a(b),this.defaultTime=c.defaultTime,this.disableFocus=c.disableFocus,this.disableMousewheel=c.disableMousewheel,this.isOpen=c.isOpen,this.minuteStep=c.minuteStep,this.modalBackdrop=c.modalBackdrop,this.orientation=c.orientation,this.secondStep=c.secondStep,this.snapToStep=c.snapToStep,this.showInputs=c.showInputs,this.showMeridian=c.showMeridian,this.showSeconds=c.showSeconds,this.template=c.template,this.appendWidgetTo=c.appendWidgetTo,this.showWidgetOnAddonClick=c.showWidgetOnAddonClick,this.icons=c.icons,this.maxHours=c.maxHours,this.explicitMode=c.explicitMode,this.handleDocumentClick=function(a){var b=a.data.scope;b.$element.parent().find(a.target).length||b.$widget.is(a.target)||b.$widget.find(a.target).length||b.hideWidget()},this._init()};d.prototype={constructor:d,_init:function(){var b=this;this.showWidgetOnAddonClick&&this.$element.parent().hasClass("input-group")&&this.$element.parent().hasClass("bootstrap-timepicker")?(this.$element.parent(".input-group.bootstrap-timepicker").find(".input-group-addon").on({"click.timepicker":a.proxy(this.showWidget,this)}),this.$element.on({"focus.timepicker":a.proxy(this.highlightUnit,this),"click.timepicker":a.proxy(this.highlightUnit,this),"keydown.timepicker":a.proxy(this.elementKeydown,this),"blur.timepicker":a.proxy(this.blurElement,this),"mousewheel.timepicker DOMMouseScroll.timepicker":a.proxy(this.mousewheel,this)})):this.template?this.$element.on({"focus.timepicker":a.proxy(this.showWidget,this),"click.timepicker":a.proxy(this.showWidget,this),"blur.timepicker":a.proxy(this.blurElement,this),"mousewheel.timepicker DOMMouseScroll.timepicker":a.proxy(this.mousewheel,this)}):this.$element.on({"focus.timepicker":a.proxy(this.highlightUnit,this),"click.timepicker":a.proxy(this.highlightUnit,this),"keydown.timepicker":a.proxy(this.elementKeydown,this),"blur.timepicker":a.proxy(this.blurElement,this),"mousewheel.timepicker DOMMouseScroll.timepicker":a.proxy(this.mousewheel,this)}),this.template!==!1?this.$widget=a(this.getTemplate()).on("click",a.proxy(this.widgetClick,this)):this.$widget=!1,this.showInputs&&this.$widget!==!1&&this.$widget.find("input").each(function(){a(this).on({"click.timepicker":function(){a(this).select()},"keydown.timepicker":a.proxy(b.widgetKeydown,b),"keyup.timepicker":a.proxy(b.widgetKeyup,b)})}),this.setDefaultTime(this.defaultTime)},blurElement:function(){this.highlightedUnit=null,this.updateFromElementVal()},clear:function(){this.hour="",this.minute="",this.second="",this.meridian="",this.$element.val("")},decrementHour:function(){if(this.showMeridian)if(1===this.hour)this.hour=12;else{if(12===this.hour)return this.hour--,this.toggleMeridian();if(0===this.hour)return this.hour=11,this.toggleMeridian();this.hour--}else this.hour<=0?this.hour=this.maxHours-1:this.hour--},decrementMinute:function(a){var b;b=a?this.minute-a:this.minute-this.minuteStep,0>b?(this.decrementHour(),this.minute=b+60):this.minute=b},decrementSecond:function(){var a=this.second-this.secondStep;0>a?(this.decrementMinute(!0),this.second=a+60):this.second=a},elementKeydown:function(a){switch(a.which){case 9:if(a.shiftKey){if("hour"===this.highlightedUnit){this.hideWidget();break}this.highlightPrevUnit()}else{if(this.showMeridian&&"meridian"===this.highlightedUnit||this.showSeconds&&"second"===this.highlightedUnit||!this.showMeridian&&!this.showSeconds&&"minute"===this.highlightedUnit){this.hideWidget();break}this.highlightNextUnit()}a.preventDefault(),this.updateFromElementVal();break;case 27:this.updateFromElementVal();break;case 37:a.preventDefault(),this.highlightPrevUnit(),this.updateFromElementVal();break;case 38:switch(a.preventDefault(),this.highlightedUnit){case"hour":this.incrementHour(),this.highlightHour();break;case"minute":this.incrementMinute(),this.highlightMinute();break;case"second":this.incrementSecond(),this.highlightSecond();break;case"meridian":this.toggleMeridian(),this.highlightMeridian()}this.update();break;case 39:a.preventDefault(),this.highlightNextUnit(),this.updateFromElementVal();break;case 40:switch(a.preventDefault(),this.highlightedUnit){case"hour":this.decrementHour(),this.highlightHour();break;case"minute":this.decrementMinute(),this.highlightMinute();break;case"second":this.decrementSecond(),this.highlightSecond();break;case"meridian":this.toggleMeridian(),this.highlightMeridian()}this.update()}},getCursorPosition:function(){var a=this.$element.get(0);if("selectionStart"in a)return a.selectionStart;if(c.selection){a.focus();var b=c.selection.createRange(),d=c.selection.createRange().text.length;return b.moveStart("character",-a.value.length),b.text.length-d}},getTemplate:function(){var a,b,c,d,e,f;switch(this.showInputs?(b='<input type="text" class="bootstrap-timepicker-hour" maxlength="2"/>',c='<input type="text" class="bootstrap-timepicker-minute" maxlength="2"/>',d='<input type="text" class="bootstrap-timepicker-second" maxlength="2"/>',e='<input type="text" class="bootstrap-timepicker-meridian" maxlength="2"/>'):(b='<span class="bootstrap-timepicker-hour"></span>',c='<span class="bootstrap-timepicker-minute"></span>',d='<span class="bootstrap-timepicker-second"></span>',e='<span class="bootstrap-timepicker-meridian"></span>'),f='<table><tr><td><a href="#" data-action="incrementHour"><span class="'+this.icons.up+'"></span></a></td><td class="separator">&nbsp;</td><td><a href="#" data-action="incrementMinute"><span class="'+this.icons.up+'"></span></a></td>'+(this.showSeconds?'<td class="separator">&nbsp;</td><td><a href="#" data-action="incrementSecond"><span class="'+this.icons.up+'"></span></a></td>':"")+(this.showMeridian?'<td class="separator">&nbsp;</td><td class="meridian-column"><a href="#" data-action="toggleMeridian"><span class="'+this.icons.up+'"></span></a></td>':"")+"</tr><tr><td>"+b+'</td> <td class="separator">:</td><td>'+c+"</td> "+(this.showSeconds?'<td class="separator">:</td><td>'+d+"</td>":"")+(this.showMeridian?'<td class="separator">&nbsp;</td><td>'+e+"</td>":"")+'</tr><tr><td><a href="#" data-action="decrementHour"><span class="'+this.icons.down+'"></span></a></td><td class="separator"></td><td><a href="#" data-action="decrementMinute"><span class="'+this.icons.down+'"></span></a></td>'+(this.showSeconds?'<td class="separator">&nbsp;</td><td><a href="#" data-action="decrementSecond"><span class="'+this.icons.down+'"></span></a></td>':"")+(this.showMeridian?'<td class="separator">&nbsp;</td><td><a href="#" data-action="toggleMeridian"><span class="'+this.icons.down+'"></span></a></td>':"")+"</tr></table>",this.template){case"modal":a='<div class="bootstrap-timepicker-widget modal hide fade in" data-backdrop="'+(this.modalBackdrop?"true":"false")+'"><div class="modal-header"><a href="#" class="close" data-dismiss="modal">&times;</a><h3>Pick a Time</h3></div><div class="modal-content">'+f+'</div><div class="modal-footer"><a href="#" class="btn btn-primary" data-dismiss="modal">OK</a></div></div>';break;case"dropdown":a='<div class="bootstrap-timepicker-widget dropdown-menu">'+f+"</div>"}return a},getTime:function(){return""===this.hour?"":this.hour+":"+(1===this.minute.toString().length?"0"+this.minute:this.minute)+(this.showSeconds?":"+(1===this.second.toString().length?"0"+this.second:this.second):"")+(this.showMeridian?" "+this.meridian:"")},hideWidget:function(){this.isOpen!==!1&&(this.$element.trigger({type:"hide.timepicker",time:{value:this.getTime(),hours:this.hour,minutes:this.minute,seconds:this.second,meridian:this.meridian}}),"modal"===this.template&&this.$widget.modal?this.$widget.modal("hide"):this.$widget.removeClass("open"),a(c).off("mousedown.timepicker, touchend.timepicker",this.handleDocumentClick),this.isOpen=!1,this.$widget.detach())},highlightUnit:function(){this.position=this.getCursorPosition(),this.position>=0&&this.position<=2?this.highlightHour():this.position>=3&&this.position<=5?this.highlightMinute():this.position>=6&&this.position<=8?this.showSeconds?this.highlightSecond():this.highlightMeridian():this.position>=9&&this.position<=11&&this.highlightMeridian()},highlightNextUnit:function(){switch(this.highlightedUnit){case"hour":this.highlightMinute();break;case"minute":this.showSeconds?this.highlightSecond():this.showMeridian?this.highlightMeridian():this.highlightHour();break;case"second":this.showMeridian?this.highlightMeridian():this.highlightHour();break;case"meridian":this.highlightHour()}},highlightPrevUnit:function(){switch(this.highlightedUnit){case"hour":this.showMeridian?this.highlightMeridian():this.showSeconds?this.highlightSecond():this.highlightMinute();break;case"minute":this.highlightHour();break;case"second":this.highlightMinute();break;case"meridian":this.showSeconds?this.highlightSecond():this.highlightMinute()}},highlightHour:function(){var a=this.$element.get(0),b=this;this.highlightedUnit="hour",a.setSelectionRange&&setTimeout(function(){b.hour<10?a.setSelectionRange(0,1):a.setSelectionRange(0,2)},0)},highlightMinute:function(){var a=this.$element.get(0),b=this;this.highlightedUnit="minute",a.setSelectionRange&&setTimeout(function(){b.hour<10?a.setSelectionRange(2,4):a.setSelectionRange(3,5)},0)},highlightSecond:function(){var a=this.$element.get(0),b=this;this.highlightedUnit="second",a.setSelectionRange&&setTimeout(function(){b.hour<10?a.setSelectionRange(5,7):a.setSelectionRange(6,8)},0)},highlightMeridian:function(){var a=this.$element.get(0),b=this;this.highlightedUnit="meridian",a.setSelectionRange&&(this.showSeconds?setTimeout(function(){b.hour<10?a.setSelectionRange(8,10):a.setSelectionRange(9,11)},0):setTimeout(function(){b.hour<10?a.setSelectionRange(5,7):a.setSelectionRange(6,8)},0))},incrementHour:function(){if(this.showMeridian){if(11===this.hour)return this.hour++,this.toggleMeridian();12===this.hour&&(this.hour=0)}return this.hour===this.maxHours-1?void(this.hour=0):void this.hour++},incrementMinute:function(a){var b;b=a?this.minute+a:this.minute+this.minuteStep-this.minute%this.minuteStep,b>59?(this.incrementHour(),this.minute=b-60):this.minute=b},incrementSecond:function(){var a=this.second+this.secondStep-this.second%this.secondStep;a>59?(this.incrementMinute(!0),this.second=a-60):this.second=a},mousewheel:function(b){if(!this.disableMousewheel){b.preventDefault(),b.stopPropagation();var c=b.originalEvent.wheelDelta||-b.originalEvent.detail,d=null;switch("mousewheel"===b.type?d=-1*b.originalEvent.wheelDelta:"DOMMouseScroll"===b.type&&(d=40*b.originalEvent.detail),d&&(b.preventDefault(),a(this).scrollTop(d+a(this).scrollTop())),this.highlightedUnit){case"minute":c>0?this.incrementMinute():this.decrementMinute(),this.highlightMinute();break;case"second":c>0?this.incrementSecond():this.decrementSecond(),this.highlightSecond();break;case"meridian":this.toggleMeridian(),this.highlightMeridian();break;default:c>0?this.incrementHour():this.decrementHour(),this.highlightHour()}return!1}},changeToNearestStep:function(a,b){return a%b===0?a:Math.round(a%b/b)?(a+(b-a%b))%60:a-a%b},place:function(){if(!this.isInline){var c=this.$widget.outerWidth(),d=this.$widget.outerHeight(),e=10,f=a(b).width(),g=a(b).height(),h=a(b).scrollTop(),i=parseInt(this.$element.parents().filter(function(){return"auto"!==a(this).css("z-index")}).first().css("z-index"),10)+10,j=this.component?this.component.parent().offset():this.$element.offset(),k=this.component?this.component.outerHeight(!0):this.$element.outerHeight(!1),l=this.component?this.component.outerWidth(!0):this.$element.outerWidth(!1),m=j.left,n=j.top;this.$widget.removeClass("timepicker-orient-top timepicker-orient-bottom timepicker-orient-right timepicker-orient-left"),"auto"!==this.orientation.x?(this.$widget.addClass("timepicker-orient-"+this.orientation.x),"right"===this.orientation.x&&(m-=c-l)):(this.$widget.addClass("timepicker-orient-left"),j.left<0?m-=j.left-e:j.left+c>f&&(m=f-c-e));var o,p,q=this.orientation.y;"auto"===q&&(o=-h+j.top-d,p=h+g-(j.top+k+d),q=Math.max(o,p)===p?"top":"bottom"),this.$widget.addClass("timepicker-orient-"+q),"top"===q?n+=k:n-=d+parseInt(this.$widget.css("padding-top"),10),this.$widget.css({top:n,left:m,zIndex:i})}},remove:function(){a("document").off(".timepicker"),this.$widget&&this.$widget.remove(),delete this.$element.data().timepicker},setDefaultTime:function(a){if(this.$element.val())this.updateFromElementVal();else if("current"===a){var b=new Date,c=b.getHours(),d=b.getMinutes(),e=b.getSeconds(),f="AM";0!==e&&(e=Math.ceil(b.getSeconds()/this.secondStep)*this.secondStep,60===e&&(d+=1,e=0)),0!==d&&(d=Math.ceil(b.getMinutes()/this.minuteStep)*this.minuteStep,60===d&&(c+=1,d=0)),this.showMeridian&&(0===c?c=12:c>=12?(c>12&&(c-=12),f="PM"):f="AM"),this.hour=c,this.minute=d,this.second=e,this.meridian=f,this.update()}else a===!1?(this.hour=0,this.minute=0,this.second=0,this.meridian="AM"):this.setTime(a)},setTime:function(a,b){if(!a)return void this.clear();var c,d,e,f,g,h;if("object"==typeof a&&a.getMonth)e=a.getHours(),f=a.getMinutes(),g=a.getSeconds(),this.showMeridian&&(h="AM",e>12&&(h="PM",e%=12),12===e&&(h="PM"));else{if(c=(/a/i.test(a)?1:0)+(/p/i.test(a)?2:0),c>2)return void this.clear();if(d=a.replace(/[^0-9\:]/g,"").split(":"),e=d[0]?d[0].toString():d.toString(),this.explicitMode&&e.length>2&&e.length%2!==0)return void this.clear();f=d[1]?d[1].toString():"",g=d[2]?d[2].toString():"",e.length>4&&(g=e.slice(-2),e=e.slice(0,-2)),e.length>2&&(f=e.slice(-2),e=e.slice(0,-2)),f.length>2&&(g=f.slice(-2),f=f.slice(0,-2)),e=parseInt(e,10),f=parseInt(f,10),g=parseInt(g,10),isNaN(e)&&(e=0),isNaN(f)&&(f=0),isNaN(g)&&(g=0),g>59&&(g=59),f>59&&(f=59),e>=this.maxHours&&(e=this.maxHours-1),this.showMeridian?(e>12&&(c=2,e-=12),c||(c=1),0===e&&(e=12),h=1===c?"AM":"PM"):12>e&&2===c?e+=12:e>=this.maxHours?e=this.maxHours-1:(0>e||12===e&&1===c)&&(e=0)}this.hour=e,this.snapToStep?(this.minute=this.changeToNearestStep(f,this.minuteStep),this.second=this.changeToNearestStep(g,this.secondStep)):(this.minute=f,this.second=g),this.meridian=h,this.update(b)},showWidget:function(){this.isOpen||this.$element.is(":disabled")||(this.$widget.appendTo(this.appendWidgetTo),a(c).on("mousedown.timepicker, touchend.timepicker",{scope:this},this.handleDocumentClick),this.$element.trigger({type:"show.timepicker",time:{value:this.getTime(),hours:this.hour,minutes:this.minute,seconds:this.second,meridian:this.meridian}}),this.place(),this.disableFocus&&this.$element.blur(),""===this.hour&&(this.defaultTime?this.setDefaultTime(this.defaultTime):this.setTime("0:0:0")),"modal"===this.template&&this.$widget.modal?this.$widget.modal("show").on("hidden",a.proxy(this.hideWidget,this)):this.isOpen===!1&&this.$widget.addClass("open"),this.isOpen=!0)},toggleMeridian:function(){this.meridian="AM"===this.meridian?"PM":"AM"},update:function(a){this.updateElement(),a||this.updateWidget(),this.$element.trigger({type:"changeTime.timepicker",time:{value:this.getTime(),hours:this.hour,minutes:this.minute,seconds:this.second,meridian:this.meridian}})},updateElement:function(){this.$element.val(this.getTime()).change()},updateFromElementVal:function(){this.setTime(this.$element.val())},updateWidget:function(){if(this.$widget!==!1){var a=this.hour,b=1===this.minute.toString().length?"0"+this.minute:this.minute,c=1===this.second.toString().length?"0"+this.second:this.second;this.showInputs?(this.$widget.find("input.bootstrap-timepicker-hour").val(a),this.$widget.find("input.bootstrap-timepicker-minute").val(b),this.showSeconds&&this.$widget.find("input.bootstrap-timepicker-second").val(c),this.showMeridian&&this.$widget.find("input.bootstrap-timepicker-meridian").val(this.meridian)):(this.$widget.find("span.bootstrap-timepicker-hour").text(a),this.$widget.find("span.bootstrap-timepicker-minute").text(b),this.showSeconds&&this.$widget.find("span.bootstrap-timepicker-second").text(c),this.showMeridian&&this.$widget.find("span.bootstrap-timepicker-meridian").text(this.meridian))}},updateFromWidgetInputs:function(){if(this.$widget!==!1){var a=this.$widget.find("input.bootstrap-timepicker-hour").val()+":"+this.$widget.find("input.bootstrap-timepicker-minute").val()+(this.showSeconds?":"+this.$widget.find("input.bootstrap-timepicker-second").val():"")+(this.showMeridian?this.$widget.find("input.bootstrap-timepicker-meridian").val():"");this.setTime(a,!0)}},widgetClick:function(b){b.stopPropagation(),b.preventDefault();var c=a(b.target),d=c.closest("a").data("action");d&&this[d](),this.update(),c.is("input")&&c.get(0).setSelectionRange(0,2)},widgetKeydown:function(b){var c=a(b.target),d=c.attr("class").replace("bootstrap-timepicker-","");switch(b.which){case 9:if(b.shiftKey){if("hour"===d)return this.hideWidget()}else if(this.showMeridian&&"meridian"===d||this.showSeconds&&"second"===d||!this.showMeridian&&!this.showSeconds&&"minute"===d)return this.hideWidget();break;case 27:this.hideWidget();break;case 38:switch(b.preventDefault(),d){case"hour":this.incrementHour();break;case"minute":this.incrementMinute();break;case"second":this.incrementSecond();break;case"meridian":this.toggleMeridian()}this.setTime(this.getTime()),c.get(0).setSelectionRange(0,2);break;case 40:switch(b.preventDefault(),d){case"hour":this.decrementHour();break;case"minute":this.decrementMinute();break;case"second":this.decrementSecond();break;case"meridian":this.toggleMeridian()}this.setTime(this.getTime()),c.get(0).setSelectionRange(0,2)}},widgetKeyup:function(a){(65===a.which||77===a.which||80===a.which||46===a.which||8===a.which||a.which>=48&&a.which<=57||a.which>=96&&a.which<=105)&&this.updateFromWidgetInputs()}},a.fn.timepicker=function(b){var c=Array.apply(null,arguments);return c.shift(),this.each(function(){var e=a(this),f=e.data("timepicker"),g="object"==typeof b&&b;f||e.data("timepicker",f=new d(this,a.extend({},a.fn.timepicker.defaults,g,a(this).data()))),"string"==typeof b&&f[b].apply(f,c)})},a.fn.timepicker.defaults={defaultTime:"current",disableFocus:!1,disableMousewheel:!1,isOpen:!1,minuteStep:15,modalBackdrop:!1,orientation:{x:"auto",y:"auto"},secondStep:15,snapToStep:!1,showSeconds:!1,showInputs:!0,showMeridian:!0,template:"dropdown",appendWidgetTo:"body",showWidgetOnAddonClick:!0,icons:{up:"glyphicon glyphicon-chevron-up",down:"glyphicon glyphicon-chevron-down"},maxHours:24,explicitMode:!1},a.fn.timepicker.Constructor=d,a(c).on("focus.timepicker.data-api click.timepicker.data-api",'[data-provide="timepicker"]',function(b){var c=a(this);c.data("timepicker")||(b.preventDefault(),c.timepicker())})}(jQuery,window,document);
$.fn.timepicker.defaults = $.extend(true, {}, $.fn.timepicker.defaults, {
icons: {
up: 'la la-angle-up',
down: 'la la-angle-down'
}
});
(function (root, factory) {
if (typeof define === 'function' && define.amd) {
define(['moment', 'jquery'], function (moment, jquery) {
if (!jquery.fn) jquery.fn = {}; // webpack server rendering
return factory(moment, jquery);
});
} else if (typeof module === 'object' && module.exports) {
var jQuery = (typeof window != 'undefined') ? window.jQuery : undefined;
if (!jQuery) {
jQuery = require('jquery');
if (!jQuery.fn) jQuery.fn = {};
}
var moment = (typeof window != 'undefined' && typeof window.moment != 'undefined') ? window.moment : require('moment');
module.exports = factory(moment, jQuery);
} else {
root.daterangepicker = factory(root.moment, root.jQuery);
}
}(this, function(moment, $) {
var DateRangePicker = function(element, options, cb) {
this.parentEl = 'body';
this.element = $(element);
this.startDate = moment().startOf('day');
this.endDate = moment().endOf('day');
this.minDate = false;
this.maxDate = false;
this.dateLimit = false;
this.autoApply = false;
this.singleDatePicker = false;
this.showDropdowns = false;
this.showWeekNumbers = false;
this.showISOWeekNumbers = false;
this.showCustomRangeLabel = true;
this.timePicker = false;
this.timePicker24Hour = false;
this.timePickerIncrement = 1;
this.timePickerSeconds = false;
this.linkedCalendars = true;
this.autoUpdateInput = true;
this.alwaysShowCalendars = false;
this.ranges = {};
this.opens = 'right';
if (this.element.hasClass('pull-right'))
this.opens = 'left';
this.drops = 'down';
if (this.element.hasClass('dropup'))
this.drops = 'up';
this.buttonClasses = 'btn btn-sm';
this.applyClass = 'btn-success';
this.cancelClass = 'btn-default';
this.locale = {
direction: 'ltr',
format: moment.localeData().longDateFormat('L'),
separator: ' - ',
applyLabel: 'Apply',
cancelLabel: 'Cancel',
weekLabel: 'W',
customRangeLabel: 'Custom Range',
daysOfWeek: moment.weekdaysMin(),
monthNames: moment.monthsShort(),
firstDay: moment.localeData().firstDayOfWeek()
};
this.callback = function() { };
this.isShowing = false;
this.leftCalendar = {};
this.rightCalendar = {};
if (typeof options !== 'object' || options === null)
options = {};
options = $.extend(this.element.data(), options);
if (typeof options.template !== 'string' && !(options.template instanceof $))
options.template = '<div class="daterangepicker dropdown-menu">' +
'<div class="calendar left">' +
'<div class="daterangepicker_input">' +
'<input class="input-mini form-control" type="text" name="daterangepicker_start" value="" />' +
'<i class="fa fa-calendar glyphicon glyphicon-calendar"></i>' +
'<div class="calendar-time">' +
'<div></div>' +
'<i class="fa fa-clock-o glyphicon glyphicon-time"></i>' +
'</div>' +
'</div>' +
'<div class="calendar-table"></div>' +
'</div>' +
'<div class="calendar right">' +
'<div class="daterangepicker_input">' +
'<input class="input-mini form-control" type="text" name="daterangepicker_end" value="" />' +
'<i class="fa fa-calendar glyphicon glyphicon-calendar"></i>' +
'<div class="calendar-time">' +
'<div></div>' +
'<i class="fa fa-clock-o glyphicon glyphicon-time"></i>' +
'</div>' +
'</div>' +
'<div class="calendar-table"></div>' +
'</div>' +
'<div class="ranges">' +
'<div class="range_inputs">' +
'<button class="applyBtn" disabled="disabled" type="button"></button> ' +
'<button class="cancelBtn" type="button"></button>' +
'</div>' +
'</div>' +
'</div>';
this.parentEl = (options.parentEl && $(options.parentEl).length) ? $(options.parentEl) : $(this.parentEl);
this.container = $(options.template).appendTo(this.parentEl);
if (typeof options.locale === 'object') {
if (typeof options.locale.direction === 'string')
this.locale.direction = options.locale.direction;
if (typeof options.locale.format === 'string')
this.locale.format = options.locale.format;
if (typeof options.locale.separator === 'string')
this.locale.separator = options.locale.separator;
if (typeof options.locale.daysOfWeek === 'object')
this.locale.daysOfWeek = options.locale.daysOfWeek.slice();
if (typeof options.locale.monthNames === 'object')
this.locale.monthNames = options.locale.monthNames.slice();
if (typeof options.locale.firstDay === 'number')
this.locale.firstDay = options.locale.firstDay;
if (typeof options.locale.applyLabel === 'string')
this.locale.applyLabel = options.locale.applyLabel;
if (typeof options.locale.cancelLabel === 'string')
this.locale.cancelLabel = options.locale.cancelLabel;
if (typeof options.locale.weekLabel === 'string')
this.locale.weekLabel = options.locale.weekLabel;
if (typeof options.locale.customRangeLabel === 'string'){
var elem = document.createElement('textarea');
elem.innerHTML = options.locale.customRangeLabel;
var rangeHtml = elem.value;
this.locale.customRangeLabel = rangeHtml;
}
}
this.container.addClass(this.locale.direction);
if (typeof options.startDate === 'string')
this.startDate = moment(options.startDate, this.locale.format);
if (typeof options.endDate === 'string')
this.endDate = moment(options.endDate, this.locale.format);
if (typeof options.minDate === 'string')
this.minDate = moment(options.minDate, this.locale.format);
if (typeof options.maxDate === 'string')
this.maxDate = moment(options.maxDate, this.locale.format);
if (typeof options.startDate === 'object')
this.startDate = moment(options.startDate);
if (typeof options.endDate === 'object')
this.endDate = moment(options.endDate);
if (typeof options.minDate === 'object')
this.minDate = moment(options.minDate);
if (typeof options.maxDate === 'object')
this.maxDate = moment(options.maxDate);
if (this.minDate && this.startDate.isBefore(this.minDate))
this.startDate = this.minDate.clone();
if (this.maxDate && this.endDate.isAfter(this.maxDate))
this.endDate = this.maxDate.clone();
if (typeof options.applyClass === 'string')
this.applyClass = options.applyClass;
if (typeof options.cancelClass === 'string')
this.cancelClass = options.cancelClass;
if (typeof options.dateLimit === 'object')
this.dateLimit = options.dateLimit;
if (typeof options.opens === 'string')
this.opens = options.opens;
if (typeof options.drops === 'string')
this.drops = options.drops;
if (typeof options.showWeekNumbers === 'boolean')
this.showWeekNumbers = options.showWeekNumbers;
if (typeof options.showISOWeekNumbers === 'boolean')
this.showISOWeekNumbers = options.showISOWeekNumbers;
if (typeof options.buttonClasses === 'string')
this.buttonClasses = options.buttonClasses;
if (typeof options.buttonClasses === 'object')
this.buttonClasses = options.buttonClasses.join(' ');
if (typeof options.showDropdowns === 'boolean')
this.showDropdowns = options.showDropdowns;
if (typeof options.showCustomRangeLabel === 'boolean')
this.showCustomRangeLabel = options.showCustomRangeLabel;
if (typeof options.singleDatePicker === 'boolean') {
this.singleDatePicker = options.singleDatePicker;
if (this.singleDatePicker)
this.endDate = this.startDate.clone();
}
if (typeof options.timePicker === 'boolean')
this.timePicker = options.timePicker;
if (typeof options.timePickerSeconds === 'boolean')
this.timePickerSeconds = options.timePickerSeconds;
if (typeof options.timePickerIncrement === 'number')
this.timePickerIncrement = options.timePickerIncrement;
if (typeof options.timePicker24Hour === 'boolean')
this.timePicker24Hour = options.timePicker24Hour;
if (typeof options.autoApply === 'boolean')
this.autoApply = options.autoApply;
if (typeof options.autoUpdateInput === 'boolean')
this.autoUpdateInput = options.autoUpdateInput;
if (typeof options.linkedCalendars === 'boolean')
this.linkedCalendars = options.linkedCalendars;
if (typeof options.isInvalidDate === 'function')
this.isInvalidDate = options.isInvalidDate;
if (typeof options.isCustomDate === 'function')
this.isCustomDate = options.isCustomDate;
if (typeof options.alwaysShowCalendars === 'boolean')
this.alwaysShowCalendars = options.alwaysShowCalendars;
if (this.locale.firstDay != 0) {
var iterator = this.locale.firstDay;
while (iterator > 0) {
this.locale.daysOfWeek.push(this.locale.daysOfWeek.shift());
iterator--;
}
}
var start, end, range;
if (typeof options.startDate === 'undefined' && typeof options.endDate === 'undefined') {
if ($(this.element).is('input[type=text]')) {
var val = $(this.element).val(),
split = val.split(this.locale.separator);
start = end = null;
if (split.length == 2) {
start = moment(split[0], this.locale.format);
end = moment(split[1], this.locale.format);
} else if (this.singleDatePicker && val !== "") {
start = moment(val, this.locale.format);
end = moment(val, this.locale.format);
}
if (start !== null && end !== null) {
this.setStartDate(start);
this.setEndDate(end);
}
}
}
if (typeof options.ranges === 'object') {
for (range in options.ranges) {
if (typeof options.ranges[range][0] === 'string')
start = moment(options.ranges[range][0], this.locale.format);
else
start = moment(options.ranges[range][0]);
if (typeof options.ranges[range][1] === 'string')
end = moment(options.ranges[range][1], this.locale.format);
else
end = moment(options.ranges[range][1]);
if (this.minDate && start.isBefore(this.minDate))
start = this.minDate.clone();
var maxDate = this.maxDate;
if (this.dateLimit && maxDate && start.clone().add(this.dateLimit).isAfter(maxDate))
maxDate = start.clone().add(this.dateLimit);
if (maxDate && end.isAfter(maxDate))
end = maxDate.clone();
if ((this.minDate && end.isBefore(this.minDate, this.timepicker ? 'minute' : 'day'))
|| (maxDate && start.isAfter(maxDate, this.timepicker ? 'minute' : 'day')))
continue;
var elem = document.createElement('textarea');
elem.innerHTML = range;
var rangeHtml = elem.value;
this.ranges[rangeHtml] = [start, end];
}
var list = '<ul>';
for (range in this.ranges) {
list += '<li data-range-key="' + range + '">' + range + '</li>';
}
if (this.showCustomRangeLabel) {
list += '<li data-range-key="' + this.locale.customRangeLabel + '">' + this.locale.customRangeLabel + '</li>';
}
list += '</ul>';
this.container.find('.ranges').prepend(list);
}
if (typeof cb === 'function') {
this.callback = cb;
}
if (!this.timePicker) {
this.startDate = this.startDate.startOf('day');
this.endDate = this.endDate.endOf('day');
this.container.find('.calendar-time').hide();
}
if (this.timePicker && this.autoApply)
this.autoApply = false;
if (this.autoApply && typeof options.ranges !== 'object') {
this.container.find('.ranges').hide();
} else if (this.autoApply) {
this.container.find('.applyBtn, .cancelBtn').addClass('hide');
}
if (this.singleDatePicker) {
this.container.addClass('single');
this.container.find('.calendar.left').addClass('single');
this.container.find('.calendar.left').show();
this.container.find('.calendar.right').hide();
this.container.find('.daterangepicker_input input, .daterangepicker_input > i').hide();
if (this.timePicker) {
this.container.find('.ranges ul').hide();
} else {
this.container.find('.ranges').hide();
}
}
if ((typeof options.ranges === 'undefined' && !this.singleDatePicker) || this.alwaysShowCalendars) {
this.container.addClass('show-calendar');
}
this.container.addClass('opens' + this.opens);
if (typeof options.ranges !== 'undefined' && this.opens == 'right') {
this.container.find('.ranges').prependTo( this.container.find('.calendar.left').parent() );
}
this.container.find('.applyBtn, .cancelBtn').addClass(this.buttonClasses);
if (this.applyClass.length)
this.container.find('.applyBtn').addClass(this.applyClass);
if (this.cancelClass.length)
this.container.find('.cancelBtn').addClass(this.cancelClass);
this.container.find('.applyBtn').html(this.locale.applyLabel);
this.container.find('.cancelBtn').html(this.locale.cancelLabel);
this.container.find('.calendar')
.on('click.daterangepicker', '.prev', $.proxy(this.clickPrev, this))
.on('click.daterangepicker', '.next', $.proxy(this.clickNext, this))
.on('mousedown.daterangepicker', 'td.available', $.proxy(this.clickDate, this))
.on('mouseenter.daterangepicker', 'td.available', $.proxy(this.hoverDate, this))
.on('mouseleave.daterangepicker', 'td.available', $.proxy(this.updateFormInputs, this))
.on('change.daterangepicker', 'select.yearselect', $.proxy(this.monthOrYearChanged, this))
.on('change.daterangepicker', 'select.monthselect', $.proxy(this.monthOrYearChanged, this))
.on('change.daterangepicker', 'select.hourselect,select.minuteselect,select.secondselect,select.ampmselect', $.proxy(this.timeChanged, this))
.on('click.daterangepicker', '.daterangepicker_input input', $.proxy(this.showCalendars, this))
.on('focus.daterangepicker', '.daterangepicker_input input', $.proxy(this.formInputsFocused, this))
.on('blur.daterangepicker', '.daterangepicker_input input', $.proxy(this.formInputsBlurred, this))
.on('change.daterangepicker', '.daterangepicker_input input', $.proxy(this.formInputsChanged, this))
.on('keydown.daterangepicker', '.daterangepicker_input input', $.proxy(this.formInputsKeydown, this));
this.container.find('.ranges')
.on('click.daterangepicker', 'button.applyBtn', $.proxy(this.clickApply, this))
.on('click.daterangepicker', 'button.cancelBtn', $.proxy(this.clickCancel, this))
.on('click.daterangepicker', 'li', $.proxy(this.clickRange, this))
.on('mouseenter.daterangepicker', 'li', $.proxy(this.hoverRange, this))
.on('mouseleave.daterangepicker', 'li', $.proxy(this.updateFormInputs, this));
if (this.element.is('input') || this.element.is('button')) {
this.element.on({
'click.daterangepicker': $.proxy(this.show, this),
'focus.daterangepicker': $.proxy(this.show, this),
'keyup.daterangepicker': $.proxy(this.elementChanged, this),
'keydown.daterangepicker': $.proxy(this.keydown, this) //IE 11 compatibility
});
} else {
this.element.on('click.daterangepicker', $.proxy(this.toggle, this));
this.element.on('keydown.daterangepicker', $.proxy(this.toggle, this));
}
if (this.element.is('input') && !this.singleDatePicker && this.autoUpdateInput) {
this.element.val(this.startDate.format(this.locale.format) + this.locale.separator + this.endDate.format(this.locale.format));
this.element.trigger('change');
} else if (this.element.is('input') && this.autoUpdateInput) {
this.element.val(this.startDate.format(this.locale.format));
this.element.trigger('change');
}
};
DateRangePicker.prototype = {
constructor: DateRangePicker,
setStartDate: function(startDate) {
if (typeof startDate === 'string')
this.startDate = moment(startDate, this.locale.format);
if (typeof startDate === 'object')
this.startDate = moment(startDate);
if (!this.timePicker)
this.startDate = this.startDate.startOf('day');
if (this.timePicker && this.timePickerIncrement)
this.startDate.minute(Math.round(this.startDate.minute() / this.timePickerIncrement) * this.timePickerIncrement);
if (this.minDate && this.startDate.isBefore(this.minDate)) {
this.startDate = this.minDate.clone();
if (this.timePicker && this.timePickerIncrement)
this.startDate.minute(Math.round(this.startDate.minute() / this.timePickerIncrement) * this.timePickerIncrement);
}
if (this.maxDate && this.startDate.isAfter(this.maxDate)) {
this.startDate = this.maxDate.clone();
if (this.timePicker && this.timePickerIncrement)
this.startDate.minute(Math.floor(this.startDate.minute() / this.timePickerIncrement) * this.timePickerIncrement);
}
if (!this.isShowing)
this.updateElement();
this.updateMonthsInView();
},
setEndDate: function(endDate) {
if (typeof endDate === 'string')
this.endDate = moment(endDate, this.locale.format);
if (typeof endDate === 'object')
this.endDate = moment(endDate);
if (!this.timePicker)
this.endDate = this.endDate.add(1,'d').startOf('day').subtract(1,'second');
if (this.timePicker && this.timePickerIncrement)
this.endDate.minute(Math.round(this.endDate.minute() / this.timePickerIncrement) * this.timePickerIncrement);
if (this.endDate.isBefore(this.startDate))
this.endDate = this.startDate.clone();
if (this.maxDate && this.endDate.isAfter(this.maxDate))
this.endDate = this.maxDate.clone();
if (this.dateLimit && this.startDate.clone().add(this.dateLimit).isBefore(this.endDate))
this.endDate = this.startDate.clone().add(this.dateLimit);
this.previousRightTime = this.endDate.clone();
if (!this.isShowing)
this.updateElement();
this.updateMonthsInView();
},
isInvalidDate: function() {
return false;
},
isCustomDate: function() {
return false;
},
updateView: function() {
if (this.timePicker) {
this.renderTimePicker('left');
this.renderTimePicker('right');
if (!this.endDate) {
this.container.find('.right .calendar-time select').attr('disabled', 'disabled').addClass('disabled');
} else {
this.container.find('.right .calendar-time select').removeAttr('disabled').removeClass('disabled');
}
}
if (this.endDate) {
this.container.find('input[name="daterangepicker_end"]').removeClass('active');
this.container.find('input[name="daterangepicker_start"]').addClass('active');
} else {
this.container.find('input[name="daterangepicker_end"]').addClass('active');
this.container.find('input[name="daterangepicker_start"]').removeClass('active');
}
this.updateMonthsInView();
this.updateCalendars();
this.updateFormInputs();
},
updateMonthsInView: function() {
if (this.endDate) {
if (!this.singleDatePicker && this.leftCalendar.month && this.rightCalendar.month &&
(this.startDate.format('YYYY-MM') == this.leftCalendar.month.format('YYYY-MM') || this.startDate.format('YYYY-MM') == this.rightCalendar.month.format('YYYY-MM'))
&&
(this.endDate.format('YYYY-MM') == this.leftCalendar.month.format('YYYY-MM') || this.endDate.format('YYYY-MM') == this.rightCalendar.month.format('YYYY-MM'))
) {
return;
}
this.leftCalendar.month = this.startDate.clone().date(2);
if (!this.linkedCalendars && (this.endDate.month() != this.startDate.month() || this.endDate.year() != this.startDate.year())) {
this.rightCalendar.month = this.endDate.clone().date(2);
} else {
this.rightCalendar.month = this.startDate.clone().date(2).add(1, 'month');
}
} else {
if (this.leftCalendar.month.format('YYYY-MM') != this.startDate.format('YYYY-MM') && this.rightCalendar.month.format('YYYY-MM') != this.startDate.format('YYYY-MM')) {
this.leftCalendar.month = this.startDate.clone().date(2);
this.rightCalendar.month = this.startDate.clone().date(2).add(1, 'month');
}
}
if (this.maxDate && this.linkedCalendars && !this.singleDatePicker && this.rightCalendar.month > this.maxDate) {
this.rightCalendar.month = this.maxDate.clone().date(2);
this.leftCalendar.month = this.maxDate.clone().date(2).subtract(1, 'month');
}
},
updateCalendars: function() {
if (this.timePicker) {
var hour, minute, second;
if (this.endDate) {
hour = parseInt(this.container.find('.left .hourselect').val(), 10);
minute = parseInt(this.container.find('.left .minuteselect').val(), 10);
second = this.timePickerSeconds ? parseInt(this.container.find('.left .secondselect').val(), 10) : 0;
if (!this.timePicker24Hour) {
var ampm = this.container.find('.left .ampmselect').val();
if (ampm === 'PM' && hour < 12)
hour += 12;
if (ampm === 'AM' && hour === 12)
hour = 0;
}
} else {
hour = parseInt(this.container.find('.right .hourselect').val(), 10);
minute = parseInt(this.container.find('.right .minuteselect').val(), 10);
second = this.timePickerSeconds ? parseInt(this.container.find('.right .secondselect').val(), 10) : 0;
if (!this.timePicker24Hour) {
var ampm = this.container.find('.right .ampmselect').val();
if (ampm === 'PM' && hour < 12)
hour += 12;
if (ampm === 'AM' && hour === 12)
hour = 0;
}
}
this.leftCalendar.month.hour(hour).minute(minute).second(second);
this.rightCalendar.month.hour(hour).minute(minute).second(second);
}
this.renderCalendar('left');
this.renderCalendar('right');
this.container.find('.ranges li').removeClass('active');
if (this.endDate == null) return;
this.calculateChosenLabel();
},
renderCalendar: function(side) {
var calendar = side == 'left' ? this.leftCalendar : this.rightCalendar;
var month = calendar.month.month();
var year = calendar.month.year();
var hour = calendar.month.hour();
var minute = calendar.month.minute();
var second = calendar.month.second();
var daysInMonth = moment([year, month]).daysInMonth();
var firstDay = moment([year, month, 1]);
var lastDay = moment([year, month, daysInMonth]);
var lastMonth = moment(firstDay).subtract(1, 'month').month();
var lastYear = moment(firstDay).subtract(1, 'month').year();
var daysInLastMonth = moment([lastYear, lastMonth]).daysInMonth();
var dayOfWeek = firstDay.day();
var calendar = [];
calendar.firstDay = firstDay;
calendar.lastDay = lastDay;
for (var i = 0; i < 6; i++) {
calendar[i] = [];
}
var startDay = daysInLastMonth - dayOfWeek + this.locale.firstDay + 1;
if (startDay > daysInLastMonth)
startDay -= 7;
if (dayOfWeek == this.locale.firstDay)
startDay = daysInLastMonth - 6;
var curDate = moment([lastYear, lastMonth, startDay, 12, minute, second]);
var col, row;
for (var i = 0, col = 0, row = 0; i < 42; i++, col++, curDate = moment(curDate).add(24, 'hour')) {
if (i > 0 && col % 7 === 0) {
col = 0;
row++;
}
calendar[row][col] = curDate.clone().hour(hour).minute(minute).second(second);
curDate.hour(12);
if (this.minDate && calendar[row][col].format('YYYY-MM-DD') == this.minDate.format('YYYY-MM-DD') && calendar[row][col].isBefore(this.minDate) && side == 'left') {
calendar[row][col] = this.minDate.clone();
}
if (this.maxDate && calendar[row][col].format('YYYY-MM-DD') == this.maxDate.format('YYYY-MM-DD') && calendar[row][col].isAfter(this.maxDate) && side == 'right') {
calendar[row][col] = this.maxDate.clone();
}
}
if (side == 'left') {
this.leftCalendar.calendar = calendar;
} else {
this.rightCalendar.calendar = calendar;
}
var minDate = side == 'left' ? this.minDate : this.startDate;
var maxDate = this.maxDate;
var selected = side == 'left' ? this.startDate : this.endDate;
var arrow = this.locale.direction == 'ltr' ? {left: 'chevron-left', right: 'chevron-right'} : {left: 'chevron-right', right: 'chevron-left'};
var html = '<table class="table-condensed">';
html += '<thead>';
html += '<tr>';
if (this.showWeekNumbers || this.showISOWeekNumbers)
html += '<th></th>';
if ((!minDate || minDate.isBefore(calendar.firstDay)) && (!this.linkedCalendars || side == 'left')) {
html += '<th class="prev available"><i class="fa fa-' + arrow.left + ' glyphicon glyphicon-' + arrow.left + '"></i></th>';
} else {
html += '<th></th>';
}
var dateHtml = this.locale.monthNames[calendar[1][1].month()] + calendar[1][1].format(" YYYY");
if (this.showDropdowns) {
var currentMonth = calendar[1][1].month();
var currentYear = calendar[1][1].year();
var maxYear = (maxDate && maxDate.year()) || (currentYear + 5);
var minYear = (minDate && minDate.year()) || (currentYear - 50);
var inMinYear = currentYear == minYear;
var inMaxYear = currentYear == maxYear;
var monthHtml = '<select class="monthselect">';
for (var m = 0; m < 12; m++) {
if ((!inMinYear || m >= minDate.month()) && (!inMaxYear || m <= maxDate.month())) {
monthHtml += "<option value='" + m + "'" +
(m === currentMonth ? " selected='selected'" : "") +
">" + this.locale.monthNames[m] + "</option>";
} else {
monthHtml += "<option value='" + m + "'" +
(m === currentMonth ? " selected='selected'" : "") +
" disabled='disabled'>" + this.locale.monthNames[m] + "</option>";
}
}
monthHtml += "</select>";
var yearHtml = '<select class="yearselect">';
for (var y = minYear; y <= maxYear; y++) {
yearHtml += '<option value="' + y + '"' +
(y === currentYear ? ' selected="selected"' : '') +
'>' + y + '</option>';
}
yearHtml += '</select>';
dateHtml = monthHtml + yearHtml;
}
html += '<th colspan="5" class="month">' + dateHtml + '</th>';
if ((!maxDate || maxDate.isAfter(calendar.lastDay)) && (!this.linkedCalendars || side == 'right' || this.singleDatePicker)) {
html += '<th class="next available"><i class="fa fa-' + arrow.right + ' glyphicon glyphicon-' + arrow.right + '"></i></th>';
} else {
html += '<th></th>';
}
html += '</tr>';
html += '<tr>';
if (this.showWeekNumbers || this.showISOWeekNumbers)
html += '<th class="week">' + this.locale.weekLabel + '</th>';
$.each(this.locale.daysOfWeek, function(index, dayOfWeek) {
html += '<th>' + dayOfWeek + '</th>';
});
html += '</tr>';
html += '</thead>';
html += '<tbody>';
if (this.endDate == null && this.dateLimit) {
var maxLimit = this.startDate.clone().add(this.dateLimit).endOf('day');
if (!maxDate || maxLimit.isBefore(maxDate)) {
maxDate = maxLimit;
}
}
for (var row = 0; row < 6; row++) {
html += '<tr>';
if (this.showWeekNumbers)
html += '<td class="week">' + calendar[row][0].week() + '</td>';
else if (this.showISOWeekNumbers)
html += '<td class="week">' + calendar[row][0].isoWeek() + '</td>';
for (var col = 0; col < 7; col++) {
var classes = [];
if (calendar[row][col].isSame(new Date(), "day"))
classes.push('today');
if (calendar[row][col].isoWeekday() > 5)
classes.push('weekend');
if (calendar[row][col].month() != calendar[1][1].month())
classes.push('off');
if (this.minDate && calendar[row][col].isBefore(this.minDate, 'day'))
classes.push('off', 'disabled');
if (maxDate && calendar[row][col].isAfter(maxDate, 'day'))
classes.push('off', 'disabled');
if (this.isInvalidDate(calendar[row][col]))
classes.push('off', 'disabled');
if (calendar[row][col].format('YYYY-MM-DD') == this.startDate.format('YYYY-MM-DD'))
classes.push('active', 'start-date');
if (this.endDate != null && calendar[row][col].format('YYYY-MM-DD') == this.endDate.format('YYYY-MM-DD'))
classes.push('active', 'end-date');
if (this.endDate != null && calendar[row][col] > this.startDate && calendar[row][col] < this.endDate)
classes.push('in-range');
var isCustom = this.isCustomDate(calendar[row][col]);
if (isCustom !== false) {
if (typeof isCustom === 'string')
classes.push(isCustom);
else
Array.prototype.push.apply(classes, isCustom);
}
var cname = '', disabled = false;
for (var i = 0; i < classes.length; i++) {
cname += classes[i] + ' ';
if (classes[i] == 'disabled')
disabled = true;
}
if (!disabled)
cname += 'available';
html += '<td class="' + cname.replace(/^\s+|\s+$/g, '') + '" data-title="' + 'r' + row + 'c' + col + '">' + calendar[row][col].date() + '</td>';
}
html += '</tr>';
}
html += '</tbody>';
html += '</table>';
this.container.find('.calendar.' + side + ' .calendar-table').html(html);
},
renderTimePicker: function(side) {
if (side == 'right' && !this.endDate) return;
var html, selected, minDate, maxDate = this.maxDate;
if (this.dateLimit && (!this.maxDate || this.startDate.clone().add(this.dateLimit).isAfter(this.maxDate)))
maxDate = this.startDate.clone().add(this.dateLimit);
if (side == 'left') {
selected = this.startDate.clone();
minDate = this.minDate;
} else if (side == 'right') {
selected = this.endDate.clone();
minDate = this.startDate;
var timeSelector = this.container.find('.calendar.right .calendar-time div');
if (timeSelector.html() != '') {
selected.hour(timeSelector.find('.hourselect option:selected').val() || selected.hour());
selected.minute(timeSelector.find('.minuteselect option:selected').val() || selected.minute());
selected.second(timeSelector.find('.secondselect option:selected').val() || selected.second());
if (!this.timePicker24Hour) {
var ampm = timeSelector.find('.ampmselect option:selected').val();
if (ampm === 'PM' && selected.hour() < 12)
selected.hour(selected.hour() + 12);
if (ampm === 'AM' && selected.hour() === 12)
selected.hour(0);
}
}
if (selected.isBefore(this.startDate))
selected = this.startDate.clone();
if (maxDate && selected.isAfter(maxDate))
selected = maxDate.clone();
}
html = '<select class="hourselect">';
var start = this.timePicker24Hour ? 0 : 1;
var end = this.timePicker24Hour ? 23 : 12;
for (var i = start; i <= end; i++) {
var i_in_24 = i;
if (!this.timePicker24Hour)
i_in_24 = selected.hour() >= 12 ? (i == 12 ? 12 : i + 12) : (i == 12 ? 0 : i);
var time = selected.clone().hour(i_in_24);
var disabled = false;
if (minDate && time.minute(59).isBefore(minDate))
disabled = true;
if (maxDate && time.minute(0).isAfter(maxDate))
disabled = true;
if (i_in_24 == selected.hour() && !disabled) {
html += '<option value="' + i + '" selected="selected">' + i + '</option>';
} else if (disabled) {
html += '<option value="' + i + '" disabled="disabled" class="disabled">' + i + '</option>';
} else {
html += '<option value="' + i + '">' + i + '</option>';
}
}
html += '</select> ';
html += ': <select class="minuteselect">';
for (var i = 0; i < 60; i += this.timePickerIncrement) {
var padded = i < 10 ? '0' + i : i;
var time = selected.clone().minute(i);
var disabled = false;
if (minDate && time.second(59).isBefore(minDate))
disabled = true;
if (maxDate && time.second(0).isAfter(maxDate))
disabled = true;
if (selected.minute() == i && !disabled) {
html += '<option value="' + i + '" selected="selected">' + padded + '</option>';
} else if (disabled) {
html += '<option value="' + i + '" disabled="disabled" class="disabled">' + padded + '</option>';
} else {
html += '<option value="' + i + '">' + padded + '</option>';
}
}
html += '</select> ';
if (this.timePickerSeconds) {
html += ': <select class="secondselect">';
for (var i = 0; i < 60; i++) {
var padded = i < 10 ? '0' + i : i;
var time = selected.clone().second(i);
var disabled = false;
if (minDate && time.isBefore(minDate))
disabled = true;
if (maxDate && time.isAfter(maxDate))
disabled = true;
if (selected.second() == i && !disabled) {
html += '<option value="' + i + '" selected="selected">' + padded + '</option>';
} else if (disabled) {
html += '<option value="' + i + '" disabled="disabled" class="disabled">' + padded + '</option>';
} else {
html += '<option value="' + i + '">' + padded + '</option>';
}
}
html += '</select> ';
}
if (!this.timePicker24Hour) {
html += '<select class="ampmselect">';
var am_html = '';
var pm_html = '';
if (minDate && selected.clone().hour(12).minute(0).second(0).isBefore(minDate))
am_html = ' disabled="disabled" class="disabled"';
if (maxDate && selected.clone().hour(0).minute(0).second(0).isAfter(maxDate))
pm_html = ' disabled="disabled" class="disabled"';
if (selected.hour() >= 12) {
html += '<option value="AM"' + am_html + '>AM</option><option value="PM" selected="selected"' + pm_html + '>PM</option>';
} else {
html += '<option value="AM" selected="selected"' + am_html + '>AM</option><option value="PM"' + pm_html + '>PM</option>';
}
html += '</select>';
}
this.container.find('.calendar.' + side + ' .calendar-time div').html(html);
},
updateFormInputs: function() {
if (this.container.find('input[name=daterangepicker_start]').is(":focus") || this.container.find('input[name=daterangepicker_end]').is(":focus"))
return;
this.container.find('input[name=daterangepicker_start]').val(this.startDate.format(this.locale.format));
if (this.endDate)
this.container.find('input[name=daterangepicker_end]').val(this.endDate.format(this.locale.format));
if (this.singleDatePicker || (this.endDate && (this.startDate.isBefore(this.endDate) || this.startDate.isSame(this.endDate)))) {
this.container.find('button.applyBtn').removeAttr('disabled');
} else {
this.container.find('button.applyBtn').attr('disabled', 'disabled');
}
},
move: function() {
var parentOffset = { top: 0, left: 0 },
containerTop;
var parentRightEdge = $(window).width();
if (!this.parentEl.is('body')) {
parentOffset = {
top: this.parentEl.offset().top - this.parentEl.scrollTop(),
left: this.parentEl.offset().left - this.parentEl.scrollLeft()
};
parentRightEdge = this.parentEl[0].clientWidth + this.parentEl.offset().left;
}
if (this.drops == 'up')
containerTop = this.element.offset().top - this.container.outerHeight() - parentOffset.top;
else
containerTop = this.element.offset().top + this.element.outerHeight() - parentOffset.top;
this.container[this.drops == 'up' ? 'addClass' : 'removeClass']('dropup');
if (this.opens == 'left') {
this.container.css({
top: containerTop,
right: parentRightEdge - this.element.offset().left - this.element.outerWidth(),
left: 'auto'
});
if (this.container.offset().left < 0) {
this.container.css({
right: 'auto',
left: 9
});
}
} else if (this.opens == 'center') {
this.container.css({
top: containerTop,
left: this.element.offset().left - parentOffset.left + this.element.outerWidth() / 2
- this.container.outerWidth() / 2,
right: 'auto'
});
if (this.container.offset().left < 0) {
this.container.css({
right: 'auto',
left: 9
});
}
} else {
this.container.css({
top: containerTop,
left: this.element.offset().left - parentOffset.left,
right: 'auto'
});
if (this.container.offset().left + this.container.outerWidth() > $(window).width()) {
this.container.css({
left: 'auto',
right: 0
});
}
}
},
show: function(e) {
if (this.isShowing) return;
this._outsideClickProxy = $.proxy(function(e) { this.outsideClick(e); }, this);
$(document)
.on('mousedown.daterangepicker', this._outsideClickProxy)
.on('touchend.daterangepicker', this._outsideClickProxy)
.on('click.daterangepicker', '[data-toggle=dropdown]', this._outsideClickProxy)
.on('focusin.daterangepicker', this._outsideClickProxy);
$(window).on('resize.daterangepicker', $.proxy(function(e) { this.move(e); }, this));
this.oldStartDate = this.startDate.clone();
this.oldEndDate = this.endDate.clone();
this.previousRightTime = this.endDate.clone();
this.updateView();
this.container.show();
this.move();
this.element.trigger('show.daterangepicker', this);
this.isShowing = true;
},
hide: function(e) {
if (!this.isShowing) return;
if (!this.endDate) {
this.startDate = this.oldStartDate.clone();
this.endDate = this.oldEndDate.clone();
}
if (!this.startDate.isSame(this.oldStartDate) || !this.endDate.isSame(this.oldEndDate))
this.callback(this.startDate, this.endDate, this.chosenLabel);
this.updateElement();
$(document).off('.daterangepicker');
$(window).off('.daterangepicker');
this.container.hide();
this.element.trigger('hide.daterangepicker', this);
this.isShowing = false;
},
toggle: function(e) {
if (this.isShowing) {
this.hide();
} else {
this.show();
}
},
outsideClick: function(e) {
var target = $(e.target);
if (
e.type == "focusin" ||
target.closest(this.element).length ||
target.closest(this.container).length ||
target.closest('.calendar-table').length
) return;
this.hide();
this.element.trigger('outsideClick.daterangepicker', this);
},
showCalendars: function() {
this.container.addClass('show-calendar');
this.move();
this.element.trigger('showCalendar.daterangepicker', this);
},
hideCalendars: function() {
this.container.removeClass('show-calendar');
this.element.trigger('hideCalendar.daterangepicker', this);
},
hoverRange: function(e) {
if (this.container.find('input[name=daterangepicker_start]').is(":focus") || this.container.find('input[name=daterangepicker_end]').is(":focus"))
return;
var label = e.target.getAttribute('data-range-key');
if (label == this.locale.customRangeLabel) {
this.updateView();
} else {
var dates = this.ranges[label];
this.container.find('input[name=daterangepicker_start]').val(dates[0].format(this.locale.format));
this.container.find('input[name=daterangepicker_end]').val(dates[1].format(this.locale.format));
}
},
clickRange: function(e) {
var label = e.target.getAttribute('data-range-key');
this.chosenLabel = label;
if (label == this.locale.customRangeLabel) {
this.showCalendars();
} else {
var dates = this.ranges[label];
this.startDate = dates[0];
this.endDate = dates[1];
if (!this.timePicker) {
this.startDate.startOf('day');
this.endDate.endOf('day');
}
if (!this.alwaysShowCalendars)
this.hideCalendars();
this.clickApply();
}
},
clickPrev: function(e) {
var cal = $(e.target).parents('.calendar');
if (cal.hasClass('left')) {
this.leftCalendar.month.subtract(1, 'month');
if (this.linkedCalendars)
this.rightCalendar.month.subtract(1, 'month');
} else {
this.rightCalendar.month.subtract(1, 'month');
}
this.updateCalendars();
},
clickNext: function(e) {
var cal = $(e.target).parents('.calendar');
if (cal.hasClass('left')) {
this.leftCalendar.month.add(1, 'month');
} else {
this.rightCalendar.month.add(1, 'month');
if (this.linkedCalendars)
this.leftCalendar.month.add(1, 'month');
}
this.updateCalendars();
},
hoverDate: function(e) {
if (!$(e.target).hasClass('available')) return;
var title = $(e.target).attr('data-title');
var row = title.substr(1, 1);
var col = title.substr(3, 1);
var cal = $(e.target).parents('.calendar');
var date = cal.hasClass('left') ? this.leftCalendar.calendar[row][col] : this.rightCalendar.calendar[row][col];
if (this.endDate && !this.container.find('input[name=daterangepicker_start]').is(":focus")) {
this.container.find('input[name=daterangepicker_start]').val(date.format(this.locale.format));
} else if (!this.endDate && !this.container.find('input[name=daterangepicker_end]').is(":focus")) {
this.container.find('input[name=daterangepicker_end]').val(date.format(this.locale.format));
}
var leftCalendar = this.leftCalendar;
var rightCalendar = this.rightCalendar;
var startDate = this.startDate;
if (!this.endDate) {
this.container.find('.calendar tbody td').each(function(index, el) {
if ($(el).hasClass('week')) return;
var title = $(el).attr('data-title');
var row = title.substr(1, 1);
var col = title.substr(3, 1);
var cal = $(el).parents('.calendar');
var dt = cal.hasClass('left') ? leftCalendar.calendar[row][col] : rightCalendar.calendar[row][col];
if ((dt.isAfter(startDate) && dt.isBefore(date)) || dt.isSame(date, 'day')) {
$(el).addClass('in-range');
} else {
$(el).removeClass('in-range');
}
});
}
},
clickDate: function(e) {
if (!$(e.target).hasClass('available')) return;
var title = $(e.target).attr('data-title');
var row = title.substr(1, 1);
var col = title.substr(3, 1);
var cal = $(e.target).parents('.calendar');
var date = cal.hasClass('left') ? this.leftCalendar.calendar[row][col] : this.rightCalendar.calendar[row][col];
if (this.endDate || date.isBefore(this.startDate, 'day')) { //picking start
if (this.timePicker) {
var hour = parseInt(this.container.find('.left .hourselect').val(), 10);
if (!this.timePicker24Hour) {
var ampm = this.container.find('.left .ampmselect').val();
if (ampm === 'PM' && hour < 12)
hour += 12;
if (ampm === 'AM' && hour === 12)
hour = 0;
}
var minute = parseInt(this.container.find('.left .minuteselect').val(), 10);
var second = this.timePickerSeconds ? parseInt(this.container.find('.left .secondselect').val(), 10) : 0;
date = date.clone().hour(hour).minute(minute).second(second);
}
this.endDate = null;
this.setStartDate(date.clone());
} else if (!this.endDate && date.isBefore(this.startDate)) {
this.setEndDate(this.startDate.clone());
} else { // picking end
if (this.timePicker) {
var hour = parseInt(this.container.find('.right .hourselect').val(), 10);
if (!this.timePicker24Hour) {
var ampm = this.container.find('.right .ampmselect').val();
if (ampm === 'PM' && hour < 12)
hour += 12;
if (ampm === 'AM' && hour === 12)
hour = 0;
}
var minute = parseInt(this.container.find('.right .minuteselect').val(), 10);
var second = this.timePickerSeconds ? parseInt(this.container.find('.right .secondselect').val(), 10) : 0;
date = date.clone().hour(hour).minute(minute).second(second);
}
this.setEndDate(date.clone());
if (this.autoApply) {
this.calculateChosenLabel();
this.clickApply();
}
}
if (this.singleDatePicker) {
this.setEndDate(this.startDate);
if (!this.timePicker)
this.clickApply();
}
this.updateView();
e.stopPropagation();
},
calculateChosenLabel: function () {
var customRange = true;
var i = 0;
for (var range in this.ranges) {
if (this.timePicker) {
var format = this.timePickerSeconds ? "YYYY-MM-DD hh:mm:ss" : "YYYY-MM-DD hh:mm";
if (this.startDate.format(format) == this.ranges[range][0].format(format) && this.endDate.format(format) == this.ranges[range][1].format(format)) {
customRange = false;
this.chosenLabel = this.container.find('.ranges li:eq(' + i + ')').addClass('active').html();
break;
}
} else {
if (this.startDate.format('YYYY-MM-DD') == this.ranges[range][0].format('YYYY-MM-DD') && this.endDate.format('YYYY-MM-DD') == this.ranges[range][1].format('YYYY-MM-DD')) {
customRange = false;
this.chosenLabel = this.container.find('.ranges li:eq(' + i + ')').addClass('active').html();
break;
}
}
i++;
}
if (customRange) {
if (this.showCustomRangeLabel) {
this.chosenLabel = this.container.find('.ranges li:last').addClass('active').html();
} else {
this.chosenLabel = null;
}
this.showCalendars();
}
},
clickApply: function(e) {
this.hide();
this.element.trigger('apply.daterangepicker', this);
},
clickCancel: function(e) {
this.startDate = this.oldStartDate;
this.endDate = this.oldEndDate;
this.hide();
this.element.trigger('cancel.daterangepicker', this);
},
monthOrYearChanged: function(e) {
var isLeft = $(e.target).closest('.calendar').hasClass('left'),
leftOrRight = isLeft ? 'left' : 'right',
cal = this.container.find('.calendar.'+leftOrRight);
var month = parseInt(cal.find('.monthselect').val(), 10);
var year = cal.find('.yearselect').val();
if (!isLeft) {
if (year < this.startDate.year() || (year == this.startDate.year() && month < this.startDate.month())) {
month = this.startDate.month();
year = this.startDate.year();
}
}
if (this.minDate) {
if (year < this.minDate.year() || (year == this.minDate.year() && month < this.minDate.month())) {
month = this.minDate.month();
year = this.minDate.year();
}
}
if (this.maxDate) {
if (year > this.maxDate.year() || (year == this.maxDate.year() && month > this.maxDate.month())) {
month = this.maxDate.month();
year = this.maxDate.year();
}
}
if (isLeft) {
this.leftCalendar.month.month(month).year(year);
if (this.linkedCalendars)
this.rightCalendar.month = this.leftCalendar.month.clone().add(1, 'month');
} else {
this.rightCalendar.month.month(month).year(year);
if (this.linkedCalendars)
this.leftCalendar.month = this.rightCalendar.month.clone().subtract(1, 'month');
}
this.updateCalendars();
},
timeChanged: function(e) {
var cal = $(e.target).closest('.calendar'),
isLeft = cal.hasClass('left');
var hour = parseInt(cal.find('.hourselect').val(), 10);
var minute = parseInt(cal.find('.minuteselect').val(), 10);
var second = this.timePickerSeconds ? parseInt(cal.find('.secondselect').val(), 10) : 0;
if (!this.timePicker24Hour) {
var ampm = cal.find('.ampmselect').val();
if (ampm === 'PM' && hour < 12)
hour += 12;
if (ampm === 'AM' && hour === 12)
hour = 0;
}
if (isLeft) {
var start = this.startDate.clone();
start.hour(hour);
start.minute(minute);
start.second(second);
this.setStartDate(start);
if (this.singleDatePicker) {
this.endDate = this.startDate.clone();
} else if (this.endDate && this.endDate.format('YYYY-MM-DD') == start.format('YYYY-MM-DD') && this.endDate.isBefore(start)) {
this.setEndDate(start.clone());
}
} else if (this.endDate) {
var end = this.endDate.clone();
end.hour(hour);
end.minute(minute);
end.second(second);
this.setEndDate(end);
}
this.updateCalendars();
this.updateFormInputs();
this.renderTimePicker('left');
this.renderTimePicker('right');
},
formInputsChanged: function(e) {
var isRight = $(e.target).closest('.calendar').hasClass('right');
var start = moment(this.container.find('input[name="daterangepicker_start"]').val(), this.locale.format);
var end = moment(this.container.find('input[name="daterangepicker_end"]').val(), this.locale.format);
if (start.isValid() && end.isValid()) {
if (isRight && end.isBefore(start))
start = end.clone();
this.setStartDate(start);
this.setEndDate(end);
if (isRight) {
this.container.find('input[name="daterangepicker_start"]').val(this.startDate.format(this.locale.format));
} else {
this.container.find('input[name="daterangepicker_end"]').val(this.endDate.format(this.locale.format));
}
}
this.updateView();
},
formInputsFocused: function(e) {
this.container.find('input[name="daterangepicker_start"], input[name="daterangepicker_end"]').removeClass('active');
$(e.target).addClass('active');
var isRight = $(e.target).closest('.calendar').hasClass('right');
if (isRight) {
this.endDate = null;
this.setStartDate(this.startDate.clone());
this.updateView();
}
},
formInputsBlurred: function(e) {
if (!this.endDate) {
var val = this.container.find('input[name="daterangepicker_end"]').val();
var end = moment(val, this.locale.format);
if (end.isValid()) {
this.setEndDate(end);
this.updateView();
}
}
},
formInputsKeydown: function(e) {
if (e.keyCode === 13) {
e.preventDefault();
this.formInputsChanged(e);
}
},
elementChanged: function() {
if (!this.element.is('input')) return;
if (!this.element.val().length) return;
var dateString = this.element.val().split(this.locale.separator),
start = null,
end = null;
if (dateString.length === 2) {
start = moment(dateString[0], this.locale.format);
end = moment(dateString[1], this.locale.format);
}
if (this.singleDatePicker || start === null || end === null) {
start = moment(this.element.val(), this.locale.format);
end = start;
}
if (!start.isValid() || !end.isValid()) return;
this.setStartDate(start);
this.setEndDate(end);
this.updateView();
},
keydown: function(e) {
if ((e.keyCode === 9) || (e.keyCode === 13)) {
this.hide();
}
if (e.keyCode === 27) {
e.preventDefault();
e.stopPropagation();
this.hide();
}
},
updateElement: function() {
if (this.element.is('input') && !this.singleDatePicker && this.autoUpdateInput) {
this.element.val(this.startDate.format(this.locale.format) + this.locale.separator + this.endDate.format(this.locale.format));
this.element.trigger('change');
} else if (this.element.is('input') && this.autoUpdateInput) {
this.element.val(this.startDate.format(this.locale.format));
this.element.trigger('change');
}
},
remove: function() {
this.container.remove();
this.element.off('.daterangepicker');
this.element.removeData();
}
};
$.fn.daterangepicker = function(options, callback) {
var implementOptions = $.extend(true, {}, $.fn.daterangepicker.defaultOptions, options);
this.each(function() {
var el = $(this);
if (el.data('daterangepicker'))
el.data('daterangepicker').remove();
el.data('daterangepicker', new DateRangePicker(el, implementOptions, callback));
});
return this;
};
return DateRangePicker;
}));
(function($) {
'use strict';
var _currentSpinnerId = 0;
function _scopedEventName(name, id) {
return name + '.touchspin_' + id;
}
function _scopeEventNames(names, id) {
return $.map(names, function(name) {
return _scopedEventName(name, id);
});
}
$.fn.TouchSpin = function(options) {
if (options === 'destroy') {
this.each(function() {
var originalinput = $(this),
originalinput_data = originalinput.data();
$(document).off(_scopeEventNames([
'mouseup',
'touchend',
'touchcancel',
'mousemove',
'touchmove',
'scroll',
'scrollstart'], originalinput_data.spinnerid).join(' '));
});
return;
}
var defaults = {
min: 0,
max: 100,
initval: '',
replacementval: '',
step: 1,
decimals: 0,
stepinterval: 100,
forcestepdivisibility: 'round', // none | floor | round | ceil
stepintervaldelay: 500,
verticalbuttons: false,
verticalupclass: 'glyphicon glyphicon-chevron-up',
verticaldownclass: 'glyphicon glyphicon-chevron-down',
prefix: '',
postfix: '',
prefix_extraclass: '',
postfix_extraclass: '',
booster: true,
boostat: 10,
maxboostedstep: false,
mousewheel: true,
buttondown_class: 'btn btn-default',
buttonup_class: 'btn btn-default',
buttondown_txt: '-',
buttonup_txt: '+'
};
var attributeMap = {
min: 'min',
max: 'max',
initval: 'init-val',
replacementval: 'replacement-val',
step: 'step',
decimals: 'decimals',
stepinterval: 'step-interval',
verticalbuttons: 'vertical-buttons',
verticalupclass: 'vertical-up-class',
verticaldownclass: 'vertical-down-class',
forcestepdivisibility: 'force-step-divisibility',
stepintervaldelay: 'step-interval-delay',
prefix: 'prefix',
postfix: 'postfix',
prefix_extraclass: 'prefix-extra-class',
postfix_extraclass: 'postfix-extra-class',
booster: 'booster',
boostat: 'boostat',
maxboostedstep: 'max-boosted-step',
mousewheel: 'mouse-wheel',
buttondown_class: 'button-down-class',
buttonup_class: 'button-up-class',
buttondown_txt: 'button-down-txt',
buttonup_txt: 'button-up-txt'
};
return this.each(function() {
var settings,
originalinput = $(this),
originalinput_data = originalinput.data(),
container,
elements,
value,
downSpinTimer,
upSpinTimer,
downDelayTimeout,
upDelayTimeout,
spincount = 0,
spinning = false;
init();
function init() {
if (originalinput.data('alreadyinitialized')) {
return;
}
originalinput.data('alreadyinitialized', true);
_currentSpinnerId += 1;
originalinput.data('spinnerid', _currentSpinnerId);
if (!originalinput.is('input')) {
console.log('Must be an input.');
return;
}
_initSettings();
_setInitval();
_checkValue();
_buildHtml();
_initElements();
_hideEmptyPrefixPostfix();
_bindEvents();
_bindEventsInterface();
elements.input.css('display', 'block');
}
function _setInitval() {
if (settings.initval !== '' && originalinput.val() === '') {
originalinput.val(settings.initval);
}
}
function changeSettings(newsettings) {
_updateSettings(newsettings);
_checkValue();
var value = elements.input.val();
if (value !== '') {
value = Number(elements.input.val());
elements.input.val(value.toFixed(settings.decimals));
}
}
function _initSettings() {
settings = $.extend({}, defaults, originalinput_data, _parseAttributes(), options);
}
function _parseAttributes() {
var data = {};
$.each(attributeMap, function(key, value) {
var attrName = 'bts-' + value + '';
if (originalinput.is('[data-' + attrName + ']')) {
data[key] = originalinput.data(attrName);
}
});
return data;
}
function _updateSettings(newsettings) {
settings = $.extend({}, settings, newsettings);
}
function _buildHtml() {
var initval = originalinput.val(),
parentelement = originalinput.parent();
if (initval !== '') {
initval = Number(initval).toFixed(settings.decimals);
}
originalinput.data('initvalue', initval).val(initval);
originalinput.addClass('form-control');
if (parentelement.hasClass('input-group')) {
_advanceInputGroup(parentelement);
}
else {
_buildInputGroup();
}
}
function _advanceInputGroup(parentelement) {
parentelement.addClass('bootstrap-touchspin');
var prev = originalinput.prev(),
next = originalinput.next();
var downhtml,
uphtml,
prefixhtml = '<span class="input-group-addon bootstrap-touchspin-prefix">' + settings.prefix + '</span>',
postfixhtml = '<span class="input-group-addon bootstrap-touchspin-postfix">' + settings.postfix + '</span>';
if (prev.hasClass('input-group-btn')) {
downhtml = '<button class="' + settings.buttondown_class + ' bootstrap-touchspin-down" type="button">' + settings.buttondown_txt + '</button>';
prev.append(downhtml);
}
else {
downhtml = '<span class="input-group-btn"><button class="' + settings.buttondown_class + ' bootstrap-touchspin-down" type="button">' + settings.buttondown_txt + '</button></span>';
$(downhtml).insertBefore(originalinput);
}
if (next.hasClass('input-group-btn')) {
uphtml = '<button class="' + settings.buttonup_class + ' bootstrap-touchspin-up" type="button">' + settings.buttonup_txt + '</button>';
next.prepend(uphtml);
}
else {
uphtml = '<span class="input-group-btn"><button class="' + settings.buttonup_class + ' bootstrap-touchspin-up" type="button">' + settings.buttonup_txt + '</button></span>';
$(uphtml).insertAfter(originalinput);
}
$(prefixhtml).insertBefore(originalinput);
$(postfixhtml).insertAfter(originalinput);
container = parentelement;
}
function _buildInputGroup() {
var html;
if (settings.verticalbuttons) {
html = '<div class="input-group bootstrap-touchspin"><span class="input-group-addon bootstrap-touchspin-prefix">' + settings.prefix + '</span><span class="input-group-addon bootstrap-touchspin-postfix">' + settings.postfix + '</span><span class="input-group-btn-vertical"><button class="' + settings.buttondown_class + ' bootstrap-touchspin-up" type="button"><i class="' + settings.verticalupclass + '"></i></button><button class="' + settings.buttonup_class + ' bootstrap-touchspin-down" type="button"><i class="' + settings.verticaldownclass + '"></i></button></span></div>';
}
else {
html = '<div class="input-group bootstrap-touchspin"><span class="input-group-btn"><button class="' + settings.buttondown_class + ' bootstrap-touchspin-down" type="button">' + settings.buttondown_txt + '</button></span><span class="input-group-addon bootstrap-touchspin-prefix">' + settings.prefix + '</span><span class="input-group-addon bootstrap-touchspin-postfix">' + settings.postfix + '</span><span class="input-group-btn"><button class="' + settings.buttonup_class + ' bootstrap-touchspin-up" type="button">' + settings.buttonup_txt + '</button></span></div>';
}
container = $(html).insertBefore(originalinput);
$('.bootstrap-touchspin-prefix', container).after(originalinput);
if (originalinput.hasClass('input-sm')) {
container.addClass('input-group-sm');
}
else if (originalinput.hasClass('input-lg')) {
container.addClass('input-group-lg');
}
}
function _initElements() {
elements = {
down: $('.bootstrap-touchspin-down', container),
up: $('.bootstrap-touchspin-up', container),
input: $('input', container),
prefix: $('.bootstrap-touchspin-prefix', container).addClass(settings.prefix_extraclass),
postfix: $('.bootstrap-touchspin-postfix', container).addClass(settings.postfix_extraclass)
};
}
function _hideEmptyPrefixPostfix() {
if (settings.prefix === '') {
elements.prefix.hide();
}
if (settings.postfix === '') {
elements.postfix.hide();
}
}
function _bindEvents() {
originalinput.on('keydown', function(ev) {
var code = ev.keyCode || ev.which;
if (code === 38) {
if (spinning !== 'up') {
upOnce();
startUpSpin();
}
ev.preventDefault();
}
else if (code === 40) {
if (spinning !== 'down') {
downOnce();
startDownSpin();
}
ev.preventDefault();
}
});
originalinput.on('keyup', function(ev) {
var code = ev.keyCode || ev.which;
if (code === 38) {
stopSpin();
}
else if (code === 40) {
stopSpin();
}
});
originalinput.on('blur', function() {
_checkValue();
});
elements.down.on('keydown', function(ev) {
var code = ev.keyCode || ev.which;
if (code === 32 || code === 13) {
if (spinning !== 'down') {
downOnce();
startDownSpin();
}
ev.preventDefault();
}
});
elements.down.on('keyup', function(ev) {
var code = ev.keyCode || ev.which;
if (code === 32 || code === 13) {
stopSpin();
}
});
elements.up.on('keydown', function(ev) {
var code = ev.keyCode || ev.which;
if (code === 32 || code === 13) {
if (spinning !== 'up') {
upOnce();
startUpSpin();
}
ev.preventDefault();
}
});
elements.up.on('keyup', function(ev) {
var code = ev.keyCode || ev.which;
if (code === 32 || code === 13) {
stopSpin();
}
});
elements.down.on('mousedown.touchspin', function(ev) {
elements.down.off('touchstart.touchspin');  // android 4 workaround
if (originalinput.is(':disabled')) {
return;
}
downOnce();
startDownSpin();
ev.preventDefault();
ev.stopPropagation();
});
elements.down.on('touchstart.touchspin', function(ev) {
elements.down.off('mousedown.touchspin');  // android 4 workaround
if (originalinput.is(':disabled')) {
return;
}
downOnce();
startDownSpin();
ev.preventDefault();
ev.stopPropagation();
});
elements.up.on('mousedown.touchspin', function(ev) {
elements.up.off('touchstart.touchspin');  // android 4 workaround
if (originalinput.is(':disabled')) {
return;
}
upOnce();
startUpSpin();
ev.preventDefault();
ev.stopPropagation();
});
elements.up.on('touchstart.touchspin', function(ev) {
elements.up.off('mousedown.touchspin');  // android 4 workaround
if (originalinput.is(':disabled')) {
return;
}
upOnce();
startUpSpin();
ev.preventDefault();
ev.stopPropagation();
});
elements.up.on('mouseout touchleave touchend touchcancel', function(ev) {
if (!spinning) {
return;
}
ev.stopPropagation();
stopSpin();
});
elements.down.on('mouseout touchleave touchend touchcancel', function(ev) {
if (!spinning) {
return;
}
ev.stopPropagation();
stopSpin();
});
elements.down.on('mousemove touchmove', function(ev) {
if (!spinning) {
return;
}
ev.stopPropagation();
ev.preventDefault();
});
elements.up.on('mousemove touchmove', function(ev) {
if (!spinning) {
return;
}
ev.stopPropagation();
ev.preventDefault();
});
$(document).on(_scopeEventNames(['mouseup', 'touchend', 'touchcancel'], _currentSpinnerId).join(' '), function(ev) {
if (!spinning) {
return;
}
ev.preventDefault();
stopSpin();
});
$(document).on(_scopeEventNames(['mousemove', 'touchmove', 'scroll', 'scrollstart'], _currentSpinnerId).join(' '), function(ev) {
if (!spinning) {
return;
}
ev.preventDefault();
stopSpin();
});
originalinput.on('mousewheel DOMMouseScroll', function(ev) {
if (!settings.mousewheel || !originalinput.is(':focus')) {
return;
}
var delta = ev.originalEvent.wheelDelta || -ev.originalEvent.deltaY || -ev.originalEvent.detail;
ev.stopPropagation();
ev.preventDefault();
if (delta < 0) {
downOnce();
}
else {
upOnce();
}
});
}
function _bindEventsInterface() {
originalinput.on('touchspin.uponce', function() {
stopSpin();
upOnce();
});
originalinput.on('touchspin.downonce', function() {
stopSpin();
downOnce();
});
originalinput.on('touchspin.startupspin', function() {
startUpSpin();
});
originalinput.on('touchspin.startdownspin', function() {
startDownSpin();
});
originalinput.on('touchspin.stopspin', function() {
stopSpin();
});
originalinput.on('touchspin.updatesettings', function(e, newsettings) {
changeSettings(newsettings);
});
}
function _forcestepdivisibility(value) {
switch (settings.forcestepdivisibility) {
case 'round':
return (Math.round(value / settings.step) * settings.step).toFixed(settings.decimals);
case 'floor':
return (Math.floor(value / settings.step) * settings.step).toFixed(settings.decimals);
case 'ceil':
return (Math.ceil(value / settings.step) * settings.step).toFixed(settings.decimals);
default:
return value;
}
}
function _checkValue() {
var val, parsedval, returnval;
val = originalinput.val();
if (val === '') {
if (settings.replacementval !== '') {
originalinput.val(settings.replacementval);
originalinput.trigger('change');
}
return;
}
if (settings.decimals > 0 && val === '.') {
return;
}
parsedval = parseFloat(val);
if (isNaN(parsedval)) {
if (settings.replacementval !== '') {
parsedval = settings.replacementval;
}
else {
parsedval = 0;
}
}
returnval = parsedval;
if (parsedval.toString() !== val) {
returnval = parsedval;
}
if (parsedval < settings.min) {
returnval = settings.min;
}
if (parsedval > settings.max) {
returnval = settings.max;
}
returnval = _forcestepdivisibility(returnval);
if (Number(val).toString() !== returnval.toString()) {
originalinput.val(returnval);
originalinput.trigger('change');
}
}
function _getBoostedStep() {
if (!settings.booster) {
return settings.step;
}
else {
var boosted = Math.pow(2, Math.floor(spincount / settings.boostat)) * settings.step;
if (settings.maxboostedstep) {
if (boosted > settings.maxboostedstep) {
boosted = settings.maxboostedstep;
value = Math.round((value / boosted)) * boosted;
}
}
return Math.max(settings.step, boosted);
}
}
function upOnce() {
_checkValue();
value = parseFloat(elements.input.val());
if (isNaN(value)) {
value = 0;
}
var initvalue = value,
boostedstep = _getBoostedStep();
value = value + boostedstep;
if (value > settings.max) {
value = settings.max;
originalinput.trigger('touchspin.on.max');
stopSpin();
}
elements.input.val(Number(value).toFixed(settings.decimals));
if (initvalue !== value) {
originalinput.trigger('change');
}
}
function downOnce() {
_checkValue();
value = parseFloat(elements.input.val());
if (isNaN(value)) {
value = 0;
}
var initvalue = value,
boostedstep = _getBoostedStep();
value = value - boostedstep;
if (value < settings.min) {
value = settings.min;
originalinput.trigger('touchspin.on.min');
stopSpin();
}
elements.input.val(value.toFixed(settings.decimals));
if (initvalue !== value) {
originalinput.trigger('change');
}
}
function startDownSpin() {
stopSpin();
spincount = 0;
spinning = 'down';
originalinput.trigger('touchspin.on.startspin');
originalinput.trigger('touchspin.on.startdownspin');
downDelayTimeout = setTimeout(function() {
downSpinTimer = setInterval(function() {
spincount++;
downOnce();
}, settings.stepinterval);
}, settings.stepintervaldelay);
}
function startUpSpin() {
stopSpin();
spincount = 0;
spinning = 'up';
originalinput.trigger('touchspin.on.startspin');
originalinput.trigger('touchspin.on.startupspin');
upDelayTimeout = setTimeout(function() {
upSpinTimer = setInterval(function() {
spincount++;
upOnce();
}, settings.stepinterval);
}, settings.stepintervaldelay);
}
function stopSpin() {
clearTimeout(downDelayTimeout);
clearTimeout(upDelayTimeout);
clearInterval(downSpinTimer);
clearInterval(upSpinTimer);
switch (spinning) {
case 'up':
originalinput.trigger('touchspin.on.stopupspin');
originalinput.trigger('touchspin.on.stopspin');
break;
case 'down':
originalinput.trigger('touchspin.on.stopdownspin');
originalinput.trigger('touchspin.on.stopspin');
break;
}
spincount = 0;
spinning = false;
}
});
};
})(jQuery);
(function ($) {
'use strict';
if (!$.event.special.destroyed) {
$.event.special.destroyed = {
remove: function (o) {
if (o.handler) {
o.handler();
}
}
};
}
$.fn.extend({
maxlength: function (options, callback) {
var documentBody = $('body'),
defaults = {
showOnReady: false, // true to always show when indicator is ready
alwaysShow: false, // if true the indicator it's always shown.
threshold: 10, // Represents how many chars left are needed to show up the counter
warningClass: 'label label-success',
limitReachedClass: 'label label-important label-danger',
separator: ' / ',
preText: '',
postText: '',
showMaxLength: true,
placement: 'bottom',
message: null, // an alternative way to provide the message text
showCharsTyped: true, // show the number of characters typed and not the number of characters remaining
validate: false, // if the browser doesn't support the maxlength attribute, attempt to type more than
utf8: false, // counts using bytesize rather than length. eg: '' is counted as 2 characters.
appendToParent: false, // append the indicator to the input field's parent instead of body
twoCharLinebreak: true,  // count linebreak as 2 characters to match IE/Chrome textarea validation. As well as DB storage.
allowOverMax: false  // false = use maxlength attribute and browswer functionality.
};
if ($.isFunction(options) && !callback) {
callback = options;
options = {};
}
options = $.extend(defaults, options);
function inputLength(input) {
var text = input.val();
if (options.twoCharLinebreak) {
text = text.replace(/\r(?!\n)|\n(?!\r)/g, '\r\n');
} else {
text = text.replace(new RegExp('\r?\n', 'g'), '\n');
}
var currentLength = 0;
if (options.utf8) {
currentLength = utf8Length(text);
} else {
currentLength = text.length;
}
return currentLength;
}
function truncateChars(input, maxlength) {
var text = input.val();
var newlines = 0;
if (options.twoCharLinebreak) {
text = text.replace(/\r(?!\n)|\n(?!\r)/g, '\r\n');
if (text.substr(text.length - 1) === '\n' && text.length % 2 === 1) {
newlines = 1;
}
}
input.val(text.substr(0, maxlength - newlines));
}
function utf8Length(string) {
var utf8length = 0;
for (var n = 0; n < string.length; n++) {
var c = string.charCodeAt(n);
if (c < 128) {
utf8length++;
}
else if ((c > 127) && (c < 2048)) {
utf8length = utf8length + 2;
}
else {
utf8length = utf8length + 3;
}
}
return utf8length;
}
function charsLeftThreshold(input, thereshold, maxlength) {
var output = true;
if (!options.alwaysShow && (maxlength - inputLength(input) > thereshold)) {
output = false;
}
return output;
}
function remainingChars(input, maxlength) {
var length = maxlength - inputLength(input);
return length;
}
function showRemaining(currentInput, indicator) {
indicator.css({
display: 'block'
});
currentInput.trigger('maxlength.shown');
}
function hideRemaining(currentInput, indicator) {
indicator.css({
display: 'none'
});
currentInput.trigger('maxlength.hidden');
}
function updateMaxLengthHTML(currentInputText, maxLengthThisInput, typedChars) {
var output = '';
if (options.message) {
if (typeof options.message === 'function') {
output = options.message(currentInputText, maxLengthThisInput);
} else {
output = options.message.replace('%charsTyped%', typedChars)
.replace('%charsRemaining%', maxLengthThisInput - typedChars)
.replace('%charsTotal%', maxLengthThisInput);
}
} else {
if (options.preText) {
output += options.preText;
}
if (!options.showCharsTyped) {
output += maxLengthThisInput - typedChars;
}
else {
output += typedChars;
}
if (options.showMaxLength) {
output += options.separator + maxLengthThisInput;
}
if (options.postText) {
output += options.postText;
}
}
return output;
}
function manageRemainingVisibility(remaining, currentInput, maxLengthCurrentInput, maxLengthIndicator) {
if (maxLengthIndicator) {
maxLengthIndicator.html(updateMaxLengthHTML(currentInput.val(), maxLengthCurrentInput, (maxLengthCurrentInput - remaining)));
if (remaining > 0) {
if (charsLeftThreshold(currentInput, options.threshold, maxLengthCurrentInput)) {
showRemaining(currentInput, maxLengthIndicator.removeClass(options.limitReachedClass).addClass(options.warningClass));
} else {
hideRemaining(currentInput, maxLengthIndicator);
}
} else {
showRemaining(currentInput, maxLengthIndicator.removeClass(options.warningClass).addClass(options.limitReachedClass));
}
}
if (options.allowOverMax) {
if (remaining < 0) {
currentInput.addClass('overmax');
} else {
currentInput.removeClass('overmax');
}
}
}
function getPosition(currentInput) {
var el = currentInput[0];
return $.extend({}, (typeof el.getBoundingClientRect === 'function') ? el.getBoundingClientRect() : {
width: el.offsetWidth,
height: el.offsetHeight
}, currentInput.offset());
}
function place(currentInput, maxLengthIndicator) {
var pos = getPosition(currentInput);
if ($.type(options.placement) === 'function'){
options.placement(currentInput, maxLengthIndicator, pos);
return;
}
if ($.isPlainObject(options.placement)){
placeWithCSS(options.placement, maxLengthIndicator);
return;
}
var inputOuter = currentInput.outerWidth(),
outerWidth = maxLengthIndicator.outerWidth(),
actualWidth = maxLengthIndicator.width(),
actualHeight = maxLengthIndicator.height();
if (options.appendToParent) {
pos.top -= currentInput.parent().offset().top;
pos.left -= currentInput.parent().offset().left;
}
switch (options.placement) {
case 'bottom':
maxLengthIndicator.css({ top: pos.top + pos.height, left: pos.left + pos.width / 2 - actualWidth / 2 });
break;
case 'top':
maxLengthIndicator.css({ top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2 });
break;
case 'left':
maxLengthIndicator.css({ top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth });
break;
case 'right':
maxLengthIndicator.css({ top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width });
break;
case 'bottom-right':
maxLengthIndicator.css({ top: pos.top + pos.height, left: pos.left + pos.width });
break;
case 'top-right':
maxLengthIndicator.css({ top: pos.top - actualHeight, left: pos.left + inputOuter });
break;
case 'top-left':
maxLengthIndicator.css({ top: pos.top - actualHeight, left: pos.left - outerWidth });
break;
case 'bottom-left':
maxLengthIndicator.css({ top: pos.top + currentInput.outerHeight(), left: pos.left - outerWidth });
break;
case 'centered-right':
maxLengthIndicator.css({ top: pos.top + (actualHeight / 2), left: pos.left + inputOuter - outerWidth - 3 });
break;
case 'bottom-right-inside':
maxLengthIndicator.css({ top: pos.top + pos.height, left: pos.left + pos.width - outerWidth });
break;
case 'top-right-inside':
maxLengthIndicator.css({ top: pos.top - actualHeight, left: pos.left + inputOuter - outerWidth });
break;
case 'top-left-inside':
maxLengthIndicator.css({ top: pos.top - actualHeight, left: pos.left });
break;
case 'bottom-left-inside':
maxLengthIndicator.css({ top: pos.top + currentInput.outerHeight(), left: pos.left });
break;
}
}
function placeWithCSS(placement, maxLengthIndicator) {
if (!placement || !maxLengthIndicator){
return;
}
var POSITION_KEYS = [
'top',
'bottom',
'left',
'right',
'position'
];
var cssPos = {};
$.each(POSITION_KEYS, function (i, key) {
var val = options.placement[key];
if (typeof val !== 'undefined'){
cssPos[key] = val;
}
});
maxLengthIndicator.css(cssPos);
return;
}
function getMaxLength(currentInput) {
var attr = 'maxlength';
if (options.allowOverMax) {
attr = 'data-bs-mxl';
}
return currentInput.attr(attr) || currentInput.attr('size');
}
return this.each(function () {
var currentInput = $(this),
maxLengthCurrentInput,
maxLengthIndicator;
$(window).resize(function () {
if (maxLengthIndicator) {
place(currentInput, maxLengthIndicator);
}
});
if (options.allowOverMax) {
$(this).attr('data-bs-mxl', $(this).attr('maxlength'));
$(this).removeAttr('maxlength');
}
function firstInit() {
var maxlengthContent = updateMaxLengthHTML(currentInput.val(), maxLengthCurrentInput, '0');
maxLengthCurrentInput = getMaxLength(currentInput);
if (!maxLengthIndicator) {
maxLengthIndicator = $('<span class="bootstrap-maxlength"></span>').css({
display: 'none',
position: 'absolute',
whiteSpace: 'nowrap',
zIndex: 1099
}).html(maxlengthContent);
}
if (currentInput.is('textarea')) {
currentInput.data('maxlenghtsizex', currentInput.outerWidth());
currentInput.data('maxlenghtsizey', currentInput.outerHeight());
currentInput.mouseup(function () {
if (currentInput.outerWidth() !== currentInput.data('maxlenghtsizex') || currentInput.outerHeight() !== currentInput.data('maxlenghtsizey')) {
place(currentInput, maxLengthIndicator);
}
currentInput.data('maxlenghtsizex', currentInput.outerWidth());
currentInput.data('maxlenghtsizey', currentInput.outerHeight());
});
}
if (options.appendToParent) {
currentInput.parent().append(maxLengthIndicator);
currentInput.parent().css('position', 'relative');
} else {
documentBody.append(maxLengthIndicator);
}
var remaining = remainingChars(currentInput, getMaxLength(currentInput));
manageRemainingVisibility(remaining, currentInput, maxLengthCurrentInput, maxLengthIndicator);
place(currentInput, maxLengthIndicator);
}
if (options.showOnReady) {
currentInput.ready(function () {
firstInit();
});
} else {
currentInput.focus(function () {
firstInit();
});
}
currentInput.on('maxlength.reposition', function () {
place(currentInput, maxLengthIndicator);
});
currentInput.on('destroyed', function () {
if (maxLengthIndicator) {
maxLengthIndicator.remove();
}
});
currentInput.on('blur', function () {
if (maxLengthIndicator && !options.showOnReady) {
maxLengthIndicator.remove();
}
});
currentInput.on('input', function () {
var maxlength = getMaxLength(currentInput),
remaining = remainingChars(currentInput, maxlength),
output = true;
if (options.validate && remaining < 0) {
truncateChars(currentInput, maxlength);
output = false;
} else {
manageRemainingVisibility(remaining, currentInput, maxLengthCurrentInput, maxLengthIndicator);
}
if (options.placement === 'bottom-right-inside' || options.placement === 'top-right-inside') {
place(currentInput, maxLengthIndicator);
}
return output;
});
});
}
});
}(jQuery));
(function (global, factory) {
if (typeof define === "function" && define.amd) {
define(['jquery'], factory);
} else if (typeof exports !== "undefined") {
factory(require('jquery'));
} else {
var mod = {
exports: {}
};
factory(global.jquery);
global.bootstrapSwitch = mod.exports;
}
})(this, function (_jquery) {
'use strict';
var _jquery2 = _interopRequireDefault(_jquery);
function _interopRequireDefault(obj) {
return obj && obj.__esModule ? obj : {
default: obj
};
}
var _extends = Object.assign || function (target) {
for (var i = 1; i < arguments.length; i++) {
var source = arguments[i];
for (var key in source) {
if (Object.prototype.hasOwnProperty.call(source, key)) {
target[key] = source[key];
}
}
}
return target;
};
function _classCallCheck(instance, Constructor) {
if (!(instance instanceof Constructor)) {
throw new TypeError("Cannot call a class as a function");
}
}
var _createClass = function () {
function defineProperties(target, props) {
for (var i = 0; i < props.length; i++) {
var descriptor = props[i];
descriptor.enumerable = descriptor.enumerable || false;
descriptor.configurable = true;
if ("value" in descriptor) descriptor.writable = true;
Object.defineProperty(target, descriptor.key, descriptor);
}
}
return function (Constructor, protoProps, staticProps) {
if (protoProps) defineProperties(Constructor.prototype, protoProps);
if (staticProps) defineProperties(Constructor, staticProps);
return Constructor;
};
}();
var $ = _jquery2.default || window.jQuery || window.$;
var BootstrapSwitch = function () {
function BootstrapSwitch(element) {
var _this = this;
var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
_classCallCheck(this, BootstrapSwitch);
this.$element = $(element);
this.options = $.extend({}, $.fn.bootstrapSwitch.defaults, this._getElementOptions(), options);
this.prevOptions = {};
this.$wrapper = $('<div>', {
class: function _class() {
var classes = [];
classes.push(_this.options.state ? 'on' : 'off');
if (_this.options.size) {
classes.push(_this.options.size);
}
if (_this.options.disabled) {
classes.push('disabled');
}
if (_this.options.readonly) {
classes.push('readonly');
}
if (_this.options.indeterminate) {
classes.push('indeterminate');
}
if (_this.options.inverse) {
classes.push('inverse');
}
if (_this.$element.attr('id')) {
classes.push('id-' + _this.$element.attr('id'));
}
return classes.map(_this._getClass.bind(_this)).concat([_this.options.baseClass], _this._getClasses(_this.options.wrapperClass)).join(' ');
}
});
this.$container = $('<div>', { class: this._getClass('container') });
this.$on = $('<span>', {
html: this.options.onText,
class: this._getClass('handle-on') + ' ' + this._getClass(this.options.onColor)
});
this.$off = $('<span>', {
html: this.options.offText,
class: this._getClass('handle-off') + ' ' + this._getClass(this.options.offColor)
});
this.$label = $('<span>', {
html: this.options.labelText,
class: this._getClass('label')
});
this.$element.on('init.bootstrapSwitch', this.options.onInit.bind(this, element));
this.$element.on('switchChange.bootstrapSwitch', function () {
for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
args[_key] = arguments[_key];
}
if (_this.options.onSwitchChange.apply(element, args) === false) {
if (_this.$element.is(':radio')) {
$('[name="' + _this.$element.attr('name') + '"]').trigger('previousState.bootstrapSwitch', true);
} else {
_this.$element.trigger('previousState.bootstrapSwitch', true);
}
}
});
this.$container = this.$element.wrap(this.$container).parent();
this.$wrapper = this.$container.wrap(this.$wrapper).parent();
this.$element.before(this.options.inverse ? this.$off : this.$on).before(this.$label).before(this.options.inverse ? this.$on : this.$off);
if (this.options.indeterminate) {
this.$element.prop('indeterminate', true);
}
this._init();
this._elementHandlers();
this._handleHandlers();
this._labelHandlers();
this._formHandler();
this._externalLabelHandler();
this.$element.trigger('init.bootstrapSwitch', this.options.state);
}
_createClass(BootstrapSwitch, [{
key: 'setPrevOptions',
value: function setPrevOptions() {
this.prevOptions = _extends({}, this.options);
}
}, {
key: 'state',
value: function state(value, skip) {
if (typeof value === 'undefined') {
return this.options.state;
}
if (this.options.disabled || this.options.readonly || this.options.state && !this.options.radioAllOff && this.$element.is(':radio')) {
return this.$element;
}
if (this.$element.is(':radio')) {
$('[name="' + this.$element.attr('name') + '"]').trigger('setPreviousOptions.bootstrapSwitch');
} else {
this.$element.trigger('setPreviousOptions.bootstrapSwitch');
}
if (this.options.indeterminate) {
this.indeterminate(false);
}
this.$element.prop('checked', Boolean(value)).trigger('change.bootstrapSwitch', skip);
return this.$element;
}
}, {
key: 'toggleState',
value: function toggleState(skip) {
if (this.options.disabled || this.options.readonly) {
return this.$element;
}
if (this.options.indeterminate) {
this.indeterminate(false);
return this.state(true);
} else {
return this.$element.prop('checked', !this.options.state).trigger('change.bootstrapSwitch', skip);
}
}
}, {
key: 'size',
value: function size(value) {
if (typeof value === 'undefined') {
return this.options.size;
}
if (this.options.size != null) {
this.$wrapper.removeClass(this._getClass(this.options.size));
}
if (value) {
this.$wrapper.addClass(this._getClass(value));
}
this._width();
this._containerPosition();
this.options.size = value;
return this.$element;
}
}, {
key: 'animate',
value: function animate(value) {
if (typeof value === 'undefined') {
return this.options.animate;
}
if (this.options.animate === Boolean(value)) {
return this.$element;
}
return this.toggleAnimate();
}
}, {
key: 'toggleAnimate',
value: function toggleAnimate() {
this.options.animate = !this.options.animate;
this.$wrapper.toggleClass(this._getClass('animate'));
return this.$element;
}
}, {
key: 'disabled',
value: function disabled(value) {
if (typeof value === 'undefined') {
return this.options.disabled;
}
if (this.options.disabled === Boolean(value)) {
return this.$element;
}
return this.toggleDisabled();
}
}, {
key: 'toggleDisabled',
value: function toggleDisabled() {
this.options.disabled = !this.options.disabled;
this.$element.prop('disabled', this.options.disabled);
this.$wrapper.toggleClass(this._getClass('disabled'));
return this.$element;
}
}, {
key: 'readonly',
value: function readonly(value) {
if (typeof value === 'undefined') {
return this.options.readonly;
}
if (this.options.readonly === Boolean(value)) {
return this.$element;
}
return this.toggleReadonly();
}
}, {
key: 'toggleReadonly',
value: function toggleReadonly() {
this.options.readonly = !this.options.readonly;
this.$element.prop('readonly', this.options.readonly);
this.$wrapper.toggleClass(this._getClass('readonly'));
return this.$element;
}
}, {
key: 'indeterminate',
value: function indeterminate(value) {
if (typeof value === 'undefined') {
return this.options.indeterminate;
}
if (this.options.indeterminate === Boolean(value)) {
return this.$element;
}
return this.toggleIndeterminate();
}
}, {
key: 'toggleIndeterminate',
value: function toggleIndeterminate() {
this.options.indeterminate = !this.options.indeterminate;
this.$element.prop('indeterminate', this.options.indeterminate);
this.$wrapper.toggleClass(this._getClass('indeterminate'));
this._containerPosition();
return this.$element;
}
}, {
key: 'inverse',
value: function inverse(value) {
if (typeof value === 'undefined') {
return this.options.inverse;
}
if (this.options.inverse === Boolean(value)) {
return this.$element;
}
return this.toggleInverse();
}
}, {
key: 'toggleInverse',
value: function toggleInverse() {
this.$wrapper.toggleClass(this._getClass('inverse'));
var $on = this.$on.clone(true);
var $off = this.$off.clone(true);
this.$on.replaceWith($off);
this.$off.replaceWith($on);
this.$on = $off;
this.$off = $on;
this.options.inverse = !this.options.inverse;
return this.$element;
}
}, {
key: 'onColor',
value: function onColor(value) {
if (typeof value === 'undefined') {
return this.options.onColor;
}
if (this.options.onColor) {
this.$on.removeClass(this._getClass(this.options.onColor));
}
this.$on.addClass(this._getClass(value));
this.options.onColor = value;
return this.$element;
}
}, {
key: 'offColor',
value: function offColor(value) {
if (typeof value === 'undefined') {
return this.options.offColor;
}
if (this.options.offColor) {
this.$off.removeClass(this._getClass(this.options.offColor));
}
this.$off.addClass(this._getClass(value));
this.options.offColor = value;
return this.$element;
}
}, {
key: 'onText',
value: function onText(value) {
if (typeof value === 'undefined') {
return this.options.onText;
}
this.$on.html(value);
this._width();
this._containerPosition();
this.options.onText = value;
return this.$element;
}
}, {
key: 'offText',
value: function offText(value) {
if (typeof value === 'undefined') {
return this.options.offText;
}
this.$off.html(value);
this._width();
this._containerPosition();
this.options.offText = value;
return this.$element;
}
}, {
key: 'labelText',
value: function labelText(value) {
if (typeof value === 'undefined') {
return this.options.labelText;
}
this.$label.html(value);
this._width();
this.options.labelText = value;
return this.$element;
}
}, {
key: 'handleWidth',
value: function handleWidth(value) {
if (typeof value === 'undefined') {
return this.options.handleWidth;
}
this.options.handleWidth = value;
this._width();
this._containerPosition();
return this.$element;
}
}, {
key: 'labelWidth',
value: function labelWidth(value) {
if (typeof value === 'undefined') {
return this.options.labelWidth;
}
this.options.labelWidth = value;
this._width();
this._containerPosition();
return this.$element;
}
}, {
key: 'baseClass',
value: function baseClass(value) {
return this.options.baseClass;
}
}, {
key: 'wrapperClass',
value: function wrapperClass(value) {
if (typeof value === 'undefined') {
return this.options.wrapperClass;
}
if (!value) {
value = $.fn.bootstrapSwitch.defaults.wrapperClass;
}
this.$wrapper.removeClass(this._getClasses(this.options.wrapperClass).join(' '));
this.$wrapper.addClass(this._getClasses(value).join(' '));
this.options.wrapperClass = value;
return this.$element;
}
}, {
key: 'radioAllOff',
value: function radioAllOff(value) {
if (typeof value === 'undefined') {
return this.options.radioAllOff;
}
var val = Boolean(value);
if (this.options.radioAllOff === val) {
return this.$element;
}
this.options.radioAllOff = val;
return this.$element;
}
}, {
key: 'onInit',
value: function onInit(value) {
if (typeof value === 'undefined') {
return this.options.onInit;
}
if (!value) {
value = $.fn.bootstrapSwitch.defaults.onInit;
}
this.options.onInit = value;
return this.$element;
}
}, {
key: 'onSwitchChange',
value: function onSwitchChange(value) {
if (typeof value === 'undefined') {
return this.options.onSwitchChange;
}
if (!value) {
value = $.fn.bootstrapSwitch.defaults.onSwitchChange;
}
this.options.onSwitchChange = value;
return this.$element;
}
}, {
key: 'destroy',
value: function destroy() {
var $form = this.$element.closest('form');
if ($form.length) {
$form.off('reset.bootstrapSwitch').removeData('bootstrap-switch');
}
this.$container.children().not(this.$element).remove();
this.$element.unwrap().unwrap().off('.bootstrapSwitch').removeData('bootstrap-switch');
return this.$element;
}
}, {
key: '_getElementOptions',
value: function _getElementOptions() {
return {
state: this.$element.is(':checked'),
size: this.$element.data('size'),
animate: this.$element.data('animate'),
disabled: this.$element.is(':disabled'),
readonly: this.$element.is('[readonly]'),
indeterminate: this.$element.data('indeterminate'),
inverse: this.$element.data('inverse'),
radioAllOff: this.$element.data('radio-all-off'),
onColor: this.$element.data('on-color'),
offColor: this.$element.data('off-color'),
onText: this.$element.data('on-text'),
offText: this.$element.data('off-text'),
labelText: this.$element.data('label-text'),
handleWidth: this.$element.data('handle-width'),
labelWidth: this.$element.data('label-width'),
baseClass: this.$element.data('base-class'),
wrapperClass: this.$element.data('wrapper-class')
};
}
}, {
key: '_width',
value: function _width() {
var _this2 = this;
var $handles = this.$on.add(this.$off).add(this.$label).css('width', '');
var handleWidth = this.options.handleWidth === 'auto' ? Math.round(Math.max(this.$on.width(), this.$off.width())) : this.options.handleWidth;
$handles.width(handleWidth);
this.$label.width(function (index, width) {
if (_this2.options.labelWidth !== 'auto') {
return _this2.options.labelWidth;
}
if (width < handleWidth) {
return handleWidth;
}
return width;
});
this._handleWidth = this.$on.outerWidth();
this._labelWidth = this.$label.outerWidth();
this.$container.width(this._handleWidth * 2 + this._labelWidth);
return this.$wrapper.width(this._handleWidth + this._labelWidth);
}
}, {
key: '_containerPosition',
value: function _containerPosition() {
var _this3 = this;
var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.options.state;
var callback = arguments[1];
this.$container.css('margin-left', function () {
var values = [0, '-' + _this3._handleWidth + 'px'];
if (_this3.options.indeterminate) {
return '-' + _this3._handleWidth / 2 + 'px';
}
if (state) {
if (_this3.options.inverse) {
return values[1];
} else {
return values[0];
}
} else {
if (_this3.options.inverse) {
return values[0];
} else {
return values[1];
}
}
});
}
}, {
key: '_init',
value: function _init() {
var _this4 = this;
var init = function init() {
_this4.setPrevOptions();
_this4._width();
_this4._containerPosition();
setTimeout(function () {
if (_this4.options.animate) {
return _this4.$wrapper.addClass(_this4._getClass('animate'));
}
}, 50);
};
if (this.$wrapper.is(':visible')) {
init();
return;
}
var initInterval = window.setInterval(function () {
if (_this4.$wrapper.is(':visible')) {
init();
return window.clearInterval(initInterval);
}
}, 50);
}
}, {
key: '_elementHandlers',
value: function _elementHandlers() {
var _this5 = this;
return this.$element.on({
'setPreviousOptions.bootstrapSwitch': this.setPrevOptions.bind(this),
'previousState.bootstrapSwitch': function previousStateBootstrapSwitch() {
_this5.options = _this5.prevOptions;
if (_this5.options.indeterminate) {
_this5.$wrapper.addClass(_this5._getClass('indeterminate'));
}
_this5.$element.prop('checked', _this5.options.state).trigger('change.bootstrapSwitch', true);
},
'change.bootstrapSwitch': function changeBootstrapSwitch(event, skip) {
event.preventDefault();
event.stopImmediatePropagation();
var state = _this5.$element.is(':checked');
_this5._containerPosition(state);
if (state === _this5.options.state) {
return;
}
_this5.options.state = state;
_this5.$wrapper.toggleClass(_this5._getClass('off')).toggleClass(_this5._getClass('on'));
if (!skip) {
if (_this5.$element.is(':radio')) {
$('[name="' + _this5.$element.attr('name') + '"]').not(_this5.$element).prop('checked', false).trigger('change.bootstrapSwitch', true);
}
_this5.$element.trigger('switchChange.bootstrapSwitch', [state]);
}
},
'focus.bootstrapSwitch': function focusBootstrapSwitch(event) {
event.preventDefault();
_this5.$wrapper.addClass(_this5._getClass('focused'));
},
'blur.bootstrapSwitch': function blurBootstrapSwitch(event) {
event.preventDefault();
_this5.$wrapper.removeClass(_this5._getClass('focused'));
},
'keydown.bootstrapSwitch': function keydownBootstrapSwitch(event) {
if (!event.which || _this5.options.disabled || _this5.options.readonly) {
return;
}
if (event.which === 37 || event.which === 39) {
event.preventDefault();
event.stopImmediatePropagation();
_this5.state(event.which === 39);
}
}
});
}
}, {
key: '_handleHandlers',
value: function _handleHandlers() {
var _this6 = this;
this.$on.on('click.bootstrapSwitch', function (event) {
event.preventDefault();
event.stopPropagation();
_this6.state(false);
return _this6.$element.trigger('focus.bootstrapSwitch');
});
return this.$off.on('click.bootstrapSwitch', function (event) {
event.preventDefault();
event.stopPropagation();
_this6.state(true);
return _this6.$element.trigger('focus.bootstrapSwitch');
});
}
}, {
key: '_labelHandlers',
value: function _labelHandlers() {
var _this7 = this;
var handlers = {
click: function click(event) {
event.stopPropagation();
},
'mousedown.bootstrapSwitch touchstart.bootstrapSwitch': function mousedownBootstrapSwitchTouchstartBootstrapSwitch(event) {
if (_this7._dragStart || _this7.options.disabled || _this7.options.readonly) {
return;
}
event.preventDefault();
event.stopPropagation();
_this7._dragStart = (event.pageX || event.originalEvent.touches[0].pageX) - parseInt(_this7.$container.css('margin-left'), 10);
if (_this7.options.animate) {
_this7.$wrapper.removeClass(_this7._getClass('animate'));
}
_this7.$element.trigger('focus.bootstrapSwitch');
},
'mousemove.bootstrapSwitch touchmove.bootstrapSwitch': function mousemoveBootstrapSwitchTouchmoveBootstrapSwitch(event) {
if (_this7._dragStart == null) {
return;
}
var difference = (event.pageX || event.originalEvent.touches[0].pageX) - _this7._dragStart;
event.preventDefault();
if (difference < -_this7._handleWidth || difference > 0) {
return;
}
_this7._dragEnd = difference;
_this7.$container.css('margin-left', _this7._dragEnd + 'px');
},
'mouseup.bootstrapSwitch touchend.bootstrapSwitch': function mouseupBootstrapSwitchTouchendBootstrapSwitch(event) {
if (!_this7._dragStart) {
return;
}
event.preventDefault();
if (_this7.options.animate) {
_this7.$wrapper.addClass(_this7._getClass('animate'));
}
if (_this7._dragEnd) {
var state = _this7._dragEnd > -(_this7._handleWidth / 2);
_this7._dragEnd = false;
_this7.state(_this7.options.inverse ? !state : state);
} else {
_this7.state(!_this7.options.state);
}
_this7._dragStart = false;
},
'mouseleave.bootstrapSwitch': function mouseleaveBootstrapSwitch() {
_this7.$label.trigger('mouseup.bootstrapSwitch');
}
};
this.$label.on(handlers);
}
}, {
key: '_externalLabelHandler',
value: function _externalLabelHandler() {
var _this8 = this;
var $externalLabel = this.$element.closest('label');
$externalLabel.on('click', function (event) {
event.preventDefault();
event.stopImmediatePropagation();
if (event.target === $externalLabel[0]) {
_this8.toggleState();
}
});
}
}, {
key: '_formHandler',
value: function _formHandler() {
var $form = this.$element.closest('form');
if ($form.data('bootstrap-switch')) {
return;
}
$form.on('reset.bootstrapSwitch', function () {
window.setTimeout(function () {
$form.find('input').filter(function () {
return $(this).data('bootstrap-switch');
}).each(function () {
return $(this).bootstrapSwitch('state', this.checked);
});
}, 1);
}).data('bootstrap-switch', true);
}
}, {
key: '_getClass',
value: function _getClass(name) {
return this.options.baseClass + '-' + name;
}
}, {
key: '_getClasses',
value: function _getClasses(classes) {
if (!$.isArray(classes)) {
return [this._getClass(classes)];
}
return classes.map(this._getClass.bind(this));
}
}]);
return BootstrapSwitch;
}();
$.fn.bootstrapSwitch = function (option) {
for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
args[_key2 - 1] = arguments[_key2];
}
function reducer(ret, next) {
var $this = $(next);
var existingData = $this.data('bootstrap-switch');
var data = existingData || new BootstrapSwitch(next, option);
if (!existingData) {
$this.data('bootstrap-switch', data);
}
if (typeof option === 'string') {
return data[option].apply(data, args);
}
return ret;
}
return Array.prototype.reduce.call(this, reducer, this);
};
$.fn.bootstrapSwitch.Constructor = BootstrapSwitch;
$.fn.bootstrapSwitch.defaults = {
state: true,
size: null,
animate: true,
disabled: false,
readonly: false,
indeterminate: false,
inverse: false,
radioAllOff: false,
onColor: 'primary',
offColor: 'default',
onText: 'ON',
offText: 'OFF',
labelText: '&nbsp',
handleWidth: 'auto',
labelWidth: 'auto',
baseClass: 'bootstrap-switch',
wrapperClass: 'wrapper',
onInit: function onInit() {},
onSwitchChange: function onSwitchChange() {}
};
});
+function(a){"use strict";function c(c){return this.each(function(){var d=a(this),e=d.data("multiselectsplitter"),f="object"==typeof c&&c;(e||"destroy"!=c)&&(e||d.data("multiselectsplitter",e=new b(this,f)),"string"==typeof c&&e[c]())})}var b=function(a,b){this.init("multiselectsplitter",a,b)};b.DEFAULTS={selectSize:null,maxSelectSize:null,clearOnFirstChange:!1,onlySameGroup:!1,groupCounter:!1,maximumSelected:null,afterInitialize:null,maximumAlert:function(a){alert("Only "+a+" values can be selected")},createFirstSelect:function(a,b){return"<option>"+a+"</option>"},createSecondSelect:function(a,b){return"<option>"+a+"</option>"},template:'<div class="row" data-multiselectsplitter-wrapper-selector><div class="col-xs-6 col-sm-6"><select class="form-control" data-multiselectsplitter-firstselect-selector></select></div> <!-- Add the extra clearfix for only the required viewport --><div class="col-xs-6 col-sm-6"><select class="form-control" data-multiselectsplitter-secondselect-selector></select></div></div>'},b.prototype.init=function(c,d,e){var f=this;f.type=c,f.last$ElementSelected=[],f.initialized=!1,f.$element=a(d),f.$element.hide(),f.options=a.extend({},b.DEFAULTS,e),f.$element.after(f.options.template),f.$wrapper=f.$element.next("div[data-multiselectsplitter-wrapper-selector]"),f.$firstSelect=a("select[data-multiselectsplitter-firstselect-selector]",f.$wrapper),f.$secondSelect=a("select[data-multiselectsplitter-secondselect-selector]",f.$wrapper);var g=0,h=0;if(0!=f.$element.find("optgroup").length){f.$element.find("optgroup").each(function(){var b=a(this).attr("label"),c=a(f.options.createFirstSelect(b,f.$element));c.val(b),c.attr("data-current-label",c.text()),f.$firstSelect.append(c);var d=a(this).find("option").length;d>h&&(h=d),g++});var i=Math.max(g,h);i=Math.min(i,10),f.options.selectSize?i=f.options.selectSize:f.options.maxSelectSize&&(i=Math.min(i,f.options.maxSelectSize)),f.$firstSelect.attr("size",i),f.$secondSelect.attr("size",i),f.$element.attr("multiple")&&f.$secondSelect.attr("multiple","multiple"),f.$element.is(":disabled")&&f.disable(),f.$firstSelect.on("change",a.proxy(f.updateParentCategory,f)),f.$secondSelect.on("click change",a.proxy(f.updateChildCategory,f)),f.update=function(){if(!(f.$element.find("option").length<1)){var b,a=f.$element.find("option:selected:first");b=a.length?a.parent().attr("label"):f.$element.find("option:first").parent().attr("label"),f.$firstSelect.find('option[value="'+b+'"]').prop("selected",!0),f.$firstSelect.trigger("change")}},f.update(),f.initialized=!0,f.options.afterInitialize&&f.options.afterInitialize(f.$firstSelect,f.$secondSelect)}},b.prototype.disable=function(){this.$secondSelect.prop("disabled",!0),this.$firstSelect.prop("disabled",!0)},b.prototype.enable=function(){this.$secondSelect.prop("disabled",!1),this.$firstSelect.prop("disabled",!1)},b.prototype.createSecondSelect=function(){var b=this;b.$secondSelect.empty(),a.each(b.$element.find('optgroup[label="'+b.$firstSelect.val()+'"] option'),function(c,d){var e=a(this).val(),f=a(this).text(),g=a(b.options.createSecondSelect(f,b.$firstSelect));g.val(e),a.each(b.$element.find("option:selected"),function(b,c){a(c).val()==e&&g.prop("selected",!0)}),b.$secondSelect.append(g)})},b.prototype.updateParentCategory=function(){var a=this;a.last$ElementSelected=a.$element.find("option:selected"),a.options.clearOnFirstChange&&a.initialized&&a.$element.find("option:selected").prop("selected",!1),a.createSecondSelect(),a.checkSelected(),a.updateCounter()},b.prototype.updateCounter=function(){var b=this;b.$element.attr("multiple")&&b.options.groupCounter&&a.each(b.$firstSelect.find("option"),function(c,d){var e=a(d).val(),f=a(d).data("currentLabel"),g=b.$element.find('optgroup[label="'+e+'"] option:selected').length;g>0&&(f+=" ("+g+")"),a(d).html(f)})},b.prototype.checkSelected=function(){var b=this;if(b.$element.attr("multiple")&&b.options.maximumSelected){var c=0;if(c="function"==typeof b.options.maximumSelected?b.options.maximumSelected(b.$firstSelect,b.$secondSelect):b.options.maximumSelected,!(c<1)){var d=b.$element.find("option:selected");if(d.length>c){b.$firstSelect.find("option:selected").prop("selected",!1),b.$secondSelect.find("option:selected").prop("selected",!1),b.initialized?(b.$element.find("option:selected").prop("selected",!1),b.last$ElementSelected.prop("selected",!0)):a.each(b.$element.find("option:selected"),function(b,d){b>c-1&&a(d).prop("selected",!1)});var e=b.last$ElementSelected.first().parent().attr("label");b.$firstSelect.find('option[value="'+e+'"]').prop("selected",!0),b.createSecondSelect(),b.options.maximumAlert(c)}}}},b.prototype.basicUpdateChildCategory=function(b,c){var d=this;d.last$ElementSelected=d.$element.find("option:selected");var e=d.$secondSelect.val();a.isArray(e)||(e=[e]);var f=d.$firstSelect.val(),g=!1;d.$element.attr("multiple")?d.options.onlySameGroup?a.each(d.$element.find("option:selected"),function(b,c){if(a(c).parent().attr("label")!=f)return g=!0,!1}):c||(g=!0):g=!0,g?d.$element.find("option:selected").prop("selected",!1):a.each(d.$element.find("option:selected"),function(b,c){f==a(c).parent().attr("label")&&a.inArray(a(c).val(),e)==-1&&a(c).prop("selected",!1)}),a.each(e,function(a,b){d.$element.find('option[value="'+b+'"]').prop("selected",!0)}),d.checkSelected(),d.updateCounter(),d.$element.trigger("change")},b.prototype.updateChildCategory=function(b){"change"==b.type?this.timeOut=setTimeout(a.proxy(function(){this.basicUpdateChildCategory(b,b.ctrlKey)},this),10):"click"==b.type&&(clearTimeout(this.timeOut),this.basicUpdateChildCategory(b,b.ctrlKey))},b.prototype.destroy=function(){this.$wrapper.remove(),this.$element.removeData(this.type),this.$element.show()},a.fn.multiselectsplitter=c,a.fn.multiselectsplitter.Constructor=b,a.fn.multiselectsplitter.VERSION="1.0.1"}(jQuery);
(function (root, factory) {
if (typeof define === 'function' && define.amd) {
define(["jquery"], function (a0) {
return (factory(a0));
});
} else if (typeof module === 'object' && module.exports) {
module.exports = factory(require("jquery"));
} else {
factory(root["jQuery"]);
}
}(this, function (jQuery) {
(function ($) {
'use strict';
if (!String.prototype.includes) {
(function () {
'use strict'; // needed to support `apply`/`call` with `undefined`/`null`
var toString = {}.toString;
var defineProperty = (function () {
try {
var object = {};
var $defineProperty = Object.defineProperty;
var result = $defineProperty(object, object, object) && $defineProperty;
} catch (error) {
}
return result;
}());
var indexOf = ''.indexOf;
var includes = function (search) {
if (this == null) {
throw new TypeError();
}
var string = String(this);
if (search && toString.call(search) == '[object RegExp]') {
throw new TypeError();
}
var stringLength = string.length;
var searchString = String(search);
var searchLength = searchString.length;
var position = arguments.length > 1 ? arguments[1] : undefined;
var pos = position ? Number(position) : 0;
if (pos != pos) { // better `isNaN`
pos = 0;
}
var start = Math.min(Math.max(pos, 0), stringLength);
if (searchLength + start > stringLength) {
return false;
}
return indexOf.call(string, searchString, pos) != -1;
};
if (defineProperty) {
defineProperty(String.prototype, 'includes', {
'value': includes,
'configurable': true,
'writable': true
});
} else {
String.prototype.includes = includes;
}
}());
}
if (!String.prototype.startsWith) {
(function () {
'use strict'; // needed to support `apply`/`call` with `undefined`/`null`
var defineProperty = (function () {
try {
var object = {};
var $defineProperty = Object.defineProperty;
var result = $defineProperty(object, object, object) && $defineProperty;
} catch (error) {
}
return result;
}());
var toString = {}.toString;
var startsWith = function (search) {
if (this == null) {
throw new TypeError();
}
var string = String(this);
if (search && toString.call(search) == '[object RegExp]') {
throw new TypeError();
}
var stringLength = string.length;
var searchString = String(search);
var searchLength = searchString.length;
var position = arguments.length > 1 ? arguments[1] : undefined;
var pos = position ? Number(position) : 0;
if (pos != pos) { // better `isNaN`
pos = 0;
}
var start = Math.min(Math.max(pos, 0), stringLength);
if (searchLength + start > stringLength) {
return false;
}
var index = -1;
while (++index < searchLength) {
if (string.charCodeAt(start + index) != searchString.charCodeAt(index)) {
return false;
}
}
return true;
};
if (defineProperty) {
defineProperty(String.prototype, 'startsWith', {
'value': startsWith,
'configurable': true,
'writable': true
});
} else {
String.prototype.startsWith = startsWith;
}
}());
}
if (!Object.keys) {
Object.keys = function (
o, // object
k, // key
r  // result array
){
r=[];
for (k in o)
r.hasOwnProperty.call(o, k) && r.push(k);
return r;
};
}
var valHooks = {
useDefault: false,
_set: $.valHooks.select.set
};
$.valHooks.select.set = function(elem, value) {
if (value && !valHooks.useDefault) $(elem).data('selected', true);
return valHooks._set.apply(this, arguments);
};
var changed_arguments = null;
var EventIsSupported = (function() {
try {
new Event('change');
return true;
} catch (e) {
return false;
}
})();
$.fn.triggerNative = function (eventName) {
var el = this[0],
event;
if (el.dispatchEvent) { // for modern browsers & IE9+
if (EventIsSupported) {
event = new Event(eventName, {
bubbles: true
});
} else {
event = document.createEvent('Event');
event.initEvent(eventName, true, false);
}
el.dispatchEvent(event);
} else if (el.fireEvent) { // for IE8
event = document.createEventObject();
event.eventType = eventName;
el.fireEvent('on' + eventName, event);
} else {
this.trigger(eventName);
}
};
$.expr.pseudos.icontains = function (obj, index, meta) {
var $obj = $(obj).find('a');
var haystack = ($obj.data('tokens') || $obj.text()).toString().toUpperCase();
return haystack.includes(meta[3].toUpperCase());
};
$.expr.pseudos.ibegins = function (obj, index, meta) {
var $obj = $(obj).find('a');
var haystack = ($obj.data('tokens') || $obj.text()).toString().toUpperCase();
return haystack.startsWith(meta[3].toUpperCase());
};
$.expr.pseudos.aicontains = function (obj, index, meta) {
var $obj = $(obj).find('a');
var haystack = ($obj.data('tokens') || $obj.data('normalizedText') || $obj.text()).toString().toUpperCase();
return haystack.includes(meta[3].toUpperCase());
};
$.expr.pseudos.aibegins = function (obj, index, meta) {
var $obj = $(obj).find('a');
var haystack = ($obj.data('tokens') || $obj.data('normalizedText') || $obj.text()).toString().toUpperCase();
return haystack.startsWith(meta[3].toUpperCase());
};
function normalizeToBase(text) {
var rExps = [
{re: /[\xC0-\xC6]/g, ch: "A"},
{re: /[\xE0-\xE6]/g, ch: "a"},
{re: /[\xC8-\xCB]/g, ch: "E"},
{re: /[\xE8-\xEB]/g, ch: "e"},
{re: /[\xCC-\xCF]/g, ch: "I"},
{re: /[\xEC-\xEF]/g, ch: "i"},
{re: /[\xD2-\xD6]/g, ch: "O"},
{re: /[\xF2-\xF6]/g, ch: "o"},
{re: /[\xD9-\xDC]/g, ch: "U"},
{re: /[\xF9-\xFC]/g, ch: "u"},
{re: /[\xC7-\xE7]/g, ch: "c"},
{re: /[\xD1]/g, ch: "N"},
{re: /[\xF1]/g, ch: "n"}
];
$.each(rExps, function () {
text = text ? text.replace(this.re, this.ch) : '';
});
return text;
}
var escapeMap = {
'&': '&amp;',
'<': '&lt;',
'>': '&gt;',
'"': '&quot;',
"'": '&#x27;',
'`': '&#x60;'
};
var unescapeMap = {
'&amp;': '&',
'&lt;': '<',
'&gt;': '>',
'&quot;': '"',
'&#x27;': "'",
'&#x60;': '`'
};
var createEscaper = function(map) {
var escaper = function(match) {
return map[match];
};
var source = '(?:' + Object.keys(map).join('|') + ')';
var testRegexp = RegExp(source);
var replaceRegexp = RegExp(source, 'g');
return function(string) {
string = string == null ? '' : '' + string;
return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
};
};
var htmlEscape = createEscaper(escapeMap);
var htmlUnescape = createEscaper(unescapeMap);
var Selectpicker = function (element, options) {
if (!valHooks.useDefault) {
$.valHooks.select.set = valHooks._set;
valHooks.useDefault = true;
}
this.$element = $(element);
this.$newElement = null;
this.$button = null;
this.$menu = null;
this.$lis = null;
this.options = options;
if (this.options.title === null) {
this.options.title = this.$element.attr('title');
}
var winPad = this.options.windowPadding;
if (typeof winPad === 'number') {
this.options.windowPadding = [winPad, winPad, winPad, winPad];
}
this.val = Selectpicker.prototype.val;
this.render = Selectpicker.prototype.render;
this.refresh = Selectpicker.prototype.refresh;
this.setStyle = Selectpicker.prototype.setStyle;
this.selectAll = Selectpicker.prototype.selectAll;
this.deselectAll = Selectpicker.prototype.deselectAll;
this.destroy = Selectpicker.prototype.destroy;
this.remove = Selectpicker.prototype.remove;
this.show = Selectpicker.prototype.show;
this.hide = Selectpicker.prototype.hide;
this.init();
};
Selectpicker.VERSION = '1.12.4';
Selectpicker.DEFAULTS = {
noneSelectedText: 'Nothing selected',
noneResultsText: 'No results matched {0}',
countSelectedText: function (numSelected, numTotal) {
return (numSelected == 1) ? "{0} item selected" : "{0} items selected";
},
maxOptionsText: function (numAll, numGroup) {
return [
(numAll == 1) ? 'Limit reached ({n} item max)' : 'Limit reached ({n} items max)',
(numGroup == 1) ? 'Group limit reached ({n} item max)' : 'Group limit reached ({n} items max)'
];
},
selectAllText: 'Select All',
deselectAllText: 'Deselect All',
doneButton: false,
doneButtonText: 'Close',
multipleSeparator: ', ',
styleBase: 'btn',
style: 'btn-default',
size: 'auto',
title: null,
selectedTextFormat: 'values',
width: false,
container: false,
hideDisabled: false,
showSubtext: false,
showIcon: true,
showContent: true,
dropupAuto: true,
header: false,
liveSearch: false,
liveSearchPlaceholder: null,
liveSearchNormalize: false,
liveSearchStyle: 'contains',
actionsBox: false,
iconBase: 'glyphicon',
tickIcon: 'glyphicon-ok',
showTick: false,
template: {
caret: '<span class="caret"></span>'
},
maxOptions: false,
mobile: false,
selectOnTab: false,
dropdownAlignRight: false,
windowPadding: 0
};
Selectpicker.prototype = {
constructor: Selectpicker,
init: function () {
var that = this,
id = this.$element.attr('id');
this.$element.addClass('bs-select-hidden');
this.liObj = {};
this.multiple = this.$element.prop('multiple');
this.autofocus = this.$element.prop('autofocus');
this.$newElement = this.createView();
this.$element
.after(this.$newElement)
.appendTo(this.$newElement);
this.$button = this.$newElement.children('button');
this.$menu = this.$newElement.children('.dropdown-menu');
this.$menuInner = this.$menu.children('.inner');
this.$searchbox = this.$menu.find('input');
this.$element.removeClass('bs-select-hidden');
if (this.options.dropdownAlignRight === true) this.$menu.addClass('dropdown-menu-right');
if (typeof id !== 'undefined') {
this.$button.attr('data-id', id);
$('label[for="' + id + '"]').click(function (e) {
e.preventDefault();
that.$button.focus();
});
}
this.checkDisabled();
this.clickListener();
if (this.options.liveSearch) this.liveSearchListener();
this.render();
this.setStyle();
this.setWidth();
if (this.options.container) this.selectPosition();
this.$menu.data('this', this);
this.$newElement.data('this', this);
if (this.options.mobile) this.mobile();
this.$newElement.on({
'hide.bs.dropdown': function (e) {
that.$menuInner.attr('aria-expanded', false);
that.$element.trigger('hide.bs.select', e);
},
'hidden.bs.dropdown': function (e) {
that.$element.trigger('hidden.bs.select', e);
},
'show.bs.dropdown': function (e) {
that.$menuInner.attr('aria-expanded', true);
that.$element.trigger('show.bs.select', e);
},
'shown.bs.dropdown': function (e) {
that.$element.trigger('shown.bs.select', e);
}
});
if (that.$element[0].hasAttribute('required')) {
this.$element.on('invalid', function () {
that.$button.addClass('bs-invalid');
that.$element.on({
'focus.bs.select': function () {
that.$button.focus();
that.$element.off('focus.bs.select');
},
'shown.bs.select': function () {
that.$element
.val(that.$element.val()) // set the value to hide the validation message in Chrome when menu is opened
.off('shown.bs.select');
},
'rendered.bs.select': function () {
if (this.validity.valid) that.$button.removeClass('bs-invalid');
that.$element.off('rendered.bs.select');
}
});
that.$button.on('blur.bs.select', function() {
that.$element.focus().blur();
that.$button.off('blur.bs.select');
});
});
}
setTimeout(function () {
that.$element.trigger('loaded.bs.select');
});
},
createDropdown: function () {
var showTick = (this.multiple || this.options.showTick) ? ' show-tick' : '',
inputGroup = this.$element.parent().hasClass('input-group') ? ' input-group-btn' : '',
autofocus = this.autofocus ? ' autofocus' : '';
var header = this.options.header ? '<div class="popover-title"><button type="button" class="close" aria-hidden="true">&times;</button>' + this.options.header + '</div>' : '';
var searchbox = this.options.liveSearch ?
'<div class="bs-searchbox">' +
'<input type="text" class="form-control" autocomplete="off"' +
(null === this.options.liveSearchPlaceholder ? '' : ' placeholder="' + htmlEscape(this.options.liveSearchPlaceholder) + '"') + ' role="textbox" aria-label="Search">' +
'</div>'
: '';
var actionsbox = this.multiple && this.options.actionsBox ?
'<div class="bs-actionsbox">' +
'<div class="btn-group btn-group-sm btn-block">' +
'<button type="button" class="actions-btn bs-select-all btn btn-default">' +
this.options.selectAllText +
'</button>' +
'<button type="button" class="actions-btn bs-deselect-all btn btn-default">' +
this.options.deselectAllText +
'</button>' +
'</div>' +
'</div>'
: '';
var donebutton = this.multiple && this.options.doneButton ?
'<div class="bs-donebutton">' +
'<div class="btn-group btn-block">' +
'<button type="button" class="btn btn-sm btn-default">' +
this.options.doneButtonText +
'</button>' +
'</div>' +
'</div>'
: '';
var drop =
'<div class="btn-group bootstrap-select' + showTick + inputGroup + '">' +
'<button type="button" class="' + this.options.styleBase + ' dropdown-toggle" data-toggle="dropdown"' + autofocus + ' role="button">' +
'<span class="filter-option pull-left"></span>&nbsp;' +
'<span class="bs-caret">' +
this.options.template.caret +
'</span>' +
'</button>' +
'<div class="dropdown-menu open" role="combobox">' +
header +
searchbox +
actionsbox +
'<ul class="dropdown-menu inner" role="listbox" aria-expanded="false">' +
'</ul>' +
donebutton +
'</div>' +
'</div>';
return $(drop);
},
createView: function () {
var $drop = this.createDropdown(),
li = this.createLi();
$drop.find('ul')[0].innerHTML = li;
return $drop;
},
reloadLi: function () {
var li = this.createLi();
this.$menuInner[0].innerHTML = li;
},
createLi: function () {
var that = this,
_li = [],
optID = 0,
titleOption = document.createElement('option'),
liIndex = -1; // increment liIndex whenever a new <li> element is created to ensure liObj is correct
var generateLI = function (content, index, classes, optgroup) {
return '<li' +
((typeof classes !== 'undefined' && '' !== classes) ? ' class="' + classes + '"' : '') +
((typeof index !== 'undefined' && null !== index) ? ' data-original-index="' + index + '"' : '') +
((typeof optgroup !== 'undefined' && null !== optgroup) ? 'data-optgroup="' + optgroup + '"' : '') +
'>' + content + '</li>';
};
var generateA = function (text, classes, inline, tokens) {
return '<a tabindex="0"' +
(typeof classes !== 'undefined' ? ' class="' + classes + '"' : '') +
(inline ? ' style="' + inline + '"' : '') +
(that.options.liveSearchNormalize ? ' data-normalized-text="' + normalizeToBase(htmlEscape($(text).html())) + '"' : '') +
(typeof tokens !== 'undefined' || tokens !== null ? ' data-tokens="' + tokens + '"' : '') +
' role="option">' + text +
'<span class="' + that.options.iconBase + ' ' + that.options.tickIcon + ' check-mark"></span>' +
'</a>';
};
if (this.options.title && !this.multiple) {
liIndex--;
if (!this.$element.find('.bs-title-option').length) {
var element = this.$element[0];
titleOption.className = 'bs-title-option';
titleOption.innerHTML = this.options.title;
titleOption.value = '';
element.insertBefore(titleOption, element.firstChild);
var $opt = $(element.options[element.selectedIndex]);
if ($opt.attr('selected') === undefined && this.$element.data('selected') === undefined) {
titleOption.selected = true;
}
}
}
var $selectOptions = this.$element.find('option');
$selectOptions.each(function (index) {
var $this = $(this);
liIndex++;
if ($this.hasClass('bs-title-option')) return;
var optionClass = this.className || '',
inline = htmlEscape(this.style.cssText),
text = $this.data('content') ? $this.data('content') : $this.html(),
tokens = $this.data('tokens') ? $this.data('tokens') : null,
subtext = typeof $this.data('subtext') !== 'undefined' ? '<small class="text-muted">' + $this.data('subtext') + '</small>' : '',
icon = typeof $this.data('icon') !== 'undefined' ? '<span class="' + that.options.iconBase + ' ' + $this.data('icon') + '"></span> ' : '',
$parent = $this.parent(),
isOptgroup = $parent[0].tagName === 'OPTGROUP',
isOptgroupDisabled = isOptgroup && $parent[0].disabled,
isDisabled = this.disabled || isOptgroupDisabled,
prevHiddenIndex;
if (icon !== '' && isDisabled) {
icon = '<span>' + icon + '</span>';
}
if (that.options.hideDisabled && (isDisabled && !isOptgroup || isOptgroupDisabled)) {
prevHiddenIndex = $this.data('prevHiddenIndex');
$this.next().data('prevHiddenIndex', (prevHiddenIndex !== undefined ? prevHiddenIndex : index));
liIndex--;
return;
}
if (!$this.data('content')) {
text = icon + '<span class="text">' + text + subtext + '</span>';
}
if (isOptgroup && $this.data('divider') !== true) {
if (that.options.hideDisabled && isDisabled) {
if ($parent.data('allOptionsDisabled') === undefined) {
var $options = $parent.children();
$parent.data('allOptionsDisabled', $options.filter(':disabled').length === $options.length);
}
if ($parent.data('allOptionsDisabled')) {
liIndex--;
return;
}
}
var optGroupClass = ' ' + $parent[0].className || '';
if ($this.index() === 0) { // Is it the first option of the optgroup?
optID += 1;
var label = $parent[0].label,
labelSubtext = typeof $parent.data('subtext') !== 'undefined' ? '<small class="text-muted">' + $parent.data('subtext') + '</small>' : '',
labelIcon = $parent.data('icon') ? '<span class="' + that.options.iconBase + ' ' + $parent.data('icon') + '"></span> ' : '';
label = labelIcon + '<span class="text">' + htmlEscape(label) + labelSubtext + '</span>';
if (index !== 0 && _li.length > 0) { // Is it NOT the first option of the select && are there elements in the dropdown?
liIndex++;
_li.push(generateLI('', null, 'divider', optID + 'div'));
}
liIndex++;
_li.push(generateLI(label, null, 'dropdown-header' + optGroupClass, optID));
}
if (that.options.hideDisabled && isDisabled) {
liIndex--;
return;
}
_li.push(generateLI(generateA(text, 'opt ' + optionClass + optGroupClass, inline, tokens), index, '', optID));
} else if ($this.data('divider') === true) {
_li.push(generateLI('', index, 'divider'));
} else if ($this.data('hidden') === true) {
prevHiddenIndex = $this.data('prevHiddenIndex');
$this.next().data('prevHiddenIndex', (prevHiddenIndex !== undefined ? prevHiddenIndex : index));
_li.push(generateLI(generateA(text, optionClass, inline, tokens), index, 'hidden is-hidden'));
} else {
var showDivider = this.previousElementSibling && this.previousElementSibling.tagName === 'OPTGROUP';
if (!showDivider && that.options.hideDisabled) {
prevHiddenIndex = $this.data('prevHiddenIndex');
if (prevHiddenIndex !== undefined) {
var prevHidden = $selectOptions.eq(prevHiddenIndex)[0].previousElementSibling;
if (prevHidden && prevHidden.tagName === 'OPTGROUP' && !prevHidden.disabled) {
showDivider = true;
}
}
}
if (showDivider) {
liIndex++;
_li.push(generateLI('', null, 'divider', optID + 'div'));
}
_li.push(generateLI(generateA(text, optionClass, inline, tokens), index));
}
that.liObj[index] = liIndex;
});
if (!this.multiple && this.$element.find('option:selected').length === 0 && !this.options.title) {
this.$element.find('option').eq(0).prop('selected', true).attr('selected', 'selected');
}
return _li.join('');
},
findLis: function () {
if (this.$lis == null) this.$lis = this.$menu.find('li');
return this.$lis;
},
render: function (updateLi) {
var that = this,
notDisabled,
$selectOptions = this.$element.find('option');
if (updateLi !== false) {
$selectOptions.each(function (index) {
var $lis = that.findLis().eq(that.liObj[index]);
that.setDisabled(index, this.disabled || this.parentNode.tagName === 'OPTGROUP' && this.parentNode.disabled, $lis);
that.setSelected(index, this.selected, $lis);
});
}
this.togglePlaceholder();
this.tabIndex();
var selectedItems = $selectOptions.map(function () {
if (this.selected) {
if (that.options.hideDisabled && (this.disabled || this.parentNode.tagName === 'OPTGROUP' && this.parentNode.disabled)) return;
var $this = $(this),
icon = $this.data('icon') && that.options.showIcon ? '<i class="' + that.options.iconBase + ' ' + $this.data('icon') + '"></i> ' : '',
subtext;
if (that.options.showSubtext && $this.data('subtext') && !that.multiple) {
subtext = ' <small class="text-muted">' + $this.data('subtext') + '</small>';
} else {
subtext = '';
}
if (typeof $this.attr('title') !== 'undefined') {
return $this.attr('title');
} else if ($this.data('content') && that.options.showContent) {
return $this.data('content').toString();
} else {
return icon + $this.html() + subtext;
}
}
}).toArray();
var title = !this.multiple ? selectedItems[0] : selectedItems.join(this.options.multipleSeparator);
if (this.multiple && this.options.selectedTextFormat.indexOf('count') > -1) {
var max = this.options.selectedTextFormat.split('>');
if ((max.length > 1 && selectedItems.length > max[1]) || (max.length == 1 && selectedItems.length >= 2)) {
notDisabled = this.options.hideDisabled ? ', [disabled]' : '';
var totalCount = $selectOptions.not('[data-divider="true"], [data-hidden="true"]' + notDisabled).length,
tr8nText = (typeof this.options.countSelectedText === 'function') ? this.options.countSelectedText(selectedItems.length, totalCount) : this.options.countSelectedText;
title = tr8nText.replace('{0}', selectedItems.length.toString()).replace('{1}', totalCount.toString());
}
}
if (this.options.title == undefined) {
this.options.title = this.$element.attr('title');
}
if (this.options.selectedTextFormat == 'static') {
title = this.options.title;
}
if (!title) {
title = typeof this.options.title !== 'undefined' ? this.options.title : this.options.noneSelectedText;
}
this.$button.attr('title', htmlUnescape($.trim(title.replace(/<[^>]*>?/g, ''))));
this.$button.children('.filter-option').html(title);
this.$element.trigger('rendered.bs.select');
},
setStyle: function (style, status) {
if (this.$element.attr('class')) {
this.$newElement.addClass(this.$element.attr('class').replace(/selectpicker|mobile-device|bs-select-hidden|validate\[.*\]/gi, ''));
}
var buttonClass = style ? style : this.options.style;
if (status == 'add') {
this.$button.addClass(buttonClass);
} else if (status == 'remove') {
this.$button.removeClass(buttonClass);
} else {
this.$button.removeClass(this.options.style);
this.$button.addClass(buttonClass);
}
},
liHeight: function (refresh) {
if (!refresh && (this.options.size === false || this.sizeInfo)) return;
var newElement = document.createElement('div'),
menu = document.createElement('div'),
menuInner = document.createElement('ul'),
divider = document.createElement('li'),
li = document.createElement('li'),
a = document.createElement('a'),
text = document.createElement('span'),
header = this.options.header && this.$menu.find('.popover-title').length > 0 ? this.$menu.find('.popover-title')[0].cloneNode(true) : null,
search = this.options.liveSearch ? document.createElement('div') : null,
actions = this.options.actionsBox && this.multiple && this.$menu.find('.bs-actionsbox').length > 0 ? this.$menu.find('.bs-actionsbox')[0].cloneNode(true) : null,
doneButton = this.options.doneButton && this.multiple && this.$menu.find('.bs-donebutton').length > 0 ? this.$menu.find('.bs-donebutton')[0].cloneNode(true) : null;
text.className = 'text';
newElement.className = this.$menu[0].parentNode.className + ' open';
menu.className = 'dropdown-menu open';
menuInner.className = 'dropdown-menu inner';
divider.className = 'divider';
text.appendChild(document.createTextNode('Inner text'));
a.appendChild(text);
li.appendChild(a);
menuInner.appendChild(li);
menuInner.appendChild(divider);
if (header) menu.appendChild(header);
if (search) {
var input = document.createElement('input');
search.className = 'bs-searchbox';
input.className = 'form-control';
search.appendChild(input);
menu.appendChild(search);
}
if (actions) menu.appendChild(actions);
menu.appendChild(menuInner);
if (doneButton) menu.appendChild(doneButton);
newElement.appendChild(menu);
document.body.appendChild(newElement);
var liHeight = a.offsetHeight,
headerHeight = header ? header.offsetHeight : 0,
searchHeight = search ? search.offsetHeight : 0,
actionsHeight = actions ? actions.offsetHeight : 0,
doneButtonHeight = doneButton ? doneButton.offsetHeight : 0,
dividerHeight = $(divider).outerHeight(true),
menuStyle = typeof getComputedStyle === 'function' ? getComputedStyle(menu) : false,
$menu = menuStyle ? null : $(menu),
menuPadding = {
vert: parseInt(menuStyle ? menuStyle.paddingTop : $menu.css('paddingTop')) +
parseInt(menuStyle ? menuStyle.paddingBottom : $menu.css('paddingBottom')) +
parseInt(menuStyle ? menuStyle.borderTopWidth : $menu.css('borderTopWidth')) +
parseInt(menuStyle ? menuStyle.borderBottomWidth : $menu.css('borderBottomWidth')),
horiz: parseInt(menuStyle ? menuStyle.paddingLeft : $menu.css('paddingLeft')) +
parseInt(menuStyle ? menuStyle.paddingRight : $menu.css('paddingRight')) +
parseInt(menuStyle ? menuStyle.borderLeftWidth : $menu.css('borderLeftWidth')) +
parseInt(menuStyle ? menuStyle.borderRightWidth : $menu.css('borderRightWidth'))
},
menuExtras =  {
vert: menuPadding.vert +
parseInt(menuStyle ? menuStyle.marginTop : $menu.css('marginTop')) +
parseInt(menuStyle ? menuStyle.marginBottom : $menu.css('marginBottom')) + 2,
horiz: menuPadding.horiz +
parseInt(menuStyle ? menuStyle.marginLeft : $menu.css('marginLeft')) +
parseInt(menuStyle ? menuStyle.marginRight : $menu.css('marginRight')) + 2
}
document.body.removeChild(newElement);
this.sizeInfo = {
liHeight: liHeight,
headerHeight: headerHeight,
searchHeight: searchHeight,
actionsHeight: actionsHeight,
doneButtonHeight: doneButtonHeight,
dividerHeight: dividerHeight,
menuPadding: menuPadding,
menuExtras: menuExtras
};
},
setSize: function () {
this.findLis();
this.liHeight();
if (this.options.header) this.$menu.css('padding-top', 0);
if (this.options.size === false) return;
var that = this,
$menu = this.$menu,
$menuInner = this.$menuInner,
$window = $(window),
selectHeight = this.$newElement[0].offsetHeight,
selectWidth = this.$newElement[0].offsetWidth,
liHeight = this.sizeInfo['liHeight'],
headerHeight = this.sizeInfo['headerHeight'],
searchHeight = this.sizeInfo['searchHeight'],
actionsHeight = this.sizeInfo['actionsHeight'],
doneButtonHeight = this.sizeInfo['doneButtonHeight'],
divHeight = this.sizeInfo['dividerHeight'],
menuPadding = this.sizeInfo['menuPadding'],
menuExtras = this.sizeInfo['menuExtras'],
notDisabled = this.options.hideDisabled ? '.disabled' : '',
menuHeight,
menuWidth,
getHeight,
getWidth,
selectOffsetTop,
selectOffsetBot,
selectOffsetLeft,
selectOffsetRight,
getPos = function() {
var pos = that.$newElement.offset(),
$container = $(that.options.container),
containerPos;
if (that.options.container && !$container.is('body')) {
containerPos = $container.offset();
containerPos.top += parseInt($container.css('borderTopWidth'));
containerPos.left += parseInt($container.css('borderLeftWidth'));
} else {
containerPos = { top: 0, left: 0 };
}
var winPad = that.options.windowPadding;
selectOffsetTop = pos.top - containerPos.top - $window.scrollTop();
selectOffsetBot = $window.height() - selectOffsetTop - selectHeight - containerPos.top - winPad[2];
selectOffsetLeft = pos.left - containerPos.left - $window.scrollLeft();
selectOffsetRight = $window.width() - selectOffsetLeft - selectWidth - containerPos.left - winPad[1];
selectOffsetTop -= winPad[0];
selectOffsetLeft -= winPad[3];
};
getPos();
if (this.options.size === 'auto') {
var getSize = function () {
var minHeight,
hasClass = function (className, include) {
return function (element) {
if (include) {
return (element.classList ? element.classList.contains(className) : $(element).hasClass(className));
} else {
return !(element.classList ? element.classList.contains(className) : $(element).hasClass(className));
}
};
},
lis = that.$menuInner[0].getElementsByTagName('li'),
lisVisible = Array.prototype.filter ? Array.prototype.filter.call(lis, hasClass('hidden', false)) : that.$lis.not('.hidden'),
optGroup = Array.prototype.filter ? Array.prototype.filter.call(lisVisible, hasClass('dropdown-header', true)) : lisVisible.filter('.dropdown-header');
getPos();
menuHeight = selectOffsetBot - menuExtras.vert;
menuWidth = selectOffsetRight - menuExtras.horiz;
if (that.options.container) {
if (!$menu.data('height')) $menu.data('height', $menu.height());
getHeight = $menu.data('height');
if (!$menu.data('width')) $menu.data('width', $menu.width());
getWidth = $menu.data('width');
} else {
getHeight = $menu.height();
getWidth = $menu.width();
}
if (that.options.dropupAuto) {
that.$newElement.toggleClass('dropup', selectOffsetTop > selectOffsetBot && (menuHeight - menuExtras.vert) < getHeight);
}
if (that.$newElement.hasClass('dropup')) {
menuHeight = selectOffsetTop - menuExtras.vert;
}
if (that.options.dropdownAlignRight === 'auto') {
$menu.toggleClass('dropdown-menu-right', selectOffsetLeft > selectOffsetRight && (menuWidth - menuExtras.horiz) < (getWidth - selectWidth));
}
if ((lisVisible.length + optGroup.length) > 3) {
minHeight = liHeight * 3 + menuExtras.vert - 2;
} else {
minHeight = 0;
}
$menu.css({
'max-height': menuHeight + 'px',
'overflow': 'hidden',
'min-height': minHeight + headerHeight + searchHeight + actionsHeight + doneButtonHeight + 'px'
});
$menuInner.css({
'max-height': menuHeight - headerHeight - searchHeight - actionsHeight - doneButtonHeight - menuPadding.vert + 'px',
'overflow-y': 'auto',
'min-height': Math.max(minHeight - menuPadding.vert, 0) + 'px'
});
};
getSize();
this.$searchbox.off('input.getSize propertychange.getSize').on('input.getSize propertychange.getSize', getSize);
$window.off('resize.getSize scroll.getSize').on('resize.getSize scroll.getSize', getSize);
} else if (this.options.size && this.options.size != 'auto' && this.$lis.not(notDisabled).length > this.options.size) {
var optIndex = this.$lis.not('.divider').not(notDisabled).children().slice(0, this.options.size).last().parent().index(),
divLength = this.$lis.slice(0, optIndex + 1).filter('.divider').length;
menuHeight = liHeight * this.options.size + divLength * divHeight + menuPadding.vert;
if (that.options.container) {
if (!$menu.data('height')) $menu.data('height', $menu.height());
getHeight = $menu.data('height');
} else {
getHeight = $menu.height();
}
if (that.options.dropupAuto) {
this.$newElement.toggleClass('dropup', selectOffsetTop > selectOffsetBot && (menuHeight - menuExtras.vert) < getHeight);
}
$menu.css({
'max-height': menuHeight + headerHeight + searchHeight + actionsHeight + doneButtonHeight + 'px',
'overflow': 'hidden',
'min-height': ''
});
$menuInner.css({
'max-height': menuHeight - menuPadding.vert + 'px',
'overflow-y': 'auto',
'min-height': ''
});
}
},
setWidth: function () {
if (this.options.width === 'auto') {
this.$menu.css('min-width', '0');
var $selectClone = this.$menu.parent().clone().appendTo('body'),
$selectClone2 = this.options.container ? this.$newElement.clone().appendTo('body') : $selectClone,
ulWidth = $selectClone.children('.dropdown-menu').outerWidth(),
btnWidth = $selectClone2.css('width', 'auto').children('button').outerWidth();
$selectClone.remove();
$selectClone2.remove();
this.$newElement.css('width', Math.max(ulWidth, btnWidth) + 'px');
} else if (this.options.width === 'fit') {
this.$menu.css('min-width', '');
this.$newElement.css('width', '').addClass('fit-width');
} else if (this.options.width) {
this.$menu.css('min-width', '');
this.$newElement.css('width', this.options.width);
} else {
this.$menu.css('min-width', '');
this.$newElement.css('width', '');
}
if (this.$newElement.hasClass('fit-width') && this.options.width !== 'fit') {
this.$newElement.removeClass('fit-width');
}
},
selectPosition: function () {
this.$bsContainer = $('<div class="bs-container" />');
var that = this,
$container = $(this.options.container),
pos,
containerPos,
actualHeight,
getPlacement = function ($element) {
that.$bsContainer.addClass($element.attr('class').replace(/form-control|fit-width/gi, '')).toggleClass('dropup', $element.hasClass('dropup'));
pos = $element.offset();
if (!$container.is('body')) {
containerPos = $container.offset();
containerPos.top += parseInt($container.css('borderTopWidth')) - $container.scrollTop();
containerPos.left += parseInt($container.css('borderLeftWidth')) - $container.scrollLeft();
} else {
containerPos = { top: 0, left: 0 };
}
actualHeight = $element.hasClass('dropup') ? 0 : $element[0].offsetHeight;
that.$bsContainer.css({
'top': pos.top - containerPos.top + actualHeight,
'left': pos.left - containerPos.left,
'width': $element[0].offsetWidth
});
};
this.$button.on('click', function () {
var $this = $(this);
if (that.isDisabled()) {
return;
}
getPlacement(that.$newElement);
that.$bsContainer
.appendTo(that.options.container)
.toggleClass('open', !$this.hasClass('open'))
.append(that.$menu);
});
$(window).on('resize scroll', function () {
getPlacement(that.$newElement);
});
this.$element.on('hide.bs.select', function () {
that.$menu.data('height', that.$menu.height());
that.$bsContainer.detach();
});
},
setSelected: function (index, selected, $lis) {
if (!$lis) {
this.togglePlaceholder(); // check if setSelected is being called by changing the value of the select
$lis = this.findLis().eq(this.liObj[index]);
}
$lis.toggleClass('selected', selected).find('a').attr('aria-selected', selected);
},
setDisabled: function (index, disabled, $lis) {
if (!$lis) {
$lis = this.findLis().eq(this.liObj[index]);
}
if (disabled) {
$lis.addClass('disabled').children('a').attr('href', '#').attr('tabindex', -1).attr('aria-disabled', true);
} else {
$lis.removeClass('disabled').children('a').removeAttr('href').attr('tabindex', 0).attr('aria-disabled', false);
}
},
isDisabled: function () {
return this.$element[0].disabled;
},
checkDisabled: function () {
var that = this;
if (this.isDisabled()) {
this.$newElement.addClass('disabled');
this.$button.addClass('disabled').attr('tabindex', -1).attr('aria-disabled', true);
} else {
if (this.$button.hasClass('disabled')) {
this.$newElement.removeClass('disabled');
this.$button.removeClass('disabled').attr('aria-disabled', false);
}
if (this.$button.attr('tabindex') == -1 && !this.$element.data('tabindex')) {
this.$button.removeAttr('tabindex');
}
}
this.$button.click(function () {
return !that.isDisabled();
});
},
togglePlaceholder: function () {
var value = this.$element.val();
this.$button.toggleClass('bs-placeholder', value === null || value === '' || (value.constructor === Array && value.length === 0));
},
tabIndex: function () {
if (this.$element.data('tabindex') !== this.$element.attr('tabindex') &&
(this.$element.attr('tabindex') !== -98 && this.$element.attr('tabindex') !== '-98')) {
this.$element.data('tabindex', this.$element.attr('tabindex'));
this.$button.attr('tabindex', this.$element.data('tabindex'));
}
this.$element.attr('tabindex', -98);
},
clickListener: function () {
var that = this,
$document = $(document);
$document.data('spaceSelect', false);
this.$button.on('keyup', function (e) {
if (/(32)/.test(e.keyCode.toString(10)) && $document.data('spaceSelect')) {
e.preventDefault();
$document.data('spaceSelect', false);
}
});
this.$button.on('click', function () {
that.setSize();
});
this.$element.on('shown.bs.select', function () {
if (!that.options.liveSearch && !that.multiple) {
that.$menuInner.find('.selected a').focus();
} else if (!that.multiple) {
var selectedIndex = that.liObj[that.$element[0].selectedIndex];
if (typeof selectedIndex !== 'number' || that.options.size === false) return;
var offset = that.$lis.eq(selectedIndex)[0].offsetTop - that.$menuInner[0].offsetTop;
offset = offset - that.$menuInner[0].offsetHeight/2 + that.sizeInfo.liHeight/2;
that.$menuInner[0].scrollTop = offset;
}
});
this.$menuInner.on('click', 'li a', function (e) {
var $this = $(this),
clickedIndex = $this.parent().data('originalIndex'),
prevValue = that.$element.val(),
prevIndex = that.$element.prop('selectedIndex'),
triggerChange = true;
if (that.multiple && that.options.maxOptions !== 1) {
e.stopPropagation();
}
e.preventDefault();
if (!that.isDisabled() && !$this.parent().hasClass('disabled')) {
var $options = that.$element.find('option'),
$option = $options.eq(clickedIndex),
state = $option.prop('selected'),
$optgroup = $option.parent('optgroup'),
maxOptions = that.options.maxOptions,
maxOptionsGrp = $optgroup.data('maxOptions') || false;
if (!that.multiple) { // Deselect all others if not multi select box
$options.prop('selected', false);
$option.prop('selected', true);
that.$menuInner.find('.selected').removeClass('selected').find('a').attr('aria-selected', false);
that.setSelected(clickedIndex, true);
} else { // Toggle the one we have chosen if we are multi select.
$option.prop('selected', !state);
that.setSelected(clickedIndex, !state);
$this.blur();
if (maxOptions !== false || maxOptionsGrp !== false) {
var maxReached = maxOptions < $options.filter(':selected').length,
maxReachedGrp = maxOptionsGrp < $optgroup.find('option:selected').length;
if ((maxOptions && maxReached) || (maxOptionsGrp && maxReachedGrp)) {
if (maxOptions && maxOptions == 1) {
$options.prop('selected', false);
$option.prop('selected', true);
that.$menuInner.find('.selected').removeClass('selected');
that.setSelected(clickedIndex, true);
} else if (maxOptionsGrp && maxOptionsGrp == 1) {
$optgroup.find('option:selected').prop('selected', false);
$option.prop('selected', true);
var optgroupID = $this.parent().data('optgroup');
that.$menuInner.find('[data-optgroup="' + optgroupID + '"]').removeClass('selected');
that.setSelected(clickedIndex, true);
} else {
var maxOptionsText = typeof that.options.maxOptionsText === 'string' ? [that.options.maxOptionsText, that.options.maxOptionsText] : that.options.maxOptionsText,
maxOptionsArr = typeof maxOptionsText === 'function' ? maxOptionsText(maxOptions, maxOptionsGrp) : maxOptionsText,
maxTxt = maxOptionsArr[0].replace('{n}', maxOptions),
maxTxtGrp = maxOptionsArr[1].replace('{n}', maxOptionsGrp),
$notify = $('<div class="notify"></div>');
if (maxOptionsArr[2]) {
maxTxt = maxTxt.replace('{var}', maxOptionsArr[2][maxOptions > 1 ? 0 : 1]);
maxTxtGrp = maxTxtGrp.replace('{var}', maxOptionsArr[2][maxOptionsGrp > 1 ? 0 : 1]);
}
$option.prop('selected', false);
that.$menu.append($notify);
if (maxOptions && maxReached) {
$notify.append($('<div>' + maxTxt + '</div>'));
triggerChange = false;
that.$element.trigger('maxReached.bs.select');
}
if (maxOptionsGrp && maxReachedGrp) {
$notify.append($('<div>' + maxTxtGrp + '</div>'));
triggerChange = false;
that.$element.trigger('maxReachedGrp.bs.select');
}
setTimeout(function () {
that.setSelected(clickedIndex, false);
}, 10);
$notify.delay(750).fadeOut(300, function () {
$(this).remove();
});
}
}
}
}
if (!that.multiple || (that.multiple && that.options.maxOptions === 1)) {
that.$button.focus();
} else if (that.options.liveSearch) {
that.$searchbox.focus();
}
if (triggerChange) {
if ((prevValue != that.$element.val() && that.multiple) || (prevIndex != that.$element.prop('selectedIndex') && !that.multiple)) {
changed_arguments = [clickedIndex, $option.prop('selected'), state];
that.$element
.triggerNative('change');
}
}
}
});
this.$menu.on('click', 'li.disabled a, .popover-title, .popover-title :not(.close)', function (e) {
if (e.currentTarget == this) {
e.preventDefault();
e.stopPropagation();
if (that.options.liveSearch && !$(e.target).hasClass('close')) {
that.$searchbox.focus();
} else {
that.$button.focus();
}
}
});
this.$menuInner.on('click', '.divider, .dropdown-header', function (e) {
e.preventDefault();
e.stopPropagation();
if (that.options.liveSearch) {
that.$searchbox.focus();
} else {
that.$button.focus();
}
});
this.$menu.on('click', '.popover-title .close', function () {
that.$button.click();
});
this.$searchbox.on('click', function (e) {
e.stopPropagation();
});
this.$menu.on('click', '.actions-btn', function (e) {
if (that.options.liveSearch) {
that.$searchbox.focus();
} else {
that.$button.focus();
}
e.preventDefault();
e.stopPropagation();
if ($(this).hasClass('bs-select-all')) {
that.selectAll();
} else {
that.deselectAll();
}
});
this.$element.change(function () {
that.render(false);
that.$element.trigger('changed.bs.select', changed_arguments);
changed_arguments = null;
});
},
liveSearchListener: function () {
var that = this,
$no_results = $('<li class="no-results"></li>');
this.$button.on('click.dropdown.data-api', function () {
that.$menuInner.find('.active').removeClass('active');
if (!!that.$searchbox.val()) {
that.$searchbox.val('');
that.$lis.not('.is-hidden').removeClass('hidden');
if (!!$no_results.parent().length) $no_results.remove();
}
if (!that.multiple) that.$menuInner.find('.selected').addClass('active');
setTimeout(function () {
that.$searchbox.focus();
}, 10);
});
this.$searchbox.on('click.dropdown.data-api focus.dropdown.data-api touchend.dropdown.data-api', function (e) {
e.stopPropagation();
});
this.$searchbox.on('input propertychange', function () {
that.$lis.not('.is-hidden').removeClass('hidden');
that.$lis.filter('.active').removeClass('active');
$no_results.remove();
if (that.$searchbox.val()) {
var $searchBase = that.$lis.not('.is-hidden, .divider, .dropdown-header'),
$hideItems;
if (that.options.liveSearchNormalize) {
$hideItems = $searchBase.not(':a' + that._searchStyle() + '("' + normalizeToBase(that.$searchbox.val()) + '")');
} else {
$hideItems = $searchBase.not(':' + that._searchStyle() + '("' + that.$searchbox.val() + '")');
}
if ($hideItems.length === $searchBase.length) {
$no_results.html(that.options.noneResultsText.replace('{0}', '"' + htmlEscape(that.$searchbox.val()) + '"'));
that.$menuInner.append($no_results);
that.$lis.addClass('hidden');
} else {
$hideItems.addClass('hidden');
var $lisVisible = that.$lis.not('.hidden'),
$foundDiv;
$lisVisible.each(function (index) {
var $this = $(this);
if ($this.hasClass('divider')) {
if ($foundDiv === undefined) {
$this.addClass('hidden');
} else {
if ($foundDiv) $foundDiv.addClass('hidden');
$foundDiv = $this;
}
} else if ($this.hasClass('dropdown-header') && $lisVisible.eq(index + 1).data('optgroup') !== $this.data('optgroup')) {
$this.addClass('hidden');
} else {
$foundDiv = null;
}
});
if ($foundDiv) $foundDiv.addClass('hidden');
$searchBase.not('.hidden').first().addClass('active');
that.$menuInner.scrollTop(0);
}
}
});
},
_searchStyle: function () {
var styles = {
begins: 'ibegins',
startsWith: 'ibegins'
};
return styles[this.options.liveSearchStyle] || 'icontains';
},
val: function (value) {
if (typeof value !== 'undefined') {
this.$element.val(value);
this.render();
return this.$element;
} else {
return this.$element.val();
}
},
changeAll: function (status) {
if (!this.multiple) return;
if (typeof status === 'undefined') status = true;
this.findLis();
var $options = this.$element.find('option'),
$lisVisible = this.$lis.not('.divider, .dropdown-header, .disabled, .hidden'),
lisVisLen = $lisVisible.length,
selectedOptions = [];
if (status) {
if ($lisVisible.filter('.selected').length === $lisVisible.length) return;
} else {
if ($lisVisible.filter('.selected').length === 0) return;
}
$lisVisible.toggleClass('selected', status);
for (var i = 0; i < lisVisLen; i++) {
var origIndex = $lisVisible[i].getAttribute('data-original-index');
selectedOptions[selectedOptions.length] = $options.eq(origIndex)[0];
}
$(selectedOptions).prop('selected', status);
this.render(false);
this.togglePlaceholder();
this.$element
.triggerNative('change');
},
selectAll: function () {
return this.changeAll(true);
},
deselectAll: function () {
return this.changeAll(false);
},
toggle: function (e) {
e = e || window.event;
if (e) e.stopPropagation();
this.$button.trigger('click');
},
keydown: function (e) {
var $this = $(this),
$parent = $this.is('input') ? $this.parent().parent() : $this.parent(),
$items,
that = $parent.data('this'),
index,
prevIndex,
isActive,
selector = ':not(.disabled, .hidden, .dropdown-header, .divider)',
keyCodeMap = {
32: ' ',
48: '0',
49: '1',
50: '2',
51: '3',
52: '4',
53: '5',
54: '6',
55: '7',
56: '8',
57: '9',
59: ';',
65: 'a',
66: 'b',
67: 'c',
68: 'd',
69: 'e',
70: 'f',
71: 'g',
72: 'h',
73: 'i',
74: 'j',
75: 'k',
76: 'l',
77: 'm',
78: 'n',
79: 'o',
80: 'p',
81: 'q',
82: 'r',
83: 's',
84: 't',
85: 'u',
86: 'v',
87: 'w',
88: 'x',
89: 'y',
90: 'z',
96: '0',
97: '1',
98: '2',
99: '3',
100: '4',
101: '5',
102: '6',
103: '7',
104: '8',
105: '9'
};
isActive = that.$newElement.hasClass('open');
if (!isActive && (e.keyCode >= 48 && e.keyCode <= 57 || e.keyCode >= 96 && e.keyCode <= 105 || e.keyCode >= 65 && e.keyCode <= 90)) {
if (!that.options.container) {
that.setSize();
that.$menu.parent().addClass('open');
isActive = true;
} else {
that.$button.trigger('click');
}
that.$searchbox.focus();
return;
}
if (that.options.liveSearch) {
if (/(^9$|27)/.test(e.keyCode.toString(10)) && isActive) {
e.preventDefault();
e.stopPropagation();
that.$menuInner.click();
that.$button.focus();
}
}
if (/(38|40)/.test(e.keyCode.toString(10))) {
$items = that.$lis.filter(selector);
if (!$items.length) return;
if (!that.options.liveSearch) {
index = $items.index($items.find('a').filter(':focus').parent());
} else {
index = $items.index($items.filter('.active'));
}
prevIndex = that.$menuInner.data('prevIndex');
if (e.keyCode == 38) {
if ((that.options.liveSearch || index == prevIndex) && index != -1) index--;
if (index < 0) index += $items.length;
} else if (e.keyCode == 40) {
if (that.options.liveSearch || index == prevIndex) index++;
index = index % $items.length;
}
that.$menuInner.data('prevIndex', index);
if (!that.options.liveSearch) {
$items.eq(index).children('a').focus();
} else {
e.preventDefault();
if (!$this.hasClass('dropdown-toggle')) {
$items.removeClass('active').eq(index).addClass('active').children('a').focus();
$this.focus();
}
}
} else if (!$this.is('input')) {
var keyIndex = [],
count,
prevKey;
$items = that.$lis.filter(selector);
$items.each(function (i) {
if ($.trim($(this).children('a').text().toLowerCase()).substring(0, 1) == keyCodeMap[e.keyCode]) {
keyIndex.push(i);
}
});
count = $(document).data('keycount');
count++;
$(document).data('keycount', count);
prevKey = $.trim($(':focus').text().toLowerCase()).substring(0, 1);
if (prevKey != keyCodeMap[e.keyCode]) {
count = 1;
$(document).data('keycount', count);
} else if (count >= keyIndex.length) {
$(document).data('keycount', 0);
if (count > keyIndex.length) count = 1;
}
$items.eq(keyIndex[count - 1]).children('a').focus();
}
if ((/(13|32)/.test(e.keyCode.toString(10)) || (/(^9$)/.test(e.keyCode.toString(10)) && that.options.selectOnTab)) && isActive) {
if (!/(32)/.test(e.keyCode.toString(10))) e.preventDefault();
if (!that.options.liveSearch) {
var elem = $(':focus');
elem.click();
elem.focus();
e.preventDefault();
$(document).data('spaceSelect', true);
} else if (!/(32)/.test(e.keyCode.toString(10))) {
that.$menuInner.find('.active a').click();
$this.focus();
}
$(document).data('keycount', 0);
}
if ((/(^9$|27)/.test(e.keyCode.toString(10)) && isActive && (that.multiple || that.options.liveSearch)) || (/(27)/.test(e.keyCode.toString(10)) && !isActive)) {
that.$menu.parent().removeClass('open');
if (that.options.container) that.$newElement.removeClass('open');
that.$button.focus();
}
},
mobile: function () {
this.$element.addClass('mobile-device');
},
refresh: function () {
this.$lis = null;
this.liObj = {};
this.reloadLi();
this.render();
this.checkDisabled();
this.liHeight(true);
this.setStyle();
this.setWidth();
if (this.$lis) this.$searchbox.trigger('propertychange');
this.$element.trigger('refreshed.bs.select');
},
hide: function () {
this.$newElement.hide();
},
show: function () {
this.$newElement.show();
},
remove: function () {
this.$newElement.remove();
this.$element.remove();
},
destroy: function () {
this.$newElement.before(this.$element).remove();
if (this.$bsContainer) {
this.$bsContainer.remove();
} else {
this.$menu.remove();
}
this.$element
.off('.bs.select')
.removeData('selectpicker')
.removeClass('bs-select-hidden selectpicker');
}
};
function Plugin(option) {
var args = arguments;
var _option = option;
[].shift.apply(args);
var value;
var chain = this.each(function () {
var $this = $(this);
if ($this.is('select')) {
var data = $this.data('selectpicker'),
options = typeof _option == 'object' && _option;
if (!data) {
var config = $.extend({}, Selectpicker.DEFAULTS, $.fn.selectpicker.defaults || {}, $this.data(), options);
config.template = $.extend({}, Selectpicker.DEFAULTS.template, ($.fn.selectpicker.defaults ? $.fn.selectpicker.defaults.template : {}), $this.data().template, options.template);
$this.data('selectpicker', (data = new Selectpicker(this, config)));
} else if (options) {
for (var i in options) {
if (options.hasOwnProperty(i)) {
data.options[i] = options[i];
}
}
}
if (typeof _option == 'string') {
if (data[_option] instanceof Function) {
value = data[_option].apply(data, args);
} else {
value = data.options[_option];
}
}
}
});
if (typeof value !== 'undefined') {
return value;
} else {
return chain;
}
}
var old = $.fn.selectpicker;
$.fn.selectpicker = Plugin;
$.fn.selectpicker.Constructor = Selectpicker;
$.fn.selectpicker.noConflict = function () {
$.fn.selectpicker = old;
return this;
};
$(document)
.data('keycount', 0)
.on('keydown.bs.select', '.bootstrap-select [data-toggle=dropdown], .bootstrap-select [role="listbox"], .bs-searchbox input', Selectpicker.prototype.keydown)
.on('focusin.modal', '.bootstrap-select [data-toggle=dropdown], .bootstrap-select [role="listbox"], .bs-searchbox input', function (e) {
e.stopPropagation();
});
$(window).on('load.bs.select.data-api', function () {
$('.selectpicker').each(function () {
var $selectpicker = $(this);
Plugin.call($selectpicker, $selectpicker.data());
})
});
})(jQuery);
}));
;(function (factory) {
if (typeof define === 'function' && define.amd) {
define(['jquery'], factory);
} else if (typeof module === 'object' && module.exports) {
module.exports = function (root, jQuery) {
if (jQuery === undefined) {
if (typeof window !== 'undefined') {
jQuery = require('jquery');
}
else {
jQuery = require('jquery')(root);
}
}
factory(jQuery);
return jQuery;
};
} else {
factory(jQuery);
}
} (function (jQuery) {
var S2 =(function () {
if (jQuery && jQuery.fn && jQuery.fn.select2 && jQuery.fn.select2.amd) {
var S2 = jQuery.fn.select2.amd;
}
var S2;(function () { if (!S2 || !S2.requirejs) {
if (!S2) { S2 = {}; } else { require = S2; }
var requirejs, require, define;
(function (undef) {
var main, req, makeMap, handlers,
defined = {},
waiting = {},
config = {},
defining = {},
hasOwn = Object.prototype.hasOwnProperty,
aps = [].slice,
jsSuffixRegExp = /\.js$/;
function hasProp(obj, prop) {
return hasOwn.call(obj, prop);
}
function normalize(name, baseName) {
var nameParts, nameSegment, mapValue, foundMap, lastIndex,
foundI, foundStarMap, starI, i, j, part, normalizedBaseParts,
baseParts = baseName && baseName.split("/"),
map = config.map,
starMap = (map && map['*']) || {};
if (name) {
name = name.split('/');
lastIndex = name.length - 1;
if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
}
if (name[0].charAt(0) === '.' && baseParts) {
normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);
name = normalizedBaseParts.concat(name);
}
for (i = 0; i < name.length; i++) {
part = name[i];
if (part === '.') {
name.splice(i, 1);
i -= 1;
} else if (part === '..') {
if (i === 0 || (i === 1 && name[2] === '..') || name[i - 1] === '..') {
continue;
} else if (i > 0) {
name.splice(i - 1, 2);
i -= 2;
}
}
}
name = name.join('/');
}
if ((baseParts || starMap) && map) {
nameParts = name.split('/');
for (i = nameParts.length; i > 0; i -= 1) {
nameSegment = nameParts.slice(0, i).join("/");
if (baseParts) {
for (j = baseParts.length; j > 0; j -= 1) {
mapValue = map[baseParts.slice(0, j).join('/')];
if (mapValue) {
mapValue = mapValue[nameSegment];
if (mapValue) {
foundMap = mapValue;
foundI = i;
break;
}
}
}
}
if (foundMap) {
break;
}
if (!foundStarMap && starMap && starMap[nameSegment]) {
foundStarMap = starMap[nameSegment];
starI = i;
}
}
if (!foundMap && foundStarMap) {
foundMap = foundStarMap;
foundI = starI;
}
if (foundMap) {
nameParts.splice(0, foundI, foundMap);
name = nameParts.join('/');
}
}
return name;
}
function makeRequire(relName, forceSync) {
return function () {
var args = aps.call(arguments, 0);
if (typeof args[0] !== 'string' && args.length === 1) {
args.push(null);
}
return req.apply(undef, args.concat([relName, forceSync]));
};
}
function makeNormalize(relName) {
return function (name) {
return normalize(name, relName);
};
}
function makeLoad(depName) {
return function (value) {
defined[depName] = value;
};
}
function callDep(name) {
if (hasProp(waiting, name)) {
var args = waiting[name];
delete waiting[name];
defining[name] = true;
main.apply(undef, args);
}
if (!hasProp(defined, name) && !hasProp(defining, name)) {
throw new Error('No ' + name);
}
return defined[name];
}
function splitPrefix(name) {
var prefix,
index = name ? name.indexOf('!') : -1;
if (index > -1) {
prefix = name.substring(0, index);
name = name.substring(index + 1, name.length);
}
return [prefix, name];
}
function makeRelParts(relName) {
return relName ? splitPrefix(relName) : [];
}
makeMap = function (name, relParts) {
var plugin,
parts = splitPrefix(name),
prefix = parts[0],
relResourceName = relParts[1];
name = parts[1];
if (prefix) {
prefix = normalize(prefix, relResourceName);
plugin = callDep(prefix);
}
if (prefix) {
if (plugin && plugin.normalize) {
name = plugin.normalize(name, makeNormalize(relResourceName));
} else {
name = normalize(name, relResourceName);
}
} else {
name = normalize(name, relResourceName);
parts = splitPrefix(name);
prefix = parts[0];
name = parts[1];
if (prefix) {
plugin = callDep(prefix);
}
}
return {
f: prefix ? prefix + '!' + name : name, //fullName
n: name,
pr: prefix,
p: plugin
};
};
function makeConfig(name) {
return function () {
return (config && config.config && config.config[name]) || {};
};
}
handlers = {
require: function (name) {
return makeRequire(name);
},
exports: function (name) {
var e = defined[name];
if (typeof e !== 'undefined') {
return e;
} else {
return (defined[name] = {});
}
},
module: function (name) {
return {
id: name,
uri: '',
exports: defined[name],
config: makeConfig(name)
};
}
};
main = function (name, deps, callback, relName) {
var cjsModule, depName, ret, map, i, relParts,
args = [],
callbackType = typeof callback,
usingExports;
relName = relName || name;
relParts = makeRelParts(relName);
if (callbackType === 'undefined' || callbackType === 'function') {
deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
for (i = 0; i < deps.length; i += 1) {
map = makeMap(deps[i], relParts);
depName = map.f;
if (depName === "require") {
args[i] = handlers.require(name);
} else if (depName === "exports") {
args[i] = handlers.exports(name);
usingExports = true;
} else if (depName === "module") {
cjsModule = args[i] = handlers.module(name);
} else if (hasProp(defined, depName) ||
hasProp(waiting, depName) ||
hasProp(defining, depName)) {
args[i] = callDep(depName);
} else if (map.p) {
map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
args[i] = defined[depName];
} else {
throw new Error(name + ' missing ' + depName);
}
}
ret = callback ? callback.apply(defined[name], args) : undefined;
if (name) {
if (cjsModule && cjsModule.exports !== undef &&
cjsModule.exports !== defined[name]) {
defined[name] = cjsModule.exports;
} else if (ret !== undef || !usingExports) {
defined[name] = ret;
}
}
} else if (name) {
defined[name] = callback;
}
};
requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
if (typeof deps === "string") {
if (handlers[deps]) {
return handlers[deps](callback);
}
return callDep(makeMap(deps, makeRelParts(callback)).f);
} else if (!deps.splice) {
config = deps;
if (config.deps) {
req(config.deps, config.callback);
}
if (!callback) {
return;
}
if (callback.splice) {
deps = callback;
callback = relName;
relName = null;
} else {
deps = undef;
}
}
callback = callback || function () {};
if (typeof relName === 'function') {
relName = forceSync;
forceSync = alt;
}
if (forceSync) {
main(undef, deps, callback, relName);
} else {
setTimeout(function () {
main(undef, deps, callback, relName);
}, 4);
}
return req;
};
req.config = function (cfg) {
return req(cfg);
};
requirejs._defined = defined;
define = function (name, deps, callback) {
if (typeof name !== 'string') {
throw new Error('See almond README: incorrect module build, no module name');
}
if (!deps.splice) {
callback = deps;
deps = [];
}
if (!hasProp(defined, name) && !hasProp(waiting, name)) {
waiting[name] = [name, deps, callback];
}
};
define.amd = {
jQuery: true
};
}());
S2.requirejs = requirejs;S2.require = require;S2.define = define;
}
}());
S2.define("almond", function(){});
S2.define('jquery',[],function () {
var _$ = jQuery || $;
if (_$ == null && console && console.error) {
console.error(
'Select2: An instance of jQuery or a jQuery-compatible library was not ' +
'found. Make sure that you are including jQuery before Select2 on your ' +
'web page.'
);
}
return _$;
});
S2.define('select2/utils',[
'jquery'
], function ($) {
var Utils = {};
Utils.Extend = function (ChildClass, SuperClass) {
var __hasProp = {}.hasOwnProperty;
function BaseConstructor () {
this.constructor = ChildClass;
}
for (var key in SuperClass) {
if (__hasProp.call(SuperClass, key)) {
ChildClass[key] = SuperClass[key];
}
}
BaseConstructor.prototype = SuperClass.prototype;
ChildClass.prototype = new BaseConstructor();
ChildClass.__super__ = SuperClass.prototype;
return ChildClass;
};
function getMethods (theClass) {
var proto = theClass.prototype;
var methods = [];
for (var methodName in proto) {
var m = proto[methodName];
if (typeof m !== 'function') {
continue;
}
if (methodName === 'constructor') {
continue;
}
methods.push(methodName);
}
return methods;
}
Utils.Decorate = function (SuperClass, DecoratorClass) {
var decoratedMethods = getMethods(DecoratorClass);
var superMethods = getMethods(SuperClass);
function DecoratedClass () {
var unshift = Array.prototype.unshift;
var argCount = DecoratorClass.prototype.constructor.length;
var calledConstructor = SuperClass.prototype.constructor;
if (argCount > 0) {
unshift.call(arguments, SuperClass.prototype.constructor);
calledConstructor = DecoratorClass.prototype.constructor;
}
calledConstructor.apply(this, arguments);
}
DecoratorClass.displayName = SuperClass.displayName;
function ctr () {
this.constructor = DecoratedClass;
}
DecoratedClass.prototype = new ctr();
for (var m = 0; m < superMethods.length; m++) {
var superMethod = superMethods[m];
DecoratedClass.prototype[superMethod] =
SuperClass.prototype[superMethod];
}
var calledMethod = function (methodName) {
var originalMethod = function () {};
if (methodName in DecoratedClass.prototype) {
originalMethod = DecoratedClass.prototype[methodName];
}
var decoratedMethod = DecoratorClass.prototype[methodName];
return function () {
var unshift = Array.prototype.unshift;
unshift.call(arguments, originalMethod);
return decoratedMethod.apply(this, arguments);
};
};
for (var d = 0; d < decoratedMethods.length; d++) {
var decoratedMethod = decoratedMethods[d];
DecoratedClass.prototype[decoratedMethod] = calledMethod(decoratedMethod);
}
return DecoratedClass;
};
var Observable = function () {
this.listeners = {};
};
Observable.prototype.on = function (event, callback) {
this.listeners = this.listeners || {};
if (event in this.listeners) {
this.listeners[event].push(callback);
} else {
this.listeners[event] = [callback];
}
};
Observable.prototype.trigger = function (event) {
var slice = Array.prototype.slice;
var params = slice.call(arguments, 1);
this.listeners = this.listeners || {};
if (params == null) {
params = [];
}
if (params.length === 0) {
params.push({});
}
params[0]._type = event;
if (event in this.listeners) {
this.invoke(this.listeners[event], slice.call(arguments, 1));
}
if ('*' in this.listeners) {
this.invoke(this.listeners['*'], arguments);
}
};
Observable.prototype.invoke = function (listeners, params) {
for (var i = 0, len = listeners.length; i < len; i++) {
listeners[i].apply(this, params);
}
};
Utils.Observable = Observable;
Utils.generateChars = function (length) {
var chars = '';
for (var i = 0; i < length; i++) {
var randomChar = Math.floor(Math.random() * 36);
chars += randomChar.toString(36);
}
return chars;
};
Utils.bind = function (func, context) {
return function () {
func.apply(context, arguments);
};
};
Utils._convertData = function (data) {
for (var originalKey in data) {
var keys = originalKey.split('-');
var dataLevel = data;
if (keys.length === 1) {
continue;
}
for (var k = 0; k < keys.length; k++) {
var key = keys[k];
key = key.substring(0, 1).toLowerCase() + key.substring(1);
if (!(key in dataLevel)) {
dataLevel[key] = {};
}
if (k == keys.length - 1) {
dataLevel[key] = data[originalKey];
}
dataLevel = dataLevel[key];
}
delete data[originalKey];
}
return data;
};
Utils.hasScroll = function (index, el) {
var $el = $(el);
var overflowX = el.style.overflowX;
var overflowY = el.style.overflowY;
if (overflowX === overflowY &&
(overflowY === 'hidden' || overflowY === 'visible')) {
return false;
}
if (overflowX === 'scroll' || overflowY === 'scroll') {
return true;
}
return ($el.innerHeight() < el.scrollHeight ||
$el.innerWidth() < el.scrollWidth);
};
Utils.escapeMarkup = function (markup) {
var replaceMap = {
'\\': '&#92;',
'&': '&amp;',
'<': '&lt;',
'>': '&gt;',
'"': '&quot;',
'\'': '&#39;',
'/': '&#47;'
};
if (typeof markup !== 'string') {
return markup;
}
return String(markup).replace(/[&<>"'\/\\]/g, function (match) {
return replaceMap[match];
});
};
Utils.appendMany = function ($element, $nodes) {
if ($.fn.jquery.substr(0, 3) === '1.7') {
var $jqNodes = $();
$.map($nodes, function (node) {
$jqNodes = $jqNodes.add(node);
});
$nodes = $jqNodes;
}
$element.append($nodes);
};
Utils.__cache = {};
var id = 0;
Utils.GetUniqueElementId = function (element) {
var select2Id = element.getAttribute('data-select2-id');
if (select2Id == null) {
if (element.id) {
select2Id = element.id;
element.setAttribute('data-select2-id', select2Id);
} else {
element.setAttribute('data-select2-id', ++id);
select2Id = id.toString();
}
}
return select2Id;
};
Utils.StoreData = function (element, name, value) {
var id = Utils.GetUniqueElementId(element);
if (!Utils.__cache[id]) {
Utils.__cache[id] = {};
}
Utils.__cache[id][name] = value;
};
Utils.GetData = function (element, name) {
var id = Utils.GetUniqueElementId(element);
if (name) {
if (Utils.__cache[id]) {
return Utils.__cache[id][name] != null ?
Utils.__cache[id][name]:
$(element).data(name); // Fallback to HTML5 data attribs.
}
return $(element).data(name); // Fallback to HTML5 data attribs.
} else {
return Utils.__cache[id];
}
};
Utils.RemoveData = function (element) {
var id = Utils.GetUniqueElementId(element);
if (Utils.__cache[id] != null) {
delete Utils.__cache[id];
}
};
return Utils;
});
S2.define('select2/results',[
'jquery',
'./utils'
], function ($, Utils) {
function Results ($element, options, dataAdapter) {
this.$element = $element;
this.data = dataAdapter;
this.options = options;
Results.__super__.constructor.call(this);
}
Utils.Extend(Results, Utils.Observable);
Results.prototype.render = function () {
var $results = $(
'<ul class="select2-results__options" role="tree"></ul>'
);
if (this.options.get('multiple')) {
$results.attr('aria-multiselectable', 'true');
}
this.$results = $results;
return $results;
};
Results.prototype.clear = function () {
this.$results.empty();
};
Results.prototype.displayMessage = function (params) {
var escapeMarkup = this.options.get('escapeMarkup');
this.clear();
this.hideLoading();
var $message = $(
'<li role="treeitem" aria-live="assertive"' +
' class="select2-results__option"></li>'
);
var message = this.options.get('translations').get(params.message);
$message.append(
escapeMarkup(
message(params.args)
)
);
$message[0].className += ' select2-results__message';
this.$results.append($message);
};
Results.prototype.hideMessages = function () {
this.$results.find('.select2-results__message').remove();
};
Results.prototype.append = function (data) {
this.hideLoading();
var $options = [];
if (data.results == null || data.results.length === 0) {
if (this.$results.children().length === 0) {
this.trigger('results:message', {
message: 'noResults'
});
}
return;
}
data.results = this.sort(data.results);
for (var d = 0; d < data.results.length; d++) {
var item = data.results[d];
var $option = this.option(item);
$options.push($option);
}
this.$results.append($options);
};
Results.prototype.position = function ($results, $dropdown) {
var $resultsContainer = $dropdown.find('.select2-results');
$resultsContainer.append($results);
};
Results.prototype.sort = function (data) {
var sorter = this.options.get('sorter');
return sorter(data);
};
Results.prototype.highlightFirstItem = function () {
var $options = this.$results
.find('.select2-results__option[aria-selected]');
var $selected = $options.filter('[aria-selected=true]');
if ($selected.length > 0) {
$selected.first().trigger('mouseenter');
} else {
$options.first().trigger('mouseenter');
}
this.ensureHighlightVisible();
};
Results.prototype.setClasses = function () {
var self = this;
this.data.current(function (selected) {
var selectedIds = $.map(selected, function (s) {
return s.id.toString();
});
var $options = self.$results
.find('.select2-results__option[aria-selected]');
$options.each(function () {
var $option = $(this);
var item = Utils.GetData(this, 'data');
var id = '' + item.id;
if ((item.element != null && item.element.selected) ||
(item.element == null && $.inArray(id, selectedIds) > -1)) {
$option.attr('aria-selected', 'true');
} else {
$option.attr('aria-selected', 'false');
}
});
});
};
Results.prototype.showLoading = function (params) {
this.hideLoading();
var loadingMore = this.options.get('translations').get('searching');
var loading = {
disabled: true,
loading: true,
text: loadingMore(params)
};
var $loading = this.option(loading);
$loading.className += ' loading-results';
this.$results.prepend($loading);
};
Results.prototype.hideLoading = function () {
this.$results.find('.loading-results').remove();
};
Results.prototype.option = function (data) {
var option = document.createElement('li');
option.className = 'select2-results__option';
var attrs = {
'role': 'treeitem',
'aria-selected': 'false'
};
if (data.disabled) {
delete attrs['aria-selected'];
attrs['aria-disabled'] = 'true';
}
if (data.id == null) {
delete attrs['aria-selected'];
}
if (data._resultId != null) {
option.id = data._resultId;
}
if (data.title) {
option.title = data.title;
}
if (data.children) {
attrs.role = 'group';
attrs['aria-label'] = data.text;
delete attrs['aria-selected'];
}
for (var attr in attrs) {
var val = attrs[attr];
option.setAttribute(attr, val);
}
if (data.children) {
var $option = $(option);
var label = document.createElement('strong');
label.className = 'select2-results__group';
var $label = $(label);
this.template(data, label);
var $children = [];
for (var c = 0; c < data.children.length; c++) {
var child = data.children[c];
var $child = this.option(child);
$children.push($child);
}
var $childrenContainer = $('<ul></ul>', {
'class': 'select2-results__options select2-results__options--nested'
});
$childrenContainer.append($children);
$option.append(label);
$option.append($childrenContainer);
} else {
this.template(data, option);
}
Utils.StoreData(option, 'data', data);
return option;
};
Results.prototype.bind = function (container, $container) {
var self = this;
var id = container.id + '-results';
this.$results.attr('id', id);
container.on('results:all', function (params) {
self.clear();
self.append(params.data);
if (container.isOpen()) {
self.setClasses();
self.highlightFirstItem();
}
});
container.on('results:append', function (params) {
self.append(params.data);
if (container.isOpen()) {
self.setClasses();
}
});
container.on('query', function (params) {
self.hideMessages();
self.showLoading(params);
});
container.on('select', function () {
if (!container.isOpen()) {
return;
}
self.setClasses();
self.highlightFirstItem();
});
container.on('unselect', function () {
if (!container.isOpen()) {
return;
}
self.setClasses();
self.highlightFirstItem();
});
container.on('open', function () {
self.$results.attr('aria-expanded', 'true');
self.$results.attr('aria-hidden', 'false');
self.setClasses();
self.ensureHighlightVisible();
});
container.on('close', function () {
self.$results.attr('aria-expanded', 'false');
self.$results.attr('aria-hidden', 'true');
self.$results.removeAttr('aria-activedescendant');
});
container.on('results:toggle', function () {
var $highlighted = self.getHighlightedResults();
if ($highlighted.length === 0) {
return;
}
$highlighted.trigger('mouseup');
});
container.on('results:select', function () {
var $highlighted = self.getHighlightedResults();
if ($highlighted.length === 0) {
return;
}
var data = Utils.GetData($highlighted[0], 'data');
if ($highlighted.attr('aria-selected') == 'true') {
self.trigger('close', {});
} else {
self.trigger('select', {
data: data
});
}
});
container.on('results:previous', function () {
var $highlighted = self.getHighlightedResults();
var $options = self.$results.find('[aria-selected]');
var currentIndex = $options.index($highlighted);
if (currentIndex <= 0) {
return;
}
var nextIndex = currentIndex - 1;
if ($highlighted.length === 0) {
nextIndex = 0;
}
var $next = $options.eq(nextIndex);
$next.trigger('mouseenter');
var currentOffset = self.$results.offset().top;
var nextTop = $next.offset().top;
var nextOffset = self.$results.scrollTop() + (nextTop - currentOffset);
if (nextIndex === 0) {
self.$results.scrollTop(0);
} else if (nextTop - currentOffset < 0) {
self.$results.scrollTop(nextOffset);
}
});
container.on('results:next', function () {
var $highlighted = self.getHighlightedResults();
var $options = self.$results.find('[aria-selected]');
var currentIndex = $options.index($highlighted);
var nextIndex = currentIndex + 1;
if (nextIndex >= $options.length) {
return;
}
var $next = $options.eq(nextIndex);
$next.trigger('mouseenter');
var currentOffset = self.$results.offset().top +
self.$results.outerHeight(false);
var nextBottom = $next.offset().top + $next.outerHeight(false);
var nextOffset = self.$results.scrollTop() + nextBottom - currentOffset;
if (nextIndex === 0) {
self.$results.scrollTop(0);
} else if (nextBottom > currentOffset) {
self.$results.scrollTop(nextOffset);
}
});
container.on('results:focus', function (params) {
params.element.addClass('select2-results__option--highlighted');
});
container.on('results:message', function (params) {
self.displayMessage(params);
});
if ($.fn.mousewheel) {
this.$results.on('mousewheel', function (e) {
var top = self.$results.scrollTop();
var bottom = self.$results.get(0).scrollHeight - top + e.deltaY;
var isAtTop = e.deltaY > 0 && top - e.deltaY <= 0;
var isAtBottom = e.deltaY < 0 && bottom <= self.$results.height();
if (isAtTop) {
self.$results.scrollTop(0);
e.preventDefault();
e.stopPropagation();
} else if (isAtBottom) {
self.$results.scrollTop(
self.$results.get(0).scrollHeight - self.$results.height()
);
e.preventDefault();
e.stopPropagation();
}
});
}
this.$results.on('mouseup', '.select2-results__option[aria-selected]',
function (evt) {
var $this = $(this);
var data = Utils.GetData(this, 'data');
if ($this.attr('aria-selected') === 'true') {
if (self.options.get('multiple')) {
self.trigger('unselect', {
originalEvent: evt,
data: data
});
} else {
self.trigger('close', {});
}
return;
}
self.trigger('select', {
originalEvent: evt,
data: data
});
});
this.$results.on('mouseenter', '.select2-results__option[aria-selected]',
function (evt) {
var data = Utils.GetData(this, 'data');
self.getHighlightedResults()
.removeClass('select2-results__option--highlighted');
self.trigger('results:focus', {
data: data,
element: $(this)
});
});
};
Results.prototype.getHighlightedResults = function () {
var $highlighted = this.$results
.find('.select2-results__option--highlighted');
return $highlighted;
};
Results.prototype.destroy = function () {
this.$results.remove();
};
Results.prototype.ensureHighlightVisible = function () {
var $highlighted = this.getHighlightedResults();
if ($highlighted.length === 0) {
return;
}
var $options = this.$results.find('[aria-selected]');
var currentIndex = $options.index($highlighted);
var currentOffset = this.$results.offset().top;
var nextTop = $highlighted.offset().top;
var nextOffset = this.$results.scrollTop() + (nextTop - currentOffset);
var offsetDelta = nextTop - currentOffset;
nextOffset -= $highlighted.outerHeight(false) * 2;
if (currentIndex <= 2) {
this.$results.scrollTop(0);
} else if (offsetDelta > this.$results.outerHeight() || offsetDelta < 0) {
this.$results.scrollTop(nextOffset);
}
};
Results.prototype.template = function (result, container) {
var template = this.options.get('templateResult');
var escapeMarkup = this.options.get('escapeMarkup');
var content = template(result, container);
if (content == null) {
container.style.display = 'none';
} else if (typeof content === 'string') {
container.innerHTML = escapeMarkup(content);
} else {
$(container).append(content);
}
};
return Results;
});
S2.define('select2/keys',[
], function () {
var KEYS = {
BACKSPACE: 8,
TAB: 9,
ENTER: 13,
SHIFT: 16,
CTRL: 17,
ALT: 18,
ESC: 27,
SPACE: 32,
PAGE_UP: 33,
PAGE_DOWN: 34,
END: 35,
HOME: 36,
LEFT: 37,
UP: 38,
RIGHT: 39,
DOWN: 40,
DELETE: 46
};
return KEYS;
});
S2.define('select2/selection/base',[
'jquery',
'../utils',
'../keys'
], function ($, Utils, KEYS) {
function BaseSelection ($element, options) {
this.$element = $element;
this.options = options;
BaseSelection.__super__.constructor.call(this);
}
Utils.Extend(BaseSelection, Utils.Observable);
BaseSelection.prototype.render = function () {
var $selection = $(
'<span class="select2-selection" role="combobox" ' +
' aria-haspopup="true" aria-expanded="false">' +
'</span>'
);
this._tabindex = 0;
if (Utils.GetData(this.$element[0], 'old-tabindex') != null) {
this._tabindex = Utils.GetData(this.$element[0], 'old-tabindex');
} else if (this.$element.attr('tabindex') != null) {
this._tabindex = this.$element.attr('tabindex');
}
$selection.attr('title', this.$element.attr('title'));
$selection.attr('tabindex', this._tabindex);
this.$selection = $selection;
return $selection;
};
BaseSelection.prototype.bind = function (container, $container) {
var self = this;
var id = container.id + '-container';
var resultsId = container.id + '-results';
this.container = container;
this.$selection.on('focus', function (evt) {
self.trigger('focus', evt);
});
this.$selection.on('blur', function (evt) {
self._handleBlur(evt);
});
this.$selection.on('keydown', function (evt) {
self.trigger('keypress', evt);
if (evt.which === KEYS.SPACE) {
evt.preventDefault();
}
});
container.on('results:focus', function (params) {
self.$selection.attr('aria-activedescendant', params.data._resultId);
});
container.on('selection:update', function (params) {
self.update(params.data);
});
container.on('open', function () {
self.$selection.attr('aria-expanded', 'true');
self.$selection.attr('aria-owns', resultsId);
self._attachCloseHandler(container);
});
container.on('close', function () {
self.$selection.attr('aria-expanded', 'false');
self.$selection.removeAttr('aria-activedescendant');
self.$selection.removeAttr('aria-owns');
self.$selection.focus();
window.setTimeout(function () {
self.$selection.focus();
}, 0);
self._detachCloseHandler(container);
});
container.on('enable', function () {
self.$selection.attr('tabindex', self._tabindex);
});
container.on('disable', function () {
self.$selection.attr('tabindex', '-1');
});
};
BaseSelection.prototype._handleBlur = function (evt) {
var self = this;
window.setTimeout(function () {
if (
(document.activeElement == self.$selection[0]) ||
($.contains(self.$selection[0], document.activeElement))
) {
return;
}
self.trigger('blur', evt);
}, 1);
};
BaseSelection.prototype._attachCloseHandler = function (container) {
var self = this;
$(document.body).on('mousedown.select2.' + container.id, function (e) {
var $target = $(e.target);
var $select = $target.closest('.select2');
var $all = $('.select2.select2-container--open');
$all.each(function () {
var $this = $(this);
if (this == $select[0]) {
return;
}
var $element = Utils.GetData(this, 'element');
$element.select2('close');
});
});
};
BaseSelection.prototype._detachCloseHandler = function (container) {
$(document.body).off('mousedown.select2.' + container.id);
};
BaseSelection.prototype.position = function ($selection, $container) {
var $selectionContainer = $container.find('.selection');
$selectionContainer.append($selection);
};
BaseSelection.prototype.destroy = function () {
this._detachCloseHandler(this.container);
};
BaseSelection.prototype.update = function (data) {
throw new Error('The `update` method must be defined in child classes.');
};
return BaseSelection;
});
S2.define('select2/selection/single',[
'jquery',
'./base',
'../utils',
'../keys'
], function ($, BaseSelection, Utils, KEYS) {
function SingleSelection () {
SingleSelection.__super__.constructor.apply(this, arguments);
}
Utils.Extend(SingleSelection, BaseSelection);
SingleSelection.prototype.render = function () {
var $selection = SingleSelection.__super__.render.call(this);
$selection.addClass('select2-selection--single');
$selection.html(
'<span class="select2-selection__rendered"></span>' +
'<span class="select2-selection__arrow" role="presentation">' +
'<b role="presentation"></b>' +
'</span>'
);
return $selection;
};
SingleSelection.prototype.bind = function (container, $container) {
var self = this;
SingleSelection.__super__.bind.apply(this, arguments);
var id = container.id + '-container';
this.$selection.find('.select2-selection__rendered')
.attr('id', id)
.attr('role', 'textbox')
.attr('aria-readonly', 'true');
this.$selection.attr('aria-labelledby', id);
this.$selection.on('mousedown', function (evt) {
if (evt.which !== 1) {
return;
}
self.trigger('toggle', {
originalEvent: evt
});
});
this.$selection.on('focus', function (evt) {
});
this.$selection.on('blur', function (evt) {
});
container.on('focus', function (evt) {
if (!container.isOpen()) {
self.$selection.focus();
}
});
};
SingleSelection.prototype.clear = function () {
var $rendered = this.$selection.find('.select2-selection__rendered');
$rendered.empty();
$rendered.removeAttr('title'); // clear tooltip on empty
};
SingleSelection.prototype.display = function (data, container) {
var template = this.options.get('templateSelection');
var escapeMarkup = this.options.get('escapeMarkup');
return escapeMarkup(template(data, container));
};
SingleSelection.prototype.selectionContainer = function () {
return $('<span></span>');
};
SingleSelection.prototype.update = function (data) {
if (data.length === 0) {
this.clear();
return;
}
var selection = data[0];
var $rendered = this.$selection.find('.select2-selection__rendered');
var formatted = this.display(selection, $rendered);
$rendered.empty().append(formatted);
$rendered.attr('title', selection.title || selection.text);
};
return SingleSelection;
});
S2.define('select2/selection/multiple',[
'jquery',
'./base',
'../utils'
], function ($, BaseSelection, Utils) {
function MultipleSelection ($element, options) {
MultipleSelection.__super__.constructor.apply(this, arguments);
}
Utils.Extend(MultipleSelection, BaseSelection);
MultipleSelection.prototype.render = function () {
var $selection = MultipleSelection.__super__.render.call(this);
$selection.addClass('select2-selection--multiple');
$selection.html(
'<ul class="select2-selection__rendered"></ul>'
);
return $selection;
};
MultipleSelection.prototype.bind = function (container, $container) {
var self = this;
MultipleSelection.__super__.bind.apply(this, arguments);
this.$selection.on('click', function (evt) {
self.trigger('toggle', {
originalEvent: evt
});
});
this.$selection.on(
'click',
'.select2-selection__choice__remove',
function (evt) {
if (self.options.get('disabled')) {
return;
}
var $remove = $(this);
var $selection = $remove.parent();
var data = Utils.GetData($selection[0], 'data');
self.trigger('unselect', {
originalEvent: evt,
data: data
});
}
);
};
MultipleSelection.prototype.clear = function () {
var $rendered = this.$selection.find('.select2-selection__rendered');
$rendered.empty();
$rendered.removeAttr('title');
};
MultipleSelection.prototype.display = function (data, container) {
var template = this.options.get('templateSelection');
var escapeMarkup = this.options.get('escapeMarkup');
return escapeMarkup(template(data, container));
};
MultipleSelection.prototype.selectionContainer = function () {
var $container = $(
'<li class="select2-selection__choice">' +
'<span class="select2-selection__choice__remove" role="presentation">' +
'&times;' +
'</span>' +
'</li>'
);
return $container;
};
MultipleSelection.prototype.update = function (data) {
this.clear();
if (data.length === 0) {
return;
}
var $selections = [];
for (var d = 0; d < data.length; d++) {
var selection = data[d];
var $selection = this.selectionContainer();
var formatted = this.display(selection, $selection);
$selection.append(formatted);
$selection.attr('title', selection.title || selection.text);
Utils.StoreData($selection[0], 'data', selection);
$selections.push($selection);
}
var $rendered = this.$selection.find('.select2-selection__rendered');
Utils.appendMany($rendered, $selections);
};
return MultipleSelection;
});
S2.define('select2/selection/placeholder',[
'../utils'
], function (Utils) {
function Placeholder (decorated, $element, options) {
this.placeholder = this.normalizePlaceholder(options.get('placeholder'));
decorated.call(this, $element, options);
}
Placeholder.prototype.normalizePlaceholder = function (_, placeholder) {
if (typeof placeholder === 'string') {
placeholder = {
id: '',
text: placeholder
};
}
return placeholder;
};
Placeholder.prototype.createPlaceholder = function (decorated, placeholder) {
var $placeholder = this.selectionContainer();
$placeholder.html(this.display(placeholder));
$placeholder.addClass('select2-selection__placeholder')
.removeClass('select2-selection__choice');
return $placeholder;
};
Placeholder.prototype.update = function (decorated, data) {
var singlePlaceholder = (
data.length == 1 && data[0].id != this.placeholder.id
);
var multipleSelections = data.length > 1;
if (multipleSelections || singlePlaceholder) {
return decorated.call(this, data);
}
this.clear();
var $placeholder = this.createPlaceholder(this.placeholder);
this.$selection.find('.select2-selection__rendered').append($placeholder);
};
return Placeholder;
});
S2.define('select2/selection/allowClear',[
'jquery',
'../keys',
'../utils'
], function ($, KEYS, Utils) {
function AllowClear () { }
AllowClear.prototype.bind = function (decorated, container, $container) {
var self = this;
decorated.call(this, container, $container);
if (this.placeholder == null) {
if (this.options.get('debug') && window.console && console.error) {
console.error(
'Select2: The `allowClear` option should be used in combination ' +
'with the `placeholder` option.'
);
}
}
this.$selection.on('mousedown', '.select2-selection__clear',
function (evt) {
self._handleClear(evt);
});
container.on('keypress', function (evt) {
self._handleKeyboardClear(evt, container);
});
};
AllowClear.prototype._handleClear = function (_, evt) {
if (this.options.get('disabled')) {
return;
}
var $clear = this.$selection.find('.select2-selection__clear');
if ($clear.length === 0) {
return;
}
evt.stopPropagation();
var data = Utils.GetData($clear[0], 'data');
var previousVal = this.$element.val();
this.$element.val(this.placeholder.id);
var unselectData = {
data: data
};
this.trigger('clear', unselectData);
if (unselectData.prevented) {
this.$element.val(previousVal);
return;
}
for (var d = 0; d < data.length; d++) {
unselectData = {
data: data[d]
};
this.trigger('unselect', unselectData);
if (unselectData.prevented) {
this.$element.val(previousVal);
return;
}
}
this.$element.trigger('change');
this.trigger('toggle', {});
};
AllowClear.prototype._handleKeyboardClear = function (_, evt, container) {
if (container.isOpen()) {
return;
}
if (evt.which == KEYS.DELETE || evt.which == KEYS.BACKSPACE) {
this._handleClear(evt);
}
};
AllowClear.prototype.update = function (decorated, data) {
decorated.call(this, data);
if (this.$selection.find('.select2-selection__placeholder').length > 0 ||
data.length === 0) {
return;
}
var $remove = $(
'<span class="select2-selection__clear">' +
'&times;' +
'</span>'
);
Utils.StoreData($remove[0], 'data', data);
this.$selection.find('.select2-selection__rendered').prepend($remove);
};
return AllowClear;
});
S2.define('select2/selection/search',[
'jquery',
'../utils',
'../keys'
], function ($, Utils, KEYS) {
function Search (decorated, $element, options) {
decorated.call(this, $element, options);
}
Search.prototype.render = function (decorated) {
var $search = $(
'<li class="select2-search select2-search--inline">' +
'<input class="select2-search__field" type="search" tabindex="-1"' +
' autocomplete="off" autocorrect="off" autocapitalize="none"' +
' spellcheck="false" role="textbox" aria-autocomplete="list" />' +
'</li>'
);
this.$searchContainer = $search;
this.$search = $search.find('input');
var $rendered = decorated.call(this);
this._transferTabIndex();
return $rendered;
};
Search.prototype.bind = function (decorated, container, $container) {
var self = this;
decorated.call(this, container, $container);
container.on('open', function () {
self.$search.trigger('focus');
});
container.on('close', function () {
self.$search.val('');
self.$search.removeAttr('aria-activedescendant');
self.$search.trigger('focus');
});
container.on('enable', function () {
self.$search.prop('disabled', false);
self._transferTabIndex();
});
container.on('disable', function () {
self.$search.prop('disabled', true);
});
container.on('focus', function (evt) {
self.$search.trigger('focus');
});
container.on('results:focus', function (params) {
self.$search.attr('aria-activedescendant', params.id);
});
this.$selection.on('focusin', '.select2-search--inline', function (evt) {
self.trigger('focus', evt);
});
this.$selection.on('focusout', '.select2-search--inline', function (evt) {
self._handleBlur(evt);
});
this.$selection.on('keydown', '.select2-search--inline', function (evt) {
evt.stopPropagation();
self.trigger('keypress', evt);
self._keyUpPrevented = evt.isDefaultPrevented();
var key = evt.which;
if (key === KEYS.BACKSPACE && self.$search.val() === '') {
var $previousChoice = self.$searchContainer
.prev('.select2-selection__choice');
if ($previousChoice.length > 0) {
var item = Utils.GetData($previousChoice[0], 'data');
self.searchRemoveChoice(item);
evt.preventDefault();
}
}
});
var msie = document.documentMode;
var disableInputEvents = msie && msie <= 11;
this.$selection.on(
'input.searchcheck',
'.select2-search--inline',
function (evt) {
if (disableInputEvents) {
self.$selection.off('input.search input.searchcheck');
return;
}
self.$selection.off('keyup.search');
}
);
this.$selection.on(
'keyup.search input.search',
'.select2-search--inline',
function (evt) {
if (disableInputEvents && evt.type === 'input') {
self.$selection.off('input.search input.searchcheck');
return;
}
var key = evt.which;
if (key == KEYS.SHIFT || key == KEYS.CTRL || key == KEYS.ALT) {
return;
}
if (key == KEYS.TAB) {
return;
}
self.handleSearch(evt);
}
);
};
Search.prototype._transferTabIndex = function (decorated) {
this.$search.attr('tabindex', this.$selection.attr('tabindex'));
this.$selection.attr('tabindex', '-1');
};
Search.prototype.createPlaceholder = function (decorated, placeholder) {
this.$search.attr('placeholder', placeholder.text);
};
Search.prototype.update = function (decorated, data) {
var searchHadFocus = this.$search[0] == document.activeElement;
this.$search.attr('placeholder', '');
decorated.call(this, data);
this.$selection.find('.select2-selection__rendered')
.append(this.$searchContainer);
this.resizeSearch();
if (searchHadFocus) {
var isTagInput = this.$element.find('[data-select2-tag]').length;
if (isTagInput) {
this.$element.focus();
} else {
this.$search.focus();
}
}
};
Search.prototype.handleSearch = function () {
this.resizeSearch();
if (!this._keyUpPrevented) {
var input = this.$search.val();
this.trigger('query', {
term: input
});
}
this._keyUpPrevented = false;
};
Search.prototype.searchRemoveChoice = function (decorated, item) {
this.trigger('unselect', {
data: item
});
this.$search.val(item.text);
this.handleSearch();
};
Search.prototype.resizeSearch = function () {
this.$search.css('width', '25px');
var width = '';
if (this.$search.attr('placeholder') !== '') {
width = this.$selection.find('.select2-selection__rendered').innerWidth();
} else {
var minimumWidth = this.$search.val().length + 1;
width = (minimumWidth * 0.75) + 'em';
}
this.$search.css('width', width);
};
return Search;
});
S2.define('select2/selection/eventRelay',[
'jquery'
], function ($) {
function EventRelay () { }
EventRelay.prototype.bind = function (decorated, container, $container) {
var self = this;
var relayEvents = [
'open', 'opening',
'close', 'closing',
'select', 'selecting',
'unselect', 'unselecting',
'clear', 'clearing'
];
var preventableEvents = [
'opening', 'closing', 'selecting', 'unselecting', 'clearing'
];
decorated.call(this, container, $container);
container.on('*', function (name, params) {
if ($.inArray(name, relayEvents) === -1) {
return;
}
params = params || {};
var evt = $.Event('select2:' + name, {
params: params
});
self.$element.trigger(evt);
if ($.inArray(name, preventableEvents) === -1) {
return;
}
params.prevented = evt.isDefaultPrevented();
});
};
return EventRelay;
});
S2.define('select2/translation',[
'jquery',
'require'
], function ($, require) {
function Translation (dict) {
this.dict = dict || {};
}
Translation.prototype.all = function () {
return this.dict;
};
Translation.prototype.get = function (key) {
return this.dict[key];
};
Translation.prototype.extend = function (translation) {
this.dict = $.extend({}, translation.all(), this.dict);
};
Translation._cache = {};
Translation.loadPath = function (path) {
if (!(path in Translation._cache)) {
var translations = require(path);
Translation._cache[path] = translations;
}
return new Translation(Translation._cache[path]);
};
return Translation;
});
S2.define('select2/diacritics',[
], function () {
var diacritics = {
'\u24B6': 'A',
'\uFF21': 'A',
'\u00C0': 'A',
'\u00C1': 'A',
'\u00C2': 'A',
'\u1EA6': 'A',
'\u1EA4': 'A',
'\u1EAA': 'A',
'\u1EA8': 'A',
'\u00C3': 'A',
'\u0100': 'A',
'\u0102': 'A',
'\u1EB0': 'A',
'\u1EAE': 'A',
'\u1EB4': 'A',
'\u1EB2': 'A',
'\u0226': 'A',
'\u01E0': 'A',
'\u00C4': 'A',
'\u01DE': 'A',
'\u1EA2': 'A',
'\u00C5': 'A',
'\u01FA': 'A',
'\u01CD': 'A',
'\u0200': 'A',
'\u0202': 'A',
'\u1EA0': 'A',
'\u1EAC': 'A',
'\u1EB6': 'A',
'\u1E00': 'A',
'\u0104': 'A',
'\u023A': 'A',
'\u2C6F': 'A',
'\uA732': 'AA',
'\u00C6': 'AE',
'\u01FC': 'AE',
'\u01E2': 'AE',
'\uA734': 'AO',
'\uA736': 'AU',
'\uA738': 'AV',
'\uA73A': 'AV',
'\uA73C': 'AY',
'\u24B7': 'B',
'\uFF22': 'B',
'\u1E02': 'B',
'\u1E04': 'B',
'\u1E06': 'B',
'\u0243': 'B',
'\u0182': 'B',
'\u0181': 'B',
'\u24B8': 'C',
'\uFF23': 'C',
'\u0106': 'C',
'\u0108': 'C',
'\u010A': 'C',
'\u010C': 'C',
'\u00C7': 'C',
'\u1E08': 'C',
'\u0187': 'C',
'\u023B': 'C',
'\uA73E': 'C',
'\u24B9': 'D',
'\uFF24': 'D',
'\u1E0A': 'D',
'\u010E': 'D',
'\u1E0C': 'D',
'\u1E10': 'D',
'\u1E12': 'D',
'\u1E0E': 'D',
'\u0110': 'D',
'\u018B': 'D',
'\u018A': 'D',
'\u0189': 'D',
'\uA779': 'D',
'\u01F1': 'DZ',
'\u01C4': 'DZ',
'\u01F2': 'Dz',
'\u01C5': 'Dz',
'\u24BA': 'E',
'\uFF25': 'E',
'\u00C8': 'E',
'\u00C9': 'E',
'\u00CA': 'E',
'\u1EC0': 'E',
'\u1EBE': 'E',
'\u1EC4': 'E',
'\u1EC2': 'E',
'\u1EBC': 'E',
'\u0112': 'E',
'\u1E14': 'E',
'\u1E16': 'E',
'\u0114': 'E',
'\u0116': 'E',
'\u00CB': 'E',
'\u1EBA': 'E',
'\u011A': 'E',
'\u0204': 'E',
'\u0206': 'E',
'\u1EB8': 'E',
'\u1EC6': 'E',
'\u0228': 'E',
'\u1E1C': 'E',
'\u0118': 'E',
'\u1E18': 'E',
'\u1E1A': 'E',
'\u0190': 'E',
'\u018E': 'E',
'\u24BB': 'F',
'\uFF26': 'F',
'\u1E1E': 'F',
'\u0191': 'F',
'\uA77B': 'F',
'\u24BC': 'G',
'\uFF27': 'G',
'\u01F4': 'G',
'\u011C': 'G',
'\u1E20': 'G',
'\u011E': 'G',
'\u0120': 'G',
'\u01E6': 'G',
'\u0122': 'G',
'\u01E4': 'G',
'\u0193': 'G',
'\uA7A0': 'G',
'\uA77D': 'G',
'\uA77E': 'G',
'\u24BD': 'H',
'\uFF28': 'H',
'\u0124': 'H',
'\u1E22': 'H',
'\u1E26': 'H',
'\u021E': 'H',
'\u1E24': 'H',
'\u1E28': 'H',
'\u1E2A': 'H',
'\u0126': 'H',
'\u2C67': 'H',
'\u2C75': 'H',
'\uA78D': 'H',
'\u24BE': 'I',
'\uFF29': 'I',
'\u00CC': 'I',
'\u00CD': 'I',
'\u00CE': 'I',
'\u0128': 'I',
'\u012A': 'I',
'\u012C': 'I',
'\u0130': 'I',
'\u00CF': 'I',
'\u1E2E': 'I',
'\u1EC8': 'I',
'\u01CF': 'I',
'\u0208': 'I',
'\u020A': 'I',
'\u1ECA': 'I',
'\u012E': 'I',
'\u1E2C': 'I',
'\u0197': 'I',
'\u24BF': 'J',
'\uFF2A': 'J',
'\u0134': 'J',
'\u0248': 'J',
'\u24C0': 'K',
'\uFF2B': 'K',
'\u1E30': 'K',
'\u01E8': 'K',
'\u1E32': 'K',
'\u0136': 'K',
'\u1E34': 'K',
'\u0198': 'K',
'\u2C69': 'K',
'\uA740': 'K',
'\uA742': 'K',
'\uA744': 'K',
'\uA7A2': 'K',
'\u24C1': 'L',
'\uFF2C': 'L',
'\u013F': 'L',
'\u0139': 'L',
'\u013D': 'L',
'\u1E36': 'L',
'\u1E38': 'L',
'\u013B': 'L',
'\u1E3C': 'L',
'\u1E3A': 'L',
'\u0141': 'L',
'\u023D': 'L',
'\u2C62': 'L',
'\u2C60': 'L',
'\uA748': 'L',
'\uA746': 'L',
'\uA780': 'L',
'\u01C7': 'LJ',
'\u01C8': 'Lj',
'\u24C2': 'M',
'\uFF2D': 'M',
'\u1E3E': 'M',
'\u1E40': 'M',
'\u1E42': 'M',
'\u2C6E': 'M',
'\u019C': 'M',
'\u24C3': 'N',
'\uFF2E': 'N',
'\u01F8': 'N',
'\u0143': 'N',
'\u00D1': 'N',
'\u1E44': 'N',
'\u0147': 'N',
'\u1E46': 'N',
'\u0145': 'N',
'\u1E4A': 'N',
'\u1E48': 'N',
'\u0220': 'N',
'\u019D': 'N',
'\uA790': 'N',
'\uA7A4': 'N',
'\u01CA': 'NJ',
'\u01CB': 'Nj',
'\u24C4': 'O',
'\uFF2F': 'O',
'\u00D2': 'O',
'\u00D3': 'O',
'\u00D4': 'O',
'\u1ED2': 'O',
'\u1ED0': 'O',
'\u1ED6': 'O',
'\u1ED4': 'O',
'\u00D5': 'O',
'\u1E4C': 'O',
'\u022C': 'O',
'\u1E4E': 'O',
'\u014C': 'O',
'\u1E50': 'O',
'\u1E52': 'O',
'\u014E': 'O',
'\u022E': 'O',
'\u0230': 'O',
'\u00D6': 'O',
'\u022A': 'O',
'\u1ECE': 'O',
'\u0150': 'O',
'\u01D1': 'O',
'\u020C': 'O',
'\u020E': 'O',
'\u01A0': 'O',
'\u1EDC': 'O',
'\u1EDA': 'O',
'\u1EE0': 'O',
'\u1EDE': 'O',
'\u1EE2': 'O',
'\u1ECC': 'O',
'\u1ED8': 'O',
'\u01EA': 'O',
'\u01EC': 'O',
'\u00D8': 'O',
'\u01FE': 'O',
'\u0186': 'O',
'\u019F': 'O',
'\uA74A': 'O',
'\uA74C': 'O',
'\u01A2': 'OI',
'\uA74E': 'OO',
'\u0222': 'OU',
'\u24C5': 'P',
'\uFF30': 'P',
'\u1E54': 'P',
'\u1E56': 'P',
'\u01A4': 'P',
'\u2C63': 'P',
'\uA750': 'P',
'\uA752': 'P',
'\uA754': 'P',
'\u24C6': 'Q',
'\uFF31': 'Q',
'\uA756': 'Q',
'\uA758': 'Q',
'\u024A': 'Q',
'\u24C7': 'R',
'\uFF32': 'R',
'\u0154': 'R',
'\u1E58': 'R',
'\u0158': 'R',
'\u0210': 'R',
'\u0212': 'R',
'\u1E5A': 'R',
'\u1E5C': 'R',
'\u0156': 'R',
'\u1E5E': 'R',
'\u024C': 'R',
'\u2C64': 'R',
'\uA75A': 'R',
'\uA7A6': 'R',
'\uA782': 'R',
'\u24C8': 'S',
'\uFF33': 'S',
'\u1E9E': 'S',
'\u015A': 'S',
'\u1E64': 'S',
'\u015C': 'S',
'\u1E60': 'S',
'\u0160': 'S',
'\u1E66': 'S',
'\u1E62': 'S',
'\u1E68': 'S',
'\u0218': 'S',
'\u015E': 'S',
'\u2C7E': 'S',
'\uA7A8': 'S',
'\uA784': 'S',
'\u24C9': 'T',
'\uFF34': 'T',
'\u1E6A': 'T',
'\u0164': 'T',
'\u1E6C': 'T',
'\u021A': 'T',
'\u0162': 'T',
'\u1E70': 'T',
'\u1E6E': 'T',
'\u0166': 'T',
'\u01AC': 'T',
'\u01AE': 'T',
'\u023E': 'T',
'\uA786': 'T',
'\uA728': 'TZ',
'\u24CA': 'U',
'\uFF35': 'U',
'\u00D9': 'U',
'\u00DA': 'U',
'\u00DB': 'U',
'\u0168': 'U',
'\u1E78': 'U',
'\u016A': 'U',
'\u1E7A': 'U',
'\u016C': 'U',
'\u00DC': 'U',
'\u01DB': 'U',
'\u01D7': 'U',
'\u01D5': 'U',
'\u01D9': 'U',
'\u1EE6': 'U',
'\u016E': 'U',
'\u0170': 'U',
'\u01D3': 'U',
'\u0214': 'U',
'\u0216': 'U',
'\u01AF': 'U',
'\u1EEA': 'U',
'\u1EE8': 'U',
'\u1EEE': 'U',
'\u1EEC': 'U',
'\u1EF0': 'U',
'\u1EE4': 'U',
'\u1E72': 'U',
'\u0172': 'U',
'\u1E76': 'U',
'\u1E74': 'U',
'\u0244': 'U',
'\u24CB': 'V',
'\uFF36': 'V',
'\u1E7C': 'V',
'\u1E7E': 'V',
'\u01B2': 'V',
'\uA75E': 'V',
'\u0245': 'V',
'\uA760': 'VY',
'\u24CC': 'W',
'\uFF37': 'W',
'\u1E80': 'W',
'\u1E82': 'W',
'\u0174': 'W',
'\u1E86': 'W',
'\u1E84': 'W',
'\u1E88': 'W',
'\u2C72': 'W',
'\u24CD': 'X',
'\uFF38': 'X',
'\u1E8A': 'X',
'\u1E8C': 'X',
'\u24CE': 'Y',
'\uFF39': 'Y',
'\u1EF2': 'Y',
'\u00DD': 'Y',
'\u0176': 'Y',
'\u1EF8': 'Y',
'\u0232': 'Y',
'\u1E8E': 'Y',
'\u0178': 'Y',
'\u1EF6': 'Y',
'\u1EF4': 'Y',
'\u01B3': 'Y',
'\u024E': 'Y',
'\u1EFE': 'Y',
'\u24CF': 'Z',
'\uFF3A': 'Z',
'\u0179': 'Z',
'\u1E90': 'Z',
'\u017B': 'Z',
'\u017D': 'Z',
'\u1E92': 'Z',
'\u1E94': 'Z',
'\u01B5': 'Z',
'\u0224': 'Z',
'\u2C7F': 'Z',
'\u2C6B': 'Z',
'\uA762': 'Z',
'\u24D0': 'a',
'\uFF41': 'a',
'\u1E9A': 'a',
'\u00E0': 'a',
'\u00E1': 'a',
'\u00E2': 'a',
'\u1EA7': 'a',
'\u1EA5': 'a',
'\u1EAB': 'a',
'\u1EA9': 'a',
'\u00E3': 'a',
'\u0101': 'a',
'\u0103': 'a',
'\u1EB1': 'a',
'\u1EAF': 'a',
'\u1EB5': 'a',
'\u1EB3': 'a',
'\u0227': 'a',
'\u01E1': 'a',
'\u00E4': 'a',
'\u01DF': 'a',
'\u1EA3': 'a',
'\u00E5': 'a',
'\u01FB': 'a',
'\u01CE': 'a',
'\u0201': 'a',
'\u0203': 'a',
'\u1EA1': 'a',
'\u1EAD': 'a',
'\u1EB7': 'a',
'\u1E01': 'a',
'\u0105': 'a',
'\u2C65': 'a',
'\u0250': 'a',
'\uA733': 'aa',
'\u00E6': 'ae',
'\u01FD': 'ae',
'\u01E3': 'ae',
'\uA735': 'ao',
'\uA737': 'au',
'\uA739': 'av',
'\uA73B': 'av',
'\uA73D': 'ay',
'\u24D1': 'b',
'\uFF42': 'b',
'\u1E03': 'b',
'\u1E05': 'b',
'\u1E07': 'b',
'\u0180': 'b',
'\u0183': 'b',
'\u0253': 'b',
'\u24D2': 'c',
'\uFF43': 'c',
'\u0107': 'c',
'\u0109': 'c',
'\u010B': 'c',
'\u010D': 'c',
'\u00E7': 'c',
'\u1E09': 'c',
'\u0188': 'c',
'\u023C': 'c',
'\uA73F': 'c',
'\u2184': 'c',
'\u24D3': 'd',
'\uFF44': 'd',
'\u1E0B': 'd',
'\u010F': 'd',
'\u1E0D': 'd',
'\u1E11': 'd',
'\u1E13': 'd',
'\u1E0F': 'd',
'\u0111': 'd',
'\u018C': 'd',
'\u0256': 'd',
'\u0257': 'd',
'\uA77A': 'd',
'\u01F3': 'dz',
'\u01C6': 'dz',
'\u24D4': 'e',
'\uFF45': 'e',
'\u00E8': 'e',
'\u00E9': 'e',
'\u00EA': 'e',
'\u1EC1': 'e',
'\u1EBF': 'e',
'\u1EC5': 'e',
'\u1EC3': 'e',
'\u1EBD': 'e',
'\u0113': 'e',
'\u1E15': 'e',
'\u1E17': 'e',
'\u0115': 'e',
'\u0117': 'e',
'\u00EB': 'e',
'\u1EBB': 'e',
'\u011B': 'e',
'\u0205': 'e',
'\u0207': 'e',
'\u1EB9': 'e',
'\u1EC7': 'e',
'\u0229': 'e',
'\u1E1D': 'e',
'\u0119': 'e',
'\u1E19': 'e',
'\u1E1B': 'e',
'\u0247': 'e',
'\u025B': 'e',
'\u01DD': 'e',
'\u24D5': 'f',
'\uFF46': 'f',
'\u1E1F': 'f',
'\u0192': 'f',
'\uA77C': 'f',
'\u24D6': 'g',
'\uFF47': 'g',
'\u01F5': 'g',
'\u011D': 'g',
'\u1E21': 'g',
'\u011F': 'g',
'\u0121': 'g',
'\u01E7': 'g',
'\u0123': 'g',
'\u01E5': 'g',
'\u0260': 'g',
'\uA7A1': 'g',
'\u1D79': 'g',
'\uA77F': 'g',
'\u24D7': 'h',
'\uFF48': 'h',
'\u0125': 'h',
'\u1E23': 'h',
'\u1E27': 'h',
'\u021F': 'h',
'\u1E25': 'h',
'\u1E29': 'h',
'\u1E2B': 'h',
'\u1E96': 'h',
'\u0127': 'h',
'\u2C68': 'h',
'\u2C76': 'h',
'\u0265': 'h',
'\u0195': 'hv',
'\u24D8': 'i',
'\uFF49': 'i',
'\u00EC': 'i',
'\u00ED': 'i',
'\u00EE': 'i',
'\u0129': 'i',
'\u012B': 'i',
'\u012D': 'i',
'\u00EF': 'i',
'\u1E2F': 'i',
'\u1EC9': 'i',
'\u01D0': 'i',
'\u0209': 'i',
'\u020B': 'i',
'\u1ECB': 'i',
'\u012F': 'i',
'\u1E2D': 'i',
'\u0268': 'i',
'\u0131': 'i',
'\u24D9': 'j',
'\uFF4A': 'j',
'\u0135': 'j',
'\u01F0': 'j',
'\u0249': 'j',
'\u24DA': 'k',
'\uFF4B': 'k',
'\u1E31': 'k',
'\u01E9': 'k',
'\u1E33': 'k',
'\u0137': 'k',
'\u1E35': 'k',
'\u0199': 'k',
'\u2C6A': 'k',
'\uA741': 'k',
'\uA743': 'k',
'\uA745': 'k',
'\uA7A3': 'k',
'\u24DB': 'l',
'\uFF4C': 'l',
'\u0140': 'l',
'\u013A': 'l',
'\u013E': 'l',
'\u1E37': 'l',
'\u1E39': 'l',
'\u013C': 'l',
'\u1E3D': 'l',
'\u1E3B': 'l',
'\u017F': 'l',
'\u0142': 'l',
'\u019A': 'l',
'\u026B': 'l',
'\u2C61': 'l',
'\uA749': 'l',
'\uA781': 'l',
'\uA747': 'l',
'\u01C9': 'lj',
'\u24DC': 'm',
'\uFF4D': 'm',
'\u1E3F': 'm',
'\u1E41': 'm',
'\u1E43': 'm',
'\u0271': 'm',
'\u026F': 'm',
'\u24DD': 'n',
'\uFF4E': 'n',
'\u01F9': 'n',
'\u0144': 'n',
'\u00F1': 'n',
'\u1E45': 'n',
'\u0148': 'n',
'\u1E47': 'n',
'\u0146': 'n',
'\u1E4B': 'n',
'\u1E49': 'n',
'\u019E': 'n',
'\u0272': 'n',
'\u0149': 'n',
'\uA791': 'n',
'\uA7A5': 'n',
'\u01CC': 'nj',
'\u24DE': 'o',
'\uFF4F': 'o',
'\u00F2': 'o',
'\u00F3': 'o',
'\u00F4': 'o',
'\u1ED3': 'o',
'\u1ED1': 'o',
'\u1ED7': 'o',
'\u1ED5': 'o',
'\u00F5': 'o',
'\u1E4D': 'o',
'\u022D': 'o',
'\u1E4F': 'o',
'\u014D': 'o',
'\u1E51': 'o',
'\u1E53': 'o',
'\u014F': 'o',
'\u022F': 'o',
'\u0231': 'o',
'\u00F6': 'o',
'\u022B': 'o',
'\u1ECF': 'o',
'\u0151': 'o',
'\u01D2': 'o',
'\u020D': 'o',
'\u020F': 'o',
'\u01A1': 'o',
'\u1EDD': 'o',
'\u1EDB': 'o',
'\u1EE1': 'o',
'\u1EDF': 'o',
'\u1EE3': 'o',
'\u1ECD': 'o',
'\u1ED9': 'o',
'\u01EB': 'o',
'\u01ED': 'o',
'\u00F8': 'o',
'\u01FF': 'o',
'\u0254': 'o',
'\uA74B': 'o',
'\uA74D': 'o',
'\u0275': 'o',
'\u01A3': 'oi',
'\u0223': 'ou',
'\uA74F': 'oo',
'\u24DF': 'p',
'\uFF50': 'p',
'\u1E55': 'p',
'\u1E57': 'p',
'\u01A5': 'p',
'\u1D7D': 'p',
'\uA751': 'p',
'\uA753': 'p',
'\uA755': 'p',
'\u24E0': 'q',
'\uFF51': 'q',
'\u024B': 'q',
'\uA757': 'q',
'\uA759': 'q',
'\u24E1': 'r',
'\uFF52': 'r',
'\u0155': 'r',
'\u1E59': 'r',
'\u0159': 'r',
'\u0211': 'r',
'\u0213': 'r',
'\u1E5B': 'r',
'\u1E5D': 'r',
'\u0157': 'r',
'\u1E5F': 'r',
'\u024D': 'r',
'\u027D': 'r',
'\uA75B': 'r',
'\uA7A7': 'r',
'\uA783': 'r',
'\u24E2': 's',
'\uFF53': 's',
'\u00DF': 's',
'\u015B': 's',
'\u1E65': 's',
'\u015D': 's',
'\u1E61': 's',
'\u0161': 's',
'\u1E67': 's',
'\u1E63': 's',
'\u1E69': 's',
'\u0219': 's',
'\u015F': 's',
'\u023F': 's',
'\uA7A9': 's',
'\uA785': 's',
'\u1E9B': 's',
'\u24E3': 't',
'\uFF54': 't',
'\u1E6B': 't',
'\u1E97': 't',
'\u0165': 't',
'\u1E6D': 't',
'\u021B': 't',
'\u0163': 't',
'\u1E71': 't',
'\u1E6F': 't',
'\u0167': 't',
'\u01AD': 't',
'\u0288': 't',
'\u2C66': 't',
'\uA787': 't',
'\uA729': 'tz',
'\u24E4': 'u',
'\uFF55': 'u',
'\u00F9': 'u',
'\u00FA': 'u',
'\u00FB': 'u',
'\u0169': 'u',
'\u1E79': 'u',
'\u016B': 'u',
'\u1E7B': 'u',
'\u016D': 'u',
'\u00FC': 'u',
'\u01DC': 'u',
'\u01D8': 'u',
'\u01D6': 'u',
'\u01DA': 'u',
'\u1EE7': 'u',
'\u016F': 'u',
'\u0171': 'u',
'\u01D4': 'u',
'\u0215': 'u',
'\u0217': 'u',
'\u01B0': 'u',
'\u1EEB': 'u',
'\u1EE9': 'u',
'\u1EEF': 'u',
'\u1EED': 'u',
'\u1EF1': 'u',
'\u1EE5': 'u',
'\u1E73': 'u',
'\u0173': 'u',
'\u1E77': 'u',
'\u1E75': 'u',
'\u0289': 'u',
'\u24E5': 'v',
'\uFF56': 'v',
'\u1E7D': 'v',
'\u1E7F': 'v',
'\u028B': 'v',
'\uA75F': 'v',
'\u028C': 'v',
'\uA761': 'vy',
'\u24E6': 'w',
'\uFF57': 'w',
'\u1E81': 'w',
'\u1E83': 'w',
'\u0175': 'w',
'\u1E87': 'w',
'\u1E85': 'w',
'\u1E98': 'w',
'\u1E89': 'w',
'\u2C73': 'w',
'\u24E7': 'x',
'\uFF58': 'x',
'\u1E8B': 'x',
'\u1E8D': 'x',
'\u24E8': 'y',
'\uFF59': 'y',
'\u1EF3': 'y',
'\u00FD': 'y',
'\u0177': 'y',
'\u1EF9': 'y',
'\u0233': 'y',
'\u1E8F': 'y',
'\u00FF': 'y',
'\u1EF7': 'y',
'\u1E99': 'y',
'\u1EF5': 'y',
'\u01B4': 'y',
'\u024F': 'y',
'\u1EFF': 'y',
'\u24E9': 'z',
'\uFF5A': 'z',
'\u017A': 'z',
'\u1E91': 'z',
'\u017C': 'z',
'\u017E': 'z',
'\u1E93': 'z',
'\u1E95': 'z',
'\u01B6': 'z',
'\u0225': 'z',
'\u0240': 'z',
'\u2C6C': 'z',
'\uA763': 'z',
'\u0386': '\u0391',
'\u0388': '\u0395',
'\u0389': '\u0397',
'\u038A': '\u0399',
'\u03AA': '\u0399',
'\u038C': '\u039F',
'\u038E': '\u03A5',
'\u03AB': '\u03A5',
'\u038F': '\u03A9',
'\u03AC': '\u03B1',
'\u03AD': '\u03B5',
'\u03AE': '\u03B7',
'\u03AF': '\u03B9',
'\u03CA': '\u03B9',
'\u0390': '\u03B9',
'\u03CC': '\u03BF',
'\u03CD': '\u03C5',
'\u03CB': '\u03C5',
'\u03B0': '\u03C5',
'\u03C9': '\u03C9',
'\u03C2': '\u03C3'
};
return diacritics;
});
S2.define('select2/data/base',[
'../utils'
], function (Utils) {
function BaseAdapter ($element, options) {
BaseAdapter.__super__.constructor.call(this);
}
Utils.Extend(BaseAdapter, Utils.Observable);
BaseAdapter.prototype.current = function (callback) {
throw new Error('The `current` method must be defined in child classes.');
};
BaseAdapter.prototype.query = function (params, callback) {
throw new Error('The `query` method must be defined in child classes.');
};
BaseAdapter.prototype.bind = function (container, $container) {
};
BaseAdapter.prototype.destroy = function () {
};
BaseAdapter.prototype.generateResultId = function (container, data) {
var id = container.id + '-result-';
id += Utils.generateChars(4);
if (data.id != null) {
id += '-' + data.id.toString();
} else {
id += '-' + Utils.generateChars(4);
}
return id;
};
return BaseAdapter;
});
S2.define('select2/data/select',[
'./base',
'../utils',
'jquery'
], function (BaseAdapter, Utils, $) {
function SelectAdapter ($element, options) {
this.$element = $element;
this.options = options;
SelectAdapter.__super__.constructor.call(this);
}
Utils.Extend(SelectAdapter, BaseAdapter);
SelectAdapter.prototype.current = function (callback) {
var data = [];
var self = this;
this.$element.find(':selected').each(function () {
var $option = $(this);
var option = self.item($option);
data.push(option);
});
callback(data);
};
SelectAdapter.prototype.select = function (data) {
var self = this;
data.selected = true;
if ($(data.element).is('option')) {
data.element.selected = true;
this.$element.trigger('change');
return;
}
if (this.$element.prop('multiple')) {
this.current(function (currentData) {
var val = [];
data = [data];
data.push.apply(data, currentData);
for (var d = 0; d < data.length; d++) {
var id = data[d].id;
if ($.inArray(id, val) === -1) {
val.push(id);
}
}
self.$element.val(val);
self.$element.trigger('change');
});
} else {
var val = data.id;
this.$element.val(val);
this.$element.trigger('change');
}
};
SelectAdapter.prototype.unselect = function (data) {
var self = this;
if (!this.$element.prop('multiple')) {
return;
}
data.selected = false;
if ($(data.element).is('option')) {
data.element.selected = false;
this.$element.trigger('change');
return;
}
this.current(function (currentData) {
var val = [];
for (var d = 0; d < currentData.length; d++) {
var id = currentData[d].id;
if (id !== data.id && $.inArray(id, val) === -1) {
val.push(id);
}
}
self.$element.val(val);
self.$element.trigger('change');
});
};
SelectAdapter.prototype.bind = function (container, $container) {
var self = this;
this.container = container;
container.on('select', function (params) {
self.select(params.data);
});
container.on('unselect', function (params) {
self.unselect(params.data);
});
};
SelectAdapter.prototype.destroy = function () {
this.$element.find('*').each(function () {
Utils.RemoveData(this);
});
};
SelectAdapter.prototype.query = function (params, callback) {
var data = [];
var self = this;
var $options = this.$element.children();
$options.each(function () {
var $option = $(this);
if (!$option.is('option') && !$option.is('optgroup')) {
return;
}
var option = self.item($option);
var matches = self.matches(params, option);
if (matches !== null) {
data.push(matches);
}
});
callback({
results: data
});
};
SelectAdapter.prototype.addOptions = function ($options) {
Utils.appendMany(this.$element, $options);
};
SelectAdapter.prototype.option = function (data) {
var option;
if (data.children) {
option = document.createElement('optgroup');
option.label = data.text;
} else {
option = document.createElement('option');
if (option.textContent !== undefined) {
option.textContent = data.text;
} else {
option.innerText = data.text;
}
}
if (data.id !== undefined) {
option.value = data.id;
}
if (data.disabled) {
option.disabled = true;
}
if (data.selected) {
option.selected = true;
}
if (data.title) {
option.title = data.title;
}
var $option = $(option);
var normalizedData = this._normalizeItem(data);
normalizedData.element = option;
Utils.StoreData(option, 'data', normalizedData);
return $option;
};
SelectAdapter.prototype.item = function ($option) {
var data = {};
data = Utils.GetData($option[0], 'data');
if (data != null) {
return data;
}
if ($option.is('option')) {
data = {
id: $option.val(),
text: $option.text(),
disabled: $option.prop('disabled'),
selected: $option.prop('selected'),
title: $option.prop('title')
};
} else if ($option.is('optgroup')) {
data = {
text: $option.prop('label'),
children: [],
title: $option.prop('title')
};
var $children = $option.children('option');
var children = [];
for (var c = 0; c < $children.length; c++) {
var $child = $($children[c]);
var child = this.item($child);
children.push(child);
}
data.children = children;
}
data = this._normalizeItem(data);
data.element = $option[0];
Utils.StoreData($option[0], 'data', data);
return data;
};
SelectAdapter.prototype._normalizeItem = function (item) {
if (item !== Object(item)) {
item = {
id: item,
text: item
};
}
item = $.extend({}, {
text: ''
}, item);
var defaults = {
selected: false,
disabled: false
};
if (item.id != null) {
item.id = item.id.toString();
}
if (item.text != null) {
item.text = item.text.toString();
}
if (item._resultId == null && item.id && this.container != null) {
item._resultId = this.generateResultId(this.container, item);
}
return $.extend({}, defaults, item);
};
SelectAdapter.prototype.matches = function (params, data) {
var matcher = this.options.get('matcher');
return matcher(params, data);
};
return SelectAdapter;
});
S2.define('select2/data/array',[
'./select',
'../utils',
'jquery'
], function (SelectAdapter, Utils, $) {
function ArrayAdapter ($element, options) {
var data = options.get('data') || [];
ArrayAdapter.__super__.constructor.call(this, $element, options);
this.addOptions(this.convertToOptions(data));
}
Utils.Extend(ArrayAdapter, SelectAdapter);
ArrayAdapter.prototype.select = function (data) {
var $option = this.$element.find('option').filter(function (i, elm) {
return elm.value == data.id.toString();
});
if ($option.length === 0) {
$option = this.option(data);
this.addOptions($option);
}
ArrayAdapter.__super__.select.call(this, data);
};
ArrayAdapter.prototype.convertToOptions = function (data) {
var self = this;
var $existing = this.$element.find('option');
var existingIds = $existing.map(function () {
return self.item($(this)).id;
}).get();
var $options = [];
function onlyItem (item) {
return function () {
return $(this).val() == item.id;
};
}
for (var d = 0; d < data.length; d++) {
var item = this._normalizeItem(data[d]);
if ($.inArray(item.id, existingIds) >= 0) {
var $existingOption = $existing.filter(onlyItem(item));
var existingData = this.item($existingOption);
var newData = $.extend(true, {}, item, existingData);
var $newOption = this.option(newData);
$existingOption.replaceWith($newOption);
continue;
}
var $option = this.option(item);
if (item.children) {
var $children = this.convertToOptions(item.children);
Utils.appendMany($option, $children);
}
$options.push($option);
}
return $options;
};
return ArrayAdapter;
});
S2.define('select2/data/ajax',[
'./array',
'../utils',
'jquery'
], function (ArrayAdapter, Utils, $) {
function AjaxAdapter ($element, options) {
this.ajaxOptions = this._applyDefaults(options.get('ajax'));
if (this.ajaxOptions.processResults != null) {
this.processResults = this.ajaxOptions.processResults;
}
AjaxAdapter.__super__.constructor.call(this, $element, options);
}
Utils.Extend(AjaxAdapter, ArrayAdapter);
AjaxAdapter.prototype._applyDefaults = function (options) {
var defaults = {
data: function (params) {
return $.extend({}, params, {
q: params.term
});
},
transport: function (params, success, failure) {
var $request = $.ajax(params);
$request.then(success);
$request.fail(failure);
return $request;
}
};
return $.extend({}, defaults, options, true);
};
AjaxAdapter.prototype.processResults = function (results) {
return results;
};
AjaxAdapter.prototype.query = function (params, callback) {
var matches = [];
var self = this;
if (this._request != null) {
if ($.isFunction(this._request.abort)) {
this._request.abort();
}
this._request = null;
}
var options = $.extend({
type: 'GET'
}, this.ajaxOptions);
if (typeof options.url === 'function') {
options.url = options.url.call(this.$element, params);
}
if (typeof options.data === 'function') {
options.data = options.data.call(this.$element, params);
}
function request () {
var $request = options.transport(options, function (data) {
var results = self.processResults(data, params);
if (self.options.get('debug') && window.console && console.error) {
if (!results || !results.results || !$.isArray(results.results)) {
console.error(
'Select2: The AJAX results did not return an array in the ' +
'`results` key of the response.'
);
}
}
callback(results);
}, function () {
if ('status' in $request &&
($request.status === 0 || $request.status === '0')) {
return;
}
self.trigger('results:message', {
message: 'errorLoading'
});
});
self._request = $request;
}
if (this.ajaxOptions.delay && params.term != null) {
if (this._queryTimeout) {
window.clearTimeout(this._queryTimeout);
}
this._queryTimeout = window.setTimeout(request, this.ajaxOptions.delay);
} else {
request();
}
};
return AjaxAdapter;
});
S2.define('select2/data/tags',[
'jquery'
], function ($) {
function Tags (decorated, $element, options) {
var tags = options.get('tags');
var createTag = options.get('createTag');
if (createTag !== undefined) {
this.createTag = createTag;
}
var insertTag = options.get('insertTag');
if (insertTag !== undefined) {
this.insertTag = insertTag;
}
decorated.call(this, $element, options);
if ($.isArray(tags)) {
for (var t = 0; t < tags.length; t++) {
var tag = tags[t];
var item = this._normalizeItem(tag);
var $option = this.option(item);
this.$element.append($option);
}
}
}
Tags.prototype.query = function (decorated, params, callback) {
var self = this;
this._removeOldTags();
if (params.term == null || params.page != null) {
decorated.call(this, params, callback);
return;
}
function wrapper (obj, child) {
var data = obj.results;
for (var i = 0; i < data.length; i++) {
var option = data[i];
var checkChildren = (
option.children != null &&
!wrapper({
results: option.children
}, true)
);
var optionText = (option.text || '').toUpperCase();
var paramsTerm = (params.term || '').toUpperCase();
var checkText = optionText === paramsTerm;
if (checkText || checkChildren) {
if (child) {
return false;
}
obj.data = data;
callback(obj);
return;
}
}
if (child) {
return true;
}
var tag = self.createTag(params);
if (tag != null) {
var $option = self.option(tag);
$option.attr('data-select2-tag', true);
self.addOptions([$option]);
self.insertTag(data, tag);
}
obj.results = data;
callback(obj);
}
decorated.call(this, params, wrapper);
};
Tags.prototype.createTag = function (decorated, params) {
var term = $.trim(params.term);
if (term === '') {
return null;
}
return {
id: term,
text: term
};
};
Tags.prototype.insertTag = function (_, data, tag) {
data.unshift(tag);
};
Tags.prototype._removeOldTags = function (_) {
var tag = this._lastTag;
var $options = this.$element.find('option[data-select2-tag]');
$options.each(function () {
if (this.selected) {
return;
}
$(this).remove();
});
};
return Tags;
});
S2.define('select2/data/tokenizer',[
'jquery'
], function ($) {
function Tokenizer (decorated, $element, options) {
var tokenizer = options.get('tokenizer');
if (tokenizer !== undefined) {
this.tokenizer = tokenizer;
}
decorated.call(this, $element, options);
}
Tokenizer.prototype.bind = function (decorated, container, $container) {
decorated.call(this, container, $container);
this.$search =  container.dropdown.$search || container.selection.$search ||
$container.find('.select2-search__field');
};
Tokenizer.prototype.query = function (decorated, params, callback) {
var self = this;
function createAndSelect (data) {
var item = self._normalizeItem(data);
var $existingOptions = self.$element.find('option').filter(function () {
return $(this).val() === item.id;
});
if (!$existingOptions.length) {
var $option = self.option(item);
$option.attr('data-select2-tag', true);
self._removeOldTags();
self.addOptions([$option]);
}
select(item);
}
function select (data) {
self.trigger('select', {
data: data
});
}
params.term = params.term || '';
var tokenData = this.tokenizer(params, this.options, createAndSelect);
if (tokenData.term !== params.term) {
if (this.$search.length) {
this.$search.val(tokenData.term);
this.$search.focus();
}
params.term = tokenData.term;
}
decorated.call(this, params, callback);
};
Tokenizer.prototype.tokenizer = function (_, params, options, callback) {
var separators = options.get('tokenSeparators') || [];
var term = params.term;
var i = 0;
var createTag = this.createTag || function (params) {
return {
id: params.term,
text: params.term
};
};
while (i < term.length) {
var termChar = term[i];
if ($.inArray(termChar, separators) === -1) {
i++;
continue;
}
var part = term.substr(0, i);
var partParams = $.extend({}, params, {
term: part
});
var data = createTag(partParams);
if (data == null) {
i++;
continue;
}
callback(data);
term = term.substr(i + 1) || '';
i = 0;
}
return {
term: term
};
};
return Tokenizer;
});
S2.define('select2/data/minimumInputLength',[
], function () {
function MinimumInputLength (decorated, $e, options) {
this.minimumInputLength = options.get('minimumInputLength');
decorated.call(this, $e, options);
}
MinimumInputLength.prototype.query = function (decorated, params, callback) {
params.term = params.term || '';
if (params.term.length < this.minimumInputLength) {
this.trigger('results:message', {
message: 'inputTooShort',
args: {
minimum: this.minimumInputLength,
input: params.term,
params: params
}
});
return;
}
decorated.call(this, params, callback);
};
return MinimumInputLength;
});
S2.define('select2/data/maximumInputLength',[
], function () {
function MaximumInputLength (decorated, $e, options) {
this.maximumInputLength = options.get('maximumInputLength');
decorated.call(this, $e, options);
}
MaximumInputLength.prototype.query = function (decorated, params, callback) {
params.term = params.term || '';
if (this.maximumInputLength > 0 &&
params.term.length > this.maximumInputLength) {
this.trigger('results:message', {
message: 'inputTooLong',
args: {
maximum: this.maximumInputLength,
input: params.term,
params: params
}
});
return;
}
decorated.call(this, params, callback);
};
return MaximumInputLength;
});
S2.define('select2/data/maximumSelectionLength',[
], function (){
function MaximumSelectionLength (decorated, $e, options) {
this.maximumSelectionLength = options.get('maximumSelectionLength');
decorated.call(this, $e, options);
}
MaximumSelectionLength.prototype.query =
function (decorated, params, callback) {
var self = this;
this.current(function (currentData) {
var count = currentData != null ? currentData.length : 0;
if (self.maximumSelectionLength > 0 &&
count >= self.maximumSelectionLength) {
self.trigger('results:message', {
message: 'maximumSelected',
args: {
maximum: self.maximumSelectionLength
}
});
return;
}
decorated.call(self, params, callback);
});
};
return MaximumSelectionLength;
});
S2.define('select2/dropdown',[
'jquery',
'./utils'
], function ($, Utils) {
function Dropdown ($element, options) {
this.$element = $element;
this.options = options;
Dropdown.__super__.constructor.call(this);
}
Utils.Extend(Dropdown, Utils.Observable);
Dropdown.prototype.render = function () {
var $dropdown = $(
'<span class="select2-dropdown">' +
'<span class="select2-results"></span>' +
'</span>'
);
$dropdown.attr('dir', this.options.get('dir'));
this.$dropdown = $dropdown;
return $dropdown;
};
Dropdown.prototype.bind = function () {
};
Dropdown.prototype.position = function ($dropdown, $container) {
};
Dropdown.prototype.destroy = function () {
this.$dropdown.remove();
};
return Dropdown;
});
S2.define('select2/dropdown/search',[
'jquery',
'../utils'
], function ($, Utils) {
function Search () { }
Search.prototype.render = function (decorated) {
var $rendered = decorated.call(this);
var $search = $(
'<span class="select2-search select2-search--dropdown">' +
'<input class="select2-search__field" type="search" tabindex="-1"' +
' autocomplete="off" autocorrect="off" autocapitalize="none"' +
' spellcheck="false" role="textbox" />' +
'</span>'
);
this.$searchContainer = $search;
this.$search = $search.find('input');
$rendered.prepend($search);
return $rendered;
};
Search.prototype.bind = function (decorated, container, $container) {
var self = this;
decorated.call(this, container, $container);
this.$search.on('keydown', function (evt) {
self.trigger('keypress', evt);
self._keyUpPrevented = evt.isDefaultPrevented();
});
this.$search.on('input', function (evt) {
$(this).off('keyup');
});
this.$search.on('keyup input', function (evt) {
self.handleSearch(evt);
});
container.on('open', function () {
self.$search.attr('tabindex', 0);
self.$search.focus();
window.setTimeout(function () {
self.$search.focus();
}, 0);
});
container.on('close', function () {
self.$search.attr('tabindex', -1);
self.$search.val('');
self.$search.blur();
});
container.on('focus', function () {
if (!container.isOpen()) {
self.$search.focus();
}
});
container.on('results:all', function (params) {
if (params.query.term == null || params.query.term === '') {
var showSearch = self.showSearch(params);
if (showSearch) {
self.$searchContainer.removeClass('select2-search--hide');
} else {
self.$searchContainer.addClass('select2-search--hide');
}
}
});
};
Search.prototype.handleSearch = function (evt) {
if (!this._keyUpPrevented) {
var input = this.$search.val();
this.trigger('query', {
term: input
});
}
this._keyUpPrevented = false;
};
Search.prototype.showSearch = function (_, params) {
return true;
};
return Search;
});
S2.define('select2/dropdown/hidePlaceholder',[
], function () {
function HidePlaceholder (decorated, $element, options, dataAdapter) {
this.placeholder = this.normalizePlaceholder(options.get('placeholder'));
decorated.call(this, $element, options, dataAdapter);
}
HidePlaceholder.prototype.append = function (decorated, data) {
data.results = this.removePlaceholder(data.results);
decorated.call(this, data);
};
HidePlaceholder.prototype.normalizePlaceholder = function (_, placeholder) {
if (typeof placeholder === 'string') {
placeholder = {
id: '',
text: placeholder
};
}
return placeholder;
};
HidePlaceholder.prototype.removePlaceholder = function (_, data) {
var modifiedData = data.slice(0);
for (var d = data.length - 1; d >= 0; d--) {
var item = data[d];
if (this.placeholder.id === item.id) {
modifiedData.splice(d, 1);
}
}
return modifiedData;
};
return HidePlaceholder;
});
S2.define('select2/dropdown/infiniteScroll',[
'jquery'
], function ($) {
function InfiniteScroll (decorated, $element, options, dataAdapter) {
this.lastParams = {};
decorated.call(this, $element, options, dataAdapter);
this.$loadingMore = this.createLoadingMore();
this.loading = false;
}
InfiniteScroll.prototype.append = function (decorated, data) {
this.$loadingMore.remove();
this.loading = false;
decorated.call(this, data);
if (this.showLoadingMore(data)) {
this.$results.append(this.$loadingMore);
}
};
InfiniteScroll.prototype.bind = function (decorated, container, $container) {
var self = this;
decorated.call(this, container, $container);
container.on('query', function (params) {
self.lastParams = params;
self.loading = true;
});
container.on('query:append', function (params) {
self.lastParams = params;
self.loading = true;
});
this.$results.on('scroll', function () {
var isLoadMoreVisible = $.contains(
document.documentElement,
self.$loadingMore[0]
);
if (self.loading || !isLoadMoreVisible) {
return;
}
var currentOffset = self.$results.offset().top +
self.$results.outerHeight(false);
var loadingMoreOffset = self.$loadingMore.offset().top +
self.$loadingMore.outerHeight(false);
if (currentOffset + 50 >= loadingMoreOffset) {
self.loadMore();
}
});
};
InfiniteScroll.prototype.loadMore = function () {
this.loading = true;
var params = $.extend({}, {page: 1}, this.lastParams);
params.page++;
this.trigger('query:append', params);
};
InfiniteScroll.prototype.showLoadingMore = function (_, data) {
return data.pagination && data.pagination.more;
};
InfiniteScroll.prototype.createLoadingMore = function () {
var $option = $(
'<li ' +
'class="select2-results__option select2-results__option--load-more"' +
'role="treeitem" aria-disabled="true"></li>'
);
var message = this.options.get('translations').get('loadingMore');
$option.html(message(this.lastParams));
return $option;
};
return InfiniteScroll;
});
S2.define('select2/dropdown/attachBody',[
'jquery',
'../utils'
], function ($, Utils) {
function AttachBody (decorated, $element, options) {
this.$dropdownParent = options.get('dropdownParent') || $(document.body);
decorated.call(this, $element, options);
}
AttachBody.prototype.bind = function (decorated, container, $container) {
var self = this;
var setupResultsEvents = false;
decorated.call(this, container, $container);
container.on('open', function () {
self._showDropdown();
self._attachPositioningHandler(container);
if (!setupResultsEvents) {
setupResultsEvents = true;
container.on('results:all', function () {
self._positionDropdown();
self._resizeDropdown();
});
container.on('results:append', function () {
self._positionDropdown();
self._resizeDropdown();
});
}
});
container.on('close', function () {
self._hideDropdown();
self._detachPositioningHandler(container);
});
this.$dropdownContainer.on('mousedown', function (evt) {
evt.stopPropagation();
});
};
AttachBody.prototype.destroy = function (decorated) {
decorated.call(this);
this.$dropdownContainer.remove();
};
AttachBody.prototype.position = function (decorated, $dropdown, $container) {
$dropdown.attr('class', $container.attr('class'));
$dropdown.removeClass('select2');
$dropdown.addClass('select2-container--open');
$dropdown.css({
position: 'absolute',
top: -999999
});
this.$container = $container;
};
AttachBody.prototype.render = function (decorated) {
var $container = $('<span></span>');
var $dropdown = decorated.call(this);
$container.append($dropdown);
this.$dropdownContainer = $container;
return $container;
};
AttachBody.prototype._hideDropdown = function (decorated) {
this.$dropdownContainer.detach();
};
AttachBody.prototype._attachPositioningHandler =
function (decorated, container) {
var self = this;
var scrollEvent = 'scroll.select2.' + container.id;
var resizeEvent = 'resize.select2.' + container.id;
var orientationEvent = 'orientationchange.select2.' + container.id;
var $watchers = this.$container.parents().filter(Utils.hasScroll);
$watchers.each(function () {
Utils.StoreData(this, 'select2-scroll-position', {
x: $(this).scrollLeft(),
y: $(this).scrollTop()
});
});
$watchers.on(scrollEvent, function (ev) {
var position = Utils.GetData(this, 'select2-scroll-position');
$(this).scrollTop(position.y);
});
$(window).on(scrollEvent + ' ' + resizeEvent + ' ' + orientationEvent,
function (e) {
self._positionDropdown();
self._resizeDropdown();
});
};
AttachBody.prototype._detachPositioningHandler =
function (decorated, container) {
var scrollEvent = 'scroll.select2.' + container.id;
var resizeEvent = 'resize.select2.' + container.id;
var orientationEvent = 'orientationchange.select2.' + container.id;
var $watchers = this.$container.parents().filter(Utils.hasScroll);
$watchers.off(scrollEvent);
$(window).off(scrollEvent + ' ' + resizeEvent + ' ' + orientationEvent);
};
AttachBody.prototype._positionDropdown = function () {
var $window = $(window);
var isCurrentlyAbove = this.$dropdown.hasClass('select2-dropdown--above');
var isCurrentlyBelow = this.$dropdown.hasClass('select2-dropdown--below');
var newDirection = null;
var offset = this.$container.offset();
offset.bottom = offset.top + this.$container.outerHeight(false);
var container = {
height: this.$container.outerHeight(false)
};
container.top = offset.top;
container.bottom = offset.top + container.height;
var dropdown = {
height: this.$dropdown.outerHeight(false)
};
var viewport = {
top: $window.scrollTop(),
bottom: $window.scrollTop() + $window.height()
};
var enoughRoomAbove = viewport.top < (offset.top - dropdown.height);
var enoughRoomBelow = viewport.bottom > (offset.bottom + dropdown.height);
var css = {
left: offset.left,
top: container.bottom
};
var $offsetParent = this.$dropdownParent;
if ($offsetParent.css('position') === 'static') {
$offsetParent = $offsetParent.offsetParent();
}
var parentOffset = $offsetParent.offset();
css.top -= parentOffset.top;
css.left -= parentOffset.left;
if (!isCurrentlyAbove && !isCurrentlyBelow) {
newDirection = 'below';
}
if (!enoughRoomBelow && enoughRoomAbove && !isCurrentlyAbove) {
newDirection = 'above';
} else if (!enoughRoomAbove && enoughRoomBelow && isCurrentlyAbove) {
newDirection = 'below';
}
if (newDirection == 'above' ||
(isCurrentlyAbove && newDirection !== 'below')) {
css.top = container.top - parentOffset.top - dropdown.height;
}
if (newDirection != null) {
this.$dropdown
.removeClass('select2-dropdown--below select2-dropdown--above')
.addClass('select2-dropdown--' + newDirection);
this.$container
.removeClass('select2-container--below select2-container--above')
.addClass('select2-container--' + newDirection);
}
this.$dropdownContainer.css(css);
};
AttachBody.prototype._resizeDropdown = function () {
var css = {
width: this.$container.outerWidth(false) + 'px'
};
if (this.options.get('dropdownAutoWidth')) {
css.minWidth = css.width;
css.position = 'relative';
css.width = 'auto';
}
this.$dropdown.css(css);
};
AttachBody.prototype._showDropdown = function (decorated) {
this.$dropdownContainer.appendTo(this.$dropdownParent);
this._positionDropdown();
this._resizeDropdown();
};
return AttachBody;
});
S2.define('select2/dropdown/minimumResultsForSearch',[
], function () {
function countResults (data) {
var count = 0;
for (var d = 0; d < data.length; d++) {
var item = data[d];
if (item.children) {
count += countResults(item.children);
} else {
count++;
}
}
return count;
}
function MinimumResultsForSearch (decorated, $element, options, dataAdapter) {
this.minimumResultsForSearch = options.get('minimumResultsForSearch');
if (this.minimumResultsForSearch < 0) {
this.minimumResultsForSearch = Infinity;
}
decorated.call(this, $element, options, dataAdapter);
}
MinimumResultsForSearch.prototype.showSearch = function (decorated, params) {
if (countResults(params.data.results) < this.minimumResultsForSearch) {
return false;
}
return decorated.call(this, params);
};
return MinimumResultsForSearch;
});
S2.define('select2/dropdown/selectOnClose',[
'../utils'
], function (Utils) {
function SelectOnClose () { }
SelectOnClose.prototype.bind = function (decorated, container, $container) {
var self = this;
decorated.call(this, container, $container);
container.on('close', function (params) {
self._handleSelectOnClose(params);
});
};
SelectOnClose.prototype._handleSelectOnClose = function (_, params) {
if (params && params.originalSelect2Event != null) {
var event = params.originalSelect2Event;
if (event._type === 'select' || event._type === 'unselect') {
return;
}
}
var $highlightedResults = this.getHighlightedResults();
if ($highlightedResults.length < 1) {
return;
}
var data = Utils.GetData($highlightedResults[0], 'data');
if (
(data.element != null && data.element.selected) ||
(data.element == null && data.selected)
) {
return;
}
this.trigger('select', {
data: data
});
};
return SelectOnClose;
});
S2.define('select2/dropdown/closeOnSelect',[
], function () {
function CloseOnSelect () { }
CloseOnSelect.prototype.bind = function (decorated, container, $container) {
var self = this;
decorated.call(this, container, $container);
container.on('select', function (evt) {
self._selectTriggered(evt);
});
container.on('unselect', function (evt) {
self._selectTriggered(evt);
});
};
CloseOnSelect.prototype._selectTriggered = function (_, evt) {
var originalEvent = evt.originalEvent;
if (originalEvent && originalEvent.ctrlKey) {
return;
}
this.trigger('close', {
originalEvent: originalEvent,
originalSelect2Event: evt
});
};
return CloseOnSelect;
});
S2.define('select2/i18n/en',[],function () {
return {
errorLoading: function () {
return 'The results could not be loaded.';
},
inputTooLong: function (args) {
var overChars = args.input.length - args.maximum;
var message = 'Please delete ' + overChars + ' character';
if (overChars != 1) {
message += 's';
}
return message;
},
inputTooShort: function (args) {
var remainingChars = args.minimum - args.input.length;
var message = 'Please enter ' + remainingChars + ' or more characters';
return message;
},
loadingMore: function () {
return 'Loading more results';
},
maximumSelected: function (args) {
var message = 'You can only select ' + args.maximum + ' item';
if (args.maximum != 1) {
message += 's';
}
return message;
},
noResults: function () {
return 'No results found';
},
searching: function () {
return 'Searching';
}
};
});
S2.define('select2/defaults',[
'jquery',
'require',
'./results',
'./selection/single',
'./selection/multiple',
'./selection/placeholder',
'./selection/allowClear',
'./selection/search',
'./selection/eventRelay',
'./utils',
'./translation',
'./diacritics',
'./data/select',
'./data/array',
'./data/ajax',
'./data/tags',
'./data/tokenizer',
'./data/minimumInputLength',
'./data/maximumInputLength',
'./data/maximumSelectionLength',
'./dropdown',
'./dropdown/search',
'./dropdown/hidePlaceholder',
'./dropdown/infiniteScroll',
'./dropdown/attachBody',
'./dropdown/minimumResultsForSearch',
'./dropdown/selectOnClose',
'./dropdown/closeOnSelect',
'./i18n/en'
], function ($, require,
ResultsList,
SingleSelection, MultipleSelection, Placeholder, AllowClear,
SelectionSearch, EventRelay,
Utils, Translation, DIACRITICS,
SelectData, ArrayData, AjaxData, Tags, Tokenizer,
MinimumInputLength, MaximumInputLength, MaximumSelectionLength,
Dropdown, DropdownSearch, HidePlaceholder, InfiniteScroll,
AttachBody, MinimumResultsForSearch, SelectOnClose, CloseOnSelect,
EnglishTranslation) {
function Defaults () {
this.reset();
}
Defaults.prototype.apply = function (options) {
options = $.extend(true, {}, this.defaults, options);
if (options.dataAdapter == null) {
if (options.ajax != null) {
options.dataAdapter = AjaxData;
} else if (options.data != null) {
options.dataAdapter = ArrayData;
} else {
options.dataAdapter = SelectData;
}
if (options.minimumInputLength > 0) {
options.dataAdapter = Utils.Decorate(
options.dataAdapter,
MinimumInputLength
);
}
if (options.maximumInputLength > 0) {
options.dataAdapter = Utils.Decorate(
options.dataAdapter,
MaximumInputLength
);
}
if (options.maximumSelectionLength > 0) {
options.dataAdapter = Utils.Decorate(
options.dataAdapter,
MaximumSelectionLength
);
}
if (options.tags) {
options.dataAdapter = Utils.Decorate(options.dataAdapter, Tags);
}
if (options.tokenSeparators != null || options.tokenizer != null) {
options.dataAdapter = Utils.Decorate(
options.dataAdapter,
Tokenizer
);
}
if (options.query != null) {
var Query = require(options.amdBase + 'compat/query');
options.dataAdapter = Utils.Decorate(
options.dataAdapter,
Query
);
}
if (options.initSelection != null) {
var InitSelection = require(options.amdBase + 'compat/initSelection');
options.dataAdapter = Utils.Decorate(
options.dataAdapter,
InitSelection
);
}
}
if (options.resultsAdapter == null) {
options.resultsAdapter = ResultsList;
if (options.ajax != null) {
options.resultsAdapter = Utils.Decorate(
options.resultsAdapter,
InfiniteScroll
);
}
if (options.placeholder != null) {
options.resultsAdapter = Utils.Decorate(
options.resultsAdapter,
HidePlaceholder
);
}
if (options.selectOnClose) {
options.resultsAdapter = Utils.Decorate(
options.resultsAdapter,
SelectOnClose
);
}
}
if (options.dropdownAdapter == null) {
if (options.multiple) {
options.dropdownAdapter = Dropdown;
} else {
var SearchableDropdown = Utils.Decorate(Dropdown, DropdownSearch);
options.dropdownAdapter = SearchableDropdown;
}
if (options.minimumResultsForSearch !== 0) {
options.dropdownAdapter = Utils.Decorate(
options.dropdownAdapter,
MinimumResultsForSearch
);
}
if (options.closeOnSelect) {
options.dropdownAdapter = Utils.Decorate(
options.dropdownAdapter,
CloseOnSelect
);
}
if (
options.dropdownCssClass != null ||
options.dropdownCss != null ||
options.adaptDropdownCssClass != null
) {
var DropdownCSS = require(options.amdBase + 'compat/dropdownCss');
options.dropdownAdapter = Utils.Decorate(
options.dropdownAdapter,
DropdownCSS
);
}
options.dropdownAdapter = Utils.Decorate(
options.dropdownAdapter,
AttachBody
);
}
if (options.selectionAdapter == null) {
if (options.multiple) {
options.selectionAdapter = MultipleSelection;
} else {
options.selectionAdapter = SingleSelection;
}
if (options.placeholder != null) {
options.selectionAdapter = Utils.Decorate(
options.selectionAdapter,
Placeholder
);
}
if (options.allowClear) {
options.selectionAdapter = Utils.Decorate(
options.selectionAdapter,
AllowClear
);
}
if (options.multiple) {
options.selectionAdapter = Utils.Decorate(
options.selectionAdapter,
SelectionSearch
);
}
if (
options.containerCssClass != null ||
options.containerCss != null ||
options.adaptContainerCssClass != null
) {
var ContainerCSS = require(options.amdBase + 'compat/containerCss');
options.selectionAdapter = Utils.Decorate(
options.selectionAdapter,
ContainerCSS
);
}
options.selectionAdapter = Utils.Decorate(
options.selectionAdapter,
EventRelay
);
}
if (typeof options.language === 'string') {
if (options.language.indexOf('-') > 0) {
var languageParts = options.language.split('-');
var baseLanguage = languageParts[0];
options.language = [options.language, baseLanguage];
} else {
options.language = [options.language];
}
}
if ($.isArray(options.language)) {
var languages = new Translation();
options.language.push('en');
var languageNames = options.language;
for (var l = 0; l < languageNames.length; l++) {
var name = languageNames[l];
var language = {};
try {
language = Translation.loadPath(name);
} catch (e) {
try {
name = this.defaults.amdLanguageBase + name;
language = Translation.loadPath(name);
} catch (ex) {
if (options.debug && window.console && console.warn) {
console.warn(
'Select2: The language file for "' + name + '" could not be ' +
'automatically loaded. A fallback will be used instead.'
);
}
continue;
}
}
languages.extend(language);
}
options.translations = languages;
} else {
var baseTranslation = Translation.loadPath(
this.defaults.amdLanguageBase + 'en'
);
var customTranslation = new Translation(options.language);
customTranslation.extend(baseTranslation);
options.translations = customTranslation;
}
return options;
};
Defaults.prototype.reset = function () {
function stripDiacritics (text) {
function match(a) {
return DIACRITICS[a] || a;
}
return text.replace(/[^\u0000-\u007E]/g, match);
}
function matcher (params, data) {
if ($.trim(params.term) === '') {
return data;
}
if (data.children && data.children.length > 0) {
var match = $.extend(true, {}, data);
for (var c = data.children.length - 1; c >= 0; c--) {
var child = data.children[c];
var matches = matcher(params, child);
if (matches == null) {
match.children.splice(c, 1);
}
}
if (match.children.length > 0) {
return match;
}
return matcher(params, match);
}
var original = stripDiacritics(data.text).toUpperCase();
var term = stripDiacritics(params.term).toUpperCase();
if (original.indexOf(term) > -1) {
return data;
}
return null;
}
this.defaults = {
amdBase: './',
amdLanguageBase: './i18n/',
closeOnSelect: true,
debug: false,
dropdownAutoWidth: false,
escapeMarkup: Utils.escapeMarkup,
language: EnglishTranslation,
matcher: matcher,
minimumInputLength: 0,
maximumInputLength: 0,
maximumSelectionLength: 0,
minimumResultsForSearch: 0,
selectOnClose: false,
sorter: function (data) {
return data;
},
templateResult: function (result) {
return result.text;
},
templateSelection: function (selection) {
return selection.text;
},
theme: 'default',
width: 'resolve'
};
};
Defaults.prototype.set = function (key, value) {
var camelKey = $.camelCase(key);
var data = {};
data[camelKey] = value;
var convertedData = Utils._convertData(data);
$.extend(true, this.defaults, convertedData);
};
var defaults = new Defaults();
return defaults;
});
S2.define('select2/options',[
'require',
'jquery',
'./defaults',
'./utils'
], function (require, $, Defaults, Utils) {
function Options (options, $element) {
this.options = options;
if ($element != null) {
this.fromElement($element);
}
this.options = Defaults.apply(this.options);
if ($element && $element.is('input')) {
var InputCompat = require(this.get('amdBase') + 'compat/inputData');
this.options.dataAdapter = Utils.Decorate(
this.options.dataAdapter,
InputCompat
);
}
}
Options.prototype.fromElement = function ($e) {
var excludedData = ['select2'];
if (this.options.multiple == null) {
this.options.multiple = $e.prop('multiple');
}
if (this.options.disabled == null) {
this.options.disabled = $e.prop('disabled');
}
if (this.options.language == null) {
if ($e.prop('lang')) {
this.options.language = $e.prop('lang').toLowerCase();
} else if ($e.closest('[lang]').prop('lang')) {
this.options.language = $e.closest('[lang]').prop('lang');
}
}
if (this.options.dir == null) {
if ($e.prop('dir')) {
this.options.dir = $e.prop('dir');
} else if ($e.closest('[dir]').prop('dir')) {
this.options.dir = $e.closest('[dir]').prop('dir');
} else {
this.options.dir = 'ltr';
}
}
$e.prop('disabled', this.options.disabled);
$e.prop('multiple', this.options.multiple);
if (Utils.GetData($e[0], 'select2Tags')) {
if (this.options.debug && window.console && console.warn) {
console.warn(
'Select2: The `data-select2-tags` attribute has been changed to ' +
'use the `data-data` and `data-tags="true"` attributes and will be ' +
'removed in future versions of Select2.'
);
}
Utils.StoreData($e[0], 'data', Utils.GetData($e[0], 'select2Tags'));
Utils.StoreData($e[0], 'tags', true);
}
if (Utils.GetData($e[0], 'ajaxUrl')) {
if (this.options.debug && window.console && console.warn) {
console.warn(
'Select2: The `data-ajax-url` attribute has been changed to ' +
'`data-ajax--url` and support for the old attribute will be removed' +
' in future versions of Select2.'
);
}
$e.attr('ajax--url', Utils.GetData($e[0], 'ajaxUrl'));
Utils.StoreData($e[0], 'ajax-Url', Utils.GetData($e[0], 'ajaxUrl'));
}
var dataset = {};
if ($.fn.jquery && $.fn.jquery.substr(0, 2) == '1.' && $e[0].dataset) {
dataset = $.extend(true, {}, $e[0].dataset, Utils.GetData($e[0]));
} else {
dataset = Utils.GetData($e[0]);
}
var data = $.extend(true, {}, dataset);
data = Utils._convertData(data);
for (var key in data) {
if ($.inArray(key, excludedData) > -1) {
continue;
}
if ($.isPlainObject(this.options[key])) {
$.extend(this.options[key], data[key]);
} else {
this.options[key] = data[key];
}
}
return this;
};
Options.prototype.get = function (key) {
return this.options[key];
};
Options.prototype.set = function (key, val) {
this.options[key] = val;
};
return Options;
});
S2.define('select2/core',[
'jquery',
'./options',
'./utils',
'./keys'
], function ($, Options, Utils, KEYS) {
var Select2 = function ($element, options) {
if (Utils.GetData($element[0], 'select2') != null) {
Utils.GetData($element[0], 'select2').destroy();
}
this.$element = $element;
this.id = this._generateId($element);
options = options || {};
this.options = new Options(options, $element);
Select2.__super__.constructor.call(this);
var tabindex = $element.attr('tabindex') || 0;
Utils.StoreData($element[0], 'old-tabindex', tabindex);
$element.attr('tabindex', '-1');
var DataAdapter = this.options.get('dataAdapter');
this.dataAdapter = new DataAdapter($element, this.options);
var $container = this.render();
this._placeContainer($container);
var SelectionAdapter = this.options.get('selectionAdapter');
this.selection = new SelectionAdapter($element, this.options);
this.$selection = this.selection.render();
this.selection.position(this.$selection, $container);
var DropdownAdapter = this.options.get('dropdownAdapter');
this.dropdown = new DropdownAdapter($element, this.options);
this.$dropdown = this.dropdown.render();
this.dropdown.position(this.$dropdown, $container);
var ResultsAdapter = this.options.get('resultsAdapter');
this.results = new ResultsAdapter($element, this.options, this.dataAdapter);
this.$results = this.results.render();
this.results.position(this.$results, this.$dropdown);
var self = this;
this._bindAdapters();
this._registerDomEvents();
this._registerDataEvents();
this._registerSelectionEvents();
this._registerDropdownEvents();
this._registerResultsEvents();
this._registerEvents();
this.dataAdapter.current(function (initialData) {
self.trigger('selection:update', {
data: initialData
});
});
$element.addClass('select2-hidden-accessible');
$element.attr('aria-hidden', 'true');
this._syncAttributes();
Utils.StoreData($element[0], 'select2', this);
$element.data('select2', this);
};
Utils.Extend(Select2, Utils.Observable);
Select2.prototype._generateId = function ($element) {
var id = '';
if ($element.attr('id') != null) {
id = $element.attr('id');
} else if ($element.attr('name') != null) {
id = $element.attr('name') + '-' + Utils.generateChars(2);
} else {
id = Utils.generateChars(4);
}
id = id.replace(/(:|\.|\[|\]|,)/g, '');
id = 'select2-' + id;
return id;
};
Select2.prototype._placeContainer = function ($container) {
$container.insertAfter(this.$element);
var width = this._resolveWidth(this.$element, this.options.get('width'));
if (width != null) {
$container.css('width', width);
}
};
Select2.prototype._resolveWidth = function ($element, method) {
var WIDTH = /^width:(([-+]?([0-9]*\.)?[0-9]+)(px|em|ex|%|in|cm|mm|pt|pc))/i;
if (method == 'resolve') {
var styleWidth = this._resolveWidth($element, 'style');
if (styleWidth != null) {
return styleWidth;
}
return this._resolveWidth($element, 'element');
}
if (method == 'element') {
var elementWidth = $element.outerWidth(false);
if (elementWidth <= 0) {
return 'auto';
}
return elementWidth + 'px';
}
if (method == 'style') {
var style = $element.attr('style');
if (typeof(style) !== 'string') {
return null;
}
var attrs = style.split(';');
for (var i = 0, l = attrs.length; i < l; i = i + 1) {
var attr = attrs[i].replace(/\s/g, '');
var matches = attr.match(WIDTH);
if (matches !== null && matches.length >= 1) {
return matches[1];
}
}
return null;
}
return method;
};
Select2.prototype._bindAdapters = function () {
this.dataAdapter.bind(this, this.$container);
this.selection.bind(this, this.$container);
this.dropdown.bind(this, this.$container);
this.results.bind(this, this.$container);
};
Select2.prototype._registerDomEvents = function () {
var self = this;
this.$element.on('change.select2', function () {
self.dataAdapter.current(function (data) {
self.trigger('selection:update', {
data: data
});
});
});
this.$element.on('focus.select2', function (evt) {
self.trigger('focus', evt);
});
this._syncA = Utils.bind(this._syncAttributes, this);
this._syncS = Utils.bind(this._syncSubtree, this);
if (this.$element[0].attachEvent) {
this.$element[0].attachEvent('onpropertychange', this._syncA);
}
var observer = window.MutationObserver ||
window.WebKitMutationObserver ||
window.MozMutationObserver
;
if (observer != null) {
this._observer = new observer(function (mutations) {
$.each(mutations, self._syncA);
$.each(mutations, self._syncS);
});
this._observer.observe(this.$element[0], {
attributes: true,
childList: true,
subtree: false
});
} else if (this.$element[0].addEventListener) {
this.$element[0].addEventListener(
'DOMAttrModified',
self._syncA,
false
);
this.$element[0].addEventListener(
'DOMNodeInserted',
self._syncS,
false
);
this.$element[0].addEventListener(
'DOMNodeRemoved',
self._syncS,
false
);
}
};
Select2.prototype._registerDataEvents = function () {
var self = this;
this.dataAdapter.on('*', function (name, params) {
self.trigger(name, params);
});
};
Select2.prototype._registerSelectionEvents = function () {
var self = this;
var nonRelayEvents = ['toggle', 'focus'];
this.selection.on('toggle', function () {
self.toggleDropdown();
});
this.selection.on('focus', function (params) {
self.focus(params);
});
this.selection.on('*', function (name, params) {
if ($.inArray(name, nonRelayEvents) !== -1) {
return;
}
self.trigger(name, params);
});
};
Select2.prototype._registerDropdownEvents = function () {
var self = this;
this.dropdown.on('*', function (name, params) {
self.trigger(name, params);
});
};
Select2.prototype._registerResultsEvents = function () {
var self = this;
this.results.on('*', function (name, params) {
self.trigger(name, params);
});
};
Select2.prototype._registerEvents = function () {
var self = this;
this.on('open', function () {
self.$container.addClass('select2-container--open');
});
this.on('close', function () {
self.$container.removeClass('select2-container--open');
});
this.on('enable', function () {
self.$container.removeClass('select2-container--disabled');
});
this.on('disable', function () {
self.$container.addClass('select2-container--disabled');
});
this.on('blur', function () {
self.$container.removeClass('select2-container--focus');
});
this.on('query', function (params) {
if (!self.isOpen()) {
self.trigger('open', {});
}
this.dataAdapter.query(params, function (data) {
self.trigger('results:all', {
data: data,
query: params
});
});
});
this.on('query:append', function (params) {
this.dataAdapter.query(params, function (data) {
self.trigger('results:append', {
data: data,
query: params
});
});
});
this.on('keypress', function (evt) {
var key = evt.which;
if (self.isOpen()) {
if (key === KEYS.ESC || key === KEYS.TAB ||
(key === KEYS.UP && evt.altKey)) {
self.close();
evt.preventDefault();
} else if (key === KEYS.ENTER) {
self.trigger('results:select', {});
evt.preventDefault();
} else if ((key === KEYS.SPACE && evt.ctrlKey)) {
self.trigger('results:toggle', {});
evt.preventDefault();
} else if (key === KEYS.UP) {
self.trigger('results:previous', {});
evt.preventDefault();
} else if (key === KEYS.DOWN) {
self.trigger('results:next', {});
evt.preventDefault();
}
} else {
if (key === KEYS.ENTER || key === KEYS.SPACE ||
(key === KEYS.DOWN && evt.altKey)) {
self.open();
evt.preventDefault();
}
}
});
};
Select2.prototype._syncAttributes = function () {
this.options.set('disabled', this.$element.prop('disabled'));
if (this.options.get('disabled')) {
if (this.isOpen()) {
this.close();
}
this.trigger('disable', {});
} else {
this.trigger('enable', {});
}
};
Select2.prototype._syncSubtree = function (evt, mutations) {
var changed = false;
var self = this;
if (
evt && evt.target && (
evt.target.nodeName !== 'OPTION' && evt.target.nodeName !== 'OPTGROUP'
)
) {
return;
}
if (!mutations) {
changed = true;
} else if (mutations.addedNodes && mutations.addedNodes.length > 0) {
for (var n = 0; n < mutations.addedNodes.length; n++) {
var node = mutations.addedNodes[n];
if (node.selected) {
changed = true;
}
}
} else if (mutations.removedNodes && mutations.removedNodes.length > 0) {
changed = true;
}
if (changed) {
this.dataAdapter.current(function (currentData) {
self.trigger('selection:update', {
data: currentData
});
});
}
};
Select2.prototype.trigger = function (name, args) {
var actualTrigger = Select2.__super__.trigger;
var preTriggerMap = {
'open': 'opening',
'close': 'closing',
'select': 'selecting',
'unselect': 'unselecting',
'clear': 'clearing'
};
if (args === undefined) {
args = {};
}
if (name in preTriggerMap) {
var preTriggerName = preTriggerMap[name];
var preTriggerArgs = {
prevented: false,
name: name,
args: args
};
actualTrigger.call(this, preTriggerName, preTriggerArgs);
if (preTriggerArgs.prevented) {
args.prevented = true;
return;
}
}
actualTrigger.call(this, name, args);
};
Select2.prototype.toggleDropdown = function () {
if (this.options.get('disabled')) {
return;
}
if (this.isOpen()) {
this.close();
} else {
this.open();
}
};
Select2.prototype.open = function () {
if (this.isOpen()) {
return;
}
this.trigger('query', {});
};
Select2.prototype.close = function () {
if (!this.isOpen()) {
return;
}
this.trigger('close', {});
};
Select2.prototype.isOpen = function () {
return this.$container.hasClass('select2-container--open');
};
Select2.prototype.hasFocus = function () {
return this.$container.hasClass('select2-container--focus');
};
Select2.prototype.focus = function (data) {
if (this.hasFocus()) {
return;
}
this.$container.addClass('select2-container--focus');
this.trigger('focus', {});
};
Select2.prototype.enable = function (args) {
if (this.options.get('debug') && window.console && console.warn) {
console.warn(
'Select2: The `select2("enable")` method has been deprecated and will' +
' be removed in later Select2 versions. Use $element.prop("disabled")' +
' instead.'
);
}
if (args == null || args.length === 0) {
args = [true];
}
var disabled = !args[0];
this.$element.prop('disabled', disabled);
};
Select2.prototype.data = function () {
if (this.options.get('debug') &&
arguments.length > 0 && window.console && console.warn) {
console.warn(
'Select2: Data can no longer be set using `select2("data")`. You ' +
'should consider setting the value instead using `$element.val()`.'
);
}
var data = [];
this.dataAdapter.current(function (currentData) {
data = currentData;
});
return data;
};
Select2.prototype.val = function (args) {
if (this.options.get('debug') && window.console && console.warn) {
console.warn(
'Select2: The `select2("val")` method has been deprecated and will be' +
' removed in later Select2 versions. Use $element.val() instead.'
);
}
if (args == null || args.length === 0) {
return this.$element.val();
}
var newVal = args[0];
if ($.isArray(newVal)) {
newVal = $.map(newVal, function (obj) {
return obj.toString();
});
}
this.$element.val(newVal).trigger('change');
};
Select2.prototype.destroy = function () {
this.$container.remove();
if (this.$element[0].detachEvent) {
this.$element[0].detachEvent('onpropertychange', this._syncA);
}
if (this._observer != null) {
this._observer.disconnect();
this._observer = null;
} else if (this.$element[0].removeEventListener) {
this.$element[0]
.removeEventListener('DOMAttrModified', this._syncA, false);
this.$element[0]
.removeEventListener('DOMNodeInserted', this._syncS, false);
this.$element[0]
.removeEventListener('DOMNodeRemoved', this._syncS, false);
}
this._syncA = null;
this._syncS = null;
this.$element.off('.select2');
this.$element.attr('tabindex',
Utils.GetData(this.$element[0], 'old-tabindex'));
this.$element.removeClass('select2-hidden-accessible');
this.$element.attr('aria-hidden', 'false');
Utils.RemoveData(this.$element[0]);
this.$element.removeData('select2');
this.dataAdapter.destroy();
this.selection.destroy();
this.dropdown.destroy();
this.results.destroy();
this.dataAdapter = null;
this.selection = null;
this.dropdown = null;
this.results = null;
};
Select2.prototype.render = function () {
var $container = $(
'<span class="select2 select2-container">' +
'<span class="selection"></span>' +
'<span class="dropdown-wrapper" aria-hidden="true"></span>' +
'</span>'
);
$container.attr('dir', this.options.get('dir'));
this.$container = $container;
this.$container.addClass('select2-container--' + this.options.get('theme'));
Utils.StoreData($container[0], 'element', this.$element);
return $container;
};
return Select2;
});
S2.define('jquery-mousewheel',[
'jquery'
], function ($) {
return $;
});
S2.define('jquery.select2',[
'jquery',
'jquery-mousewheel',
'./select2/core',
'./select2/defaults',
'./select2/utils'
], function ($, _, Select2, Defaults, Utils) {
if ($.fn.select2 == null) {
var thisMethods = ['open', 'close', 'destroy'];
$.fn.select2 = function (options) {
options = options || {};
if (typeof options === 'object') {
this.each(function () {
var instanceOptions = $.extend(true, {}, options);
var instance = new Select2($(this), instanceOptions);
});
return this;
} else if (typeof options === 'string') {
var ret;
var args = Array.prototype.slice.call(arguments, 1);
this.each(function () {
var instance = Utils.GetData(this, 'select2');
if (instance == null && window.console && console.error) {
console.error(
'The select2(\'' + options + '\') method was called on an ' +
'element that is not using Select2.'
);
}
ret = instance[options].apply(instance, args);
});
if ($.inArray(options, thisMethods) > -1) {
return this;
}
return ret;
} else {
throw new Error('Invalid arguments for Select2: ' + options);
}
};
}
if ($.fn.select2.defaults == null) {
$.fn.select2.defaults = Defaults;
}
return Select2;
});
return {
define: S2.define,
require: S2.require
};
}());
var select2 = S2.require('jquery.select2');
jQuery.fn.select2.amd = S2;
return select2;
}));
(function(root, factory) {
if (typeof define === "function" && define.amd) {
define("bloodhound", [ "jquery" ], function(a0) {
return root["Bloodhound"] = factory(a0);
});
} else if (typeof exports === "object") {
module.exports = factory(require("jquery"));
} else {
root["Bloodhound"] = factory(jQuery);
}
})(this, function($) {
var _ = function() {
"use strict";
return {
isMsie: function() {
return /(msie|trident)/i.test(navigator.userAgent) ? navigator.userAgent.match(/(msie |rv:)(\d+(.\d+)?)/i)[2] : false;
},
isBlankString: function(str) {
return !str || /^\s*$/.test(str);
},
escapeRegExChars: function(str) {
return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
},
isString: function(obj) {
return typeof obj === "string";
},
isNumber: function(obj) {
return typeof obj === "number";
},
isArray: $.isArray,
isFunction: $.isFunction,
isObject: $.isPlainObject,
isUndefined: function(obj) {
return typeof obj === "undefined";
},
isElement: function(obj) {
return !!(obj && obj.nodeType === 1);
},
isJQuery: function(obj) {
return obj instanceof $;
},
toStr: function toStr(s) {
return _.isUndefined(s) || s === null ? "" : s + "";
},
bind: $.proxy,
each: function(collection, cb) {
$.each(collection, reverseArgs);
function reverseArgs(index, value) {
return cb(value, index);
}
},
map: $.map,
filter: $.grep,
every: function(obj, test) {
var result = true;
if (!obj) {
return result;
}
$.each(obj, function(key, val) {
if (!(result = test.call(null, val, key, obj))) {
return false;
}
});
return !!result;
},
some: function(obj, test) {
var result = false;
if (!obj) {
return result;
}
$.each(obj, function(key, val) {
if (result = test.call(null, val, key, obj)) {
return false;
}
});
return !!result;
},
mixin: $.extend,
identity: function(x) {
return x;
},
clone: function(obj) {
return $.extend(true, {}, obj);
},
getIdGenerator: function() {
var counter = 0;
return function() {
return counter++;
};
},
templatify: function templatify(obj) {
return $.isFunction(obj) ? obj : template;
function template() {
return String(obj);
}
},
defer: function(fn) {
setTimeout(fn, 0);
},
debounce: function(func, wait, immediate) {
var timeout, result;
return function() {
var context = this, args = arguments, later, callNow;
later = function() {
timeout = null;
if (!immediate) {
result = func.apply(context, args);
}
};
callNow = immediate && !timeout;
clearTimeout(timeout);
timeout = setTimeout(later, wait);
if (callNow) {
result = func.apply(context, args);
}
return result;
};
},
throttle: function(func, wait) {
var context, args, timeout, result, previous, later;
previous = 0;
later = function() {
previous = new Date();
timeout = null;
result = func.apply(context, args);
};
return function() {
var now = new Date(), remaining = wait - (now - previous);
context = this;
args = arguments;
if (remaining <= 0) {
clearTimeout(timeout);
timeout = null;
previous = now;
result = func.apply(context, args);
} else if (!timeout) {
timeout = setTimeout(later, remaining);
}
return result;
};
},
stringify: function(val) {
return _.isString(val) ? val : JSON.stringify(val);
},
noop: function() {}
};
}();
var VERSION = "0.11.1";
var tokenizers = function() {
"use strict";
return {
nonword: nonword,
whitespace: whitespace,
obj: {
nonword: getObjTokenizer(nonword),
whitespace: getObjTokenizer(whitespace)
}
};
function whitespace(str) {
str = _.toStr(str);
return str ? str.split(/\s+/) : [];
}
function nonword(str) {
str = _.toStr(str);
return str ? str.split(/\W+/) : [];
}
function getObjTokenizer(tokenizer) {
return function setKey(keys) {
keys = _.isArray(keys) ? keys : [].slice.call(arguments, 0);
return function tokenize(o) {
var tokens = [];
_.each(keys, function(k) {
tokens = tokens.concat(tokenizer(_.toStr(o[k])));
});
return tokens;
};
};
}
}();
var LruCache = function() {
"use strict";
function LruCache(maxSize) {
this.maxSize = _.isNumber(maxSize) ? maxSize : 100;
this.reset();
if (this.maxSize <= 0) {
this.set = this.get = $.noop;
}
}
_.mixin(LruCache.prototype, {
set: function set(key, val) {
var tailItem = this.list.tail, node;
if (this.size >= this.maxSize) {
this.list.remove(tailItem);
delete this.hash[tailItem.key];
this.size--;
}
if (node = this.hash[key]) {
node.val = val;
this.list.moveToFront(node);
} else {
node = new Node(key, val);
this.list.add(node);
this.hash[key] = node;
this.size++;
}
},
get: function get(key) {
var node = this.hash[key];
if (node) {
this.list.moveToFront(node);
return node.val;
}
},
reset: function reset() {
this.size = 0;
this.hash = {};
this.list = new List();
}
});
function List() {
this.head = this.tail = null;
}
_.mixin(List.prototype, {
add: function add(node) {
if (this.head) {
node.next = this.head;
this.head.prev = node;
}
this.head = node;
this.tail = this.tail || node;
},
remove: function remove(node) {
node.prev ? node.prev.next = node.next : this.head = node.next;
node.next ? node.next.prev = node.prev : this.tail = node.prev;
},
moveToFront: function(node) {
this.remove(node);
this.add(node);
}
});
function Node(key, val) {
this.key = key;
this.val = val;
this.prev = this.next = null;
}
return LruCache;
}();
var PersistentStorage = function() {
"use strict";
var LOCAL_STORAGE;
try {
LOCAL_STORAGE = window.localStorage;
LOCAL_STORAGE.setItem("~~~", "!");
LOCAL_STORAGE.removeItem("~~~");
} catch (err) {
LOCAL_STORAGE = null;
}
function PersistentStorage(namespace, override) {
this.prefix = [ "__", namespace, "__" ].join("");
this.ttlKey = "__ttl__";
this.keyMatcher = new RegExp("^" + _.escapeRegExChars(this.prefix));
this.ls = override || LOCAL_STORAGE;
!this.ls && this._noop();
}
_.mixin(PersistentStorage.prototype, {
_prefix: function(key) {
return this.prefix + key;
},
_ttlKey: function(key) {
return this._prefix(key) + this.ttlKey;
},
_noop: function() {
this.get = this.set = this.remove = this.clear = this.isExpired = _.noop;
},
_safeSet: function(key, val) {
try {
this.ls.setItem(key, val);
} catch (err) {
if (err.name === "QuotaExceededError") {
this.clear();
this._noop();
}
}
},
get: function(key) {
if (this.isExpired(key)) {
this.remove(key);
}
return decode(this.ls.getItem(this._prefix(key)));
},
set: function(key, val, ttl) {
if (_.isNumber(ttl)) {
this._safeSet(this._ttlKey(key), encode(now() + ttl));
} else {
this.ls.removeItem(this._ttlKey(key));
}
return this._safeSet(this._prefix(key), encode(val));
},
remove: function(key) {
this.ls.removeItem(this._ttlKey(key));
this.ls.removeItem(this._prefix(key));
return this;
},
clear: function() {
var i, keys = gatherMatchingKeys(this.keyMatcher);
for (i = keys.length; i--; ) {
this.remove(keys[i]);
}
return this;
},
isExpired: function(key) {
var ttl = decode(this.ls.getItem(this._ttlKey(key)));
return _.isNumber(ttl) && now() > ttl ? true : false;
}
});
return PersistentStorage;
function now() {
return new Date().getTime();
}
function encode(val) {
return JSON.stringify(_.isUndefined(val) ? null : val);
}
function decode(val) {
return $.parseJSON(val);
}
function gatherMatchingKeys(keyMatcher) {
var i, key, keys = [], len = LOCAL_STORAGE.length;
for (i = 0; i < len; i++) {
if ((key = LOCAL_STORAGE.key(i)).match(keyMatcher)) {
keys.push(key.replace(keyMatcher, ""));
}
}
return keys;
}
}();
var Transport = function() {
"use strict";
var pendingRequestsCount = 0, pendingRequests = {}, maxPendingRequests = 6, sharedCache = new LruCache(10);
function Transport(o) {
o = o || {};
this.cancelled = false;
this.lastReq = null;
this._send = o.transport;
this._get = o.limiter ? o.limiter(this._get) : this._get;
this._cache = o.cache === false ? new LruCache(0) : sharedCache;
}
Transport.setMaxPendingRequests = function setMaxPendingRequests(num) {
maxPendingRequests = num;
};
Transport.resetCache = function resetCache() {
sharedCache.reset();
};
_.mixin(Transport.prototype, {
_fingerprint: function fingerprint(o) {
o = o || {};
return o.url + o.type + $.param(o.data || {});
},
_get: function(o, cb) {
var that = this, fingerprint, jqXhr;
fingerprint = this._fingerprint(o);
if (this.cancelled || fingerprint !== this.lastReq) {
return;
}
if (jqXhr = pendingRequests[fingerprint]) {
jqXhr.done(done).fail(fail);
} else if (pendingRequestsCount < maxPendingRequests) {
pendingRequestsCount++;
pendingRequests[fingerprint] = this._send(o).done(done).fail(fail).always(always);
} else {
this.onDeckRequestArgs = [].slice.call(arguments, 0);
}
function done(resp) {
cb(null, resp);
that._cache.set(fingerprint, resp);
}
function fail() {
cb(true);
}
function always() {
pendingRequestsCount--;
delete pendingRequests[fingerprint];
if (that.onDeckRequestArgs) {
that._get.apply(that, that.onDeckRequestArgs);
that.onDeckRequestArgs = null;
}
}
},
get: function(o, cb) {
var resp, fingerprint;
cb = cb || $.noop;
o = _.isString(o) ? {
url: o
} : o || {};
fingerprint = this._fingerprint(o);
this.cancelled = false;
this.lastReq = fingerprint;
if (resp = this._cache.get(fingerprint)) {
cb(null, resp);
} else {
this._get(o, cb);
}
},
cancel: function() {
this.cancelled = true;
}
});
return Transport;
}();
var SearchIndex = window.SearchIndex = function() {
"use strict";
var CHILDREN = "c", IDS = "i";
function SearchIndex(o) {
o = o || {};
if (!o.datumTokenizer || !o.queryTokenizer) {
$.error("datumTokenizer and queryTokenizer are both required");
}
this.identify = o.identify || _.stringify;
this.datumTokenizer = o.datumTokenizer;
this.queryTokenizer = o.queryTokenizer;
this.reset();
}
_.mixin(SearchIndex.prototype, {
bootstrap: function bootstrap(o) {
this.datums = o.datums;
this.trie = o.trie;
},
add: function(data) {
var that = this;
data = _.isArray(data) ? data : [ data ];
_.each(data, function(datum) {
var id, tokens;
that.datums[id = that.identify(datum)] = datum;
tokens = normalizeTokens(that.datumTokenizer(datum));
_.each(tokens, function(token) {
var node, chars, ch;
node = that.trie;
chars = token.split("");
while (ch = chars.shift()) {
node = node[CHILDREN][ch] || (node[CHILDREN][ch] = newNode());
node[IDS].push(id);
}
});
});
},
get: function get(ids) {
var that = this;
return _.map(ids, function(id) {
return that.datums[id];
});
},
search: function search(query) {
var that = this, tokens, matches;
tokens = normalizeTokens(this.queryTokenizer(query));
_.each(tokens, function(token) {
var node, chars, ch, ids;
if (matches && matches.length === 0) {
return false;
}
node = that.trie;
chars = token.split("");
while (node && (ch = chars.shift())) {
node = node[CHILDREN][ch];
}
if (node && chars.length === 0) {
ids = node[IDS].slice(0);
matches = matches ? getIntersection(matches, ids) : ids;
} else {
matches = [];
return false;
}
});
return matches ? _.map(unique(matches), function(id) {
return that.datums[id];
}) : [];
},
all: function all() {
var values = [];
for (var key in this.datums) {
values.push(this.datums[key]);
}
return values;
},
reset: function reset() {
this.datums = {};
this.trie = newNode();
},
serialize: function serialize() {
return {
datums: this.datums,
trie: this.trie
};
}
});
return SearchIndex;
function normalizeTokens(tokens) {
tokens = _.filter(tokens, function(token) {
return !!token;
});
tokens = _.map(tokens, function(token) {
return token.toLowerCase();
});
return tokens;
}
function newNode() {
var node = {};
node[IDS] = [];
node[CHILDREN] = {};
return node;
}
function unique(array) {
var seen = {}, uniques = [];
for (var i = 0, len = array.length; i < len; i++) {
if (!seen[array[i]]) {
seen[array[i]] = true;
uniques.push(array[i]);
}
}
return uniques;
}
function getIntersection(arrayA, arrayB) {
var ai = 0, bi = 0, intersection = [];
arrayA = arrayA.sort();
arrayB = arrayB.sort();
var lenArrayA = arrayA.length, lenArrayB = arrayB.length;
while (ai < lenArrayA && bi < lenArrayB) {
if (arrayA[ai] < arrayB[bi]) {
ai++;
} else if (arrayA[ai] > arrayB[bi]) {
bi++;
} else {
intersection.push(arrayA[ai]);
ai++;
bi++;
}
}
return intersection;
}
}();
var Prefetch = function() {
"use strict";
var keys;
keys = {
data: "data",
protocol: "protocol",
thumbprint: "thumbprint"
};
function Prefetch(o) {
this.url = o.url;
this.ttl = o.ttl;
this.cache = o.cache;
this.prepare = o.prepare;
this.transform = o.transform;
this.transport = o.transport;
this.thumbprint = o.thumbprint;
this.storage = new PersistentStorage(o.cacheKey);
}
_.mixin(Prefetch.prototype, {
_settings: function settings() {
return {
url: this.url,
type: "GET",
dataType: "json"
};
},
store: function store(data) {
if (!this.cache) {
return;
}
this.storage.set(keys.data, data, this.ttl);
this.storage.set(keys.protocol, location.protocol, this.ttl);
this.storage.set(keys.thumbprint, this.thumbprint, this.ttl);
},
fromCache: function fromCache() {
var stored = {}, isExpired;
if (!this.cache) {
return null;
}
stored.data = this.storage.get(keys.data);
stored.protocol = this.storage.get(keys.protocol);
stored.thumbprint = this.storage.get(keys.thumbprint);
isExpired = stored.thumbprint !== this.thumbprint || stored.protocol !== location.protocol;
return stored.data && !isExpired ? stored.data : null;
},
fromNetwork: function(cb) {
var that = this, settings;
if (!cb) {
return;
}
settings = this.prepare(this._settings());
this.transport(settings).fail(onError).done(onResponse);
function onError() {
cb(true);
}
function onResponse(resp) {
cb(null, that.transform(resp));
}
},
clear: function clear() {
this.storage.clear();
return this;
}
});
return Prefetch;
}();
var Remote = function() {
"use strict";
function Remote(o) {
this.url = o.url;
this.prepare = o.prepare;
this.transform = o.transform;
this.transport = new Transport({
cache: o.cache,
limiter: o.limiter,
transport: o.transport
});
}
_.mixin(Remote.prototype, {
_settings: function settings() {
return {
url: this.url,
type: "GET",
dataType: "json"
};
},
get: function get(query, cb) {
var that = this, settings;
if (!cb) {
return;
}
query = query || "";
settings = this.prepare(query, this._settings());
return this.transport.get(settings, onResponse);
function onResponse(err, resp) {
err ? cb([]) : cb(that.transform(resp));
}
},
cancelLastRequest: function cancelLastRequest() {
this.transport.cancel();
}
});
return Remote;
}();
var oParser = function() {
"use strict";
return function parse(o) {
var defaults, sorter;
defaults = {
initialize: true,
identify: _.stringify,
datumTokenizer: null,
queryTokenizer: null,
sufficient: 5,
sorter: null,
local: [],
prefetch: null,
remote: null
};
o = _.mixin(defaults, o || {});
!o.datumTokenizer && $.error("datumTokenizer is required");
!o.queryTokenizer && $.error("queryTokenizer is required");
sorter = o.sorter;
o.sorter = sorter ? function(x) {
return x.sort(sorter);
} : _.identity;
o.local = _.isFunction(o.local) ? o.local() : o.local;
o.prefetch = parsePrefetch(o.prefetch);
o.remote = parseRemote(o.remote);
return o;
};
function parsePrefetch(o) {
var defaults;
if (!o) {
return null;
}
defaults = {
url: null,
ttl: 24 * 60 * 60 * 1e3,
cache: true,
cacheKey: null,
thumbprint: "",
prepare: _.identity,
transform: _.identity,
transport: null
};
o = _.isString(o) ? {
url: o
} : o;
o = _.mixin(defaults, o);
!o.url && $.error("prefetch requires url to be set");
o.transform = o.filter || o.transform;
o.cacheKey = o.cacheKey || o.url;
o.thumbprint = VERSION + o.thumbprint;
o.transport = o.transport ? callbackToDeferred(o.transport) : $.ajax;
return o;
}
function parseRemote(o) {
var defaults;
if (!o) {
return;
}
defaults = {
url: null,
cache: true,
prepare: null,
replace: null,
wildcard: null,
limiter: null,
rateLimitBy: "debounce",
rateLimitWait: 300,
transform: _.identity,
transport: null
};
o = _.isString(o) ? {
url: o
} : o;
o = _.mixin(defaults, o);
!o.url && $.error("remote requires url to be set");
o.transform = o.filter || o.transform;
o.prepare = toRemotePrepare(o);
o.limiter = toLimiter(o);
o.transport = o.transport ? callbackToDeferred(o.transport) : $.ajax;
delete o.replace;
delete o.wildcard;
delete o.rateLimitBy;
delete o.rateLimitWait;
return o;
}
function toRemotePrepare(o) {
var prepare, replace, wildcard;
prepare = o.prepare;
replace = o.replace;
wildcard = o.wildcard;
if (prepare) {
return prepare;
}
if (replace) {
prepare = prepareByReplace;
} else if (o.wildcard) {
prepare = prepareByWildcard;
} else {
prepare = idenityPrepare;
}
return prepare;
function prepareByReplace(query, settings) {
settings.url = replace(settings.url, query);
return settings;
}
function prepareByWildcard(query, settings) {
settings.url = settings.url.replace(wildcard, encodeURIComponent(query));
return settings;
}
function idenityPrepare(query, settings) {
return settings;
}
}
function toLimiter(o) {
var limiter, method, wait;
limiter = o.limiter;
method = o.rateLimitBy;
wait = o.rateLimitWait;
if (!limiter) {
limiter = /^throttle$/i.test(method) ? throttle(wait) : debounce(wait);
}
return limiter;
function debounce(wait) {
return function debounce(fn) {
return _.debounce(fn, wait);
};
}
function throttle(wait) {
return function throttle(fn) {
return _.throttle(fn, wait);
};
}
}
function callbackToDeferred(fn) {
return function wrapper(o) {
var deferred = $.Deferred();
fn(o, onSuccess, onError);
return deferred;
function onSuccess(resp) {
_.defer(function() {
deferred.resolve(resp);
});
}
function onError(err) {
_.defer(function() {
deferred.reject(err);
});
}
};
}
}();
var Bloodhound = function() {
"use strict";
var old;
old = window && window.Bloodhound;
function Bloodhound(o) {
o = oParser(o);
this.sorter = o.sorter;
this.identify = o.identify;
this.sufficient = o.sufficient;
this.local = o.local;
this.remote = o.remote ? new Remote(o.remote) : null;
this.prefetch = o.prefetch ? new Prefetch(o.prefetch) : null;
this.index = new SearchIndex({
identify: this.identify,
datumTokenizer: o.datumTokenizer,
queryTokenizer: o.queryTokenizer
});
o.initialize !== false && this.initialize();
}
Bloodhound.noConflict = function noConflict() {
window && (window.Bloodhound = old);
return Bloodhound;
};
Bloodhound.tokenizers = tokenizers;
_.mixin(Bloodhound.prototype, {
__ttAdapter: function ttAdapter() {
var that = this;
return this.remote ? withAsync : withoutAsync;
function withAsync(query, sync, async) {
return that.search(query, sync, async);
}
function withoutAsync(query, sync) {
return that.search(query, sync);
}
},
_loadPrefetch: function loadPrefetch() {
var that = this, deferred, serialized;
deferred = $.Deferred();
if (!this.prefetch) {
deferred.resolve();
} else if (serialized = this.prefetch.fromCache()) {
this.index.bootstrap(serialized);
deferred.resolve();
} else {
this.prefetch.fromNetwork(done);
}
return deferred.promise();
function done(err, data) {
if (err) {
return deferred.reject();
}
that.add(data);
that.prefetch.store(that.index.serialize());
deferred.resolve();
}
},
_initialize: function initialize() {
var that = this, deferred;
this.clear();
(this.initPromise = this._loadPrefetch()).done(addLocalToIndex);
return this.initPromise;
function addLocalToIndex() {
that.add(that.local);
}
},
initialize: function initialize(force) {
return !this.initPromise || force ? this._initialize() : this.initPromise;
},
add: function add(data) {
this.index.add(data);
return this;
},
get: function get(ids) {
ids = _.isArray(ids) ? ids : [].slice.call(arguments);
return this.index.get(ids);
},
search: function search(query, sync, async) {
var that = this, local;
local = this.sorter(this.index.search(query));
sync(this.remote ? local.slice() : local);
if (this.remote && local.length < this.sufficient) {
this.remote.get(query, processRemote);
} else if (this.remote) {
this.remote.cancelLastRequest();
}
return this;
function processRemote(remote) {
var nonDuplicates = [];
_.each(remote, function(r) {
!_.some(local, function(l) {
return that.identify(r) === that.identify(l);
}) && nonDuplicates.push(r);
});
async && async(nonDuplicates);
}
},
all: function all() {
return this.index.all();
},
clear: function clear() {
this.index.reset();
return this;
},
clearPrefetchCache: function clearPrefetchCache() {
this.prefetch && this.prefetch.clear();
return this;
},
clearRemoteCache: function clearRemoteCache() {
Transport.resetCache();
return this;
},
ttAdapter: function ttAdapter() {
return this.__ttAdapter();
}
});
return Bloodhound;
}();
return Bloodhound;
});
(function(root, factory) {
if (typeof define === "function" && define.amd) {
define("typeahead.js", [ "jquery" ], function(a0) {
return factory(a0);
});
} else if (typeof exports === "object") {
module.exports = factory(require("jquery"));
} else {
factory(jQuery);
}
})(this, function($) {
var _ = function() {
"use strict";
return {
isMsie: function() {
return /(msie|trident)/i.test(navigator.userAgent) ? navigator.userAgent.match(/(msie |rv:)(\d+(.\d+)?)/i)[2] : false;
},
isBlankString: function(str) {
return !str || /^\s*$/.test(str);
},
escapeRegExChars: function(str) {
return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
},
isString: function(obj) {
return typeof obj === "string";
},
isNumber: function(obj) {
return typeof obj === "number";
},
isArray: $.isArray,
isFunction: $.isFunction,
isObject: $.isPlainObject,
isUndefined: function(obj) {
return typeof obj === "undefined";
},
isElement: function(obj) {
return !!(obj && obj.nodeType === 1);
},
isJQuery: function(obj) {
return obj instanceof $;
},
toStr: function toStr(s) {
return _.isUndefined(s) || s === null ? "" : s + "";
},
bind: $.proxy,
each: function(collection, cb) {
$.each(collection, reverseArgs);
function reverseArgs(index, value) {
return cb(value, index);
}
},
map: $.map,
filter: $.grep,
every: function(obj, test) {
var result = true;
if (!obj) {
return result;
}
$.each(obj, function(key, val) {
if (!(result = test.call(null, val, key, obj))) {
return false;
}
});
return !!result;
},
some: function(obj, test) {
var result = false;
if (!obj) {
return result;
}
$.each(obj, function(key, val) {
if (result = test.call(null, val, key, obj)) {
return false;
}
});
return !!result;
},
mixin: $.extend,
identity: function(x) {
return x;
},
clone: function(obj) {
return $.extend(true, {}, obj);
},
getIdGenerator: function() {
var counter = 0;
return function() {
return counter++;
};
},
templatify: function templatify(obj) {
return $.isFunction(obj) ? obj : template;
function template() {
return String(obj);
}
},
defer: function(fn) {
setTimeout(fn, 0);
},
debounce: function(func, wait, immediate) {
var timeout, result;
return function() {
var context = this, args = arguments, later, callNow;
later = function() {
timeout = null;
if (!immediate) {
result = func.apply(context, args);
}
};
callNow = immediate && !timeout;
clearTimeout(timeout);
timeout = setTimeout(later, wait);
if (callNow) {
result = func.apply(context, args);
}
return result;
};
},
throttle: function(func, wait) {
var context, args, timeout, result, previous, later;
previous = 0;
later = function() {
previous = new Date();
timeout = null;
result = func.apply(context, args);
};
return function() {
var now = new Date(), remaining = wait - (now - previous);
context = this;
args = arguments;
if (remaining <= 0) {
clearTimeout(timeout);
timeout = null;
previous = now;
result = func.apply(context, args);
} else if (!timeout) {
timeout = setTimeout(later, remaining);
}
return result;
};
},
stringify: function(val) {
return _.isString(val) ? val : JSON.stringify(val);
},
noop: function() {}
};
}();
var WWW = function() {
"use strict";
var defaultClassNames = {
wrapper: "twitter-typeahead",
input: "tt-input",
hint: "tt-hint",
menu: "tt-menu",
dataset: "tt-dataset",
suggestion: "tt-suggestion",
selectable: "tt-selectable",
empty: "tt-empty",
open: "tt-open",
cursor: "tt-cursor",
highlight: "tt-highlight"
};
return build;
function build(o) {
var www, classes;
classes = _.mixin({}, defaultClassNames, o);
www = {
css: buildCss(),
classes: classes,
html: buildHtml(classes),
selectors: buildSelectors(classes)
};
return {
css: www.css,
html: www.html,
classes: www.classes,
selectors: www.selectors,
mixin: function(o) {
_.mixin(o, www);
}
};
}
function buildHtml(c) {
return {
wrapper: '<span class="' + c.wrapper + '"></span>',
menu: '<div class="' + c.menu + '"></div>'
};
}
function buildSelectors(classes) {
var selectors = {};
_.each(classes, function(v, k) {
selectors[k] = "." + v;
});
return selectors;
}
function buildCss() {
var css = {
wrapper: {
position: "relative",
display: "inline-block"
},
hint: {
position: "absolute",
top: "0",
left: "0",
borderColor: "transparent",
boxShadow: "none",
opacity: "1"
},
input: {
position: "relative",
verticalAlign: "top",
backgroundColor: "transparent"
},
inputWithNoHint: {
position: "relative",
verticalAlign: "top"
},
menu: {
position: "absolute",
top: "100%",
left: "0",
zIndex: "100",
display: "none"
},
ltr: {
left: "0",
right: "auto"
},
rtl: {
left: "auto",
right: " 0"
}
};
if (_.isMsie()) {
_.mixin(css.input, {
backgroundImage: "url(data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)"
});
}
return css;
}
}();
var EventBus = function() {
"use strict";
var namespace, deprecationMap;
namespace = "typeahead:";
deprecationMap = {
render: "rendered",
cursorchange: "cursorchanged",
select: "selected",
autocomplete: "autocompleted"
};
function EventBus(o) {
if (!o || !o.el) {
$.error("EventBus initialized without el");
}
this.$el = $(o.el);
}
_.mixin(EventBus.prototype, {
_trigger: function(type, args) {
var $e;
$e = $.Event(namespace + type);
(args = args || []).unshift($e);
this.$el.trigger.apply(this.$el, args);
return $e;
},
before: function(type) {
var args, $e;
args = [].slice.call(arguments, 1);
$e = this._trigger("before" + type, args);
return $e.isDefaultPrevented();
},
trigger: function(type) {
var deprecatedType;
this._trigger(type, [].slice.call(arguments, 1));
if (deprecatedType = deprecationMap[type]) {
this._trigger(deprecatedType, [].slice.call(arguments, 1));
}
}
});
return EventBus;
}();
var EventEmitter = function() {
"use strict";
var splitter = /\s+/, nextTick = getNextTick();
return {
onSync: onSync,
onAsync: onAsync,
off: off,
trigger: trigger
};
function on(method, types, cb, context) {
var type;
if (!cb) {
return this;
}
types = types.split(splitter);
cb = context ? bindContext(cb, context) : cb;
this._callbacks = this._callbacks || {};
while (type = types.shift()) {
this._callbacks[type] = this._callbacks[type] || {
sync: [],
async: []
};
this._callbacks[type][method].push(cb);
}
return this;
}
function onAsync(types, cb, context) {
return on.call(this, "async", types, cb, context);
}
function onSync(types, cb, context) {
return on.call(this, "sync", types, cb, context);
}
function off(types) {
var type;
if (!this._callbacks) {
return this;
}
types = types.split(splitter);
while (type = types.shift()) {
delete this._callbacks[type];
}
return this;
}
function trigger(types) {
var type, callbacks, args, syncFlush, asyncFlush;
if (!this._callbacks) {
return this;
}
types = types.split(splitter);
args = [].slice.call(arguments, 1);
while ((type = types.shift()) && (callbacks = this._callbacks[type])) {
syncFlush = getFlush(callbacks.sync, this, [ type ].concat(args));
asyncFlush = getFlush(callbacks.async, this, [ type ].concat(args));
syncFlush() && nextTick(asyncFlush);
}
return this;
}
function getFlush(callbacks, context, args) {
return flush;
function flush() {
var cancelled;
for (var i = 0, len = callbacks.length; !cancelled && i < len; i += 1) {
cancelled = callbacks[i].apply(context, args) === false;
}
return !cancelled;
}
}
function getNextTick() {
var nextTickFn;
if (window.setImmediate) {
nextTickFn = function nextTickSetImmediate(fn) {
setImmediate(function() {
fn();
});
};
} else {
nextTickFn = function nextTickSetTimeout(fn) {
setTimeout(function() {
fn();
}, 0);
};
}
return nextTickFn;
}
function bindContext(fn, context) {
return fn.bind ? fn.bind(context) : function() {
fn.apply(context, [].slice.call(arguments, 0));
};
}
}();
var highlight = function(doc) {
"use strict";
var defaults = {
node: null,
pattern: null,
tagName: "strong",
className: null,
wordsOnly: false,
caseSensitive: false
};
return function hightlight(o) {
var regex;
o = _.mixin({}, defaults, o);
if (!o.node || !o.pattern) {
return;
}
o.pattern = _.isArray(o.pattern) ? o.pattern : [ o.pattern ];
regex = getRegex(o.pattern, o.caseSensitive, o.wordsOnly);
traverse(o.node, hightlightTextNode);
function hightlightTextNode(textNode) {
var match, patternNode, wrapperNode;
if (match = regex.exec(textNode.data)) {
wrapperNode = doc.createElement(o.tagName);
o.className && (wrapperNode.className = o.className);
patternNode = textNode.splitText(match.index);
patternNode.splitText(match[0].length);
wrapperNode.appendChild(patternNode.cloneNode(true));
textNode.parentNode.replaceChild(wrapperNode, patternNode);
}
return !!match;
}
function traverse(el, hightlightTextNode) {
var childNode, TEXT_NODE_TYPE = 3;
for (var i = 0; i < el.childNodes.length; i++) {
childNode = el.childNodes[i];
if (childNode.nodeType === TEXT_NODE_TYPE) {
i += hightlightTextNode(childNode) ? 1 : 0;
} else {
traverse(childNode, hightlightTextNode);
}
}
}
};
function getRegex(patterns, caseSensitive, wordsOnly) {
var escapedPatterns = [], regexStr;
for (var i = 0, len = patterns.length; i < len; i++) {
escapedPatterns.push(_.escapeRegExChars(patterns[i]));
}
regexStr = wordsOnly ? "\\b(" + escapedPatterns.join("|") + ")\\b" : "(" + escapedPatterns.join("|") + ")";
return caseSensitive ? new RegExp(regexStr) : new RegExp(regexStr, "i");
}
}(window.document);
var Input = function() {
"use strict";
var specialKeyCodeMap;
specialKeyCodeMap = {
9: "tab",
27: "esc",
37: "left",
39: "right",
13: "enter",
38: "up",
40: "down"
};
function Input(o, www) {
o = o || {};
if (!o.input) {
$.error("input is missing");
}
www.mixin(this);
this.$hint = $(o.hint);
this.$input = $(o.input);
this.query = this.$input.val();
this.queryWhenFocused = this.hasFocus() ? this.query : null;
this.$overflowHelper = buildOverflowHelper(this.$input);
this._checkLanguageDirection();
if (this.$hint.length === 0) {
this.setHint = this.getHint = this.clearHint = this.clearHintIfInvalid = _.noop;
}
}
Input.normalizeQuery = function(str) {
return _.toStr(str).replace(/^\s*/g, "").replace(/\s{2,}/g, " ");
};
_.mixin(Input.prototype, EventEmitter, {
_onBlur: function onBlur() {
this.resetInputValue();
this.trigger("blurred");
},
_onFocus: function onFocus() {
this.queryWhenFocused = this.query;
this.trigger("focused");
},
_onKeydown: function onKeydown($e) {
var keyName = specialKeyCodeMap[$e.which || $e.keyCode];
this._managePreventDefault(keyName, $e);
if (keyName && this._shouldTrigger(keyName, $e)) {
this.trigger(keyName + "Keyed", $e);
}
},
_onInput: function onInput() {
this._setQuery(this.getInputValue());
this.clearHintIfInvalid();
this._checkLanguageDirection();
},
_managePreventDefault: function managePreventDefault(keyName, $e) {
var preventDefault;
switch (keyName) {
case "up":
case "down":
preventDefault = !withModifier($e);
break;
default:
preventDefault = false;
}
preventDefault && $e.preventDefault();
},
_shouldTrigger: function shouldTrigger(keyName, $e) {
var trigger;
switch (keyName) {
case "tab":
trigger = !withModifier($e);
break;
default:
trigger = true;
}
return trigger;
},
_checkLanguageDirection: function checkLanguageDirection() {
var dir = (this.$input.css("direction") || "ltr").toLowerCase();
if (this.dir !== dir) {
this.dir = dir;
this.$hint.attr("dir", dir);
this.trigger("langDirChanged", dir);
}
},
_setQuery: function setQuery(val, silent) {
var areEquivalent, hasDifferentWhitespace;
areEquivalent = areQueriesEquivalent(val, this.query);
hasDifferentWhitespace = areEquivalent ? this.query.length !== val.length : false;
this.query = val;
if (!silent && !areEquivalent) {
this.trigger("queryChanged", this.query);
} else if (!silent && hasDifferentWhitespace) {
this.trigger("whitespaceChanged", this.query);
}
},
bind: function() {
var that = this, onBlur, onFocus, onKeydown, onInput;
onBlur = _.bind(this._onBlur, this);
onFocus = _.bind(this._onFocus, this);
onKeydown = _.bind(this._onKeydown, this);
onInput = _.bind(this._onInput, this);
this.$input.on("blur.tt", onBlur).on("focus.tt", onFocus).on("keydown.tt", onKeydown);
if (!_.isMsie() || _.isMsie() > 9) {
this.$input.on("input.tt", onInput);
} else {
this.$input.on("keydown.tt keypress.tt cut.tt paste.tt", function($e) {
if (specialKeyCodeMap[$e.which || $e.keyCode]) {
return;
}
_.defer(_.bind(that._onInput, that, $e));
});
}
return this;
},
focus: function focus() {
this.$input.focus();
},
blur: function blur() {
this.$input.blur();
},
getLangDir: function getLangDir() {
return this.dir;
},
getQuery: function getQuery() {
return this.query || "";
},
setQuery: function setQuery(val, silent) {
this.setInputValue(val);
this._setQuery(val, silent);
},
hasQueryChangedSinceLastFocus: function hasQueryChangedSinceLastFocus() {
return this.query !== this.queryWhenFocused;
},
getInputValue: function getInputValue() {
return this.$input.val();
},
setInputValue: function setInputValue(value) {
this.$input.val(value);
this.clearHintIfInvalid();
this._checkLanguageDirection();
},
resetInputValue: function resetInputValue() {
this.setInputValue(this.query);
},
getHint: function getHint() {
return this.$hint.val();
},
setHint: function setHint(value) {
this.$hint.val(value);
},
clearHint: function clearHint() {
this.setHint("");
},
clearHintIfInvalid: function clearHintIfInvalid() {
var val, hint, valIsPrefixOfHint, isValid;
val = this.getInputValue();
hint = this.getHint();
valIsPrefixOfHint = val !== hint && hint.indexOf(val) === 0;
isValid = val !== "" && valIsPrefixOfHint && !this.hasOverflow();
!isValid && this.clearHint();
},
hasFocus: function hasFocus() {
return this.$input.is(":focus");
},
hasOverflow: function hasOverflow() {
var constraint = this.$input.width() - 2;
this.$overflowHelper.text(this.getInputValue());
return this.$overflowHelper.width() >= constraint;
},
isCursorAtEnd: function() {
var valueLength, selectionStart, range;
valueLength = this.$input.val().length;
selectionStart = this.$input[0].selectionStart;
if (_.isNumber(selectionStart)) {
return selectionStart === valueLength;
} else if (document.selection) {
range = document.selection.createRange();
range.moveStart("character", -valueLength);
return valueLength === range.text.length;
}
return true;
},
destroy: function destroy() {
this.$hint.off(".tt");
this.$input.off(".tt");
this.$overflowHelper.remove();
this.$hint = this.$input = this.$overflowHelper = $("<div>");
}
});
return Input;
function buildOverflowHelper($input) {
return $('<pre aria-hidden="true"></pre>').css({
position: "absolute",
visibility: "hidden",
whiteSpace: "pre",
fontFamily: $input.css("font-family"),
fontSize: $input.css("font-size"),
fontStyle: $input.css("font-style"),
fontVariant: $input.css("font-variant"),
fontWeight: $input.css("font-weight"),
wordSpacing: $input.css("word-spacing"),
letterSpacing: $input.css("letter-spacing"),
textIndent: $input.css("text-indent"),
textRendering: $input.css("text-rendering"),
textTransform: $input.css("text-transform")
}).insertAfter($input);
}
function areQueriesEquivalent(a, b) {
return Input.normalizeQuery(a) === Input.normalizeQuery(b);
}
function withModifier($e) {
return $e.altKey || $e.ctrlKey || $e.metaKey || $e.shiftKey;
}
}();
var Dataset = function() {
"use strict";
var keys, nameGenerator;
keys = {
val: "tt-selectable-display",
obj: "tt-selectable-object"
};
nameGenerator = _.getIdGenerator();
function Dataset(o, www) {
o = o || {};
o.templates = o.templates || {};
o.templates.notFound = o.templates.notFound || o.templates.empty;
if (!o.source) {
$.error("missing source");
}
if (!o.node) {
$.error("missing node");
}
if (o.name && !isValidName(o.name)) {
$.error("invalid dataset name: " + o.name);
}
www.mixin(this);
this.highlight = !!o.highlight;
this.name = o.name || nameGenerator();
this.limit = o.limit || 5;
this.displayFn = getDisplayFn(o.display || o.displayKey);
this.templates = getTemplates(o.templates, this.displayFn);
this.source = o.source.__ttAdapter ? o.source.__ttAdapter() : o.source;
this.async = _.isUndefined(o.async) ? this.source.length > 2 : !!o.async;
this._resetLastSuggestion();
this.$el = $(o.node).addClass(this.classes.dataset).addClass(this.classes.dataset + "-" + this.name);
}
Dataset.extractData = function extractData(el) {
var $el = $(el);
if ($el.data(keys.obj)) {
return {
val: $el.data(keys.val) || "",
obj: $el.data(keys.obj) || null
};
}
return null;
};
_.mixin(Dataset.prototype, EventEmitter, {
_overwrite: function overwrite(query, suggestions) {
suggestions = suggestions || [];
if (suggestions.length) {
this._renderSuggestions(query, suggestions);
} else if (this.async && this.templates.pending) {
this._renderPending(query);
} else if (!this.async && this.templates.notFound) {
this._renderNotFound(query);
} else {
this._empty();
}
this.trigger("rendered", this.name, suggestions, false);
},
_append: function append(query, suggestions) {
suggestions = suggestions || [];
if (suggestions.length && this.$lastSuggestion.length) {
this._appendSuggestions(query, suggestions);
} else if (suggestions.length) {
this._renderSuggestions(query, suggestions);
} else if (!this.$lastSuggestion.length && this.templates.notFound) {
this._renderNotFound(query);
}
this.trigger("rendered", this.name, suggestions, true);
},
_renderSuggestions: function renderSuggestions(query, suggestions) {
var $fragment;
$fragment = this._getSuggestionsFragment(query, suggestions);
this.$lastSuggestion = $fragment.children().last();
this.$el.html($fragment).prepend(this._getHeader(query, suggestions)).append(this._getFooter(query, suggestions));
},
_appendSuggestions: function appendSuggestions(query, suggestions) {
var $fragment, $lastSuggestion;
$fragment = this._getSuggestionsFragment(query, suggestions);
$lastSuggestion = $fragment.children().last();
this.$lastSuggestion.after($fragment);
this.$lastSuggestion = $lastSuggestion;
},
_renderPending: function renderPending(query) {
var template = this.templates.pending;
this._resetLastSuggestion();
template && this.$el.html(template({
query: query,
dataset: this.name
}));
},
_renderNotFound: function renderNotFound(query) {
var template = this.templates.notFound;
this._resetLastSuggestion();
template && this.$el.html(template({
query: query,
dataset: this.name
}));
},
_empty: function empty() {
this.$el.empty();
this._resetLastSuggestion();
},
_getSuggestionsFragment: function getSuggestionsFragment(query, suggestions) {
var that = this, fragment;
fragment = document.createDocumentFragment();
_.each(suggestions, function getSuggestionNode(suggestion) {
var $el, context;
context = that._injectQuery(query, suggestion);
$el = $(that.templates.suggestion(context)).data(keys.obj, suggestion).data(keys.val, that.displayFn(suggestion)).addClass(that.classes.suggestion + " " + that.classes.selectable);
fragment.appendChild($el[0]);
});
this.highlight && highlight({
className: this.classes.highlight,
node: fragment,
pattern: query
});
return $(fragment);
},
_getFooter: function getFooter(query, suggestions) {
return this.templates.footer ? this.templates.footer({
query: query,
suggestions: suggestions,
dataset: this.name
}) : null;
},
_getHeader: function getHeader(query, suggestions) {
return this.templates.header ? this.templates.header({
query: query,
suggestions: suggestions,
dataset: this.name
}) : null;
},
_resetLastSuggestion: function resetLastSuggestion() {
this.$lastSuggestion = $();
},
_injectQuery: function injectQuery(query, obj) {
return _.isObject(obj) ? _.mixin({
_query: query
}, obj) : obj;
},
update: function update(query) {
var that = this, canceled = false, syncCalled = false, rendered = 0;
this.cancel();
this.cancel = function cancel() {
canceled = true;
that.cancel = $.noop;
that.async && that.trigger("asyncCanceled", query);
};
this.source(query, sync, async);
!syncCalled && sync([]);
function sync(suggestions) {
if (syncCalled) {
return;
}
syncCalled = true;
suggestions = (suggestions || []).slice(0, that.limit);
rendered = suggestions.length;
that._overwrite(query, suggestions);
if (rendered < that.limit && that.async) {
that.trigger("asyncRequested", query);
}
}
function async(suggestions) {
suggestions = suggestions || [];
if (!canceled && rendered < that.limit) {
that.cancel = $.noop;
rendered += suggestions.length;
that._append(query, suggestions.slice(0, that.limit - rendered));
that.async && that.trigger("asyncReceived", query);
}
}
},
cancel: $.noop,
clear: function clear() {
this._empty();
this.cancel();
this.trigger("cleared");
},
isEmpty: function isEmpty() {
return this.$el.is(":empty");
},
destroy: function destroy() {
this.$el = $("<div>");
}
});
return Dataset;
function getDisplayFn(display) {
display = display || _.stringify;
return _.isFunction(display) ? display : displayFn;
function displayFn(obj) {
return obj[display];
}
}
function getTemplates(templates, displayFn) {
return {
notFound: templates.notFound && _.templatify(templates.notFound),
pending: templates.pending && _.templatify(templates.pending),
header: templates.header && _.templatify(templates.header),
footer: templates.footer && _.templatify(templates.footer),
suggestion: templates.suggestion || suggestionTemplate
};
function suggestionTemplate(context) {
return $("<div>").text(displayFn(context));
}
}
function isValidName(str) {
return /^[_a-zA-Z0-9-]+$/.test(str);
}
}();
var Menu = function() {
"use strict";
function Menu(o, www) {
var that = this;
o = o || {};
if (!o.node) {
$.error("node is required");
}
www.mixin(this);
this.$node = $(o.node);
this.query = null;
this.datasets = _.map(o.datasets, initializeDataset);
function initializeDataset(oDataset) {
var node = that.$node.find(oDataset.node).first();
oDataset.node = node.length ? node : $("<div>").appendTo(that.$node);
return new Dataset(oDataset, www);
}
}
_.mixin(Menu.prototype, EventEmitter, {
_onSelectableClick: function onSelectableClick($e) {
this.trigger("selectableClicked", $($e.currentTarget));
},
_onRendered: function onRendered(type, dataset, suggestions, async) {
this.$node.toggleClass(this.classes.empty, this._allDatasetsEmpty());
this.trigger("datasetRendered", dataset, suggestions, async);
},
_onCleared: function onCleared() {
this.$node.toggleClass(this.classes.empty, this._allDatasetsEmpty());
this.trigger("datasetCleared");
},
_propagate: function propagate() {
this.trigger.apply(this, arguments);
},
_allDatasetsEmpty: function allDatasetsEmpty() {
return _.every(this.datasets, isDatasetEmpty);
function isDatasetEmpty(dataset) {
return dataset.isEmpty();
}
},
_getSelectables: function getSelectables() {
return this.$node.find(this.selectors.selectable);
},
_removeCursor: function _removeCursor() {
var $selectable = this.getActiveSelectable();
$selectable && $selectable.removeClass(this.classes.cursor);
},
_ensureVisible: function ensureVisible($el) {
var elTop, elBottom, nodeScrollTop, nodeHeight;
elTop = $el.position().top;
elBottom = elTop + $el.outerHeight(true);
nodeScrollTop = this.$node.scrollTop();
nodeHeight = this.$node.height() + parseInt(this.$node.css("paddingTop"), 10) + parseInt(this.$node.css("paddingBottom"), 10);
if (elTop < 0) {
this.$node.scrollTop(nodeScrollTop + elTop);
} else if (nodeHeight < elBottom) {
this.$node.scrollTop(nodeScrollTop + (elBottom - nodeHeight));
}
},
bind: function() {
var that = this, onSelectableClick;
onSelectableClick = _.bind(this._onSelectableClick, this);
this.$node.on("click.tt", this.selectors.selectable, onSelectableClick);
_.each(this.datasets, function(dataset) {
dataset.onSync("asyncRequested", that._propagate, that).onSync("asyncCanceled", that._propagate, that).onSync("asyncReceived", that._propagate, that).onSync("rendered", that._onRendered, that).onSync("cleared", that._onCleared, that);
});
return this;
},
isOpen: function isOpen() {
return this.$node.hasClass(this.classes.open);
},
open: function open() {
this.$node.addClass(this.classes.open);
},
close: function close() {
this.$node.removeClass(this.classes.open);
this._removeCursor();
},
setLanguageDirection: function setLanguageDirection(dir) {
this.$node.attr("dir", dir);
},
selectableRelativeToCursor: function selectableRelativeToCursor(delta) {
var $selectables, $oldCursor, oldIndex, newIndex;
$oldCursor = this.getActiveSelectable();
$selectables = this._getSelectables();
oldIndex = $oldCursor ? $selectables.index($oldCursor) : -1;
newIndex = oldIndex + delta;
newIndex = (newIndex + 1) % ($selectables.length + 1) - 1;
newIndex = newIndex < -1 ? $selectables.length - 1 : newIndex;
return newIndex === -1 ? null : $selectables.eq(newIndex);
},
setCursor: function setCursor($selectable) {
this._removeCursor();
if ($selectable = $selectable && $selectable.first()) {
$selectable.addClass(this.classes.cursor);
this._ensureVisible($selectable);
}
},
getSelectableData: function getSelectableData($el) {
return $el && $el.length ? Dataset.extractData($el) : null;
},
getActiveSelectable: function getActiveSelectable() {
var $selectable = this._getSelectables().filter(this.selectors.cursor).first();
return $selectable.length ? $selectable : null;
},
getTopSelectable: function getTopSelectable() {
var $selectable = this._getSelectables().first();
return $selectable.length ? $selectable : null;
},
update: function update(query) {
var isValidUpdate = query !== this.query;
if (isValidUpdate) {
this.query = query;
_.each(this.datasets, updateDataset);
}
return isValidUpdate;
function updateDataset(dataset) {
dataset.update(query);
}
},
empty: function empty() {
_.each(this.datasets, clearDataset);
this.query = null;
this.$node.addClass(this.classes.empty);
function clearDataset(dataset) {
dataset.clear();
}
},
destroy: function destroy() {
this.$node.off(".tt");
this.$node = $("<div>");
_.each(this.datasets, destroyDataset);
function destroyDataset(dataset) {
dataset.destroy();
}
}
});
return Menu;
}();
var DefaultMenu = function() {
"use strict";
var s = Menu.prototype;
function DefaultMenu() {
Menu.apply(this, [].slice.call(arguments, 0));
}
_.mixin(DefaultMenu.prototype, Menu.prototype, {
open: function open() {
!this._allDatasetsEmpty() && this._show();
return s.open.apply(this, [].slice.call(arguments, 0));
},
close: function close() {
this._hide();
return s.close.apply(this, [].slice.call(arguments, 0));
},
_onRendered: function onRendered() {
if (this._allDatasetsEmpty()) {
this._hide();
} else {
this.isOpen() && this._show();
}
return s._onRendered.apply(this, [].slice.call(arguments, 0));
},
_onCleared: function onCleared() {
if (this._allDatasetsEmpty()) {
this._hide();
} else {
this.isOpen() && this._show();
}
return s._onCleared.apply(this, [].slice.call(arguments, 0));
},
setLanguageDirection: function setLanguageDirection(dir) {
this.$node.css(dir === "ltr" ? this.css.ltr : this.css.rtl);
return s.setLanguageDirection.apply(this, [].slice.call(arguments, 0));
},
_hide: function hide() {
this.$node.hide();
},
_show: function show() {
this.$node.css("display", "block");
}
});
return DefaultMenu;
}();
var Typeahead = function() {
"use strict";
function Typeahead(o, www) {
var onFocused, onBlurred, onEnterKeyed, onTabKeyed, onEscKeyed, onUpKeyed, onDownKeyed, onLeftKeyed, onRightKeyed, onQueryChanged, onWhitespaceChanged;
o = o || {};
if (!o.input) {
$.error("missing input");
}
if (!o.menu) {
$.error("missing menu");
}
if (!o.eventBus) {
$.error("missing event bus");
}
www.mixin(this);
this.eventBus = o.eventBus;
this.minLength = _.isNumber(o.minLength) ? o.minLength : 1;
this.input = o.input;
this.menu = o.menu;
this.enabled = true;
this.active = false;
this.input.hasFocus() && this.activate();
this.dir = this.input.getLangDir();
this._hacks();
this.menu.bind().onSync("selectableClicked", this._onSelectableClicked, this).onSync("asyncRequested", this._onAsyncRequested, this).onSync("asyncCanceled", this._onAsyncCanceled, this).onSync("asyncReceived", this._onAsyncReceived, this).onSync("datasetRendered", this._onDatasetRendered, this).onSync("datasetCleared", this._onDatasetCleared, this);
onFocused = c(this, "activate", "open", "_onFocused");
onBlurred = c(this, "deactivate", "_onBlurred");
onEnterKeyed = c(this, "isActive", "isOpen", "_onEnterKeyed");
onTabKeyed = c(this, "isActive", "isOpen", "_onTabKeyed");
onEscKeyed = c(this, "isActive", "_onEscKeyed");
onUpKeyed = c(this, "isActive", "open", "_onUpKeyed");
onDownKeyed = c(this, "isActive", "open", "_onDownKeyed");
onLeftKeyed = c(this, "isActive", "isOpen", "_onLeftKeyed");
onRightKeyed = c(this, "isActive", "isOpen", "_onRightKeyed");
onQueryChanged = c(this, "_openIfActive", "_onQueryChanged");
onWhitespaceChanged = c(this, "_openIfActive", "_onWhitespaceChanged");
this.input.bind().onSync("focused", onFocused, this).onSync("blurred", onBlurred, this).onSync("enterKeyed", onEnterKeyed, this).onSync("tabKeyed", onTabKeyed, this).onSync("escKeyed", onEscKeyed, this).onSync("upKeyed", onUpKeyed, this).onSync("downKeyed", onDownKeyed, this).onSync("leftKeyed", onLeftKeyed, this).onSync("rightKeyed", onRightKeyed, this).onSync("queryChanged", onQueryChanged, this).onSync("whitespaceChanged", onWhitespaceChanged, this).onSync("langDirChanged", this._onLangDirChanged, this);
}
_.mixin(Typeahead.prototype, {
_hacks: function hacks() {
var $input, $menu;
$input = this.input.$input || $("<div>");
$menu = this.menu.$node || $("<div>");
$input.on("blur.tt", function($e) {
var active, isActive, hasActive;
active = document.activeElement;
isActive = $menu.is(active);
hasActive = $menu.has(active).length > 0;
if (_.isMsie() && (isActive || hasActive)) {
$e.preventDefault();
$e.stopImmediatePropagation();
_.defer(function() {
$input.focus();
});
}
});
$menu.on("mousedown.tt", function($e) {
$e.preventDefault();
});
},
_onSelectableClicked: function onSelectableClicked(type, $el) {
this.select($el);
},
_onDatasetCleared: function onDatasetCleared() {
this._updateHint();
},
_onDatasetRendered: function onDatasetRendered(type, dataset, suggestions, async) {
this._updateHint();
this.eventBus.trigger("render", suggestions, async, dataset);
},
_onAsyncRequested: function onAsyncRequested(type, dataset, query) {
this.eventBus.trigger("asyncrequest", query, dataset);
},
_onAsyncCanceled: function onAsyncCanceled(type, dataset, query) {
this.eventBus.trigger("asynccancel", query, dataset);
},
_onAsyncReceived: function onAsyncReceived(type, dataset, query) {
this.eventBus.trigger("asyncreceive", query, dataset);
},
_onFocused: function onFocused() {
this._minLengthMet() && this.menu.update(this.input.getQuery());
},
_onBlurred: function onBlurred() {
if (this.input.hasQueryChangedSinceLastFocus()) {
this.eventBus.trigger("change", this.input.getQuery());
}
},
_onEnterKeyed: function onEnterKeyed(type, $e) {
var $selectable;
if ($selectable = this.menu.getActiveSelectable()) {
this.select($selectable) && $e.preventDefault();
}
},
_onTabKeyed: function onTabKeyed(type, $e) {
var $selectable;
if ($selectable = this.menu.getActiveSelectable()) {
this.select($selectable) && $e.preventDefault();
} else if ($selectable = this.menu.getTopSelectable()) {
this.autocomplete($selectable) && $e.preventDefault();
}
},
_onEscKeyed: function onEscKeyed() {
this.close();
},
_onUpKeyed: function onUpKeyed() {
this.moveCursor(-1);
},
_onDownKeyed: function onDownKeyed() {
this.moveCursor(+1);
},
_onLeftKeyed: function onLeftKeyed() {
if (this.dir === "rtl" && this.input.isCursorAtEnd()) {
this.autocomplete(this.menu.getTopSelectable());
}
},
_onRightKeyed: function onRightKeyed() {
if (this.dir === "ltr" && this.input.isCursorAtEnd()) {
this.autocomplete(this.menu.getTopSelectable());
}
},
_onQueryChanged: function onQueryChanged(e, query) {
this._minLengthMet(query) ? this.menu.update(query) : this.menu.empty();
},
_onWhitespaceChanged: function onWhitespaceChanged() {
this._updateHint();
},
_onLangDirChanged: function onLangDirChanged(e, dir) {
if (this.dir !== dir) {
this.dir = dir;
this.menu.setLanguageDirection(dir);
}
},
_openIfActive: function openIfActive() {
this.isActive() && this.open();
},
_minLengthMet: function minLengthMet(query) {
query = _.isString(query) ? query : this.input.getQuery() || "";
return query.length >= this.minLength;
},
_updateHint: function updateHint() {
var $selectable, data, val, query, escapedQuery, frontMatchRegEx, match;
$selectable = this.menu.getTopSelectable();
data = this.menu.getSelectableData($selectable);
val = this.input.getInputValue();
if (data && !_.isBlankString(val) && !this.input.hasOverflow()) {
query = Input.normalizeQuery(val);
escapedQuery = _.escapeRegExChars(query);
frontMatchRegEx = new RegExp("^(?:" + escapedQuery + ")(.+$)", "i");
match = frontMatchRegEx.exec(data.val);
match && this.input.setHint(val + match[1]);
} else {
this.input.clearHint();
}
},
isEnabled: function isEnabled() {
return this.enabled;
},
enable: function enable() {
this.enabled = true;
},
disable: function disable() {
this.enabled = false;
},
isActive: function isActive() {
return this.active;
},
activate: function activate() {
if (this.isActive()) {
return true;
} else if (!this.isEnabled() || this.eventBus.before("active")) {
return false;
} else {
this.active = true;
this.eventBus.trigger("active");
return true;
}
},
deactivate: function deactivate() {
if (!this.isActive()) {
return true;
} else if (this.eventBus.before("idle")) {
return false;
} else {
this.active = false;
this.close();
this.eventBus.trigger("idle");
return true;
}
},
isOpen: function isOpen() {
return this.menu.isOpen();
},
open: function open() {
if (!this.isOpen() && !this.eventBus.before("open")) {
this.menu.open();
this._updateHint();
this.eventBus.trigger("open");
}
return this.isOpen();
},
close: function close() {
if (this.isOpen() && !this.eventBus.before("close")) {
this.menu.close();
this.input.clearHint();
this.input.resetInputValue();
this.eventBus.trigger("close");
}
return !this.isOpen();
},
setVal: function setVal(val) {
this.input.setQuery(_.toStr(val));
},
getVal: function getVal() {
return this.input.getQuery();
},
select: function select($selectable) {
var data = this.menu.getSelectableData($selectable);
if (data && !this.eventBus.before("select", data.obj)) {
this.input.setQuery(data.val, true);
this.eventBus.trigger("select", data.obj);
this.close();
return true;
}
return false;
},
autocomplete: function autocomplete($selectable) {
var query, data, isValid;
query = this.input.getQuery();
data = this.menu.getSelectableData($selectable);
isValid = data && query !== data.val;
if (isValid && !this.eventBus.before("autocomplete", data.obj)) {
this.input.setQuery(data.val);
this.eventBus.trigger("autocomplete", data.obj);
return true;
}
return false;
},
moveCursor: function moveCursor(delta) {
var query, $candidate, data, payload, cancelMove;
query = this.input.getQuery();
$candidate = this.menu.selectableRelativeToCursor(delta);
data = this.menu.getSelectableData($candidate);
payload = data ? data.obj : null;
cancelMove = this._minLengthMet() && this.menu.update(query);
if (!cancelMove && !this.eventBus.before("cursorchange", payload)) {
this.menu.setCursor($candidate);
if (data) {
this.input.setInputValue(data.val);
} else {
this.input.resetInputValue();
this._updateHint();
}
this.eventBus.trigger("cursorchange", payload);
return true;
}
return false;
},
destroy: function destroy() {
this.input.destroy();
this.menu.destroy();
}
});
return Typeahead;
function c(ctx) {
var methods = [].slice.call(arguments, 1);
return function() {
var args = [].slice.call(arguments);
_.each(methods, function(method) {
return ctx[method].apply(ctx, args);
});
};
}
}();
(function() {
"use strict";
var old, keys, methods;
old = $.fn.typeahead;
keys = {
www: "tt-www",
attrs: "tt-attrs",
typeahead: "tt-typeahead"
};
methods = {
initialize: function initialize(o, datasets) {
var www;
datasets = _.isArray(datasets) ? datasets : [].slice.call(arguments, 1);
o = o || {};
www = WWW(o.classNames);
return this.each(attach);
function attach() {
var $input, $wrapper, $hint, $menu, defaultHint, defaultMenu, eventBus, input, menu, typeahead, MenuConstructor;
_.each(datasets, function(d) {
d.highlight = !!o.highlight;
});
$input = $(this);
$wrapper = $(www.html.wrapper);
$hint = $elOrNull(o.hint);
$menu = $elOrNull(o.menu);
defaultHint = o.hint !== false && !$hint;
defaultMenu = o.menu !== false && !$menu;
defaultHint && ($hint = buildHintFromInput($input, www));
defaultMenu && ($menu = $(www.html.menu).css(www.css.menu));
$hint && $hint.val("");
$input = prepInput($input, www);
if (defaultHint || defaultMenu) {
$wrapper.css(www.css.wrapper);
$input.css(defaultHint ? www.css.input : www.css.inputWithNoHint);
$input.wrap($wrapper).parent().prepend(defaultHint ? $hint : null).append(defaultMenu ? $menu : null);
}
MenuConstructor = defaultMenu ? DefaultMenu : Menu;
eventBus = new EventBus({
el: $input
});
input = new Input({
hint: $hint,
input: $input
}, www);
menu = new MenuConstructor({
node: $menu,
datasets: datasets
}, www);
typeahead = new Typeahead({
input: input,
menu: menu,
eventBus: eventBus,
minLength: o.minLength
}, www);
$input.data(keys.www, www);
$input.data(keys.typeahead, typeahead);
}
},
isEnabled: function isEnabled() {
var enabled;
ttEach(this.first(), function(t) {
enabled = t.isEnabled();
});
return enabled;
},
enable: function enable() {
ttEach(this, function(t) {
t.enable();
});
return this;
},
disable: function disable() {
ttEach(this, function(t) {
t.disable();
});
return this;
},
isActive: function isActive() {
var active;
ttEach(this.first(), function(t) {
active = t.isActive();
});
return active;
},
activate: function activate() {
ttEach(this, function(t) {
t.activate();
});
return this;
},
deactivate: function deactivate() {
ttEach(this, function(t) {
t.deactivate();
});
return this;
},
isOpen: function isOpen() {
var open;
ttEach(this.first(), function(t) {
open = t.isOpen();
});
return open;
},
open: function open() {
ttEach(this, function(t) {
t.open();
});
return this;
},
close: function close() {
ttEach(this, function(t) {
t.close();
});
return this;
},
select: function select(el) {
var success = false, $el = $(el);
ttEach(this.first(), function(t) {
success = t.select($el);
});
return success;
},
autocomplete: function autocomplete(el) {
var success = false, $el = $(el);
ttEach(this.first(), function(t) {
success = t.autocomplete($el);
});
return success;
},
moveCursor: function moveCursoe(delta) {
var success = false;
ttEach(this.first(), function(t) {
success = t.moveCursor(delta);
});
return success;
},
val: function val(newVal) {
var query;
if (!arguments.length) {
ttEach(this.first(), function(t) {
query = t.getVal();
});
return query;
} else {
ttEach(this, function(t) {
t.setVal(newVal);
});
return this;
}
},
destroy: function destroy() {
ttEach(this, function(typeahead, $input) {
revert($input);
typeahead.destroy();
});
return this;
}
};
$.fn.typeahead = function(method) {
if (methods[method]) {
return methods[method].apply(this, [].slice.call(arguments, 1));
} else {
return methods.initialize.apply(this, arguments);
}
};
$.fn.typeahead.noConflict = function noConflict() {
$.fn.typeahead = old;
return this;
};
function ttEach($els, fn) {
$els.each(function() {
var $input = $(this), typeahead;
(typeahead = $input.data(keys.typeahead)) && fn(typeahead, $input);
});
}
function buildHintFromInput($input, www) {
return $input.clone().addClass(www.classes.hint).removeData().css(www.css.hint).css(getBackgroundStyles($input)).prop("readonly", true).removeAttr("id name placeholder required").attr({
autocomplete: "off",
spellcheck: "false",
tabindex: -1
});
}
function prepInput($input, www) {
$input.data(keys.attrs, {
dir: $input.attr("dir"),
autocomplete: $input.attr("autocomplete"),
spellcheck: $input.attr("spellcheck"),
style: $input.attr("style")
});
$input.addClass(www.classes.input).attr({
autocomplete: "off",
spellcheck: false
});
try {
!$input.attr("dir") && $input.attr("dir", "auto");
} catch (e) {}
return $input;
}
function getBackgroundStyles($el) {
return {
backgroundAttachment: $el.css("background-attachment"),
backgroundClip: $el.css("background-clip"),
backgroundColor: $el.css("background-color"),
backgroundImage: $el.css("background-image"),
backgroundOrigin: $el.css("background-origin"),
backgroundPosition: $el.css("background-position"),
backgroundRepeat: $el.css("background-repeat"),
backgroundSize: $el.css("background-size")
};
}
function revert($input) {
var www, $wrapper;
www = $input.data(keys.www);
$wrapper = $input.parent().filter(www.selectors.wrapper);
_.each($input.data(keys.attrs), function(val, key) {
_.isUndefined(val) ? $input.removeAttr(key) : $input.attr(key, val);
});
$input.removeData(keys.typeahead).removeData(keys.www).removeData(keys.attr).removeClass(www.classes.input);
if ($wrapper.length) {
$input.detach().insertAfter($wrapper);
$wrapper.remove();
}
}
function $elOrNull(obj) {
var isValid, $el;
isValid = _.isJQuery(obj) || _.isElement(obj);
$el = isValid ? $(obj).first() : [];
return $el.length ? $el : null;
}
})();
});
(function webpackUniversalModuleDefinition(root, factory) {
if(typeof exports === 'object' && typeof module === 'object')
module.exports = factory();
else if(typeof define === 'function' && define.amd)
define([], factory);
else if(typeof exports === 'object')
exports["Handlebars"] = factory();
else
root["Handlebars"] = factory();
})(this, function() {
return (function(modules) { // webpackBootstrap 	// The module cache 	var installedModules = {};
'use strict';
var _interopRequireDefault = __webpack_require__(1)['default'];
exports.__esModule = true;
var _handlebarsRuntime = __webpack_require__(2);
var _handlebarsRuntime2 = _interopRequireDefault(_handlebarsRuntime);
var _handlebarsCompilerAst = __webpack_require__(35);
var _handlebarsCompilerAst2 = _interopRequireDefault(_handlebarsCompilerAst);
var _handlebarsCompilerBase = __webpack_require__(36);
var _handlebarsCompilerCompiler = __webpack_require__(41);
var _handlebarsCompilerJavascriptCompiler = __webpack_require__(42);
var _handlebarsCompilerJavascriptCompiler2 = _interopRequireDefault(_handlebarsCompilerJavascriptCompiler);
var _handlebarsCompilerVisitor = __webpack_require__(39);
var _handlebarsCompilerVisitor2 = _interopRequireDefault(_handlebarsCompilerVisitor);
var _handlebarsNoConflict = __webpack_require__(34);
var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);
var _create = _handlebarsRuntime2['default'].create;
function create() {
var hb = _create();
hb.compile = function (input, options) {
return _handlebarsCompilerCompiler.compile(input, options, hb);
};
hb.precompile = function (input, options) {
return _handlebarsCompilerCompiler.precompile(input, options, hb);
};
hb.AST = _handlebarsCompilerAst2['default'];
hb.Compiler = _handlebarsCompilerCompiler.Compiler;
hb.JavaScriptCompiler = _handlebarsCompilerJavascriptCompiler2['default'];
hb.Parser = _handlebarsCompilerBase.parser;
hb.parse = _handlebarsCompilerBase.parse;
return hb;
}
var inst = create();
inst.create = create;
_handlebarsNoConflict2['default'](inst);
inst.Visitor = _handlebarsCompilerVisitor2['default'];
inst['default'] = inst;
exports['default'] = inst;
module.exports = exports['default'];
}), (function(module, exports) {
"use strict";
exports["default"] = function (obj) {
return obj && obj.__esModule ? obj : {
"default": obj
};
};
exports.__esModule = true;
}), (function(module, exports, __webpack_require__) {
'use strict';
var _interopRequireWildcard = __webpack_require__(3)['default'];
var _interopRequireDefault = __webpack_require__(1)['default'];
exports.__esModule = true;
var _handlebarsBase = __webpack_require__(4);
var base = _interopRequireWildcard(_handlebarsBase);
var _handlebarsSafeString = __webpack_require__(21);
var _handlebarsSafeString2 = _interopRequireDefault(_handlebarsSafeString);
var _handlebarsException = __webpack_require__(6);
var _handlebarsException2 = _interopRequireDefault(_handlebarsException);
var _handlebarsUtils = __webpack_require__(5);
var Utils = _interopRequireWildcard(_handlebarsUtils);
var _handlebarsRuntime = __webpack_require__(22);
var runtime = _interopRequireWildcard(_handlebarsRuntime);
var _handlebarsNoConflict = __webpack_require__(34);
var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);
function create() {
var hb = new base.HandlebarsEnvironment();
Utils.extend(hb, base);
hb.SafeString = _handlebarsSafeString2['default'];
hb.Exception = _handlebarsException2['default'];
hb.Utils = Utils;
hb.escapeExpression = Utils.escapeExpression;
hb.VM = runtime;
hb.template = function (spec) {
return runtime.template(spec, hb);
};
return hb;
}
var inst = create();
inst.create = create;
_handlebarsNoConflict2['default'](inst);
inst['default'] = inst;
exports['default'] = inst;
module.exports = exports['default'];
}), (function(module, exports) {
"use strict";
exports["default"] = function (obj) {
if (obj && obj.__esModule) {
return obj;
} else {
var newObj = {};
if (obj != null) {
for (var key in obj) {
if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
}
}
newObj["default"] = obj;
return newObj;
}
};
exports.__esModule = true;
}), (function(module, exports, __webpack_require__) {
'use strict';
var _interopRequireDefault = __webpack_require__(1)['default'];
exports.__esModule = true;
exports.HandlebarsEnvironment = HandlebarsEnvironment;
var _utils = __webpack_require__(5);
var _exception = __webpack_require__(6);
var _exception2 = _interopRequireDefault(_exception);
var _helpers = __webpack_require__(10);
var _decorators = __webpack_require__(18);
var _logger = __webpack_require__(20);
var _logger2 = _interopRequireDefault(_logger);
var VERSION = '4.0.10';
exports.VERSION = VERSION;
var COMPILER_REVISION = 7;
exports.COMPILER_REVISION = COMPILER_REVISION;
var REVISION_CHANGES = {
1: '<= 1.0.rc.2', // 1.0.rc.2 is actually rev2 but doesn't report it
2: '== 1.0.0-rc.3',
3: '== 1.0.0-rc.4',
4: '== 1.x.x',
5: '== 2.0.0-alpha.x',
6: '>= 2.0.0-beta.1',
7: '>= 4.0.0'
};
exports.REVISION_CHANGES = REVISION_CHANGES;
var objectType = '[object Object]';
function HandlebarsEnvironment(helpers, partials, decorators) {
this.helpers = helpers || {};
this.partials = partials || {};
this.decorators = decorators || {};
_helpers.registerDefaultHelpers(this);
_decorators.registerDefaultDecorators(this);
}
HandlebarsEnvironment.prototype = {
constructor: HandlebarsEnvironment,
logger: _logger2['default'],
log: _logger2['default'].log,
registerHelper: function registerHelper(name, fn) {
if (_utils.toString.call(name) === objectType) {
if (fn) {
throw new _exception2['default']('Arg not supported with multiple helpers');
}
_utils.extend(this.helpers, name);
} else {
this.helpers[name] = fn;
}
},
unregisterHelper: function unregisterHelper(name) {
delete this.helpers[name];
},
registerPartial: function registerPartial(name, partial) {
if (_utils.toString.call(name) === objectType) {
_utils.extend(this.partials, name);
} else {
if (typeof partial === 'undefined') {
throw new _exception2['default']('Attempting to register a partial called "' + name + '" as undefined');
}
this.partials[name] = partial;
}
},
unregisterPartial: function unregisterPartial(name) {
delete this.partials[name];
},
registerDecorator: function registerDecorator(name, fn) {
if (_utils.toString.call(name) === objectType) {
if (fn) {
throw new _exception2['default']('Arg not supported with multiple decorators');
}
_utils.extend(this.decorators, name);
} else {
this.decorators[name] = fn;
}
},
unregisterDecorator: function unregisterDecorator(name) {
delete this.decorators[name];
}
};
var log = _logger2['default'].log;
exports.log = log;
exports.createFrame = _utils.createFrame;
exports.logger = _logger2['default'];
}), (function(module, exports) {
'use strict';
exports.__esModule = true;
exports.extend = extend;
exports.indexOf = indexOf;
exports.escapeExpression = escapeExpression;
exports.isEmpty = isEmpty;
exports.createFrame = createFrame;
exports.blockParams = blockParams;
exports.appendContextPath = appendContextPath;
var escape = {
'&': '&amp;',
'<': '&lt;',
'>': '&gt;',
'"': '&quot;',
"'": '&#x27;',
'`': '&#x60;',
'=': '&#x3D;'
};
var badChars = /[&<>"'`=]/g,
possible = /[&<>"'`=]/;
function escapeChar(chr) {
return escape[chr];
}
function extend(obj) {
for (var i = 1; i < arguments.length; i++) {
for (var key in arguments[i]) {
if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
obj[key] = arguments[i][key];
}
}
}
return obj;
}
var toString = Object.prototype.toString;
exports.toString = toString;
var isFunction = function isFunction(value) {
return typeof value === 'function';
};
if (isFunction(/x/)) {
exports.isFunction = isFunction = function (value) {
return typeof value === 'function' && toString.call(value) === '[object Function]';
};
}
exports.isFunction = isFunction;
var isArray = Array.isArray || function (value) {
return value && typeof value === 'object' ? toString.call(value) === '[object Array]' : false;
};
exports.isArray = isArray;
function indexOf(array, value) {
for (var i = 0, len = array.length; i < len; i++) {
if (array[i] === value) {
return i;
}
}
return -1;
}
function escapeExpression(string) {
if (typeof string !== 'string') {
if (string && string.toHTML) {
return string.toHTML();
} else if (string == null) {
return '';
} else if (!string) {
return string + '';
}
string = '' + string;
}
if (!possible.test(string)) {
return string;
}
return string.replace(badChars, escapeChar);
}
function isEmpty(value) {
if (!value && value !== 0) {
return true;
} else if (isArray(value) && value.length === 0) {
return true;
} else {
return false;
}
}
function createFrame(object) {
var frame = extend({}, object);
frame._parent = object;
return frame;
}
function blockParams(params, ids) {
params.path = ids;
return params;
}
function appendContextPath(contextPath, id) {
return (contextPath ? contextPath + '.' : '') + id;
}
}), (function(module, exports, __webpack_require__) {
'use strict';
var _Object$defineProperty = __webpack_require__(7)['default'];
exports.__esModule = true;
var errorProps = ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];
function Exception(message, node) {
var loc = node && node.loc,
line = undefined,
column = undefined;
if (loc) {
line = loc.start.line;
column = loc.start.column;
message += ' - ' + line + ':' + column;
}
var tmp = Error.prototype.constructor.call(this, message);
for (var idx = 0; idx < errorProps.length; idx++) {
this[errorProps[idx]] = tmp[errorProps[idx]];
}
if (Error.captureStackTrace) {
Error.captureStackTrace(this, Exception);
}
try {
if (loc) {
this.lineNumber = line;
if (_Object$defineProperty) {
Object.defineProperty(this, 'column', {
value: column,
enumerable: true
});
} else {
this.column = column;
}
}
} catch (nop) {
}
}
Exception.prototype = new Error();
exports['default'] = Exception;
module.exports = exports['default'];
}), (function(module, exports, __webpack_require__) {
module.exports = { "default": __webpack_require__(8), __esModule: true };
}), (function(module, exports, __webpack_require__) {
var $ = __webpack_require__(9);
module.exports = function defineProperty(it, key, desc){
return $.setDesc(it, key, desc);
};
}), (function(module, exports) {
var $Object = Object;
module.exports = {
create:     $Object.create,
getProto:   $Object.getPrototypeOf,
isEnum:     {}.propertyIsEnumerable,
getDesc:    $Object.getOwnPropertyDescriptor,
setDesc:    $Object.defineProperty,
setDescs:   $Object.defineProperties,
getKeys:    $Object.keys,
getNames:   $Object.getOwnPropertyNames,
getSymbols: $Object.getOwnPropertySymbols,
each:       [].forEach
};
}), (function(module, exports, __webpack_require__) {
'use strict';
var _interopRequireDefault = __webpack_require__(1)['default'];
exports.__esModule = true;
exports.registerDefaultHelpers = registerDefaultHelpers;
var _helpersBlockHelperMissing = __webpack_require__(11);
var _helpersBlockHelperMissing2 = _interopRequireDefault(_helpersBlockHelperMissing);
var _helpersEach = __webpack_require__(12);
var _helpersEach2 = _interopRequireDefault(_helpersEach);
var _helpersHelperMissing = __webpack_require__(13);
var _helpersHelperMissing2 = _interopRequireDefault(_helpersHelperMissing);
var _helpersIf = __webpack_require__(14);
var _helpersIf2 = _interopRequireDefault(_helpersIf);
var _helpersLog = __webpack_require__(15);
var _helpersLog2 = _interopRequireDefault(_helpersLog);
var _helpersLookup = __webpack_require__(16);
var _helpersLookup2 = _interopRequireDefault(_helpersLookup);
var _helpersWith = __webpack_require__(17);
var _helpersWith2 = _interopRequireDefault(_helpersWith);
function registerDefaultHelpers(instance) {
_helpersBlockHelperMissing2['default'](instance);
_helpersEach2['default'](instance);
_helpersHelperMissing2['default'](instance);
_helpersIf2['default'](instance);
_helpersLog2['default'](instance);
_helpersLookup2['default'](instance);
_helpersWith2['default'](instance);
}
}), (function(module, exports, __webpack_require__) {
'use strict';
exports.__esModule = true;
var _utils = __webpack_require__(5);
exports['default'] = function (instance) {
instance.registerHelper('blockHelperMissing', function (context, options) {
var inverse = options.inverse,
fn = options.fn;
if (context === true) {
return fn(this);
} else if (context === false || context == null) {
return inverse(this);
} else if (_utils.isArray(context)) {
if (context.length > 0) {
if (options.ids) {
options.ids = [options.name];
}
return instance.helpers.each(context, options);
} else {
return inverse(this);
}
} else {
if (options.data && options.ids) {
var data = _utils.createFrame(options.data);
data.contextPath = _utils.appendContextPath(options.data.contextPath, options.name);
options = { data: data };
}
return fn(context, options);
}
});
};
module.exports = exports['default'];
}), (function(module, exports, __webpack_require__) {
'use strict';
var _interopRequireDefault = __webpack_require__(1)['default'];
exports.__esModule = true;
var _utils = __webpack_require__(5);
var _exception = __webpack_require__(6);
var _exception2 = _interopRequireDefault(_exception);
exports['default'] = function (instance) {
instance.registerHelper('each', function (context, options) {
if (!options) {
throw new _exception2['default']('Must pass iterator to #each');
}
var fn = options.fn,
inverse = options.inverse,
i = 0,
ret = '',
data = undefined,
contextPath = undefined;
if (options.data && options.ids) {
contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]) + '.';
}
if (_utils.isFunction(context)) {
context = context.call(this);
}
if (options.data) {
data = _utils.createFrame(options.data);
}
function execIteration(field, index, last) {
if (data) {
data.key = field;
data.index = index;
data.first = index === 0;
data.last = !!last;
if (contextPath) {
data.contextPath = contextPath + field;
}
}
ret = ret + fn(context[field], {
data: data,
blockParams: _utils.blockParams([context[field], field], [contextPath + field, null])
});
}
if (context && typeof context === 'object') {
if (_utils.isArray(context)) {
for (var j = context.length; i < j; i++) {
if (i in context) {
execIteration(i, i, i === context.length - 1);
}
}
} else {
var priorKey = undefined;
for (var key in context) {
if (context.hasOwnProperty(key)) {
if (priorKey !== undefined) {
execIteration(priorKey, i - 1);
}
priorKey = key;
i++;
}
}
if (priorKey !== undefined) {
execIteration(priorKey, i - 1, true);
}
}
}
if (i === 0) {
ret = inverse(this);
}
return ret;
});
};
module.exports = exports['default'];
}), (function(module, exports, __webpack_require__) {
'use strict';
var _interopRequireDefault = __webpack_require__(1)['default'];
exports.__esModule = true;
var _exception = __webpack_require__(6);
var _exception2 = _interopRequireDefault(_exception);
exports['default'] = function (instance) {
instance.registerHelper('helperMissing', function (){
if (arguments.length === 1) {
return undefined;
} else {
throw new _exception2['default']('Missing helper: "' + arguments[arguments.length - 1].name + '"');
}
});
};
module.exports = exports['default'];
}), (function(module, exports, __webpack_require__) {
'use strict';
exports.__esModule = true;
var _utils = __webpack_require__(5);
exports['default'] = function (instance) {
instance.registerHelper('if', function (conditional, options) {
if (_utils.isFunction(conditional)) {
conditional = conditional.call(this);
}
if (!options.hash.includeZero && !conditional || _utils.isEmpty(conditional)) {
return options.inverse(this);
} else {
return options.fn(this);
}
});
instance.registerHelper('unless', function (conditional, options) {
return instance.helpers['if'].call(this, conditional, { fn: options.inverse, inverse: options.fn, hash: options.hash });
});
};
module.exports = exports['default'];
}), (function(module, exports) {
'use strict';
exports.__esModule = true;
exports['default'] = function (instance) {
instance.registerHelper('log', function (){
var args = [undefined],
options = arguments[arguments.length - 1];
for (var i = 0; i < arguments.length - 1; i++) {
args.push(arguments[i]);
}
var level = 1;
if (options.hash.level != null) {
level = options.hash.level;
} else if (options.data && options.data.level != null) {
level = options.data.level;
}
args[0] = level;
instance.log.apply(instance, args);
});
};
module.exports = exports['default'];
}), (function(module, exports) {
'use strict';
exports.__esModule = true;
exports['default'] = function (instance) {
instance.registerHelper('lookup', function (obj, field) {
return obj && obj[field];
});
};
module.exports = exports['default'];
}), (function(module, exports, __webpack_require__) {
'use strict';
exports.__esModule = true;
var _utils = __webpack_require__(5);
exports['default'] = function (instance) {
instance.registerHelper('with', function (context, options) {
if (_utils.isFunction(context)) {
context = context.call(this);
}
var fn = options.fn;
if (!_utils.isEmpty(context)) {
var data = options.data;
if (options.data && options.ids) {
data = _utils.createFrame(options.data);
data.contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]);
}
return fn(context, {
data: data,
blockParams: _utils.blockParams([context], [data && data.contextPath])
});
} else {
return options.inverse(this);
}
});
};
module.exports = exports['default'];
}), (function(module, exports, __webpack_require__) {
'use strict';
var _interopRequireDefault = __webpack_require__(1)['default'];
exports.__esModule = true;
exports.registerDefaultDecorators = registerDefaultDecorators;
var _decoratorsInline = __webpack_require__(19);
var _decoratorsInline2 = _interopRequireDefault(_decoratorsInline);
function registerDefaultDecorators(instance) {
_decoratorsInline2['default'](instance);
}
}), (function(module, exports, __webpack_require__) {
'use strict';
exports.__esModule = true;
var _utils = __webpack_require__(5);
exports['default'] = function (instance) {
instance.registerDecorator('inline', function (fn, props, container, options) {
var ret = fn;
if (!props.partials) {
props.partials = {};
ret = function (context, options) {
var original = container.partials;
container.partials = _utils.extend({}, original, props.partials);
var ret = fn(context, options);
container.partials = original;
return ret;
};
}
props.partials[options.args[0]] = options.fn;
return ret;
});
};
module.exports = exports['default'];
}), (function(module, exports, __webpack_require__) {
'use strict';
exports.__esModule = true;
var _utils = __webpack_require__(5);
var logger = {
methodMap: ['debug', 'info', 'warn', 'error'],
level: 'info',
lookupLevel: function lookupLevel(level) {
if (typeof level === 'string') {
var levelMap = _utils.indexOf(logger.methodMap, level.toLowerCase());
if (levelMap >= 0) {
level = levelMap;
} else {
level = parseInt(level, 10);
}
}
return level;
},
log: function log(level) {
level = logger.lookupLevel(level);
if (typeof console !== 'undefined' && logger.lookupLevel(logger.level) <= level) {
var method = logger.methodMap[level];
if (!console[method]) {
method = 'log';
}
for (var _len = arguments.length, message = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
message[_key - 1] = arguments[_key];
}
console[method].apply(console, message); // eslint-disable-line no-console
}
}
};
exports['default'] = logger;
module.exports = exports['default'];
}), (function(module, exports) {
'use strict';
exports.__esModule = true;
function SafeString(string) {
this.string = string;
}
SafeString.prototype.toString = SafeString.prototype.toHTML = function () {
return '' + this.string;
};
exports['default'] = SafeString;
module.exports = exports['default'];
}), (function(module, exports, __webpack_require__) {
'use strict';
var _Object$seal = __webpack_require__(23)['default'];
var _interopRequireWildcard = __webpack_require__(3)['default'];
var _interopRequireDefault = __webpack_require__(1)['default'];
exports.__esModule = true;
exports.checkRevision = checkRevision;
exports.template = template;
exports.wrapProgram = wrapProgram;
exports.resolvePartial = resolvePartial;
exports.invokePartial = invokePartial;
exports.noop = noop;
var _utils = __webpack_require__(5);
var Utils = _interopRequireWildcard(_utils);
var _exception = __webpack_require__(6);
var _exception2 = _interopRequireDefault(_exception);
var _base = __webpack_require__(4);
function checkRevision(compilerInfo) {
var compilerRevision = compilerInfo && compilerInfo[0] || 1,
currentRevision = _base.COMPILER_REVISION;
if (compilerRevision !== currentRevision) {
if (compilerRevision < currentRevision) {
var runtimeVersions = _base.REVISION_CHANGES[currentRevision],
compilerVersions = _base.REVISION_CHANGES[compilerRevision];
throw new _exception2['default']('Template was precompiled with an older version of Handlebars than the current runtime. ' + 'Please update your precompiler to a newer version (' + runtimeVersions + ') or downgrade your runtime to an older version (' + compilerVersions + ').');
} else {
throw new _exception2['default']('Template was precompiled with a newer version of Handlebars than the current runtime. ' + 'Please update your runtime to a newer version (' + compilerInfo[1] + ').');
}
}
}
function template(templateSpec, env) {
if (!env) {
throw new _exception2['default']('No environment passed to template');
}
if (!templateSpec || !templateSpec.main) {
throw new _exception2['default']('Unknown template object: ' + typeof templateSpec);
}
templateSpec.main.decorator = templateSpec.main_d;
env.VM.checkRevision(templateSpec.compiler);
function invokePartialWrapper(partial, context, options) {
if (options.hash) {
context = Utils.extend({}, context, options.hash);
if (options.ids) {
options.ids[0] = true;
}
}
partial = env.VM.resolvePartial.call(this, partial, context, options);
var result = env.VM.invokePartial.call(this, partial, context, options);
if (result == null && env.compile) {
options.partials[options.name] = env.compile(partial, templateSpec.compilerOptions, env);
result = options.partials[options.name](context, options);
}
if (result != null) {
if (options.indent) {
var lines = result.split('\n');
for (var i = 0, l = lines.length; i < l; i++) {
if (!lines[i] && i + 1 === l) {
break;
}
lines[i] = options.indent + lines[i];
}
result = lines.join('\n');
}
return result;
} else {
throw new _exception2['default']('The partial ' + options.name + ' could not be compiled when running in runtime-only mode');
}
}
var container = {
strict: function strict(obj, name) {
if (!(name in obj)) {
throw new _exception2['default']('"' + name + '" not defined in ' + obj);
}
return obj[name];
},
lookup: function lookup(depths, name) {
var len = depths.length;
for (var i = 0; i < len; i++) {
if (depths[i] && depths[i][name] != null) {
return depths[i][name];
}
}
},
lambda: function lambda(current, context) {
return typeof current === 'function' ? current.call(context) : current;
},
escapeExpression: Utils.escapeExpression,
invokePartial: invokePartialWrapper,
fn: function fn(i) {
var ret = templateSpec[i];
ret.decorator = templateSpec[i + '_d'];
return ret;
},
programs: [],
program: function program(i, data, declaredBlockParams, blockParams, depths) {
var programWrapper = this.programs[i],
fn = this.fn(i);
if (data || depths || blockParams || declaredBlockParams) {
programWrapper = wrapProgram(this, i, fn, data, declaredBlockParams, blockParams, depths);
} else if (!programWrapper) {
programWrapper = this.programs[i] = wrapProgram(this, i, fn);
}
return programWrapper;
},
data: function data(value, depth) {
while (value && depth--) {
value = value._parent;
}
return value;
},
merge: function merge(param, common) {
var obj = param || common;
if (param && common && param !== common) {
obj = Utils.extend({}, common, param);
}
return obj;
},
nullContext: _Object$seal({}),
noop: env.VM.noop,
compilerInfo: templateSpec.compiler
};
function ret(context) {
var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
var data = options.data;
ret._setup(options);
if (!options.partial && templateSpec.useData) {
data = initData(context, data);
}
var depths = undefined,
blockParams = templateSpec.useBlockParams ? [] : undefined;
if (templateSpec.useDepths) {
if (options.depths) {
depths = context != options.depths[0] ? [context].concat(options.depths) : options.depths;
} else {
depths = [context];
}
}
function main(context) {
return '' + templateSpec.main(container, context, container.helpers, container.partials, data, blockParams, depths);
}
main = executeDecorators(templateSpec.main, main, container, options.depths || [], data, blockParams);
return main(context, options);
}
ret.isTop = true;
ret._setup = function (options) {
if (!options.partial) {
container.helpers = container.merge(options.helpers, env.helpers);
if (templateSpec.usePartial) {
container.partials = container.merge(options.partials, env.partials);
}
if (templateSpec.usePartial || templateSpec.useDecorators) {
container.decorators = container.merge(options.decorators, env.decorators);
}
} else {
container.helpers = options.helpers;
container.partials = options.partials;
container.decorators = options.decorators;
}
};
ret._child = function (i, data, blockParams, depths) {
if (templateSpec.useBlockParams && !blockParams) {
throw new _exception2['default']('must pass block params');
}
if (templateSpec.useDepths && !depths) {
throw new _exception2['default']('must pass parent depths');
}
return wrapProgram(container, i, templateSpec[i], data, 0, blockParams, depths);
};
return ret;
}
function wrapProgram(container, i, fn, data, declaredBlockParams, blockParams, depths) {
function prog(context) {
var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
var currentDepths = depths;
if (depths && context != depths[0] && !(context === container.nullContext && depths[0] === null)) {
currentDepths = [context].concat(depths);
}
return fn(container, context, container.helpers, container.partials, options.data || data, blockParams && [options.blockParams].concat(blockParams), currentDepths);
}
prog = executeDecorators(fn, prog, container, depths, data, blockParams);
prog.program = i;
prog.depth = depths ? depths.length : 0;
prog.blockParams = declaredBlockParams || 0;
return prog;
}
function resolvePartial(partial, context, options) {
if (!partial) {
if (options.name === '@partial-block') {
partial = options.data['partial-block'];
} else {
partial = options.partials[options.name];
}
} else if (!partial.call && !options.name) {
options.name = partial;
partial = options.partials[partial];
}
return partial;
}
function invokePartial(partial, context, options) {
var currentPartialBlock = options.data && options.data['partial-block'];
options.partial = true;
if (options.ids) {
options.data.contextPath = options.ids[0] || options.data.contextPath;
}
var partialBlock = undefined;
if (options.fn && options.fn !== noop) {
(function () {
options.data = _base.createFrame(options.data);
var fn = options.fn;
partialBlock = options.data['partial-block'] = function partialBlockWrapper(context) {
var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
options.data = _base.createFrame(options.data);
options.data['partial-block'] = currentPartialBlock;
return fn(context, options);
};
if (fn.partials) {
options.partials = Utils.extend({}, options.partials, fn.partials);
}
})();
}
if (partial === undefined && partialBlock) {
partial = partialBlock;
}
if (partial === undefined) {
throw new _exception2['default']('The partial ' + options.name + ' could not be found');
} else if (partial instanceof Function) {
return partial(context, options);
}
}
function noop() {
return '';
}
function initData(context, data) {
if (!data || !('root' in data)) {
data = data ? _base.createFrame(data) : {};
data.root = context;
}
return data;
}
function executeDecorators(fn, prog, container, depths, data, blockParams) {
if (fn.decorator) {
var props = {};
prog = fn.decorator(prog, props, container, depths && depths[0], data, blockParams, depths);
Utils.extend(prog, props);
}
return prog;
}
}), (function(module, exports, __webpack_require__) {
module.exports = { "default": __webpack_require__(24), __esModule: true };
}), (function(module, exports, __webpack_require__) {
__webpack_require__(25);
module.exports = __webpack_require__(30).Object.seal;
}), (function(module, exports, __webpack_require__) {
var isObject = __webpack_require__(26);
__webpack_require__(27)('seal', function($seal){
return function seal(it){
return $seal && isObject(it) ? $seal(it) : it;
};
});
}), (function(module, exports) {
module.exports = function(it){
return typeof it === 'object' ? it !== null : typeof it === 'function';
};
}), (function(module, exports, __webpack_require__) {
var $export = __webpack_require__(28)
, core    = __webpack_require__(30)
, fails   = __webpack_require__(33);
module.exports = function(KEY, exec){
var fn  = (core.Object || {})[KEY] || Object[KEY]
, exp = {};
exp[KEY] = exec(fn);
$export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);
};
}), (function(module, exports, __webpack_require__) {
var global    = __webpack_require__(29)
, core      = __webpack_require__(30)
, ctx       = __webpack_require__(31)
, PROTOTYPE = 'prototype';
var $export = function(type, name, source){
var IS_FORCED = type & $export.F
, IS_GLOBAL = type & $export.G
, IS_STATIC = type & $export.S
, IS_PROTO  = type & $export.P
, IS_BIND   = type & $export.B
, IS_WRAP   = type & $export.W
, exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
, target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]
, key, own, out;
if(IS_GLOBAL)source = name;
for(key in source){
own = !IS_FORCED && target && key in target;
if(own && key in exports)continue;
out = own ? target[key] : source[key];
exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
: IS_BIND && own ? ctx(out, global)
: IS_WRAP && target[key] == out ? (function(C){
var F = function(param){
return this instanceof C ? new C(param) : C(param);
};
F[PROTOTYPE] = C[PROTOTYPE];
return F;
})(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
if(IS_PROTO)(exports[PROTOTYPE] || (exports[PROTOTYPE] = {}))[key] = out;
}
};
$export.F = 1;  // forced
$export.G = 2;  // global
$export.S = 4;  // static
$export.P = 8;  // proto
$export.B = 16; // bind
$export.W = 32; // wrap
module.exports = $export;
}), (function(module, exports) {
var global = module.exports = typeof window != 'undefined' && window.Math == Math
? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef
}), (function(module, exports) {
var core = module.exports = {version: '1.2.6'};
if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef
}), (function(module, exports, __webpack_require__) {
var aFunction = __webpack_require__(32);
module.exports = function(fn, that, length){
aFunction(fn);
if(that === undefined)return fn;
switch(length){
case 1: return function(a){
return fn.call(that, a);
};
case 2: return function(a, b){
return fn.call(that, a, b);
};
case 3: return function(a, b, c){
return fn.call(that, a, b, c);
};
}
return function(/* ...args */){
return fn.apply(that, arguments);
};
};
}), (function(module, exports) {
module.exports = function(it){
if(typeof it != 'function')throw TypeError(it + ' is not a function!');
return it;
};
}), (function(module, exports) {
module.exports = function(exec){
try {
return !!exec();
} catch(e){
return true;
}
};
}), (function(module, exports) {
(function(global) {/* global window */
'use strict';
exports.__esModule = true;
exports['default'] = function (Handlebars) {
var root = typeof global !== 'undefined' ? global : window,
$Handlebars = root.Handlebars;
Handlebars.noConflict = function () {
if (root.Handlebars === Handlebars) {
root.Handlebars = $Handlebars;
}
return Handlebars;
};
};
module.exports = exports['default'];
}.call(exports, (function() { return this; }())))
}), (function(module, exports) {
'use strict';
exports.__esModule = true;
var AST = {
helpers: {
helperExpression: function helperExpression(node) {
return node.type === 'SubExpression' || (node.type === 'MustacheStatement' || node.type === 'BlockStatement') && !!(node.params && node.params.length || node.hash);
},
scopedId: function scopedId(path) {
return (/^\.|this\b/.test(path.original)
);
},
simpleId: function simpleId(path) {
return path.parts.length === 1 && !AST.helpers.scopedId(path) && !path.depth;
}
}
};
exports['default'] = AST;
module.exports = exports['default'];
}), (function(module, exports, __webpack_require__) {
'use strict';
var _interopRequireDefault = __webpack_require__(1)['default'];
var _interopRequireWildcard = __webpack_require__(3)['default'];
exports.__esModule = true;
exports.parse = parse;
var _parser = __webpack_require__(37);
var _parser2 = _interopRequireDefault(_parser);
var _whitespaceControl = __webpack_require__(38);
var _whitespaceControl2 = _interopRequireDefault(_whitespaceControl);
var _helpers = __webpack_require__(40);
var Helpers = _interopRequireWildcard(_helpers);
var _utils = __webpack_require__(5);
exports.parser = _parser2['default'];
var yy = {};
_utils.extend(yy, Helpers);
function parse(input, options) {
if (input.type === 'Program') {
return input;
}
_parser2['default'].yy = yy;
yy.locInfo = function (locInfo) {
return new yy.SourceLocation(options && options.srcName, locInfo);
};
var strip = new _whitespaceControl2['default'](options);
return strip.accept(_parser2['default'].parse(input));
}
}), (function(module, exports) {
"use strict";
exports.__esModule = true;
var handlebars = (function () {
var parser = { trace: function trace() {},
yy: {},
symbols_: { "error": 2, "root": 3, "program": 4, "EOF": 5, "program_repetition0": 6, "statement": 7, "mustache": 8, "block": 9, "rawBlock": 10, "partial": 11, "partialBlock": 12, "content": 13, "COMMENT": 14, "CONTENT": 15, "openRawBlock": 16, "rawBlock_repetition_plus0": 17, "END_RAW_BLOCK": 18, "OPEN_RAW_BLOCK": 19, "helperName": 20, "openRawBlock_repetition0": 21, "openRawBlock_option0": 22, "CLOSE_RAW_BLOCK": 23, "openBlock": 24, "block_option0": 25, "closeBlock": 26, "openInverse": 27, "block_option1": 28, "OPEN_BLOCK": 29, "openBlock_repetition0": 30, "openBlock_option0": 31, "openBlock_option1": 32, "CLOSE": 33, "OPEN_INVERSE": 34, "openInverse_repetition0": 35, "openInverse_option0": 36, "openInverse_option1": 37, "openInverseChain": 38, "OPEN_INVERSE_CHAIN": 39, "openInverseChain_repetition0": 40, "openInverseChain_option0": 41, "openInverseChain_option1": 42, "inverseAndProgram": 43, "INVERSE": 44, "inverseChain": 45, "inverseChain_option0": 46, "OPEN_ENDBLOCK": 47, "OPEN": 48, "mustache_repetition0": 49, "mustache_option0": 50, "OPEN_UNESCAPED": 51, "mustache_repetition1": 52, "mustache_option1": 53, "CLOSE_UNESCAPED": 54, "OPEN_PARTIAL": 55, "partialName": 56, "partial_repetition0": 57, "partial_option0": 58, "openPartialBlock": 59, "OPEN_PARTIAL_BLOCK": 60, "openPartialBlock_repetition0": 61, "openPartialBlock_option0": 62, "param": 63, "sexpr": 64, "OPEN_SEXPR": 65, "sexpr_repetition0": 66, "sexpr_option0": 67, "CLOSE_SEXPR": 68, "hash": 69, "hash_repetition_plus0": 70, "hashSegment": 71, "ID": 72, "EQUALS": 73, "blockParams": 74, "OPEN_BLOCK_PARAMS": 75, "blockParams_repetition_plus0": 76, "CLOSE_BLOCK_PARAMS": 77, "path": 78, "dataName": 79, "STRING": 80, "NUMBER": 81, "BOOLEAN": 82, "UNDEFINED": 83, "NULL": 84, "DATA": 85, "pathSegments": 86, "SEP": 87, "$accept": 0, "$end": 1 },
terminals_: { 2: "error", 5: "EOF", 14: "COMMENT", 15: "CONTENT", 18: "END_RAW_BLOCK", 19: "OPEN_RAW_BLOCK", 23: "CLOSE_RAW_BLOCK", 29: "OPEN_BLOCK", 33: "CLOSE", 34: "OPEN_INVERSE", 39: "OPEN_INVERSE_CHAIN", 44: "INVERSE", 47: "OPEN_ENDBLOCK", 48: "OPEN", 51: "OPEN_UNESCAPED", 54: "CLOSE_UNESCAPED", 55: "OPEN_PARTIAL", 60: "OPEN_PARTIAL_BLOCK", 65: "OPEN_SEXPR", 68: "CLOSE_SEXPR", 72: "ID", 73: "EQUALS", 75: "OPEN_BLOCK_PARAMS", 77: "CLOSE_BLOCK_PARAMS", 80: "STRING", 81: "NUMBER", 82: "BOOLEAN", 83: "UNDEFINED", 84: "NULL", 85: "DATA", 87: "SEP" },
productions_: [0, [3, 2], [4, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [13, 1], [10, 3], [16, 5], [9, 4], [9, 4], [24, 6], [27, 6], [38, 6], [43, 2], [45, 3], [45, 1], [26, 3], [8, 5], [8, 5], [11, 5], [12, 3], [59, 5], [63, 1], [63, 1], [64, 5], [69, 1], [71, 3], [74, 3], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [56, 1], [56, 1], [79, 2], [78, 1], [86, 3], [86, 1], [6, 0], [6, 2], [17, 1], [17, 2], [21, 0], [21, 2], [22, 0], [22, 1], [25, 0], [25, 1], [28, 0], [28, 1], [30, 0], [30, 2], [31, 0], [31, 1], [32, 0], [32, 1], [35, 0], [35, 2], [36, 0], [36, 1], [37, 0], [37, 1], [40, 0], [40, 2], [41, 0], [41, 1], [42, 0], [42, 1], [46, 0], [46, 1], [49, 0], [49, 2], [50, 0], [50, 1], [52, 0], [52, 2], [53, 0], [53, 1], [57, 0], [57, 2], [58, 0], [58, 1], [61, 0], [61, 2], [62, 0], [62, 1], [66, 0], [66, 2], [67, 0], [67, 1], [70, 1], [70, 2], [76, 1], [76, 2]],
performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$
) {
var $0 = $$.length - 1;
switch (yystate) {
case 1:
return $$[$0 - 1];
break;
case 2:
this.$ = yy.prepareProgram($$[$0]);
break;
case 3:
this.$ = $$[$0];
break;
case 4:
this.$ = $$[$0];
break;
case 5:
this.$ = $$[$0];
break;
case 6:
this.$ = $$[$0];
break;
case 7:
this.$ = $$[$0];
break;
case 8:
this.$ = $$[$0];
break;
case 9:
this.$ = {
type: 'CommentStatement',
value: yy.stripComment($$[$0]),
strip: yy.stripFlags($$[$0], $$[$0]),
loc: yy.locInfo(this._$)
};
break;
case 10:
this.$ = {
type: 'ContentStatement',
original: $$[$0],
value: $$[$0],
loc: yy.locInfo(this._$)
};
break;
case 11:
this.$ = yy.prepareRawBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
break;
case 12:
this.$ = { path: $$[$0 - 3], params: $$[$0 - 2], hash: $$[$0 - 1] };
break;
case 13:
this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], false, this._$);
break;
case 14:
this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], true, this._$);
break;
case 15:
this.$ = { open: $$[$0 - 5], path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
break;
case 16:
this.$ = { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
break;
case 17:
this.$ = { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
break;
case 18:
this.$ = { strip: yy.stripFlags($$[$0 - 1], $$[$0 - 1]), program: $$[$0] };
break;
case 19:
var inverse = yy.prepareBlock($$[$0 - 2], $$[$0 - 1], $$[$0], $$[$0], false, this._$),
program = yy.prepareProgram([inverse], $$[$0 - 1].loc);
program.chained = true;
this.$ = { strip: $$[$0 - 2].strip, program: program, chain: true };
break;
case 20:
this.$ = $$[$0];
break;
case 21:
this.$ = { path: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 2], $$[$0]) };
break;
case 22:
this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
break;
case 23:
this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
break;
case 24:
this.$ = {
type: 'PartialStatement',
name: $$[$0 - 3],
params: $$[$0 - 2],
hash: $$[$0 - 1],
indent: '',
strip: yy.stripFlags($$[$0 - 4], $$[$0]),
loc: yy.locInfo(this._$)
};
break;
case 25:
this.$ = yy.preparePartialBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
break;
case 26:
this.$ = { path: $$[$0 - 3], params: $$[$0 - 2], hash: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 4], $$[$0]) };
break;
case 27:
this.$ = $$[$0];
break;
case 28:
this.$ = $$[$0];
break;
case 29:
this.$ = {
type: 'SubExpression',
path: $$[$0 - 3],
params: $$[$0 - 2],
hash: $$[$0 - 1],
loc: yy.locInfo(this._$)
};
break;
case 30:
this.$ = { type: 'Hash', pairs: $$[$0], loc: yy.locInfo(this._$) };
break;
case 31:
this.$ = { type: 'HashPair', key: yy.id($$[$0 - 2]), value: $$[$0], loc: yy.locInfo(this._$) };
break;
case 32:
this.$ = yy.id($$[$0 - 1]);
break;
case 33:
this.$ = $$[$0];
break;
case 34:
this.$ = $$[$0];
break;
case 35:
this.$ = { type: 'StringLiteral', value: $$[$0], original: $$[$0], loc: yy.locInfo(this._$) };
break;
case 36:
this.$ = { type: 'NumberLiteral', value: Number($$[$0]), original: Number($$[$0]), loc: yy.locInfo(this._$) };
break;
case 37:
this.$ = { type: 'BooleanLiteral', value: $$[$0] === 'true', original: $$[$0] === 'true', loc: yy.locInfo(this._$) };
break;
case 38:
this.$ = { type: 'UndefinedLiteral', original: undefined, value: undefined, loc: yy.locInfo(this._$) };
break;
case 39:
this.$ = { type: 'NullLiteral', original: null, value: null, loc: yy.locInfo(this._$) };
break;
case 40:
this.$ = $$[$0];
break;
case 41:
this.$ = $$[$0];
break;
case 42:
this.$ = yy.preparePath(true, $$[$0], this._$);
break;
case 43:
this.$ = yy.preparePath(false, $$[$0], this._$);
break;
case 44:
$$[$0 - 2].push({ part: yy.id($$[$0]), original: $$[$0], separator: $$[$0 - 1] });this.$ = $$[$0 - 2];
break;
case 45:
this.$ = [{ part: yy.id($$[$0]), original: $$[$0] }];
break;
case 46:
this.$ = [];
break;
case 47:
$$[$0 - 1].push($$[$0]);
break;
case 48:
this.$ = [$$[$0]];
break;
case 49:
$$[$0 - 1].push($$[$0]);
break;
case 50:
this.$ = [];
break;
case 51:
$$[$0 - 1].push($$[$0]);
break;
case 58:
this.$ = [];
break;
case 59:
$$[$0 - 1].push($$[$0]);
break;
case 64:
this.$ = [];
break;
case 65:
$$[$0 - 1].push($$[$0]);
break;
case 70:
this.$ = [];
break;
case 71:
$$[$0 - 1].push($$[$0]);
break;
case 78:
this.$ = [];
break;
case 79:
$$[$0 - 1].push($$[$0]);
break;
case 82:
this.$ = [];
break;
case 83:
$$[$0 - 1].push($$[$0]);
break;
case 86:
this.$ = [];
break;
case 87:
$$[$0 - 1].push($$[$0]);
break;
case 90:
this.$ = [];
break;
case 91:
$$[$0 - 1].push($$[$0]);
break;
case 94:
this.$ = [];
break;
case 95:
$$[$0 - 1].push($$[$0]);
break;
case 98:
this.$ = [$$[$0]];
break;
case 99:
$$[$0 - 1].push($$[$0]);
break;
case 100:
this.$ = [$$[$0]];
break;
case 101:
$$[$0 - 1].push($$[$0]);
break;
}
},
table: [{ 3: 1, 4: 2, 5: [2, 46], 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 1: [3] }, { 5: [1, 4] }, { 5: [2, 2], 7: 5, 8: 6, 9: 7, 10: 8, 11: 9, 12: 10, 13: 11, 14: [1, 12], 15: [1, 20], 16: 17, 19: [1, 23], 24: 15, 27: 16, 29: [1, 21], 34: [1, 22], 39: [2, 2], 44: [2, 2], 47: [2, 2], 48: [1, 13], 51: [1, 14], 55: [1, 18], 59: 19, 60: [1, 24] }, { 1: [2, 1] }, { 5: [2, 47], 14: [2, 47], 15: [2, 47], 19: [2, 47], 29: [2, 47], 34: [2, 47], 39: [2, 47], 44: [2, 47], 47: [2, 47], 48: [2, 47], 51: [2, 47], 55: [2, 47], 60: [2, 47] }, { 5: [2, 3], 14: [2, 3], 15: [2, 3], 19: [2, 3], 29: [2, 3], 34: [2, 3], 39: [2, 3], 44: [2, 3], 47: [2, 3], 48: [2, 3], 51: [2, 3], 55: [2, 3], 60: [2, 3] }, { 5: [2, 4], 14: [2, 4], 15: [2, 4], 19: [2, 4], 29: [2, 4], 34: [2, 4], 39: [2, 4], 44: [2, 4], 47: [2, 4], 48: [2, 4], 51: [2, 4], 55: [2, 4], 60: [2, 4] }, { 5: [2, 5], 14: [2, 5], 15: [2, 5], 19: [2, 5], 29: [2, 5], 34: [2, 5], 39: [2, 5], 44: [2, 5], 47: [2, 5], 48: [2, 5], 51: [2, 5], 55: [2, 5], 60: [2, 5] }, { 5: [2, 6], 14: [2, 6], 15: [2, 6], 19: [2, 6], 29: [2, 6], 34: [2, 6], 39: [2, 6], 44: [2, 6], 47: [2, 6], 48: [2, 6], 51: [2, 6], 55: [2, 6], 60: [2, 6] }, { 5: [2, 7], 14: [2, 7], 15: [2, 7], 19: [2, 7], 29: [2, 7], 34: [2, 7], 39: [2, 7], 44: [2, 7], 47: [2, 7], 48: [2, 7], 51: [2, 7], 55: [2, 7], 60: [2, 7] }, { 5: [2, 8], 14: [2, 8], 15: [2, 8], 19: [2, 8], 29: [2, 8], 34: [2, 8], 39: [2, 8], 44: [2, 8], 47: [2, 8], 48: [2, 8], 51: [2, 8], 55: [2, 8], 60: [2, 8] }, { 5: [2, 9], 14: [2, 9], 15: [2, 9], 19: [2, 9], 29: [2, 9], 34: [2, 9], 39: [2, 9], 44: [2, 9], 47: [2, 9], 48: [2, 9], 51: [2, 9], 55: [2, 9], 60: [2, 9] }, { 20: 25, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 36, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 37, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 4: 38, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 13: 40, 15: [1, 20], 17: 39 }, { 20: 42, 56: 41, 64: 43, 65: [1, 44], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 45, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 5: [2, 10], 14: [2, 10], 15: [2, 10], 18: [2, 10], 19: [2, 10], 29: [2, 10], 34: [2, 10], 39: [2, 10], 44: [2, 10], 47: [2, 10], 48: [2, 10], 51: [2, 10], 55: [2, 10], 60: [2, 10] }, { 20: 46, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 47, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 48, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 42, 56: 49, 64: 43, 65: [1, 44], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [2, 78], 49: 50, 65: [2, 78], 72: [2, 78], 80: [2, 78], 81: [2, 78], 82: [2, 78], 83: [2, 78], 84: [2, 78], 85: [2, 78] }, { 23: [2, 33], 33: [2, 33], 54: [2, 33], 65: [2, 33], 68: [2, 33], 72: [2, 33], 75: [2, 33], 80: [2, 33], 81: [2, 33], 82: [2, 33], 83: [2, 33], 84: [2, 33], 85: [2, 33] }, { 23: [2, 34], 33: [2, 34], 54: [2, 34], 65: [2, 34], 68: [2, 34], 72: [2, 34], 75: [2, 34], 80: [2, 34], 81: [2, 34], 82: [2, 34], 83: [2, 34], 84: [2, 34], 85: [2, 34] }, { 23: [2, 35], 33: [2, 35], 54: [2, 35], 65: [2, 35], 68: [2, 35], 72: [2, 35], 75: [2, 35], 80: [2, 35], 81: [2, 35], 82: [2, 35], 83: [2, 35], 84: [2, 35], 85: [2, 35] }, { 23: [2, 36], 33: [2, 36], 54: [2, 36], 65: [2, 36], 68: [2, 36], 72: [2, 36], 75: [2, 36], 80: [2, 36], 81: [2, 36], 82: [2, 36], 83: [2, 36], 84: [2, 36], 85: [2, 36] }, { 23: [2, 37], 33: [2, 37], 54: [2, 37], 65: [2, 37], 68: [2, 37], 72: [2, 37], 75: [2, 37], 80: [2, 37], 81: [2, 37], 82: [2, 37], 83: [2, 37], 84: [2, 37], 85: [2, 37] }, { 23: [2, 38], 33: [2, 38], 54: [2, 38], 65: [2, 38], 68: [2, 38], 72: [2, 38], 75: [2, 38], 80: [2, 38], 81: [2, 38], 82: [2, 38], 83: [2, 38], 84: [2, 38], 85: [2, 38] }, { 23: [2, 39], 33: [2, 39], 54: [2, 39], 65: [2, 39], 68: [2, 39], 72: [2, 39], 75: [2, 39], 80: [2, 39], 81: [2, 39], 82: [2, 39], 83: [2, 39], 84: [2, 39], 85: [2, 39] }, { 23: [2, 43], 33: [2, 43], 54: [2, 43], 65: [2, 43], 68: [2, 43], 72: [2, 43], 75: [2, 43], 80: [2, 43], 81: [2, 43], 82: [2, 43], 83: [2, 43], 84: [2, 43], 85: [2, 43], 87: [1, 51] }, { 72: [1, 35], 86: 52 }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 52: 53, 54: [2, 82], 65: [2, 82], 72: [2, 82], 80: [2, 82], 81: [2, 82], 82: [2, 82], 83: [2, 82], 84: [2, 82], 85: [2, 82] }, { 25: 54, 38: 56, 39: [1, 58], 43: 57, 44: [1, 59], 45: 55, 47: [2, 54] }, { 28: 60, 43: 61, 44: [1, 59], 47: [2, 56] }, { 13: 63, 15: [1, 20], 18: [1, 62] }, { 15: [2, 48], 18: [2, 48] }, { 33: [2, 86], 57: 64, 65: [2, 86], 72: [2, 86], 80: [2, 86], 81: [2, 86], 82: [2, 86], 83: [2, 86], 84: [2, 86], 85: [2, 86] }, { 33: [2, 40], 65: [2, 40], 72: [2, 40], 80: [2, 40], 81: [2, 40], 82: [2, 40], 83: [2, 40], 84: [2, 40], 85: [2, 40] }, { 33: [2, 41], 65: [2, 41], 72: [2, 41], 80: [2, 41], 81: [2, 41], 82: [2, 41], 83: [2, 41], 84: [2, 41], 85: [2, 41] }, { 20: 65, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 66, 47: [1, 67] }, { 30: 68, 33: [2, 58], 65: [2, 58], 72: [2, 58], 75: [2, 58], 80: [2, 58], 81: [2, 58], 82: [2, 58], 83: [2, 58], 84: [2, 58], 85: [2, 58] }, { 33: [2, 64], 35: 69, 65: [2, 64], 72: [2, 64], 75: [2, 64], 80: [2, 64], 81: [2, 64], 82: [2, 64], 83: [2, 64], 84: [2, 64], 85: [2, 64] }, { 21: 70, 23: [2, 50], 65: [2, 50], 72: [2, 50], 80: [2, 50], 81: [2, 50], 82: [2, 50], 83: [2, 50], 84: [2, 50], 85: [2, 50] }, { 33: [2, 90], 61: 71, 65: [2, 90], 72: [2, 90], 80: [2, 90], 81: [2, 90], 82: [2, 90], 83: [2, 90], 84: [2, 90], 85: [2, 90] }, { 20: 75, 33: [2, 80], 50: 72, 63: 73, 64: 76, 65: [1, 44], 69: 74, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 72: [1, 80] }, { 23: [2, 42], 33: [2, 42], 54: [2, 42], 65: [2, 42], 68: [2, 42], 72: [2, 42], 75: [2, 42], 80: [2, 42], 81: [2, 42], 82: [2, 42], 83: [2, 42], 84: [2, 42], 85: [2, 42], 87: [1, 51] }, { 20: 75, 53: 81, 54: [2, 84], 63: 82, 64: 76, 65: [1, 44], 69: 83, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 84, 47: [1, 67] }, { 47: [2, 55] }, { 4: 85, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 47: [2, 20] }, { 20: 86, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 87, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 26: 88, 47: [1, 67] }, { 47: [2, 57] }, { 5: [2, 11], 14: [2, 11], 15: [2, 11], 19: [2, 11], 29: [2, 11], 34: [2, 11], 39: [2, 11], 44: [2, 11], 47: [2, 11], 48: [2, 11], 51: [2, 11], 55: [2, 11], 60: [2, 11] }, { 15: [2, 49], 18: [2, 49] }, { 20: 75, 33: [2, 88], 58: 89, 63: 90, 64: 76, 65: [1, 44], 69: 91, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 65: [2, 94], 66: 92, 68: [2, 94], 72: [2, 94], 80: [2, 94], 81: [2, 94], 82: [2, 94], 83: [2, 94], 84: [2, 94], 85: [2, 94] }, { 5: [2, 25], 14: [2, 25], 15: [2, 25], 19: [2, 25], 29: [2, 25], 34: [2, 25], 39: [2, 25], 44: [2, 25], 47: [2, 25], 48: [2, 25], 51: [2, 25], 55: [2, 25], 60: [2, 25] }, { 20: 93, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 75, 31: 94, 33: [2, 60], 63: 95, 64: 76, 65: [1, 44], 69: 96, 70: 77, 71: 78, 72: [1, 79], 75: [2, 60], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 75, 33: [2, 66], 36: 97, 63: 98, 64: 76, 65: [1, 44], 69: 99, 70: 77, 71: 78, 72: [1, 79], 75: [2, 66], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 75, 22: 100, 23: [2, 52], 63: 101, 64: 76, 65: [1, 44], 69: 102, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 75, 33: [2, 92], 62: 103, 63: 104, 64: 76, 65: [1, 44], 69: 105, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 106] }, { 33: [2, 79], 65: [2, 79], 72: [2, 79], 80: [2, 79], 81: [2, 79], 82: [2, 79], 83: [2, 79], 84: [2, 79], 85: [2, 79] }, { 33: [2, 81] }, { 23: [2, 27], 33: [2, 27], 54: [2, 27], 65: [2, 27], 68: [2, 27], 72: [2, 27], 75: [2, 27], 80: [2, 27], 81: [2, 27], 82: [2, 27], 83: [2, 27], 84: [2, 27], 85: [2, 27] }, { 23: [2, 28], 33: [2, 28], 54: [2, 28], 65: [2, 28], 68: [2, 28], 72: [2, 28], 75: [2, 28], 80: [2, 28], 81: [2, 28], 82: [2, 28], 83: [2, 28], 84: [2, 28], 85: [2, 28] }, { 23: [2, 30], 33: [2, 30], 54: [2, 30], 68: [2, 30], 71: 107, 72: [1, 108], 75: [2, 30] }, { 23: [2, 98], 33: [2, 98], 54: [2, 98], 68: [2, 98], 72: [2, 98], 75: [2, 98] }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 73: [1, 109], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 23: [2, 44], 33: [2, 44], 54: [2, 44], 65: [2, 44], 68: [2, 44], 72: [2, 44], 75: [2, 44], 80: [2, 44], 81: [2, 44], 82: [2, 44], 83: [2, 44], 84: [2, 44], 85: [2, 44], 87: [2, 44] }, { 54: [1, 110] }, { 54: [2, 83], 65: [2, 83], 72: [2, 83], 80: [2, 83], 81: [2, 83], 82: [2, 83], 83: [2, 83], 84: [2, 83], 85: [2, 83] }, { 54: [2, 85] }, { 5: [2, 13], 14: [2, 13], 15: [2, 13], 19: [2, 13], 29: [2, 13], 34: [2, 13], 39: [2, 13], 44: [2, 13], 47: [2, 13], 48: [2, 13], 51: [2, 13], 55: [2, 13], 60: [2, 13] }, { 38: 56, 39: [1, 58], 43: 57, 44: [1, 59], 45: 112, 46: 111, 47: [2, 76] }, { 33: [2, 70], 40: 113, 65: [2, 70], 72: [2, 70], 75: [2, 70], 80: [2, 70], 81: [2, 70], 82: [2, 70], 83: [2, 70], 84: [2, 70], 85: [2, 70] }, { 47: [2, 18] }, { 5: [2, 14], 14: [2, 14], 15: [2, 14], 19: [2, 14], 29: [2, 14], 34: [2, 14], 39: [2, 14], 44: [2, 14], 47: [2, 14], 48: [2, 14], 51: [2, 14], 55: [2, 14], 60: [2, 14] }, { 33: [1, 114] }, { 33: [2, 87], 65: [2, 87], 72: [2, 87], 80: [2, 87], 81: [2, 87], 82: [2, 87], 83: [2, 87], 84: [2, 87], 85: [2, 87] }, { 33: [2, 89] }, { 20: 75, 63: 116, 64: 76, 65: [1, 44], 67: 115, 68: [2, 96], 69: 117, 70: 77, 71: 78, 72: [1, 79], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 118] }, { 32: 119, 33: [2, 62], 74: 120, 75: [1, 121] }, { 33: [2, 59], 65: [2, 59], 72: [2, 59], 75: [2, 59], 80: [2, 59], 81: [2, 59], 82: [2, 59], 83: [2, 59], 84: [2, 59], 85: [2, 59] }, { 33: [2, 61], 75: [2, 61] }, { 33: [2, 68], 37: 122, 74: 123, 75: [1, 121] }, { 33: [2, 65], 65: [2, 65], 72: [2, 65], 75: [2, 65], 80: [2, 65], 81: [2, 65], 82: [2, 65], 83: [2, 65], 84: [2, 65], 85: [2, 65] }, { 33: [2, 67], 75: [2, 67] }, { 23: [1, 124] }, { 23: [2, 51], 65: [2, 51], 72: [2, 51], 80: [2, 51], 81: [2, 51], 82: [2, 51], 83: [2, 51], 84: [2, 51], 85: [2, 51] }, { 23: [2, 53] }, { 33: [1, 125] }, { 33: [2, 91], 65: [2, 91], 72: [2, 91], 80: [2, 91], 81: [2, 91], 82: [2, 91], 83: [2, 91], 84: [2, 91], 85: [2, 91] }, { 33: [2, 93] }, { 5: [2, 22], 14: [2, 22], 15: [2, 22], 19: [2, 22], 29: [2, 22], 34: [2, 22], 39: [2, 22], 44: [2, 22], 47: [2, 22], 48: [2, 22], 51: [2, 22], 55: [2, 22], 60: [2, 22] }, { 23: [2, 99], 33: [2, 99], 54: [2, 99], 68: [2, 99], 72: [2, 99], 75: [2, 99] }, { 73: [1, 109] }, { 20: 75, 63: 126, 64: 76, 65: [1, 44], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 23], 14: [2, 23], 15: [2, 23], 19: [2, 23], 29: [2, 23], 34: [2, 23], 39: [2, 23], 44: [2, 23], 47: [2, 23], 48: [2, 23], 51: [2, 23], 55: [2, 23], 60: [2, 23] }, { 47: [2, 19] }, { 47: [2, 77] }, { 20: 75, 33: [2, 72], 41: 127, 63: 128, 64: 76, 65: [1, 44], 69: 129, 70: 77, 71: 78, 72: [1, 79], 75: [2, 72], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 24], 14: [2, 24], 15: [2, 24], 19: [2, 24], 29: [2, 24], 34: [2, 24], 39: [2, 24], 44: [2, 24], 47: [2, 24], 48: [2, 24], 51: [2, 24], 55: [2, 24], 60: [2, 24] }, { 68: [1, 130] }, { 65: [2, 95], 68: [2, 95], 72: [2, 95], 80: [2, 95], 81: [2, 95], 82: [2, 95], 83: [2, 95], 84: [2, 95], 85: [2, 95] }, { 68: [2, 97] }, { 5: [2, 21], 14: [2, 21], 15: [2, 21], 19: [2, 21], 29: [2, 21], 34: [2, 21], 39: [2, 21], 44: [2, 21], 47: [2, 21], 48: [2, 21], 51: [2, 21], 55: [2, 21], 60: [2, 21] }, { 33: [1, 131] }, { 33: [2, 63] }, { 72: [1, 133], 76: 132 }, { 33: [1, 134] }, { 33: [2, 69] }, { 15: [2, 12] }, { 14: [2, 26], 15: [2, 26], 19: [2, 26], 29: [2, 26], 34: [2, 26], 47: [2, 26], 48: [2, 26], 51: [2, 26], 55: [2, 26], 60: [2, 26] }, { 23: [2, 31], 33: [2, 31], 54: [2, 31], 68: [2, 31], 72: [2, 31], 75: [2, 31] }, { 33: [2, 74], 42: 135, 74: 136, 75: [1, 121] }, { 33: [2, 71], 65: [2, 71], 72: [2, 71], 75: [2, 71], 80: [2, 71], 81: [2, 71], 82: [2, 71], 83: [2, 71], 84: [2, 71], 85: [2, 71] }, { 33: [2, 73], 75: [2, 73] }, { 23: [2, 29], 33: [2, 29], 54: [2, 29], 65: [2, 29], 68: [2, 29], 72: [2, 29], 75: [2, 29], 80: [2, 29], 81: [2, 29], 82: [2, 29], 83: [2, 29], 84: [2, 29], 85: [2, 29] }, { 14: [2, 15], 15: [2, 15], 19: [2, 15], 29: [2, 15], 34: [2, 15], 39: [2, 15], 44: [2, 15], 47: [2, 15], 48: [2, 15], 51: [2, 15], 55: [2, 15], 60: [2, 15] }, { 72: [1, 138], 77: [1, 137] }, { 72: [2, 100], 77: [2, 100] }, { 14: [2, 16], 15: [2, 16], 19: [2, 16], 29: [2, 16], 34: [2, 16], 44: [2, 16], 47: [2, 16], 48: [2, 16], 51: [2, 16], 55: [2, 16], 60: [2, 16] }, { 33: [1, 139] }, { 33: [2, 75] }, { 33: [2, 32] }, { 72: [2, 101], 77: [2, 101] }, { 14: [2, 17], 15: [2, 17], 19: [2, 17], 29: [2, 17], 34: [2, 17], 39: [2, 17], 44: [2, 17], 47: [2, 17], 48: [2, 17], 51: [2, 17], 55: [2, 17], 60: [2, 17] }],
defaultActions: { 4: [2, 1], 55: [2, 55], 57: [2, 20], 61: [2, 57], 74: [2, 81], 83: [2, 85], 87: [2, 18], 91: [2, 89], 102: [2, 53], 105: [2, 93], 111: [2, 19], 112: [2, 77], 117: [2, 97], 120: [2, 63], 123: [2, 69], 124: [2, 12], 136: [2, 75], 137: [2, 32] },
parseError: function parseError(str, hash) {
throw new Error(str);
},
parse: function parse(input) {
var self = this,
stack = [0],
vstack = [null],
lstack = [],
table = this.table,
yytext = "",
yylineno = 0,
yyleng = 0,
recovering = 0,
TERROR = 2,
EOF = 1;
this.lexer.setInput(input);
this.lexer.yy = this.yy;
this.yy.lexer = this.lexer;
this.yy.parser = this;
if (typeof this.lexer.yylloc == "undefined") this.lexer.yylloc = {};
var yyloc = this.lexer.yylloc;
lstack.push(yyloc);
var ranges = this.lexer.options && this.lexer.options.ranges;
if (typeof this.yy.parseError === "function") this.parseError = this.yy.parseError;
function popStack(n) {
stack.length = stack.length - 2 * n;
vstack.length = vstack.length - n;
lstack.length = lstack.length - n;
}
function lex() {
var token;
token = self.lexer.lex() || 1;
if (typeof token !== "number") {
token = self.symbols_[token] || token;
}
return token;
}
var symbol,
preErrorSymbol,
state,
action,
a,
r,
yyval = {},
p,
len,
newState,
expected;
while (true) {
state = stack[stack.length - 1];
if (this.defaultActions[state]) {
action = this.defaultActions[state];
} else {
if (symbol === null || typeof symbol == "undefined") {
symbol = lex();
}
action = table[state] && table[state][symbol];
}
if (typeof action === "undefined" || !action.length || !action[0]) {
var errStr = "";
if (!recovering) {
expected = [];
for (p in table[state]) if (this.terminals_[p] && p > 2) {
expected.push("'" + this.terminals_[p] + "'");
}
if (this.lexer.showPosition) {
errStr = "Parse error on line " + (yylineno + 1) + ":\n" + this.lexer.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
} else {
errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == 1 ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
}
this.parseError(errStr, { text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected: expected });
}
}
if (action[0] instanceof Array && action.length > 1) {
throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
}
switch (action[0]) {
case 1:
stack.push(symbol);
vstack.push(this.lexer.yytext);
lstack.push(this.lexer.yylloc);
stack.push(action[1]);
symbol = null;
if (!preErrorSymbol) {
yyleng = this.lexer.yyleng;
yytext = this.lexer.yytext;
yylineno = this.lexer.yylineno;
yyloc = this.lexer.yylloc;
if (recovering > 0) recovering--;
} else {
symbol = preErrorSymbol;
preErrorSymbol = null;
}
break;
case 2:
len = this.productions_[action[1]][1];
yyval.$ = vstack[vstack.length - len];
yyval._$ = { first_line: lstack[lstack.length - (len || 1)].first_line, last_line: lstack[lstack.length - 1].last_line, first_column: lstack[lstack.length - (len || 1)].first_column, last_column: lstack[lstack.length - 1].last_column };
if (ranges) {
yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
}
r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);
if (typeof r !== "undefined") {
return r;
}
if (len) {
stack = stack.slice(0, -1 * len * 2);
vstack = vstack.slice(0, -1 * len);
lstack = lstack.slice(0, -1 * len);
}
stack.push(this.productions_[action[1]][0]);
vstack.push(yyval.$);
lstack.push(yyval._$);
newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
stack.push(newState);
break;
case 3:
return true;
}
}
return true;
}
};
var lexer = (function () {
var lexer = { EOF: 1,
parseError: function parseError(str, hash) {
if (this.yy.parser) {
this.yy.parser.parseError(str, hash);
} else {
throw new Error(str);
}
},
setInput: function setInput(input) {
this._input = input;
this._more = this._less = this.done = false;
this.yylineno = this.yyleng = 0;
this.yytext = this.matched = this.match = '';
this.conditionStack = ['INITIAL'];
this.yylloc = { first_line: 1, first_column: 0, last_line: 1, last_column: 0 };
if (this.options.ranges) this.yylloc.range = [0, 0];
this.offset = 0;
return this;
},
input: function input() {
var ch = this._input[0];
this.yytext += ch;
this.yyleng++;
this.offset++;
this.match += ch;
this.matched += ch;
var lines = ch.match(/(?:\r\n?|\n).*/g);
if (lines) {
this.yylineno++;
this.yylloc.last_line++;
} else {
this.yylloc.last_column++;
}
if (this.options.ranges) this.yylloc.range[1]++;
this._input = this._input.slice(1);
return ch;
},
unput: function unput(ch) {
var len = ch.length;
var lines = ch.split(/(?:\r\n?|\n)/g);
this._input = ch + this._input;
this.yytext = this.yytext.substr(0, this.yytext.length - len - 1);
this.offset -= len;
var oldLines = this.match.split(/(?:\r\n?|\n)/g);
this.match = this.match.substr(0, this.match.length - 1);
this.matched = this.matched.substr(0, this.matched.length - 1);
if (lines.length - 1) this.yylineno -= lines.length - 1;
var r = this.yylloc.range;
this.yylloc = { first_line: this.yylloc.first_line,
last_line: this.yylineno + 1,
first_column: this.yylloc.first_column,
last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
};
if (this.options.ranges) {
this.yylloc.range = [r[0], r[0] + this.yyleng - len];
}
return this;
},
more: function more() {
this._more = true;
return this;
},
less: function less(n) {
this.unput(this.match.slice(n));
},
pastInput: function pastInput() {
var past = this.matched.substr(0, this.matched.length - this.match.length);
return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\n/g, "");
},
upcomingInput: function upcomingInput() {
var next = this.match;
if (next.length < 20) {
next += this._input.substr(0, 20 - next.length);
}
return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
},
showPosition: function showPosition() {
var pre = this.pastInput();
var c = new Array(pre.length + 1).join("-");
return pre + this.upcomingInput() + "\n" + c + "^";
},
next: function next() {
if (this.done) {
return this.EOF;
}
if (!this._input) this.done = true;
var token, match, tempMatch, index, col, lines;
if (!this._more) {
this.yytext = '';
this.match = '';
}
var rules = this._currentRules();
for (var i = 0; i < rules.length; i++) {
tempMatch = this._input.match(this.rules[rules[i]]);
if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
match = tempMatch;
index = i;
if (!this.options.flex) break;
}
}
if (match) {
lines = match[0].match(/(?:\r\n?|\n).*/g);
if (lines) this.yylineno += lines.length;
this.yylloc = { first_line: this.yylloc.last_line,
last_line: this.yylineno + 1,
first_column: this.yylloc.last_column,
last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length };
this.yytext += match[0];
this.match += match[0];
this.matches = match;
this.yyleng = this.yytext.length;
if (this.options.ranges) {
this.yylloc.range = [this.offset, this.offset += this.yyleng];
}
this._more = false;
this._input = this._input.slice(match[0].length);
this.matched += match[0];
token = this.performAction.call(this, this.yy, this, rules[index], this.conditionStack[this.conditionStack.length - 1]);
if (this.done && this._input) this.done = false;
if (token) return token;else return;
}
if (this._input === "") {
return this.EOF;
} else {
return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), { text: "", token: null, line: this.yylineno });
}
},
lex: function lex() {
var r = this.next();
if (typeof r !== 'undefined') {
return r;
} else {
return this.lex();
}
},
begin: function begin(condition) {
this.conditionStack.push(condition);
},
popState: function popState() {
return this.conditionStack.pop();
},
_currentRules: function _currentRules() {
return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
},
topState: function topState() {
return this.conditionStack[this.conditionStack.length - 2];
},
pushState: function begin(condition) {
this.begin(condition);
} };
lexer.options = {};
lexer.performAction = function anonymous(yy, yy_, $avoiding_name_collisions, YY_START
) {
function strip(start, end) {
return yy_.yytext = yy_.yytext.substr(start, yy_.yyleng - end);
}
var YYSTATE = YY_START;
switch ($avoiding_name_collisions) {
case 0:
if (yy_.yytext.slice(-2) === "\\\\") {
strip(0, 1);
this.begin("mu");
} else if (yy_.yytext.slice(-1) === "\\") {
strip(0, 1);
this.begin("emu");
} else {
this.begin("mu");
}
if (yy_.yytext) return 15;
break;
case 1:
return 15;
break;
case 2:
this.popState();
return 15;
break;
case 3:
this.begin('raw');return 15;
break;
case 4:
this.popState();
if (this.conditionStack[this.conditionStack.length - 1] === 'raw') {
return 15;
} else {
yy_.yytext = yy_.yytext.substr(5, yy_.yyleng - 9);
return 'END_RAW_BLOCK';
}
break;
case 5:
return 15;
break;
case 6:
this.popState();
return 14;
break;
case 7:
return 65;
break;
case 8:
return 68;
break;
case 9:
return 19;
break;
case 10:
this.popState();
this.begin('raw');
return 23;
break;
case 11:
return 55;
break;
case 12:
return 60;
break;
case 13:
return 29;
break;
case 14:
return 47;
break;
case 15:
this.popState();return 44;
break;
case 16:
this.popState();return 44;
break;
case 17:
return 34;
break;
case 18:
return 39;
break;
case 19:
return 51;
break;
case 20:
return 48;
break;
case 21:
this.unput(yy_.yytext);
this.popState();
this.begin('com');
break;
case 22:
this.popState();
return 14;
break;
case 23:
return 48;
break;
case 24:
return 73;
break;
case 25:
return 72;
break;
case 26:
return 72;
break;
case 27:
return 87;
break;
case 28:
break;
case 29:
this.popState();return 54;
break;
case 30:
this.popState();return 33;
break;
case 31:
yy_.yytext = strip(1, 2).replace(/\\"/g, '"');return 80;
break;
case 32:
yy_.yytext = strip(1, 2).replace(/\\'/g, "'");return 80;
break;
case 33:
return 85;
break;
case 34:
return 82;
break;
case 35:
return 82;
break;
case 36:
return 83;
break;
case 37:
return 84;
break;
case 38:
return 81;
break;
case 39:
return 75;
break;
case 40:
return 77;
break;
case 41:
return 72;
break;
case 42:
yy_.yytext = yy_.yytext.replace(/\\([\\\]])/g, '$1');return 72;
break;
case 43:
return 'INVALID';
break;
case 44:
return 5;
break;
}
};
lexer.rules = [/^(?:[^\x00]*?(?=(\{\{)))/, /^(?:[^\x00]+)/, /^(?:[^\x00]{2,}?(?=(\{\{|\\\{\{|\\\\\{\{|$)))/, /^(?:\{\{\{\{(?=[^\/]))/, /^(?:\{\{\{\{\/[^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=[=}\s\/.])\}\}\}\})/, /^(?:[^\x00]*?(?=(\{\{\{\{)))/, /^(?:[\s\S]*?--(~)?\}\})/, /^(?:\()/, /^(?:\))/, /^(?:\{\{\{\{)/, /^(?:\}\}\}\})/, /^(?:\{\{(~)?>)/, /^(?:\{\{(~)?#>)/, /^(?:\{\{(~)?#\*?)/, /^(?:\{\{(~)?\/)/, /^(?:\{\{(~)?\^\s*(~)?\}\})/, /^(?:\{\{(~)?\s*else\s*(~)?\}\})/, /^(?:\{\{(~)?\^)/, /^(?:\{\{(~)?\s*else\b)/, /^(?:\{\{(~)?\{)/, /^(?:\{\{(~)?&)/, /^(?:\{\{(~)?!--)/, /^(?:\{\{(~)?![\s\S]*?\}\})/, /^(?:\{\{(~)?\*?)/, /^(?:=)/, /^(?:\.\.)/, /^(?:\.(?=([=~}\s\/.)|])))/, /^(?:[\/.])/, /^(?:\s+)/, /^(?:\}(~)?\}\})/, /^(?:(~)?\}\})/, /^(?:"(\\["]|[^"])*")/, /^(?:'(\\[']|[^'])*')/, /^(?:@)/, /^(?:true(?=([~}\s)])))/, /^(?:false(?=([~}\s)])))/, /^(?:undefined(?=([~}\s)])))/, /^(?:null(?=([~}\s)])))/, /^(?:-?[0-9]+(?:\.[0-9]+)?(?=([~}\s)])))/, /^(?:as\s+\|)/, /^(?:\|)/, /^(?:([^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=([=~}\s\/.)|]))))/, /^(?:\[(\\\]|[^\]])*\])/, /^(?:.)/, /^(?:$)/];
lexer.conditions = { "mu": { "rules": [7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44], "inclusive": false }, "emu": { "rules": [2], "inclusive": false }, "com": { "rules": [6], "inclusive": false }, "raw": { "rules": [3, 4, 5], "inclusive": false }, "INITIAL": { "rules": [0, 1, 44], "inclusive": true } };
return lexer;
})();
parser.lexer = lexer;
function Parser() {
this.yy = {};
}Parser.prototype = parser;parser.Parser = Parser;
return new Parser();
})();exports["default"] = handlebars;
module.exports = exports["default"];
}), (function(module, exports, __webpack_require__) {
'use strict';
var _interopRequireDefault = __webpack_require__(1)['default'];
exports.__esModule = true;
var _visitor = __webpack_require__(39);
var _visitor2 = _interopRequireDefault(_visitor);
function WhitespaceControl() {
var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
this.options = options;
}
WhitespaceControl.prototype = new _visitor2['default']();
WhitespaceControl.prototype.Program = function (program) {
var doStandalone = !this.options.ignoreStandalone;
var isRoot = !this.isRootSeen;
this.isRootSeen = true;
var body = program.body;
for (var i = 0, l = body.length; i < l; i++) {
var current = body[i],
strip = this.accept(current);
if (!strip) {
continue;
}
var _isPrevWhitespace = isPrevWhitespace(body, i, isRoot),
_isNextWhitespace = isNextWhitespace(body, i, isRoot),
openStandalone = strip.openStandalone && _isPrevWhitespace,
closeStandalone = strip.closeStandalone && _isNextWhitespace,
inlineStandalone = strip.inlineStandalone && _isPrevWhitespace && _isNextWhitespace;
if (strip.close) {
omitRight(body, i, true);
}
if (strip.open) {
omitLeft(body, i, true);
}
if (doStandalone && inlineStandalone) {
omitRight(body, i);
if (omitLeft(body, i)) {
if (current.type === 'PartialStatement') {
current.indent = /([ \t]+$)/.exec(body[i - 1].original)[1];
}
}
}
if (doStandalone && openStandalone) {
omitRight((current.program || current.inverse).body);
omitLeft(body, i);
}
if (doStandalone && closeStandalone) {
omitRight(body, i);
omitLeft((current.inverse || current.program).body);
}
}
return program;
};
WhitespaceControl.prototype.BlockStatement = WhitespaceControl.prototype.DecoratorBlock = WhitespaceControl.prototype.PartialBlockStatement = function (block) {
this.accept(block.program);
this.accept(block.inverse);
var program = block.program || block.inverse,
inverse = block.program && block.inverse,
firstInverse = inverse,
lastInverse = inverse;
if (inverse && inverse.chained) {
firstInverse = inverse.body[0].program;
while (lastInverse.chained) {
lastInverse = lastInverse.body[lastInverse.body.length - 1].program;
}
}
var strip = {
open: block.openStrip.open,
close: block.closeStrip.close,
openStandalone: isNextWhitespace(program.body),
closeStandalone: isPrevWhitespace((firstInverse || program).body)
};
if (block.openStrip.close) {
omitRight(program.body, null, true);
}
if (inverse) {
var inverseStrip = block.inverseStrip;
if (inverseStrip.open) {
omitLeft(program.body, null, true);
}
if (inverseStrip.close) {
omitRight(firstInverse.body, null, true);
}
if (block.closeStrip.open) {
omitLeft(lastInverse.body, null, true);
}
if (!this.options.ignoreStandalone && isPrevWhitespace(program.body) && isNextWhitespace(firstInverse.body)) {
omitLeft(program.body);
omitRight(firstInverse.body);
}
} else if (block.closeStrip.open) {
omitLeft(program.body, null, true);
}
return strip;
};
WhitespaceControl.prototype.Decorator = WhitespaceControl.prototype.MustacheStatement = function (mustache) {
return mustache.strip;
};
WhitespaceControl.prototype.PartialStatement = WhitespaceControl.prototype.CommentStatement = function (node) {
var strip = node.strip || {};
return {
inlineStandalone: true,
open: strip.open,
close: strip.close
};
};
function isPrevWhitespace(body, i, isRoot) {
if (i === undefined) {
i = body.length;
}
var prev = body[i - 1],
sibling = body[i - 2];
if (!prev) {
return isRoot;
}
if (prev.type === 'ContentStatement') {
return (sibling || !isRoot ? /\r?\n\s*?$/ : /(^|\r?\n)\s*?$/).test(prev.original);
}
}
function isNextWhitespace(body, i, isRoot) {
if (i === undefined) {
i = -1;
}
var next = body[i + 1],
sibling = body[i + 2];
if (!next) {
return isRoot;
}
if (next.type === 'ContentStatement') {
return (sibling || !isRoot ? /^\s*?\r?\n/ : /^\s*?(\r?\n|$)/).test(next.original);
}
}
function omitRight(body, i, multiple) {
var current = body[i == null ? 0 : i + 1];
if (!current || current.type !== 'ContentStatement' || !multiple && current.rightStripped) {
return;
}
var original = current.value;
current.value = current.value.replace(multiple ? /^\s+/ : /^[ \t]*\r?\n?/, '');
current.rightStripped = current.value !== original;
}
function omitLeft(body, i, multiple) {
var current = body[i == null ? body.length - 1 : i - 1];
if (!current || current.type !== 'ContentStatement' || !multiple && current.leftStripped) {
return;
}
var original = current.value;
current.value = current.value.replace(multiple ? /\s+$/ : /[ \t]+$/, '');
current.leftStripped = current.value !== original;
return current.leftStripped;
}
exports['default'] = WhitespaceControl;
module.exports = exports['default'];
}), (function(module, exports, __webpack_require__) {
'use strict';
var _interopRequireDefault = __webpack_require__(1)['default'];
exports.__esModule = true;
var _exception = __webpack_require__(6);
var _exception2 = _interopRequireDefault(_exception);
function Visitor() {
this.parents = [];
}
Visitor.prototype = {
constructor: Visitor,
mutating: false,
acceptKey: function acceptKey(node, name) {
var value = this.accept(node[name]);
if (this.mutating) {
if (value && !Visitor.prototype[value.type]) {
throw new _exception2['default']('Unexpected node type "' + value.type + '" found when accepting ' + name + ' on ' + node.type);
}
node[name] = value;
}
},
acceptRequired: function acceptRequired(node, name) {
this.acceptKey(node, name);
if (!node[name]) {
throw new _exception2['default'](node.type + ' requires ' + name);
}
},
acceptArray: function acceptArray(array) {
for (var i = 0, l = array.length; i < l; i++) {
this.acceptKey(array, i);
if (!array[i]) {
array.splice(i, 1);
i--;
l--;
}
}
},
accept: function accept(object) {
if (!object) {
return;
}
if (!this[object.type]) {
throw new _exception2['default']('Unknown type: ' + object.type, object);
}
if (this.current) {
this.parents.unshift(this.current);
}
this.current = object;
var ret = this[object.type](object);
this.current = this.parents.shift();
if (!this.mutating || ret) {
return ret;
} else if (ret !== false) {
return object;
}
},
Program: function Program(program) {
this.acceptArray(program.body);
},
MustacheStatement: visitSubExpression,
Decorator: visitSubExpression,
BlockStatement: visitBlock,
DecoratorBlock: visitBlock,
PartialStatement: visitPartial,
PartialBlockStatement: function PartialBlockStatement(partial) {
visitPartial.call(this, partial);
this.acceptKey(partial, 'program');
},
ContentStatement: function ContentStatement(){},
CommentStatement: function CommentStatement(){},
SubExpression: visitSubExpression,
PathExpression: function PathExpression(){},
StringLiteral: function StringLiteral(){},
NumberLiteral: function NumberLiteral(){},
BooleanLiteral: function BooleanLiteral(){},
UndefinedLiteral: function UndefinedLiteral(){},
NullLiteral: function NullLiteral(){},
Hash: function Hash(hash) {
this.acceptArray(hash.pairs);
},
HashPair: function HashPair(pair) {
this.acceptRequired(pair, 'value');
}
};
function visitSubExpression(mustache) {
this.acceptRequired(mustache, 'path');
this.acceptArray(mustache.params);
this.acceptKey(mustache, 'hash');
}
function visitBlock(block) {
visitSubExpression.call(this, block);
this.acceptKey(block, 'program');
this.acceptKey(block, 'inverse');
}
function visitPartial(partial) {
this.acceptRequired(partial, 'name');
this.acceptArray(partial.params);
this.acceptKey(partial, 'hash');
}
exports['default'] = Visitor;
module.exports = exports['default'];
}), (function(module, exports, __webpack_require__) {
'use strict';
var _interopRequireDefault = __webpack_require__(1)['default'];
exports.__esModule = true;
exports.SourceLocation = SourceLocation;
exports.id = id;
exports.stripFlags = stripFlags;
exports.stripComment = stripComment;
exports.preparePath = preparePath;
exports.prepareMustache = prepareMustache;
exports.prepareRawBlock = prepareRawBlock;
exports.prepareBlock = prepareBlock;
exports.prepareProgram = prepareProgram;
exports.preparePartialBlock = preparePartialBlock;
var _exception = __webpack_require__(6);
var _exception2 = _interopRequireDefault(_exception);
function validateClose(open, close) {
close = close.path ? close.path.original : close;
if (open.path.original !== close) {
var errorNode = { loc: open.path.loc };
throw new _exception2['default'](open.path.original + " doesn't match " + close, errorNode);
}
}
function SourceLocation(source, locInfo) {
this.source = source;
this.start = {
line: locInfo.first_line,
column: locInfo.first_column
};
this.end = {
line: locInfo.last_line,
column: locInfo.last_column
};
}
function id(token) {
if (/^\[.*\]$/.test(token)) {
return token.substr(1, token.length - 2);
} else {
return token;
}
}
function stripFlags(open, close) {
return {
open: open.charAt(2) === '~',
close: close.charAt(close.length - 3) === '~'
};
}
function stripComment(comment) {
return comment.replace(/^\{\{~?\!-?-?/, '').replace(/-?-?~?\}\}$/, '');
}
function preparePath(data, parts, loc) {
loc = this.locInfo(loc);
var original = data ? '@' : '',
dig = [],
depth = 0,
depthString = '';
for (var i = 0, l = parts.length; i < l; i++) {
var part = parts[i].part,
isLiteral = parts[i].original !== part;
original += (parts[i].separator || '') + part;
if (!isLiteral && (part === '..' || part === '.' || part === 'this')) {
if (dig.length > 0) {
throw new _exception2['default']('Invalid path: ' + original, { loc: loc });
} else if (part === '..') {
depth++;
depthString += '../';
}
} else {
dig.push(part);
}
}
return {
type: 'PathExpression',
data: data,
depth: depth,
parts: dig,
original: original,
loc: loc
};
}
function prepareMustache(path, params, hash, open, strip, locInfo) {
var escapeFlag = open.charAt(3) || open.charAt(2),
escaped = escapeFlag !== '{' && escapeFlag !== '&';
var decorator = /\*/.test(open);
return {
type: decorator ? 'Decorator' : 'MustacheStatement',
path: path,
params: params,
hash: hash,
escaped: escaped,
strip: strip,
loc: this.locInfo(locInfo)
};
}
function prepareRawBlock(openRawBlock, contents, close, locInfo) {
validateClose(openRawBlock, close);
locInfo = this.locInfo(locInfo);
var program = {
type: 'Program',
body: contents,
strip: {},
loc: locInfo
};
return {
type: 'BlockStatement',
path: openRawBlock.path,
params: openRawBlock.params,
hash: openRawBlock.hash,
program: program,
openStrip: {},
inverseStrip: {},
closeStrip: {},
loc: locInfo
};
}
function prepareBlock(openBlock, program, inverseAndProgram, close, inverted, locInfo) {
if (close && close.path) {
validateClose(openBlock, close);
}
var decorator = /\*/.test(openBlock.open);
program.blockParams = openBlock.blockParams;
var inverse = undefined,
inverseStrip = undefined;
if (inverseAndProgram) {
if (decorator) {
throw new _exception2['default']('Unexpected inverse block on decorator', inverseAndProgram);
}
if (inverseAndProgram.chain) {
inverseAndProgram.program.body[0].closeStrip = close.strip;
}
inverseStrip = inverseAndProgram.strip;
inverse = inverseAndProgram.program;
}
if (inverted) {
inverted = inverse;
inverse = program;
program = inverted;
}
return {
type: decorator ? 'DecoratorBlock' : 'BlockStatement',
path: openBlock.path,
params: openBlock.params,
hash: openBlock.hash,
program: program,
inverse: inverse,
openStrip: openBlock.strip,
inverseStrip: inverseStrip,
closeStrip: close && close.strip,
loc: this.locInfo(locInfo)
};
}
function prepareProgram(statements, loc) {
if (!loc && statements.length) {
var firstLoc = statements[0].loc,
lastLoc = statements[statements.length - 1].loc;
if (firstLoc && lastLoc) {
loc = {
source: firstLoc.source,
start: {
line: firstLoc.start.line,
column: firstLoc.start.column
},
end: {
line: lastLoc.end.line,
column: lastLoc.end.column
}
};
}
}
return {
type: 'Program',
body: statements,
strip: {},
loc: loc
};
}
function preparePartialBlock(open, program, close, locInfo) {
validateClose(open, close);
return {
type: 'PartialBlockStatement',
name: open.path,
params: open.params,
hash: open.hash,
program: program,
openStrip: open.strip,
closeStrip: close && close.strip,
loc: this.locInfo(locInfo)
};
}
}), (function(module, exports, __webpack_require__) {
'use strict';
var _interopRequireDefault = __webpack_require__(1)['default'];
exports.__esModule = true;
exports.Compiler = Compiler;
exports.precompile = precompile;
exports.compile = compile;
var _exception = __webpack_require__(6);
var _exception2 = _interopRequireDefault(_exception);
var _utils = __webpack_require__(5);
var _ast = __webpack_require__(35);
var _ast2 = _interopRequireDefault(_ast);
var slice = [].slice;
function Compiler() {}
Compiler.prototype = {
compiler: Compiler,
equals: function equals(other) {
var len = this.opcodes.length;
if (other.opcodes.length !== len) {
return false;
}
for (var i = 0; i < len; i++) {
var opcode = this.opcodes[i],
otherOpcode = other.opcodes[i];
if (opcode.opcode !== otherOpcode.opcode || !argEquals(opcode.args, otherOpcode.args)) {
return false;
}
}
len = this.children.length;
for (var i = 0; i < len; i++) {
if (!this.children[i].equals(other.children[i])) {
return false;
}
}
return true;
},
guid: 0,
compile: function compile(program, options) {
this.sourceNode = [];
this.opcodes = [];
this.children = [];
this.options = options;
this.stringParams = options.stringParams;
this.trackIds = options.trackIds;
options.blockParams = options.blockParams || [];
var knownHelpers = options.knownHelpers;
options.knownHelpers = {
'helperMissing': true,
'blockHelperMissing': true,
'each': true,
'if': true,
'unless': true,
'with': true,
'log': true,
'lookup': true
};
if (knownHelpers) {
for (var _name in knownHelpers) {
if (_name in knownHelpers) {
this.options.knownHelpers[_name] = knownHelpers[_name];
}
}
}
return this.accept(program);
},
compileProgram: function compileProgram(program) {
var childCompiler = new this.compiler(),
result = childCompiler.compile(program, this.options),
guid = this.guid++;
this.usePartial = this.usePartial || result.usePartial;
this.children[guid] = result;
this.useDepths = this.useDepths || result.useDepths;
return guid;
},
accept: function accept(node) {
if (!this[node.type]) {
throw new _exception2['default']('Unknown type: ' + node.type, node);
}
this.sourceNode.unshift(node);
var ret = this[node.type](node);
this.sourceNode.shift();
return ret;
},
Program: function Program(program) {
this.options.blockParams.unshift(program.blockParams);
var body = program.body,
bodyLength = body.length;
for (var i = 0; i < bodyLength; i++) {
this.accept(body[i]);
}
this.options.blockParams.shift();
this.isSimple = bodyLength === 1;
this.blockParams = program.blockParams ? program.blockParams.length : 0;
return this;
},
BlockStatement: function BlockStatement(block) {
transformLiteralToPath(block);
var program = block.program,
inverse = block.inverse;
program = program && this.compileProgram(program);
inverse = inverse && this.compileProgram(inverse);
var type = this.classifySexpr(block);
if (type === 'helper') {
this.helperSexpr(block, program, inverse);
} else if (type === 'simple') {
this.simpleSexpr(block);
this.opcode('pushProgram', program);
this.opcode('pushProgram', inverse);
this.opcode('emptyHash');
this.opcode('blockValue', block.path.original);
} else {
this.ambiguousSexpr(block, program, inverse);
this.opcode('pushProgram', program);
this.opcode('pushProgram', inverse);
this.opcode('emptyHash');
this.opcode('ambiguousBlockValue');
}
this.opcode('append');
},
DecoratorBlock: function DecoratorBlock(decorator) {
var program = decorator.program && this.compileProgram(decorator.program);
var params = this.setupFullMustacheParams(decorator, program, undefined),
path = decorator.path;
this.useDecorators = true;
this.opcode('registerDecorator', params.length, path.original);
},
PartialStatement: function PartialStatement(partial) {
this.usePartial = true;
var program = partial.program;
if (program) {
program = this.compileProgram(partial.program);
}
var params = partial.params;
if (params.length > 1) {
throw new _exception2['default']('Unsupported number of partial arguments: ' + params.length, partial);
} else if (!params.length) {
if (this.options.explicitPartialContext) {
this.opcode('pushLiteral', 'undefined');
} else {
params.push({ type: 'PathExpression', parts: [], depth: 0 });
}
}
var partialName = partial.name.original,
isDynamic = partial.name.type === 'SubExpression';
if (isDynamic) {
this.accept(partial.name);
}
this.setupFullMustacheParams(partial, program, undefined, true);
var indent = partial.indent || '';
if (this.options.preventIndent && indent) {
this.opcode('appendContent', indent);
indent = '';
}
this.opcode('invokePartial', isDynamic, partialName, indent);
this.opcode('append');
},
PartialBlockStatement: function PartialBlockStatement(partialBlock) {
this.PartialStatement(partialBlock);
},
MustacheStatement: function MustacheStatement(mustache) {
this.SubExpression(mustache);
if (mustache.escaped && !this.options.noEscape) {
this.opcode('appendEscaped');
} else {
this.opcode('append');
}
},
Decorator: function Decorator(decorator) {
this.DecoratorBlock(decorator);
},
ContentStatement: function ContentStatement(content) {
if (content.value) {
this.opcode('appendContent', content.value);
}
},
CommentStatement: function CommentStatement() {},
SubExpression: function SubExpression(sexpr) {
transformLiteralToPath(sexpr);
var type = this.classifySexpr(sexpr);
if (type === 'simple') {
this.simpleSexpr(sexpr);
} else if (type === 'helper') {
this.helperSexpr(sexpr);
} else {
this.ambiguousSexpr(sexpr);
}
},
ambiguousSexpr: function ambiguousSexpr(sexpr, program, inverse) {
var path = sexpr.path,
name = path.parts[0],
isBlock = program != null || inverse != null;
this.opcode('getContext', path.depth);
this.opcode('pushProgram', program);
this.opcode('pushProgram', inverse);
path.strict = true;
this.accept(path);
this.opcode('invokeAmbiguous', name, isBlock);
},
simpleSexpr: function simpleSexpr(sexpr) {
var path = sexpr.path;
path.strict = true;
this.accept(path);
this.opcode('resolvePossibleLambda');
},
helperSexpr: function helperSexpr(sexpr, program, inverse) {
var params = this.setupFullMustacheParams(sexpr, program, inverse),
path = sexpr.path,
name = path.parts[0];
if (this.options.knownHelpers[name]) {
this.opcode('invokeKnownHelper', params.length, name);
} else if (this.options.knownHelpersOnly) {
throw new _exception2['default']('You specified knownHelpersOnly, but used the unknown helper ' + name, sexpr);
} else {
path.strict = true;
path.falsy = true;
this.accept(path);
this.opcode('invokeHelper', params.length, path.original, _ast2['default'].helpers.simpleId(path));
}
},
PathExpression: function PathExpression(path) {
this.addDepth(path.depth);
this.opcode('getContext', path.depth);
var name = path.parts[0],
scoped = _ast2['default'].helpers.scopedId(path),
blockParamId = !path.depth && !scoped && this.blockParamIndex(name);
if (blockParamId) {
this.opcode('lookupBlockParam', blockParamId, path.parts);
} else if (!name) {
this.opcode('pushContext');
} else if (path.data) {
this.options.data = true;
this.opcode('lookupData', path.depth, path.parts, path.strict);
} else {
this.opcode('lookupOnContext', path.parts, path.falsy, path.strict, scoped);
}
},
StringLiteral: function StringLiteral(string) {
this.opcode('pushString', string.value);
},
NumberLiteral: function NumberLiteral(number) {
this.opcode('pushLiteral', number.value);
},
BooleanLiteral: function BooleanLiteral(bool) {
this.opcode('pushLiteral', bool.value);
},
UndefinedLiteral: function UndefinedLiteral() {
this.opcode('pushLiteral', 'undefined');
},
NullLiteral: function NullLiteral() {
this.opcode('pushLiteral', 'null');
},
Hash: function Hash(hash) {
var pairs = hash.pairs,
i = 0,
l = pairs.length;
this.opcode('pushHash');
for (; i < l; i++) {
this.pushParam(pairs[i].value);
}
while (i--) {
this.opcode('assignToHash', pairs[i].key);
}
this.opcode('popHash');
},
opcode: function opcode(name) {
this.opcodes.push({ opcode: name, args: slice.call(arguments, 1), loc: this.sourceNode[0].loc });
},
addDepth: function addDepth(depth) {
if (!depth) {
return;
}
this.useDepths = true;
},
classifySexpr: function classifySexpr(sexpr) {
var isSimple = _ast2['default'].helpers.simpleId(sexpr.path);
var isBlockParam = isSimple && !!this.blockParamIndex(sexpr.path.parts[0]);
var isHelper = !isBlockParam && _ast2['default'].helpers.helperExpression(sexpr);
var isEligible = !isBlockParam && (isHelper || isSimple);
if (isEligible && !isHelper) {
var _name2 = sexpr.path.parts[0],
options = this.options;
if (options.knownHelpers[_name2]) {
isHelper = true;
} else if (options.knownHelpersOnly) {
isEligible = false;
}
}
if (isHelper) {
return 'helper';
} else if (isEligible) {
return 'ambiguous';
} else {
return 'simple';
}
},
pushParams: function pushParams(params) {
for (var i = 0, l = params.length; i < l; i++) {
this.pushParam(params[i]);
}
},
pushParam: function pushParam(val) {
var value = val.value != null ? val.value : val.original || '';
if (this.stringParams) {
if (value.replace) {
value = value.replace(/^(\.?\.\/)*/g, '').replace(/\//g, '.');
}
if (val.depth) {
this.addDepth(val.depth);
}
this.opcode('getContext', val.depth || 0);
this.opcode('pushStringParam', value, val.type);
if (val.type === 'SubExpression') {
this.accept(val);
}
} else {
if (this.trackIds) {
var blockParamIndex = undefined;
if (val.parts && !_ast2['default'].helpers.scopedId(val) && !val.depth) {
blockParamIndex = this.blockParamIndex(val.parts[0]);
}
if (blockParamIndex) {
var blockParamChild = val.parts.slice(1).join('.');
this.opcode('pushId', 'BlockParam', blockParamIndex, blockParamChild);
} else {
value = val.original || value;
if (value.replace) {
value = value.replace(/^this(?:\.|$)/, '').replace(/^\.\//, '').replace(/^\.$/, '');
}
this.opcode('pushId', val.type, value);
}
}
this.accept(val);
}
},
setupFullMustacheParams: function setupFullMustacheParams(sexpr, program, inverse, omitEmpty) {
var params = sexpr.params;
this.pushParams(params);
this.opcode('pushProgram', program);
this.opcode('pushProgram', inverse);
if (sexpr.hash) {
this.accept(sexpr.hash);
} else {
this.opcode('emptyHash', omitEmpty);
}
return params;
},
blockParamIndex: function blockParamIndex(name) {
for (var depth = 0, len = this.options.blockParams.length; depth < len; depth++) {
var blockParams = this.options.blockParams[depth],
param = blockParams && _utils.indexOf(blockParams, name);
if (blockParams && param >= 0) {
return [depth, param];
}
}
}
};
function precompile(input, options, env) {
if (input == null || typeof input !== 'string' && input.type !== 'Program') {
throw new _exception2['default']('You must pass a string or Handlebars AST to Handlebars.precompile. You passed ' + input);
}
options = options || {};
if (!('data' in options)) {
options.data = true;
}
if (options.compat) {
options.useDepths = true;
}
var ast = env.parse(input, options),
environment = new env.Compiler().compile(ast, options);
return new env.JavaScriptCompiler().compile(environment, options);
}
function compile(input, options, env) {
if (options === undefined) options = {};
if (input == null || typeof input !== 'string' && input.type !== 'Program') {
throw new _exception2['default']('You must pass a string or Handlebars AST to Handlebars.compile. You passed ' + input);
}
options = _utils.extend({}, options);
if (!('data' in options)) {
options.data = true;
}
if (options.compat) {
options.useDepths = true;
}
var compiled = undefined;
function compileInput() {
var ast = env.parse(input, options),
environment = new env.Compiler().compile(ast, options),
templateSpec = new env.JavaScriptCompiler().compile(environment, options, undefined, true);
return env.template(templateSpec);
}
function ret(context, execOptions) {
if (!compiled) {
compiled = compileInput();
}
return compiled.call(this, context, execOptions);
}
ret._setup = function (setupOptions) {
if (!compiled) {
compiled = compileInput();
}
return compiled._setup(setupOptions);
};
ret._child = function (i, data, blockParams, depths) {
if (!compiled) {
compiled = compileInput();
}
return compiled._child(i, data, blockParams, depths);
};
return ret;
}
function argEquals(a, b) {
if (a === b) {
return true;
}
if (_utils.isArray(a) && _utils.isArray(b) && a.length === b.length) {
for (var i = 0; i < a.length; i++) {
if (!argEquals(a[i], b[i])) {
return false;
}
}
return true;
}
}
function transformLiteralToPath(sexpr) {
if (!sexpr.path.parts) {
var literal = sexpr.path;
sexpr.path = {
type: 'PathExpression',
data: false,
depth: 0,
parts: [literal.original + ''],
original: literal.original + '',
loc: literal.loc
};
}
}
}), (function(module, exports, __webpack_require__) {
'use strict';
var _interopRequireDefault = __webpack_require__(1)['default'];
exports.__esModule = true;
var _base = __webpack_require__(4);
var _exception = __webpack_require__(6);
var _exception2 = _interopRequireDefault(_exception);
var _utils = __webpack_require__(5);
var _codeGen = __webpack_require__(43);
var _codeGen2 = _interopRequireDefault(_codeGen);
function Literal(value) {
this.value = value;
}
function JavaScriptCompiler() {}
JavaScriptCompiler.prototype = {
nameLookup: function nameLookup(parent, name) {
if (JavaScriptCompiler.isValidJavaScriptVariableName(name)) {
return [parent, '.', name];
} else {
return [parent, '[', JSON.stringify(name), ']'];
}
},
depthedLookup: function depthedLookup(name) {
return [this.aliasable('container.lookup'), '(depths, "', name, '")'];
},
compilerInfo: function compilerInfo() {
var revision = _base.COMPILER_REVISION,
versions = _base.REVISION_CHANGES[revision];
return [revision, versions];
},
appendToBuffer: function appendToBuffer(source, location, explicit) {
if (!_utils.isArray(source)) {
source = [source];
}
source = this.source.wrap(source, location);
if (this.environment.isSimple) {
return ['return ', source, ';'];
} else if (explicit) {
return ['buffer += ', source, ';'];
} else {
source.appendToBuffer = true;
return source;
}
},
initializeBuffer: function initializeBuffer() {
return this.quotedString('');
},
compile: function compile(environment, options, context, asObject) {
this.environment = environment;
this.options = options;
this.stringParams = this.options.stringParams;
this.trackIds = this.options.trackIds;
this.precompile = !asObject;
this.name = this.environment.name;
this.isChild = !!context;
this.context = context || {
decorators: [],
programs: [],
environments: []
};
this.preamble();
this.stackSlot = 0;
this.stackVars = [];
this.aliases = {};
this.registers = { list: [] };
this.hashes = [];
this.compileStack = [];
this.inlineStack = [];
this.blockParams = [];
this.compileChildren(environment, options);
this.useDepths = this.useDepths || environment.useDepths || environment.useDecorators || this.options.compat;
this.useBlockParams = this.useBlockParams || environment.useBlockParams;
var opcodes = environment.opcodes,
opcode = undefined,
firstLoc = undefined,
i = undefined,
l = undefined;
for (i = 0, l = opcodes.length; i < l; i++) {
opcode = opcodes[i];
this.source.currentLocation = opcode.loc;
firstLoc = firstLoc || opcode.loc;
this[opcode.opcode].apply(this, opcode.args);
}
this.source.currentLocation = firstLoc;
this.pushSource('');
if (this.stackSlot || this.inlineStack.length || this.compileStack.length) {
throw new _exception2['default']('Compile completed with content left on stack');
}
if (!this.decorators.isEmpty()) {
this.useDecorators = true;
this.decorators.prepend('var decorators = container.decorators;\n');
this.decorators.push('return fn;');
if (asObject) {
this.decorators = Function.apply(this, ['fn', 'props', 'container', 'depth0', 'data', 'blockParams', 'depths', this.decorators.merge()]);
} else {
this.decorators.prepend('function(fn, props, container, depth0, data, blockParams, depths) {\n');
this.decorators.push('}\n');
this.decorators = this.decorators.merge();
}
} else {
this.decorators = undefined;
}
var fn = this.createFunctionContext(asObject);
if (!this.isChild) {
var ret = {
compiler: this.compilerInfo(),
main: fn
};
if (this.decorators) {
ret.main_d = this.decorators; // eslint-disable-line camelcase
ret.useDecorators = true;
}
var _context = this.context;
var programs = _context.programs;
var decorators = _context.decorators;
for (i = 0, l = programs.length; i < l; i++) {
if (programs[i]) {
ret[i] = programs[i];
if (decorators[i]) {
ret[i + '_d'] = decorators[i];
ret.useDecorators = true;
}
}
}
if (this.environment.usePartial) {
ret.usePartial = true;
}
if (this.options.data) {
ret.useData = true;
}
if (this.useDepths) {
ret.useDepths = true;
}
if (this.useBlockParams) {
ret.useBlockParams = true;
}
if (this.options.compat) {
ret.compat = true;
}
if (!asObject) {
ret.compiler = JSON.stringify(ret.compiler);
this.source.currentLocation = { start: { line: 1, column: 0 } };
ret = this.objectLiteral(ret);
if (options.srcName) {
ret = ret.toStringWithSourceMap({ file: options.destName });
ret.map = ret.map && ret.map.toString();
} else {
ret = ret.toString();
}
} else {
ret.compilerOptions = this.options;
}
return ret;
} else {
return fn;
}
},
preamble: function preamble() {
this.lastContext = 0;
this.source = new _codeGen2['default'](this.options.srcName);
this.decorators = new _codeGen2['default'](this.options.srcName);
},
createFunctionContext: function createFunctionContext(asObject) {
var varDeclarations = '';
var locals = this.stackVars.concat(this.registers.list);
if (locals.length > 0) {
varDeclarations += ', ' + locals.join(', ');
}
var aliasCount = 0;
for (var alias in this.aliases) {
var node = this.aliases[alias];
if (this.aliases.hasOwnProperty(alias) && node.children && node.referenceCount > 1) {
varDeclarations += ', alias' + ++aliasCount + '=' + alias;
node.children[0] = 'alias' + aliasCount;
}
}
var params = ['container', 'depth0', 'helpers', 'partials', 'data'];
if (this.useBlockParams || this.useDepths) {
params.push('blockParams');
}
if (this.useDepths) {
params.push('depths');
}
var source = this.mergeSource(varDeclarations);
if (asObject) {
params.push(source);
return Function.apply(this, params);
} else {
return this.source.wrap(['function(', params.join(','), ') {\n  ', source, '}']);
}
},
mergeSource: function mergeSource(varDeclarations) {
var isSimple = this.environment.isSimple,
appendOnly = !this.forceBuffer,
appendFirst = undefined,
sourceSeen = undefined,
bufferStart = undefined,
bufferEnd = undefined;
this.source.each(function (line) {
if (line.appendToBuffer) {
if (bufferStart) {
line.prepend('  + ');
} else {
bufferStart = line;
}
bufferEnd = line;
} else {
if (bufferStart) {
if (!sourceSeen) {
appendFirst = true;
} else {
bufferStart.prepend('buffer += ');
}
bufferEnd.add(';');
bufferStart = bufferEnd = undefined;
}
sourceSeen = true;
if (!isSimple) {
appendOnly = false;
}
}
});
if (appendOnly) {
if (bufferStart) {
bufferStart.prepend('return ');
bufferEnd.add(';');
} else if (!sourceSeen) {
this.source.push('return "";');
}
} else {
varDeclarations += ', buffer = ' + (appendFirst ? '' : this.initializeBuffer());
if (bufferStart) {
bufferStart.prepend('return buffer + ');
bufferEnd.add(';');
} else {
this.source.push('return buffer;');
}
}
if (varDeclarations) {
this.source.prepend('var ' + varDeclarations.substring(2) + (appendFirst ? '' : ';\n'));
}
return this.source.merge();
},
blockValue: function blockValue(name) {
var blockHelperMissing = this.aliasable('helpers.blockHelperMissing'),
params = [this.contextName(0)];
this.setupHelperArgs(name, 0, params);
var blockName = this.popStack();
params.splice(1, 0, blockName);
this.push(this.source.functionCall(blockHelperMissing, 'call', params));
},
ambiguousBlockValue: function ambiguousBlockValue() {
var blockHelperMissing = this.aliasable('helpers.blockHelperMissing'),
params = [this.contextName(0)];
this.setupHelperArgs('', 0, params, true);
this.flushInline();
var current = this.topStack();
params.splice(1, 0, current);
this.pushSource(['if (!', this.lastHelper, ') { ', current, ' = ', this.source.functionCall(blockHelperMissing, 'call', params), '}']);
},
appendContent: function appendContent(content) {
if (this.pendingContent) {
content = this.pendingContent + content;
} else {
this.pendingLocation = this.source.currentLocation;
}
this.pendingContent = content;
},
append: function append() {
if (this.isInline()) {
this.replaceStack(function (current) {
return [' != null ? ', current, ' : ""'];
});
this.pushSource(this.appendToBuffer(this.popStack()));
} else {
var local = this.popStack();
this.pushSource(['if (', local, ' != null) { ', this.appendToBuffer(local, undefined, true), ' }']);
if (this.environment.isSimple) {
this.pushSource(['else { ', this.appendToBuffer("''", undefined, true), ' }']);
}
}
},
appendEscaped: function appendEscaped() {
this.pushSource(this.appendToBuffer([this.aliasable('container.escapeExpression'), '(', this.popStack(), ')']));
},
getContext: function getContext(depth) {
this.lastContext = depth;
},
pushContext: function pushContext() {
this.pushStackLiteral(this.contextName(this.lastContext));
},
lookupOnContext: function lookupOnContext(parts, falsy, strict, scoped) {
var i = 0;
if (!scoped && this.options.compat && !this.lastContext) {
this.push(this.depthedLookup(parts[i++]));
} else {
this.pushContext();
}
this.resolvePath('context', parts, i, falsy, strict);
},
lookupBlockParam: function lookupBlockParam(blockParamId, parts) {
this.useBlockParams = true;
this.push(['blockParams[', blockParamId[0], '][', blockParamId[1], ']']);
this.resolvePath('context', parts, 1);
},
lookupData: function lookupData(depth, parts, strict) {
if (!depth) {
this.pushStackLiteral('data');
} else {
this.pushStackLiteral('container.data(data, ' + depth + ')');
}
this.resolvePath('data', parts, 0, true, strict);
},
resolvePath: function resolvePath(type, parts, i, falsy, strict) {
var _this = this;
if (this.options.strict || this.options.assumeObjects) {
this.push(strictLookup(this.options.strict && strict, this, parts, type));
return;
}
var len = parts.length;
for (; i < len; i++) {
this.replaceStack(function (current) {
var lookup = _this.nameLookup(current, parts[i], type);
if (!falsy) {
return [' != null ? ', lookup, ' : ', current];
} else {
return [' && ', lookup];
}
});
}
},
resolvePossibleLambda: function resolvePossibleLambda() {
this.push([this.aliasable('container.lambda'), '(', this.popStack(), ', ', this.contextName(0), ')']);
},
pushStringParam: function pushStringParam(string, type) {
this.pushContext();
this.pushString(type);
if (type !== 'SubExpression') {
if (typeof string === 'string') {
this.pushString(string);
} else {
this.pushStackLiteral(string);
}
}
},
emptyHash: function emptyHash(omitEmpty) {
if (this.trackIds) {
this.push('{}'); // hashIds
}
if (this.stringParams) {
this.push('{}'); // hashContexts
this.push('{}'); // hashTypes
}
this.pushStackLiteral(omitEmpty ? 'undefined' : '{}');
},
pushHash: function pushHash() {
if (this.hash) {
this.hashes.push(this.hash);
}
this.hash = { values: [], types: [], contexts: [], ids: [] };
},
popHash: function popHash() {
var hash = this.hash;
this.hash = this.hashes.pop();
if (this.trackIds) {
this.push(this.objectLiteral(hash.ids));
}
if (this.stringParams) {
this.push(this.objectLiteral(hash.contexts));
this.push(this.objectLiteral(hash.types));
}
this.push(this.objectLiteral(hash.values));
},
pushString: function pushString(string) {
this.pushStackLiteral(this.quotedString(string));
},
pushLiteral: function pushLiteral(value) {
this.pushStackLiteral(value);
},
pushProgram: function pushProgram(guid) {
if (guid != null) {
this.pushStackLiteral(this.programExpression(guid));
} else {
this.pushStackLiteral(null);
}
},
registerDecorator: function registerDecorator(paramSize, name) {
var foundDecorator = this.nameLookup('decorators', name, 'decorator'),
options = this.setupHelperArgs(name, paramSize);
this.decorators.push(['fn = ', this.decorators.functionCall(foundDecorator, '', ['fn', 'props', 'container', options]), ' || fn;']);
},
invokeHelper: function invokeHelper(paramSize, name, isSimple) {
var nonHelper = this.popStack(),
helper = this.setupHelper(paramSize, name),
simple = isSimple ? [helper.name, ' || '] : '';
var lookup = ['('].concat(simple, nonHelper);
if (!this.options.strict) {
lookup.push(' || ', this.aliasable('helpers.helperMissing'));
}
lookup.push(')');
this.push(this.source.functionCall(lookup, 'call', helper.callParams));
},
invokeKnownHelper: function invokeKnownHelper(paramSize, name) {
var helper = this.setupHelper(paramSize, name);
this.push(this.source.functionCall(helper.name, 'call', helper.callParams));
},
invokeAmbiguous: function invokeAmbiguous(name, helperCall) {
this.useRegister('helper');
var nonHelper = this.popStack();
this.emptyHash();
var helper = this.setupHelper(0, name, helperCall);
var helperName = this.lastHelper = this.nameLookup('helpers', name, 'helper');
var lookup = ['(', '(helper = ', helperName, ' || ', nonHelper, ')'];
if (!this.options.strict) {
lookup[0] = '(helper = ';
lookup.push(' != null ? helper : ', this.aliasable('helpers.helperMissing'));
}
this.push(['(', lookup, helper.paramsInit ? ['),(', helper.paramsInit] : [], '),', '(typeof helper === ', this.aliasable('"function"'), ' ? ', this.source.functionCall('helper', 'call', helper.callParams), ' : helper))']);
},
invokePartial: function invokePartial(isDynamic, name, indent) {
var params = [],
options = this.setupParams(name, 1, params);
if (isDynamic) {
name = this.popStack();
delete options.name;
}
if (indent) {
options.indent = JSON.stringify(indent);
}
options.helpers = 'helpers';
options.partials = 'partials';
options.decorators = 'container.decorators';
if (!isDynamic) {
params.unshift(this.nameLookup('partials', name, 'partial'));
} else {
params.unshift(name);
}
if (this.options.compat) {
options.depths = 'depths';
}
options = this.objectLiteral(options);
params.push(options);
this.push(this.source.functionCall('container.invokePartial', '', params));
},
assignToHash: function assignToHash(key) {
var value = this.popStack(),
context = undefined,
type = undefined,
id = undefined;
if (this.trackIds) {
id = this.popStack();
}
if (this.stringParams) {
type = this.popStack();
context = this.popStack();
}
var hash = this.hash;
if (context) {
hash.contexts[key] = context;
}
if (type) {
hash.types[key] = type;
}
if (id) {
hash.ids[key] = id;
}
hash.values[key] = value;
},
pushId: function pushId(type, name, child) {
if (type === 'BlockParam') {
this.pushStackLiteral('blockParams[' + name[0] + '].path[' + name[1] + ']' + (child ? ' + ' + JSON.stringify('.' + child) : ''));
} else if (type === 'PathExpression') {
this.pushString(name);
} else if (type === 'SubExpression') {
this.pushStackLiteral('true');
} else {
this.pushStackLiteral('null');
}
},
compiler: JavaScriptCompiler,
compileChildren: function compileChildren(environment, options) {
var children = environment.children,
child = undefined,
compiler = undefined;
for (var i = 0, l = children.length; i < l; i++) {
child = children[i];
compiler = new this.compiler(); // eslint-disable-line new-cap
var existing = this.matchExistingProgram(child);
if (existing == null) {
this.context.programs.push(''); // Placeholder to prevent name conflicts for nested children
var index = this.context.programs.length;
child.index = index;
child.name = 'program' + index;
this.context.programs[index] = compiler.compile(child, options, this.context, !this.precompile);
this.context.decorators[index] = compiler.decorators;
this.context.environments[index] = child;
this.useDepths = this.useDepths || compiler.useDepths;
this.useBlockParams = this.useBlockParams || compiler.useBlockParams;
child.useDepths = this.useDepths;
child.useBlockParams = this.useBlockParams;
} else {
child.index = existing.index;
child.name = 'program' + existing.index;
this.useDepths = this.useDepths || existing.useDepths;
this.useBlockParams = this.useBlockParams || existing.useBlockParams;
}
}
},
matchExistingProgram: function matchExistingProgram(child) {
for (var i = 0, len = this.context.environments.length; i < len; i++) {
var environment = this.context.environments[i];
if (environment && environment.equals(child)) {
return environment;
}
}
},
programExpression: function programExpression(guid) {
var child = this.environment.children[guid],
programParams = [child.index, 'data', child.blockParams];
if (this.useBlockParams || this.useDepths) {
programParams.push('blockParams');
}
if (this.useDepths) {
programParams.push('depths');
}
return 'container.program(' + programParams.join(', ') + ')';
},
useRegister: function useRegister(name) {
if (!this.registers[name]) {
this.registers[name] = true;
this.registers.list.push(name);
}
},
push: function push(expr) {
if (!(expr instanceof Literal)) {
expr = this.source.wrap(expr);
}
this.inlineStack.push(expr);
return expr;
},
pushStackLiteral: function pushStackLiteral(item) {
this.push(new Literal(item));
},
pushSource: function pushSource(source) {
if (this.pendingContent) {
this.source.push(this.appendToBuffer(this.source.quotedString(this.pendingContent), this.pendingLocation));
this.pendingContent = undefined;
}
if (source) {
this.source.push(source);
}
},
replaceStack: function replaceStack(callback) {
var prefix = ['('],
stack = undefined,
createdStack = undefined,
usedLiteral = undefined;
if (!this.isInline()) {
throw new _exception2['default']('replaceStack on non-inline');
}
var top = this.popStack(true);
if (top instanceof Literal) {
stack = [top.value];
prefix = ['(', stack];
usedLiteral = true;
} else {
createdStack = true;
var _name = this.incrStack();
prefix = ['((', this.push(_name), ' = ', top, ')'];
stack = this.topStack();
}
var item = callback.call(this, stack);
if (!usedLiteral) {
this.popStack();
}
if (createdStack) {
this.stackSlot--;
}
this.push(prefix.concat(item, ')'));
},
incrStack: function incrStack() {
this.stackSlot++;
if (this.stackSlot > this.stackVars.length) {
this.stackVars.push('stack' + this.stackSlot);
}
return this.topStackName();
},
topStackName: function topStackName() {
return 'stack' + this.stackSlot;
},
flushInline: function flushInline() {
var inlineStack = this.inlineStack;
this.inlineStack = [];
for (var i = 0, len = inlineStack.length; i < len; i++) {
var entry = inlineStack[i];
if (entry instanceof Literal) {
this.compileStack.push(entry);
} else {
var stack = this.incrStack();
this.pushSource([stack, ' = ', entry, ';']);
this.compileStack.push(stack);
}
}
},
isInline: function isInline() {
return this.inlineStack.length;
},
popStack: function popStack(wrapped) {
var inline = this.isInline(),
item = (inline ? this.inlineStack : this.compileStack).pop();
if (!wrapped && item instanceof Literal) {
return item.value;
} else {
if (!inline) {
if (!this.stackSlot) {
throw new _exception2['default']('Invalid stack pop');
}
this.stackSlot--;
}
return item;
}
},
topStack: function topStack() {
var stack = this.isInline() ? this.inlineStack : this.compileStack,
item = stack[stack.length - 1];
if (item instanceof Literal) {
return item.value;
} else {
return item;
}
},
contextName: function contextName(context) {
if (this.useDepths && context) {
return 'depths[' + context + ']';
} else {
return 'depth' + context;
}
},
quotedString: function quotedString(str) {
return this.source.quotedString(str);
},
objectLiteral: function objectLiteral(obj) {
return this.source.objectLiteral(obj);
},
aliasable: function aliasable(name) {
var ret = this.aliases[name];
if (ret) {
ret.referenceCount++;
return ret;
}
ret = this.aliases[name] = this.source.wrap(name);
ret.aliasable = true;
ret.referenceCount = 1;
return ret;
},
setupHelper: function setupHelper(paramSize, name, blockHelper) {
var params = [],
paramsInit = this.setupHelperArgs(name, paramSize, params, blockHelper);
var foundHelper = this.nameLookup('helpers', name, 'helper'),
callContext = this.aliasable(this.contextName(0) + ' != null ? ' + this.contextName(0) + ' : (container.nullContext || {})');
return {
params: params,
paramsInit: paramsInit,
name: foundHelper,
callParams: [callContext].concat(params)
};
},
setupParams: function setupParams(helper, paramSize, params) {
var options = {},
contexts = [],
types = [],
ids = [],
objectArgs = !params,
param = undefined;
if (objectArgs) {
params = [];
}
options.name = this.quotedString(helper);
options.hash = this.popStack();
if (this.trackIds) {
options.hashIds = this.popStack();
}
if (this.stringParams) {
options.hashTypes = this.popStack();
options.hashContexts = this.popStack();
}
var inverse = this.popStack(),
program = this.popStack();
if (program || inverse) {
options.fn = program || 'container.noop';
options.inverse = inverse || 'container.noop';
}
var i = paramSize;
while (i--) {
param = this.popStack();
params[i] = param;
if (this.trackIds) {
ids[i] = this.popStack();
}
if (this.stringParams) {
types[i] = this.popStack();
contexts[i] = this.popStack();
}
}
if (objectArgs) {
options.args = this.source.generateArray(params);
}
if (this.trackIds) {
options.ids = this.source.generateArray(ids);
}
if (this.stringParams) {
options.types = this.source.generateArray(types);
options.contexts = this.source.generateArray(contexts);
}
if (this.options.data) {
options.data = 'data';
}
if (this.useBlockParams) {
options.blockParams = 'blockParams';
}
return options;
},
setupHelperArgs: function setupHelperArgs(helper, paramSize, params, useRegister) {
var options = this.setupParams(helper, paramSize, params);
options = this.objectLiteral(options);
if (useRegister) {
this.useRegister('options');
params.push('options');
return ['options=', options];
} else if (params) {
params.push(options);
return '';
} else {
return options;
}
}
};
(function () {
var reservedWords = ('break else new var' + ' case finally return void' + ' catch for switch while' + ' continue function this with' + ' default if throw' + ' delete in try' + ' do instanceof typeof' + ' abstract enum int short' + ' boolean export interface static' + ' byte extends long super' + ' char final native synchronized' + ' class float package throws' + ' const goto private transient' + ' debugger implements protected volatile' + ' double import public let yield await' + ' null true false').split(' ');
var compilerWords = JavaScriptCompiler.RESERVED_WORDS = {};
for (var i = 0, l = reservedWords.length; i < l; i++) {
compilerWords[reservedWords[i]] = true;
}
})();
JavaScriptCompiler.isValidJavaScriptVariableName = function (name) {
return !JavaScriptCompiler.RESERVED_WORDS[name] && /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(name);
};
function strictLookup(requireTerminal, compiler, parts, type) {
var stack = compiler.popStack(),
i = 0,
len = parts.length;
if (requireTerminal) {
len--;
}
for (; i < len; i++) {
stack = compiler.nameLookup(stack, parts[i], type);
}
if (requireTerminal) {
return [compiler.aliasable('container.strict'), '(', stack, ', ', compiler.quotedString(parts[i]), ')'];
} else {
return stack;
}
}
exports['default'] = JavaScriptCompiler;
module.exports = exports['default'];
}), (function(module, exports, __webpack_require__) {
'use strict';
exports.__esModule = true;
var _utils = __webpack_require__(5);
var SourceNode = undefined;
try {
if (false) {
var SourceMap = require('source-map');
SourceNode = SourceMap.SourceNode;
}
} catch (err) {}
if (!SourceNode) {
SourceNode = function (line, column, srcFile, chunks) {
this.src = '';
if (chunks) {
this.add(chunks);
}
};
SourceNode.prototype = {
add: function add(chunks) {
if (_utils.isArray(chunks)) {
chunks = chunks.join('');
}
this.src += chunks;
},
prepend: function prepend(chunks) {
if (_utils.isArray(chunks)) {
chunks = chunks.join('');
}
this.src = chunks + this.src;
},
toStringWithSourceMap: function toStringWithSourceMap() {
return { code: this.toString() };
},
toString: function toString() {
return this.src;
}
};
}
function castChunk(chunk, codeGen, loc) {
if (_utils.isArray(chunk)) {
var ret = [];
for (var i = 0, len = chunk.length; i < len; i++) {
ret.push(codeGen.wrap(chunk[i], loc));
}
return ret;
} else if (typeof chunk === 'boolean' || typeof chunk === 'number') {
return chunk + '';
}
return chunk;
}
function CodeGen(srcFile) {
this.srcFile = srcFile;
this.source = [];
}
CodeGen.prototype = {
isEmpty: function isEmpty() {
return !this.source.length;
},
prepend: function prepend(source, loc) {
this.source.unshift(this.wrap(source, loc));
},
push: function push(source, loc) {
this.source.push(this.wrap(source, loc));
},
merge: function merge() {
var source = this.empty();
this.each(function (line) {
source.add(['  ', line, '\n']);
});
return source;
},
each: function each(iter) {
for (var i = 0, len = this.source.length; i < len; i++) {
iter(this.source[i]);
}
},
empty: function empty() {
var loc = this.currentLocation || { start: {} };
return new SourceNode(loc.start.line, loc.start.column, this.srcFile);
},
wrap: function wrap(chunk) {
var loc = arguments.length <= 1 || arguments[1] === undefined ? this.currentLocation || { start: {} } : arguments[1];
if (chunk instanceof SourceNode) {
return chunk;
}
chunk = castChunk(chunk, this, loc);
return new SourceNode(loc.start.line, loc.start.column, this.srcFile, chunk);
},
functionCall: function functionCall(fn, type, params) {
params = this.generateList(params);
return this.wrap([fn, type ? '.' + type + '(' : '(', params, ')']);
},
quotedString: function quotedString(str) {
return '"' + (str + '').replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/\u2028/g, '\\u2028') // Per Ecma-262 7.3 + 7.8.4
.replace(/\u2029/g, '\\u2029') + '"';
},
objectLiteral: function objectLiteral(obj) {
var pairs = [];
for (var key in obj) {
if (obj.hasOwnProperty(key)) {
var value = castChunk(obj[key], this);
if (value !== 'undefined') {
pairs.push([this.quotedString(key), ':', value]);
}
}
}
var ret = this.generateList(pairs);
ret.prepend('{');
ret.add('}');
return ret;
},
generateList: function generateList(entries) {
var ret = this.empty();
for (var i = 0, len = entries.length; i < len; i++) {
if (i) {
ret.add(',');
}
ret.add(castChunk(entries[i], this));
}
return ret;
},
generateArray: function generateArray(entries) {
var ret = this.generateList(entries);
ret.prepend('[');
ret.add(']');
return ret;
}
};
exports['default'] = CodeGen;
module.exports = exports['default'];
}) ])
});
;
!function(modules) {
function __webpack_require__(moduleId) {
if (installedModules[moduleId]) return installedModules[moduleId].exports;
var module = installedModules[moduleId] = {
i: moduleId,
l: !1,
exports: {}
};
return modules[moduleId].call(module.exports, module, module.exports, __webpack_require__),
module.l = !0, module.exports;
}
var installedModules = {};
__webpack_require__.m = modules, __webpack_require__.c = installedModules, __webpack_require__.d = function(exports, name, getter) {
__webpack_require__.o(exports, name) || Object.defineProperty(exports, name, {
configurable: !1,
enumerable: !0,
get: getter
});
}, __webpack_require__.n = function(module) {
var getter = module && module.__esModule ? function() {
return module.default;
} : function() {
return module;
};
return __webpack_require__.d(getter, "a", getter), getter;
}, __webpack_require__.o = function(object, property) {
return Object.prototype.hasOwnProperty.call(object, property);
}, __webpack_require__.p = "", __webpack_require__(__webpack_require__.s = 3);
}([ function(module, exports, __webpack_require__) {
"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
"function" == typeof Symbol && Symbol.iterator;
!function(factory) {
__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(2) ], void 0 !== (__WEBPACK_AMD_DEFINE_RESULT__ = "function" == typeof (__WEBPACK_AMD_DEFINE_FACTORY__ = factory) ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__) && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__);
}(function($) {
return $;
});
}, function(module, exports, __webpack_require__) {
"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__, _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
return typeof obj;
} : function(obj) {
return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};
!function(factory) {
__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(0), __webpack_require__(10), __webpack_require__(11) ],
void 0 !== (__WEBPACK_AMD_DEFINE_RESULT__ = "function" == typeof (__WEBPACK_AMD_DEFINE_FACTORY__ = factory) ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__) && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__);
}(function($, window, document, undefined) {
function Inputmask(alias, options, internal) {
if (!(this instanceof Inputmask)) return new Inputmask(alias, options, internal);
this.el = undefined, this.events = {}, this.maskset = undefined, this.refreshValue = !1,
!0 !== internal && ($.isPlainObject(alias) ? options = alias : (options = options || {}).alias = alias,
this.opts = $.extend(!0, {}, this.defaults, options), this.noMasksCache = options && options.definitions !== undefined,
this.userOptions = options || {}, this.isRTL = this.opts.numericInput, resolveAlias(this.opts.alias, options, this.opts));
}
function resolveAlias(aliasStr, options, opts) {
var aliasDefinition = Inputmask.prototype.aliases[aliasStr];
return aliasDefinition ? (aliasDefinition.alias && resolveAlias(aliasDefinition.alias, undefined, opts),
$.extend(!0, opts, aliasDefinition), $.extend(!0, opts, options), !0) : (null === opts.mask && (opts.mask = aliasStr),
!1);
}
function generateMaskSet(opts, nocache) {
function generateMask(mask, metadata, opts) {
var regexMask = !1;
if (null !== mask && "" !== mask || ((regexMask = null !== opts.regex) ? mask = (mask = opts.regex).replace(/^(\^)(.*)(\$)$/, "$2") : (regexMask = !0,
mask = ".*")), 1 === mask.length && !1 === opts.greedy && 0 !== opts.repeat && (opts.placeholder = ""),
opts.repeat > 0 || "*" === opts.repeat || "+" === opts.repeat) {
var repeatStart = "*" === opts.repeat ? 0 : "+" === opts.repeat ? 1 : opts.repeat;
mask = opts.groupmarker.start + mask + opts.groupmarker.end + opts.quantifiermarker.start + repeatStart + "," + opts.repeat + opts.quantifiermarker.end;
}
var masksetDefinition, maskdefKey = regexMask ? "regex_" + opts.regex : opts.numericInput ? mask.split("").reverse().join("") : mask;
return Inputmask.prototype.masksCache[maskdefKey] === undefined || !0 === nocache ? (masksetDefinition = {
mask: mask,
maskToken: Inputmask.prototype.analyseMask(mask, regexMask, opts),
validPositions: {},
_buffer: undefined,
buffer: undefined,
tests: {},
metadata: metadata,
maskLength: undefined
}, !0 !== nocache && (Inputmask.prototype.masksCache[maskdefKey] = masksetDefinition,
masksetDefinition = $.extend(!0, {}, Inputmask.prototype.masksCache[maskdefKey]))) : masksetDefinition = $.extend(!0, {}, Inputmask.prototype.masksCache[maskdefKey]),
masksetDefinition;
}
if ($.isFunction(opts.mask) && (opts.mask = opts.mask(opts)), $.isArray(opts.mask)) {
if (opts.mask.length > 1) {
opts.keepStatic = null === opts.keepStatic || opts.keepStatic;
var altMask = opts.groupmarker.start;
return $.each(opts.numericInput ? opts.mask.reverse() : opts.mask, function(ndx, msk) {
altMask.length > 1 && (altMask += opts.groupmarker.end + opts.alternatormarker + opts.groupmarker.start),
msk.mask === undefined || $.isFunction(msk.mask) ? altMask += msk : altMask += msk.mask;
}), altMask += opts.groupmarker.end, generateMask(altMask, opts.mask, opts);
}
opts.mask = opts.mask.pop();
}
return opts.mask && opts.mask.mask !== undefined && !$.isFunction(opts.mask.mask) ? generateMask(opts.mask.mask, opts.mask, opts) : generateMask(opts.mask, opts.mask, opts);
}
function maskScope(actionObj, maskset, opts) {
function getMaskTemplate(baseOnInput, minimalPos, includeMode) {
minimalPos = minimalPos || 0;
var ndxIntlzr, test, testPos, maskTemplate = [], pos = 0, lvp = getLastValidPosition();
do {
!0 === baseOnInput && getMaskSet().validPositions[pos] ? (test = (testPos = getMaskSet().validPositions[pos]).match,
ndxIntlzr = testPos.locator.slice(), maskTemplate.push(!0 === includeMode ? testPos.input : !1 === includeMode ? test.nativeDef : getPlaceholder(pos, test))) : (test = (testPos = getTestTemplate(pos, ndxIntlzr, pos - 1)).match,
ndxIntlzr = testPos.locator.slice(), (!1 === opts.jitMasking || pos < lvp || "number" == typeof opts.jitMasking && isFinite(opts.jitMasking) && opts.jitMasking > pos) && maskTemplate.push(!1 === includeMode ? test.nativeDef : getPlaceholder(pos, test))),
pos++;
} while ((maxLength === undefined || pos < maxLength) && (null !== test.fn || "" !== test.def) || minimalPos > pos);
return "" === maskTemplate[maskTemplate.length - 1] && maskTemplate.pop(), getMaskSet().maskLength = pos + 1,
maskTemplate;
}
function getMaskSet() {
return maskset;
}
function resetMaskSet(soft) {
var maskset = getMaskSet();
maskset.buffer = undefined, !0 !== soft && (maskset.validPositions = {}, maskset.p = 0);
}
function getLastValidPosition(closestTo, strict, validPositions) {
var before = -1, after = -1, valids = validPositions || getMaskSet().validPositions;
closestTo === undefined && (closestTo = -1);
for (var posNdx in valids) {
var psNdx = parseInt(posNdx);
valids[psNdx] && (strict || !0 !== valids[psNdx].generatedInput) && (psNdx <= closestTo && (before = psNdx),
psNdx >= closestTo && (after = psNdx));
}
return -1 !== before && closestTo - before > 1 || after < closestTo ? before : after;
}
function stripValidPositions(start, end, nocheck, strict) {
var i, startPos = start, positionsClone = $.extend(!0, {}, getMaskSet().validPositions), needsValidation = !1;
for (getMaskSet().p = start, i = end - 1; i >= startPos; i--) getMaskSet().validPositions[i] !== undefined && (!0 !== nocheck && (!getMaskSet().validPositions[i].match.optionality && function(pos) {
var posMatch = getMaskSet().validPositions[pos];
if (posMatch !== undefined && null === posMatch.match.fn) {
var prevMatch = getMaskSet().validPositions[pos - 1], nextMatch = getMaskSet().validPositions[pos + 1];
return prevMatch !== undefined && nextMatch !== undefined;
}
return !1;
}(i) || !1 === opts.canClearPosition(getMaskSet(), i, getLastValidPosition(), strict, opts)) || delete getMaskSet().validPositions[i]);
for (resetMaskSet(!0), i = startPos + 1; i <= getLastValidPosition(); ) {
for (;getMaskSet().validPositions[startPos] !== undefined; ) startPos++;
if (i < startPos && (i = startPos + 1), getMaskSet().validPositions[i] === undefined && isMask(i)) i++; else {
var t = getTestTemplate(i);
!1 === needsValidation && positionsClone[startPos] && positionsClone[startPos].match.def === t.match.def ? (getMaskSet().validPositions[startPos] = $.extend(!0, {}, positionsClone[startPos]),
getMaskSet().validPositions[startPos].input = t.input, delete getMaskSet().validPositions[i],
i++) : positionCanMatchDefinition(startPos, t.match.def) ? !1 !== isValid(startPos, t.input || getPlaceholder(i), !0) && (delete getMaskSet().validPositions[i],
i++, needsValidation = !0) : isMask(i) || (i++, startPos--), startPos++;
}
}
resetMaskSet(!0);
}
function determineTestTemplate(tests, guessNextBest) {
for (var testPos, testPositions = tests, lvp = getLastValidPosition(), lvTest = getMaskSet().validPositions[lvp] || getTests(0)[0], lvTestAltArr = lvTest.alternation !== undefined ? lvTest.locator[lvTest.alternation].toString().split(",") : [], ndx = 0; ndx < testPositions.length && (!((testPos = testPositions[ndx]).match && (opts.greedy && !0 !== testPos.match.optionalQuantifier || (!1 === testPos.match.optionality || !1 === testPos.match.newBlockMarker) && !0 !== testPos.match.optionalQuantifier) && (lvTest.alternation === undefined || lvTest.alternation !== testPos.alternation || testPos.locator[lvTest.alternation] !== undefined && checkAlternationMatch(testPos.locator[lvTest.alternation].toString().split(","), lvTestAltArr))) || !0 === guessNextBest && (null !== testPos.match.fn || /[0-9a-bA-Z]/.test(testPos.match.def))); ndx++) ;
return testPos;
}
function getTestTemplate(pos, ndxIntlzr, tstPs) {
return getMaskSet().validPositions[pos] || determineTestTemplate(getTests(pos, ndxIntlzr ? ndxIntlzr.slice() : ndxIntlzr, tstPs));
}
function getTest(pos) {
return getMaskSet().validPositions[pos] ? getMaskSet().validPositions[pos] : getTests(pos)[0];
}
function positionCanMatchDefinition(pos, def) {
for (var valid = !1, tests = getTests(pos), tndx = 0; tndx < tests.length; tndx++) if (tests[tndx].match && tests[tndx].match.def === def) {
valid = !0;
break;
}
return valid;
}
function getTests(pos, ndxIntlzr, tstPs) {
function resolveTestFromToken(maskToken, ndxInitializer, loopNdx, quantifierRecurse) {
function handleMatch(match, loopNdx, quantifierRecurse) {
function isFirstMatch(latestMatch, tokenGroup) {
var firstMatch = 0 === $.inArray(latestMatch, tokenGroup.matches);
return firstMatch || $.each(tokenGroup.matches, function(ndx, match) {
if (!0 === match.isQuantifier && (firstMatch = isFirstMatch(latestMatch, tokenGroup.matches[ndx - 1]))) return !1;
}), firstMatch;
}
function resolveNdxInitializer(pos, alternateNdx, targetAlternation) {
var bestMatch, indexPos;
if (getMaskSet().validPositions[pos - 1] && targetAlternation && getMaskSet().tests[pos]) for (var vpAlternation = getMaskSet().validPositions[pos - 1].locator, tpAlternation = getMaskSet().tests[pos][0].locator, i = 0; i < targetAlternation; i++) if (vpAlternation[i] !== tpAlternation[i]) return vpAlternation.slice(targetAlternation + 1);
return (getMaskSet().tests[pos] || getMaskSet().validPositions[pos]) && $.each(getMaskSet().tests[pos] || [ getMaskSet().validPositions[pos] ], function(ndx, lmnt) {
var alternation = targetAlternation !== undefined ? targetAlternation : lmnt.alternation, ndxPos = lmnt.locator[alternation] !== undefined ? lmnt.locator[alternation].toString().indexOf(alternateNdx) : -1;
(indexPos === undefined || ndxPos < indexPos) && -1 !== ndxPos && (bestMatch = lmnt,
indexPos = ndxPos);
}), bestMatch ? bestMatch.locator.slice((targetAlternation !== undefined ? targetAlternation : bestMatch.alternation) + 1) : targetAlternation !== undefined ? resolveNdxInitializer(pos, alternateNdx) : undefined;
}
if (testPos > 1e4) throw "Inputmask: There is probably an error in your mask definition or in the code. Create an issue on github with an example of the mask you are using. " + getMaskSet().mask;
if (testPos === pos && match.matches === undefined) return matches.push({
match: match,
locator: loopNdx.reverse(),
cd: cacheDependency
}), !0;
if (match.matches !== undefined) {
if (match.isGroup && quantifierRecurse !== match) {
if (match = handleMatch(maskToken.matches[$.inArray(match, maskToken.matches) + 1], loopNdx)) return !0;
} else if (match.isOptional) {
var optionalToken = match;
if (match = resolveTestFromToken(match, ndxInitializer, loopNdx, quantifierRecurse)) {
if (latestMatch = matches[matches.length - 1].match, !isFirstMatch(latestMatch, optionalToken)) return !0;
insertStop = !0, testPos = pos;
}
} else if (match.isAlternator) {
var maltMatches, alternateToken = match, malternateMatches = [], currentMatches = matches.slice(), loopNdxCnt = loopNdx.length, altIndex = ndxInitializer.length > 0 ? ndxInitializer.shift() : -1;
if (-1 === altIndex || "string" == typeof altIndex) {
var amndx, currentPos = testPos, ndxInitializerClone = ndxInitializer.slice(), altIndexArr = [];
if ("string" == typeof altIndex) altIndexArr = altIndex.split(","); else for (amndx = 0; amndx < alternateToken.matches.length; amndx++) altIndexArr.push(amndx);
for (var ndx = 0; ndx < altIndexArr.length; ndx++) {
if (amndx = parseInt(altIndexArr[ndx]), matches = [], ndxInitializer = resolveNdxInitializer(testPos, amndx, loopNdxCnt) || ndxInitializerClone.slice(),
!0 !== (match = handleMatch(alternateToken.matches[amndx] || maskToken.matches[amndx], [ amndx ].concat(loopNdx), quantifierRecurse) || match) && match !== undefined && altIndexArr[altIndexArr.length - 1] < alternateToken.matches.length) {
var ntndx = $.inArray(match, maskToken.matches) + 1;
maskToken.matches.length > ntndx && (match = handleMatch(maskToken.matches[ntndx], [ ntndx ].concat(loopNdx.slice(1, loopNdx.length)), quantifierRecurse)) && (altIndexArr.push(ntndx.toString()),
$.each(matches, function(ndx, lmnt) {
lmnt.alternation = loopNdx.length - 1;
}));
}
maltMatches = matches.slice(), testPos = currentPos, matches = [];
for (var ndx1 = 0; ndx1 < maltMatches.length; ndx1++) {
var altMatch = maltMatches[ndx1], dropMatch = !1;
altMatch.alternation = altMatch.alternation || loopNdxCnt;
for (var ndx2 = 0; ndx2 < malternateMatches.length; ndx2++) {
var altMatch2 = malternateMatches[ndx2];
if ("string" != typeof altIndex || -1 !== $.inArray(altMatch.locator[altMatch.alternation].toString(), altIndexArr)) {
if (function(source, target) {
return source.match.nativeDef === target.match.nativeDef || source.match.def === target.match.nativeDef || source.match.nativeDef === target.match.def;
}(altMatch, altMatch2)) {
dropMatch = !0, altMatch.alternation === altMatch2.alternation && -1 === altMatch2.locator[altMatch2.alternation].toString().indexOf(altMatch.locator[altMatch.alternation]) && (altMatch2.locator[altMatch2.alternation] = altMatch2.locator[altMatch2.alternation] + "," + altMatch.locator[altMatch.alternation],
altMatch2.alternation = altMatch.alternation), altMatch.match.nativeDef === altMatch2.match.def && (altMatch.locator[altMatch.alternation] = altMatch2.locator[altMatch2.alternation],
malternateMatches.splice(malternateMatches.indexOf(altMatch2), 1, altMatch));
break;
}
if (altMatch.match.def === altMatch2.match.def) {
dropMatch = !1;
break;
}
if (function(source, target) {
return null === source.match.fn && null !== target.match.fn && target.match.fn.test(source.match.def, getMaskSet(), pos, !1, opts, !1);
}(altMatch, altMatch2) || function(source, target) {
return null !== source.match.fn && null !== target.match.fn && target.match.fn.test(source.match.def.replace(/[\[\]]/g, ""), getMaskSet(), pos, !1, opts, !1);
}(altMatch, altMatch2)) {
altMatch.alternation === altMatch2.alternation && -1 === altMatch.locator[altMatch.alternation].toString().indexOf(altMatch2.locator[altMatch2.alternation].toString().split("")[0]) && (altMatch.na = altMatch.na || altMatch.locator[altMatch.alternation].toString(),
-1 === altMatch.na.indexOf(altMatch.locator[altMatch.alternation].toString().split("")[0]) && (altMatch.na = altMatch.na + "," + altMatch.locator[altMatch2.alternation].toString().split("")[0]),
dropMatch = !0, altMatch.locator[altMatch.alternation] = altMatch2.locator[altMatch2.alternation].toString().split("")[0] + "," + altMatch.locator[altMatch.alternation],
malternateMatches.splice(malternateMatches.indexOf(altMatch2), 0, altMatch));
break;
}
}
}
dropMatch || malternateMatches.push(altMatch);
}
}
"string" == typeof altIndex && (malternateMatches = $.map(malternateMatches, function(lmnt, ndx) {
if (isFinite(ndx)) {
var alternation = lmnt.alternation, altLocArr = lmnt.locator[alternation].toString().split(",");
lmnt.locator[alternation] = undefined, lmnt.alternation = undefined;
for (var alndx = 0; alndx < altLocArr.length; alndx++) -1 !== $.inArray(altLocArr[alndx], altIndexArr) && (lmnt.locator[alternation] !== undefined ? (lmnt.locator[alternation] += ",",
lmnt.locator[alternation] += altLocArr[alndx]) : lmnt.locator[alternation] = parseInt(altLocArr[alndx]),
lmnt.alternation = alternation);
if (lmnt.locator[alternation] !== undefined) return lmnt;
}
})), matches = currentMatches.concat(malternateMatches), testPos = pos, insertStop = matches.length > 0,
match = malternateMatches.length > 0, ndxInitializer = ndxInitializerClone.slice();
} else match = handleMatch(alternateToken.matches[altIndex] || maskToken.matches[altIndex], [ altIndex ].concat(loopNdx), quantifierRecurse);
if (match) return !0;
} else if (match.isQuantifier && quantifierRecurse !== maskToken.matches[$.inArray(match, maskToken.matches) - 1]) for (var qt = match, qndx = ndxInitializer.length > 0 ? ndxInitializer.shift() : 0; qndx < (isNaN(qt.quantifier.max) ? qndx + 1 : qt.quantifier.max) && testPos <= pos; qndx++) {
var tokenGroup = maskToken.matches[$.inArray(qt, maskToken.matches) - 1];
if (match = handleMatch(tokenGroup, [ qndx ].concat(loopNdx), tokenGroup)) {
if (latestMatch = matches[matches.length - 1].match, latestMatch.optionalQuantifier = qndx > qt.quantifier.min - 1,
isFirstMatch(latestMatch, tokenGroup)) {
if (qndx > qt.quantifier.min - 1) {
insertStop = !0, testPos = pos;
break;
}
return !0;
}
return !0;
}
} else if (match = resolveTestFromToken(match, ndxInitializer, loopNdx, quantifierRecurse)) return !0;
} else testPos++;
}
for (var tndx = ndxInitializer.length > 0 ? ndxInitializer.shift() : 0; tndx < maskToken.matches.length; tndx++) if (!0 !== maskToken.matches[tndx].isQuantifier) {
var match = handleMatch(maskToken.matches[tndx], [ tndx ].concat(loopNdx), quantifierRecurse);
if (match && testPos === pos) return match;
if (testPos > pos) break;
}
}
function filterTests(tests) {
if (opts.keepStatic && pos > 0 && tests.length > 1 + ("" === tests[tests.length - 1].match.def ? 1 : 0) && !0 !== tests[0].match.optionality && !0 !== tests[0].match.optionalQuantifier && null === tests[0].match.fn && !/[0-9a-bA-Z]/.test(tests[0].match.def)) {
if (getMaskSet().validPositions[pos - 1] === undefined) return [ determineTestTemplate(tests) ];
if (getMaskSet().validPositions[pos - 1].alternation === tests[0].alternation) return [ determineTestTemplate(tests) ];
if (getMaskSet().validPositions[pos - 1]) return [ determineTestTemplate(tests) ];
}
return tests;
}
var latestMatch, maskTokens = getMaskSet().maskToken, testPos = ndxIntlzr ? tstPs : 0, ndxInitializer = ndxIntlzr ? ndxIntlzr.slice() : [ 0 ], matches = [], insertStop = !1, cacheDependency = ndxIntlzr ? ndxIntlzr.join("") : "";
if (pos > -1) {
if (ndxIntlzr === undefined) {
for (var test, previousPos = pos - 1; (test = getMaskSet().validPositions[previousPos] || getMaskSet().tests[previousPos]) === undefined && previousPos > -1; ) previousPos--;
test !== undefined && previousPos > -1 && (ndxInitializer = function(tests) {
var locator = [];
return $.isArray(tests) || (tests = [ tests ]), tests.length > 0 && (tests[0].alternation === undefined ? 0 === (locator = determineTestTemplate(tests.slice()).locator.slice()).length && (locator = tests[0].locator.slice()) : $.each(tests, function(ndx, tst) {
if ("" !== tst.def) if (0 === locator.length) locator = tst.locator.slice(); else for (var i = 0; i < locator.length; i++) tst.locator[i] && -1 === locator[i].toString().indexOf(tst.locator[i]) && (locator[i] += "," + tst.locator[i]);
})), locator;
}(test), cacheDependency = ndxInitializer.join(""), testPos = previousPos);
}
if (getMaskSet().tests[pos] && getMaskSet().tests[pos][0].cd === cacheDependency) return filterTests(getMaskSet().tests[pos]);
for (var mtndx = ndxInitializer.shift(); mtndx < maskTokens.length && !(resolveTestFromToken(maskTokens[mtndx], ndxInitializer, [ mtndx ]) && testPos === pos || testPos > pos); mtndx++) ;
}
return (0 === matches.length || insertStop) && matches.push({
match: {
fn: null,
cardinality: 0,
optionality: !0,
casing: null,
def: "",
placeholder: ""
},
locator: [],
cd: cacheDependency
}), ndxIntlzr !== undefined && getMaskSet().tests[pos] ? filterTests($.extend(!0, [], matches)) : (getMaskSet().tests[pos] = $.extend(!0, [], matches),
filterTests(getMaskSet().tests[pos]));
}
function getBufferTemplate() {
return getMaskSet()._buffer === undefined && (getMaskSet()._buffer = getMaskTemplate(!1, 1),
getMaskSet().buffer === undefined && (getMaskSet().buffer = getMaskSet()._buffer.slice())),
getMaskSet()._buffer;
}
function getBuffer(noCache) {
return getMaskSet().buffer !== undefined && !0 !== noCache || (getMaskSet().buffer = getMaskTemplate(!0, getLastValidPosition(), !0)),
getMaskSet().buffer;
}
function refreshFromBuffer(start, end, buffer) {
var i, p;
if (!0 === start) resetMaskSet(), start = 0, end = buffer.length; else for (i = start; i < end; i++) delete getMaskSet().validPositions[i];
for (p = start, i = start; i < end; i++) if (resetMaskSet(!0), buffer[i] !== opts.skipOptionalPartCharacter) {
var valResult = isValid(p, buffer[i], !0, !0);
!1 !== valResult && (resetMaskSet(!0), p = valResult.caret !== undefined ? valResult.caret : valResult.pos + 1);
}
}
function casing(elem, test, pos) {
switch (opts.casing || test.casing) {
case "upper":
elem = elem.toUpperCase();
break;
case "lower":
elem = elem.toLowerCase();
break;
case "title":
var posBefore = getMaskSet().validPositions[pos - 1];
elem = 0 === pos || posBefore && posBefore.input === String.fromCharCode(Inputmask.keyCode.SPACE) ? elem.toUpperCase() : elem.toLowerCase();
break;
default:
if ($.isFunction(opts.casing)) {
var args = Array.prototype.slice.call(arguments);
args.push(getMaskSet().validPositions), elem = opts.casing.apply(this, args);
}
}
return elem;
}
function checkAlternationMatch(altArr1, altArr2, na) {
for (var naNdx, altArrC = opts.greedy ? altArr2 : altArr2.slice(0, 1), isMatch = !1, naArr = na !== undefined ? na.split(",") : [], i = 0; i < naArr.length; i++) -1 !== (naNdx = altArr1.indexOf(naArr[i])) && altArr1.splice(naNdx, 1);
for (var alndx = 0; alndx < altArr1.length; alndx++) if (-1 !== $.inArray(altArr1[alndx], altArrC)) {
isMatch = !0;
break;
}
return isMatch;
}
function isValid(pos, c, strict, fromSetValid, fromAlternate, validateOnly) {
function isSelection(posObj) {
var selection = isRTL ? posObj.begin - posObj.end > 1 || posObj.begin - posObj.end == 1 : posObj.end - posObj.begin > 1 || posObj.end - posObj.begin == 1;
return selection && 0 === posObj.begin && posObj.end === getMaskSet().maskLength ? "full" : selection;
}
function _isValid(position, c, strict) {
var rslt = !1;
return $.each(getTests(position), function(ndx, tst) {
for (var test = tst.match, loopend = c ? 1 : 0, chrs = "", i = test.cardinality; i > loopend; i--) chrs += getBufferElement(position - (i - 1));
if (c && (chrs += c), getBuffer(!0), !1 !== (rslt = null != test.fn ? test.fn.test(chrs, getMaskSet(), position, strict, opts, isSelection(pos)) : (c === test.def || c === opts.skipOptionalPartCharacter) && "" !== test.def && {
c: getPlaceholder(position, test, !0) || test.def,
pos: position
})) {
var elem = rslt.c !== undefined ? rslt.c : c;
elem = elem === opts.skipOptionalPartCharacter && null === test.fn ? getPlaceholder(position, test, !0) || test.def : elem;
var validatedPos = position, possibleModifiedBuffer = getBuffer();
if (rslt.remove !== undefined && ($.isArray(rslt.remove) || (rslt.remove = [ rslt.remove ]),
$.each(rslt.remove.sort(function(a, b) {
return b - a;
}), function(ndx, lmnt) {
stripValidPositions(lmnt, lmnt + 1, !0);
})), rslt.insert !== undefined && ($.isArray(rslt.insert) || (rslt.insert = [ rslt.insert ]),
$.each(rslt.insert.sort(function(a, b) {
return a - b;
}), function(ndx, lmnt) {
isValid(lmnt.pos, lmnt.c, !0, fromSetValid);
})), rslt.refreshFromBuffer) {
var refresh = rslt.refreshFromBuffer;
if (refreshFromBuffer(!0 === refresh ? refresh : refresh.start, refresh.end, possibleModifiedBuffer),
rslt.pos === undefined && rslt.c === undefined) return rslt.pos = getLastValidPosition(),
!1;
if ((validatedPos = rslt.pos !== undefined ? rslt.pos : position) !== position) return rslt = $.extend(rslt, isValid(validatedPos, elem, !0, fromSetValid)),
!1;
} else if (!0 !== rslt && rslt.pos !== undefined && rslt.pos !== position && (validatedPos = rslt.pos,
refreshFromBuffer(position, validatedPos, getBuffer().slice()), validatedPos !== position)) return rslt = $.extend(rslt, isValid(validatedPos, elem, !0)),
!1;
return (!0 === rslt || rslt.pos !== undefined || rslt.c !== undefined) && (ndx > 0 && resetMaskSet(!0),
setValidPosition(validatedPos, $.extend({}, tst, {
input: casing(elem, test, validatedPos)
}), fromSetValid, isSelection(pos)) || (rslt = !1), !1);
}
}), rslt;
}
function setValidPosition(pos, validTest, fromSetValid, isSelection) {
if (isSelection || opts.insertMode && getMaskSet().validPositions[pos] !== undefined && fromSetValid === undefined) {
var i, positionsClone = $.extend(!0, {}, getMaskSet().validPositions), lvp = getLastValidPosition(undefined, !0);
for (i = pos; i <= lvp; i++) delete getMaskSet().validPositions[i];
getMaskSet().validPositions[pos] = $.extend(!0, {}, validTest);
var j, valid = !0, vps = getMaskSet().validPositions, needsValidation = !1, initialLength = getMaskSet().maskLength;
for (i = j = pos; i <= lvp; i++) {
var t = positionsClone[i];
if (t !== undefined) for (var posMatch = j; posMatch < getMaskSet().maskLength && (null === t.match.fn && vps[i] && (!0 === vps[i].match.optionalQuantifier || !0 === vps[i].match.optionality) || null != t.match.fn); ) {
if (posMatch++, !1 === needsValidation && positionsClone[posMatch] && positionsClone[posMatch].match.def === t.match.def) getMaskSet().validPositions[posMatch] = $.extend(!0, {}, positionsClone[posMatch]),
getMaskSet().validPositions[posMatch].input = t.input, fillMissingNonMask(posMatch),
j = posMatch, valid = !0; else if (positionCanMatchDefinition(posMatch, t.match.def)) {
var result = isValid(posMatch, t.input, !0, !0);
valid = !1 !== result, j = result.caret || result.insert ? getLastValidPosition() : posMatch,
needsValidation = !0;
} else if (!(valid = !0 === t.generatedInput) && posMatch >= getMaskSet().maskLength - 1) break;
if (getMaskSet().maskLength < initialLength && (getMaskSet().maskLength = initialLength),
valid) break;
}
if (!valid) break;
}
if (!valid) return getMaskSet().validPositions = $.extend(!0, {}, positionsClone),
resetMaskSet(!0), !1;
} else getMaskSet().validPositions[pos] = $.extend(!0, {}, validTest);
return resetMaskSet(!0), !0;
}
function fillMissingNonMask(maskPos) {
for (var pndx = maskPos - 1; pndx > -1 && !getMaskSet().validPositions[pndx]; pndx--) ;
var testTemplate, testsFromPos;
for (pndx++; pndx < maskPos; pndx++) getMaskSet().validPositions[pndx] === undefined && (!1 === opts.jitMasking || opts.jitMasking > pndx) && ("" === (testsFromPos = getTests(pndx, getTestTemplate(pndx - 1).locator, pndx - 1).slice())[testsFromPos.length - 1].match.def && testsFromPos.pop(),
(testTemplate = determineTestTemplate(testsFromPos)) && (testTemplate.match.def === opts.radixPointDefinitionSymbol || !isMask(pndx, !0) || $.inArray(opts.radixPoint, getBuffer()) < pndx && testTemplate.match.fn && testTemplate.match.fn.test(getPlaceholder(pndx), getMaskSet(), pndx, !1, opts)) && !1 !== (result = _isValid(pndx, getPlaceholder(pndx, testTemplate.match, !0) || (null == testTemplate.match.fn ? testTemplate.match.def : "" !== getPlaceholder(pndx) ? getPlaceholder(pndx) : getBuffer()[pndx]), !0)) && (getMaskSet().validPositions[result.pos || pndx].generatedInput = !0));
}
strict = !0 === strict;
var maskPos = pos;
pos.begin !== undefined && (maskPos = isRTL && !isSelection(pos) ? pos.end : pos.begin);
var result = !0, positionsClone = $.extend(!0, {}, getMaskSet().validPositions);
if ($.isFunction(opts.preValidation) && !strict && !0 !== fromSetValid && !0 !== validateOnly && (result = opts.preValidation(getBuffer(), maskPos, c, isSelection(pos), opts)),
!0 === result) {
if (fillMissingNonMask(maskPos), isSelection(pos) && (handleRemove(undefined, Inputmask.keyCode.DELETE, pos, !0, !0),
maskPos = getMaskSet().p), maskPos < getMaskSet().maskLength && (maxLength === undefined || maskPos < maxLength) && (result = _isValid(maskPos, c, strict),
(!strict || !0 === fromSetValid) && !1 === result && !0 !== validateOnly)) {
var currentPosValid = getMaskSet().validPositions[maskPos];
if (!currentPosValid || null !== currentPosValid.match.fn || currentPosValid.match.def !== c && c !== opts.skipOptionalPartCharacter) {
if ((opts.insertMode || getMaskSet().validPositions[seekNext(maskPos)] === undefined) && !isMask(maskPos, !0)) for (var nPos = maskPos + 1, snPos = seekNext(maskPos); nPos <= snPos; nPos++) if (!1 !== (result = _isValid(nPos, c, strict))) {
!function(originalPos, newPos) {
var vp = getMaskSet().validPositions[newPos];
if (vp) for (var targetLocator = vp.locator, tll = targetLocator.length, ps = originalPos; ps < newPos; ps++) if (getMaskSet().validPositions[ps] === undefined && !isMask(ps, !0)) {
var tests = getTests(ps).slice(), bestMatch = determineTestTemplate(tests, !0), equality = -1;
"" === tests[tests.length - 1].match.def && tests.pop(), $.each(tests, function(ndx, tst) {
for (var i = 0; i < tll; i++) {
if (tst.locator[i] === undefined || !checkAlternationMatch(tst.locator[i].toString().split(","), targetLocator[i].toString().split(","), tst.na)) {
var targetAI = targetLocator[i], bestMatchAI = bestMatch.locator[i], tstAI = tst.locator[i];
targetAI - bestMatchAI > Math.abs(targetAI - tstAI) && (bestMatch = tst);
break;
}
equality < i && (equality = i, bestMatch = tst);
}
}), (bestMatch = $.extend({}, bestMatch, {
input: getPlaceholder(ps, bestMatch.match, !0) || bestMatch.match.def
})).generatedInput = !0, setValidPosition(ps, bestMatch, !0), getMaskSet().validPositions[newPos] = undefined,
_isValid(newPos, vp.input, !0);
}
}(maskPos, result.pos !== undefined ? result.pos : nPos), maskPos = nPos;
break;
}
} else result = {
caret: seekNext(maskPos)
};
}
!1 === result && opts.keepStatic && !strict && !0 !== fromAlternate && (result = function(pos, c, strict) {
var lastAlt, alternation, altPos, prevAltPos, i, validPos, altNdxs, decisionPos, validPsClone = $.extend(!0, {}, getMaskSet().validPositions), isValidRslt = !1, lAltPos = getLastValidPosition();
for (prevAltPos = getMaskSet().validPositions[lAltPos]; lAltPos >= 0; lAltPos--) if ((altPos = getMaskSet().validPositions[lAltPos]) && altPos.alternation !== undefined) {
if (lastAlt = lAltPos, alternation = getMaskSet().validPositions[lastAlt].alternation,
prevAltPos.locator[altPos.alternation] !== altPos.locator[altPos.alternation]) break;
prevAltPos = altPos;
}
if (alternation !== undefined) {
decisionPos = parseInt(lastAlt);
var decisionTaker = prevAltPos.locator[prevAltPos.alternation || alternation] !== undefined ? prevAltPos.locator[prevAltPos.alternation || alternation] : altNdxs[0];
decisionTaker.length > 0 && (decisionTaker = decisionTaker.split(",")[0]);
var possibilityPos = getMaskSet().validPositions[decisionPos], prevPos = getMaskSet().validPositions[decisionPos - 1];
$.each(getTests(decisionPos, prevPos ? prevPos.locator : undefined, decisionPos - 1), function(ndx, test) {
altNdxs = test.locator[alternation] ? test.locator[alternation].toString().split(",") : [];
for (var mndx = 0; mndx < altNdxs.length; mndx++) {
var validInputs = [], staticInputsBeforePos = 0, staticInputsBeforePosAlternate = 0, verifyValidInput = !1;
if (decisionTaker < altNdxs[mndx] && (test.na === undefined || -1 === $.inArray(altNdxs[mndx], test.na.split(",")) || -1 === $.inArray(decisionTaker.toString(), altNdxs))) {
getMaskSet().validPositions[decisionPos] = $.extend(!0, {}, test);
var possibilities = getMaskSet().validPositions[decisionPos].locator;
for (getMaskSet().validPositions[decisionPos].locator[alternation] = parseInt(altNdxs[mndx]),
null == test.match.fn ? (possibilityPos.input !== test.match.def && (verifyValidInput = !0,
!0 !== possibilityPos.generatedInput && validInputs.push(possibilityPos.input)),
staticInputsBeforePosAlternate++, getMaskSet().validPositions[decisionPos].generatedInput = !/[0-9a-bA-Z]/.test(test.match.def),
getMaskSet().validPositions[decisionPos].input = test.match.def) : getMaskSet().validPositions[decisionPos].input = possibilityPos.input,
i = decisionPos + 1; i < getLastValidPosition(undefined, !0) + 1; i++) (validPos = getMaskSet().validPositions[i]) && !0 !== validPos.generatedInput && /[0-9a-bA-Z]/.test(validPos.input) ? validInputs.push(validPos.input) : i < pos && staticInputsBeforePos++,
delete getMaskSet().validPositions[i];
for (verifyValidInput && validInputs[0] === test.match.def && validInputs.shift(),
resetMaskSet(!0), isValidRslt = !0; validInputs.length > 0; ) {
var input = validInputs.shift();
if (input !== opts.skipOptionalPartCharacter && !(isValidRslt = isValid(getLastValidPosition(undefined, !0) + 1, input, !1, fromSetValid, !0))) break;
}
if (isValidRslt) {
getMaskSet().validPositions[decisionPos].locator = possibilities;
var targetLvp = getLastValidPosition(pos) + 1;
for (i = decisionPos + 1; i < getLastValidPosition() + 1; i++) ((validPos = getMaskSet().validPositions[i]) === undefined || null == validPos.match.fn) && i < pos + (staticInputsBeforePosAlternate - staticInputsBeforePos) && staticInputsBeforePosAlternate++;
isValidRslt = isValid((pos += staticInputsBeforePosAlternate - staticInputsBeforePos) > targetLvp ? targetLvp : pos, c, strict, fromSetValid, !0);
}
if (isValidRslt) return !1;
resetMaskSet(), getMaskSet().validPositions = $.extend(!0, {}, validPsClone);
}
}
});
}
return isValidRslt;
}(maskPos, c, strict)), !0 === result && (result = {
pos: maskPos
});
}
if ($.isFunction(opts.postValidation) && !1 !== result && !strict && !0 !== fromSetValid && !0 !== validateOnly) {
var postResult = opts.postValidation(getBuffer(!0), result, opts);
if (postResult.refreshFromBuffer && postResult.buffer) {
var refresh = postResult.refreshFromBuffer;
refreshFromBuffer(!0 === refresh ? refresh : refresh.start, refresh.end, postResult.buffer);
}
result = !0 === postResult ? result : postResult;
}
return result && result.pos === undefined && (result.pos = maskPos), !1 !== result && !0 !== validateOnly || (resetMaskSet(!0),
getMaskSet().validPositions = $.extend(!0, {}, positionsClone)), result;
}
function isMask(pos, strict) {
var test = getTestTemplate(pos).match;
if ("" === test.def && (test = getTest(pos).match), null != test.fn) return test.fn;
if (!0 !== strict && pos > -1) {
var tests = getTests(pos);
return tests.length > 1 + ("" === tests[tests.length - 1].match.def ? 1 : 0);
}
return !1;
}
function seekNext(pos, newBlock) {
var maskL = getMaskSet().maskLength;
if (pos >= maskL) return maskL;
var position = pos;
for (getTests(maskL + 1).length > 1 && (getMaskTemplate(!0, maskL + 1, !0), maskL = getMaskSet().maskLength); ++position < maskL && (!0 === newBlock && (!0 !== getTest(position).match.newBlockMarker || !isMask(position)) || !0 !== newBlock && !isMask(position)); ) ;
return position;
}
function seekPrevious(pos, newBlock) {
var tests, position = pos;
if (position <= 0) return 0;
for (;--position > 0 && (!0 === newBlock && !0 !== getTest(position).match.newBlockMarker || !0 !== newBlock && !isMask(position) && ((tests = getTests(position)).length < 2 || 2 === tests.length && "" === tests[1].match.def)); ) ;
return position;
}
function getBufferElement(position) {
return getMaskSet().validPositions[position] === undefined ? getPlaceholder(position) : getMaskSet().validPositions[position].input;
}
function writeBuffer(input, buffer, caretPos, event, triggerInputEvent) {
if (event && $.isFunction(opts.onBeforeWrite)) {
var result = opts.onBeforeWrite.call(inputmask, event, buffer, caretPos, opts);
if (result) {
if (result.refreshFromBuffer) {
var refresh = result.refreshFromBuffer;
refreshFromBuffer(!0 === refresh ? refresh : refresh.start, refresh.end, result.buffer || buffer),
buffer = getBuffer(!0);
}
caretPos !== undefined && (caretPos = result.caret !== undefined ? result.caret : caretPos);
}
}
input !== undefined && (input.inputmask._valueSet(buffer.join("")), caretPos === undefined || event !== undefined && "blur" === event.type ? renderColorMask(input, caretPos, 0 === buffer.length) : android && event && "input" === event.type ? setTimeout(function() {
caret(input, caretPos);
}, 0) : caret(input, caretPos), !0 === triggerInputEvent && (skipInputEvent = !0,
$(input).trigger("input")));
}
function getPlaceholder(pos, test, returnPL) {
if ((test = test || getTest(pos).match).placeholder !== undefined || !0 === returnPL) return $.isFunction(test.placeholder) ? test.placeholder(opts) : test.placeholder;
if (null === test.fn) {
if (pos > -1 && getMaskSet().validPositions[pos] === undefined) {
var prevTest, tests = getTests(pos), staticAlternations = [];
if (tests.length > 1 + ("" === tests[tests.length - 1].match.def ? 1 : 0)) for (var i = 0; i < tests.length; i++) if (!0 !== tests[i].match.optionality && !0 !== tests[i].match.optionalQuantifier && (null === tests[i].match.fn || prevTest === undefined || !1 !== tests[i].match.fn.test(prevTest.match.def, getMaskSet(), pos, !0, opts)) && (staticAlternations.push(tests[i]),
null === tests[i].match.fn && (prevTest = tests[i]), staticAlternations.length > 1 && /[0-9a-bA-Z]/.test(staticAlternations[0].match.def))) return opts.placeholder.charAt(pos % opts.placeholder.length);
}
return test.def;
}
return opts.placeholder.charAt(pos % opts.placeholder.length);
}
function checkVal(input, writeOut, strict, nptvl, initiatingEvent) {
function isTemplateMatch(ndx, charCodes) {
return -1 !== getBufferTemplate().slice(ndx, seekNext(ndx)).join("").indexOf(charCodes) && !isMask(ndx) && getTest(ndx).match.nativeDef === charCodes.charAt(charCodes.length - 1);
}
var inputValue = nptvl.slice(), charCodes = "", initialNdx = -1, result = undefined;
if (resetMaskSet(), strict || !0 === opts.autoUnmask) initialNdx = seekNext(initialNdx); else {
var staticInput = getBufferTemplate().slice(0, seekNext(-1)).join(""), matches = inputValue.join("").match(new RegExp("^" + Inputmask.escapeRegex(staticInput), "g"));
matches && matches.length > 0 && (inputValue.splice(0, matches.length * staticInput.length),
initialNdx = seekNext(initialNdx));
}
if (-1 === initialNdx ? (getMaskSet().p = seekNext(initialNdx), initialNdx = 0) : getMaskSet().p = initialNdx,
$.each(inputValue, function(ndx, charCode) {
if (charCode !== undefined) if (getMaskSet().validPositions[ndx] === undefined && inputValue[ndx] === getPlaceholder(ndx) && isMask(ndx, !0) && !1 === isValid(ndx, inputValue[ndx], !0, undefined, undefined, !0)) getMaskSet().p++; else {
var keypress = new $.Event("_checkval");
keypress.which = charCode.charCodeAt(0), charCodes += charCode;
var lvp = getLastValidPosition(undefined, !0), lvTest = getMaskSet().validPositions[lvp], nextTest = getTestTemplate(lvp + 1, lvTest ? lvTest.locator.slice() : undefined, lvp);
if (!isTemplateMatch(initialNdx, charCodes) || strict || opts.autoUnmask) {
var pos = strict ? ndx : null == nextTest.match.fn && nextTest.match.optionality && lvp + 1 < getMaskSet().p ? lvp + 1 : getMaskSet().p;
result = EventHandlers.keypressEvent.call(input, keypress, !0, !1, strict, pos),
initialNdx = pos + 1, charCodes = "";
} else result = EventHandlers.keypressEvent.call(input, keypress, !0, !1, !0, lvp + 1);
if (!1 !== result && !strict && $.isFunction(opts.onBeforeWrite)) {
var origResult = result;
if (result = opts.onBeforeWrite.call(inputmask, keypress, getBuffer(), result.forwardPosition, opts),
(result = $.extend(origResult, result)) && result.refreshFromBuffer) {
var refresh = result.refreshFromBuffer;
refreshFromBuffer(!0 === refresh ? refresh : refresh.start, refresh.end, result.buffer),
resetMaskSet(!0), result.caret && (getMaskSet().p = result.caret, result.forwardPosition = result.caret);
}
}
}
}), writeOut) {
var caretPos = undefined;
document.activeElement === input && result && (caretPos = opts.numericInput ? seekPrevious(result.forwardPosition) : result.forwardPosition),
writeBuffer(input, getBuffer(), caretPos, initiatingEvent || new $.Event("checkval"), initiatingEvent && "input" === initiatingEvent.type);
}
}
function unmaskedvalue(input) {
if (input) {
if (input.inputmask === undefined) return input.value;
input.inputmask && input.inputmask.refreshValue && EventHandlers.setValueEvent.call(input);
}
var umValue = [], vps = getMaskSet().validPositions;
for (var pndx in vps) vps[pndx].match && null != vps[pndx].match.fn && umValue.push(vps[pndx].input);
var unmaskedValue = 0 === umValue.length ? "" : (isRTL ? umValue.reverse() : umValue).join("");
if ($.isFunction(opts.onUnMask)) {
var bufferValue = (isRTL ? getBuffer().slice().reverse() : getBuffer()).join("");
unmaskedValue = opts.onUnMask.call(inputmask, bufferValue, unmaskedValue, opts);
}
return unmaskedValue;
}
function caret(input, begin, end, notranslate) {
function translatePosition(pos) {
return !0 === notranslate || !isRTL || "number" != typeof pos || opts.greedy && "" === opts.placeholder || (pos = getBuffer().join("").length - pos),
pos;
}
var range;
if (begin === undefined) return input.setSelectionRange ? (begin = input.selectionStart,
end = input.selectionEnd) : window.getSelection ? (range = window.getSelection().getRangeAt(0)).commonAncestorContainer.parentNode !== input && range.commonAncestorContainer !== input || (begin = range.startOffset,
end = range.endOffset) : document.selection && document.selection.createRange && (end = (begin = 0 - (range = document.selection.createRange()).duplicate().moveStart("character", -input.inputmask._valueGet().length)) + range.text.length),
{
begin: translatePosition(begin),
end: translatePosition(end)
};
if (begin.begin !== undefined && (end = begin.end, begin = begin.begin), "number" == typeof begin) {
begin = translatePosition(begin), end = "number" == typeof (end = translatePosition(end)) ? end : begin;
var scrollCalc = parseInt(((input.ownerDocument.defaultView || window).getComputedStyle ? (input.ownerDocument.defaultView || window).getComputedStyle(input, null) : input.currentStyle).fontSize) * end;
if (input.scrollLeft = scrollCalc > input.scrollWidth ? scrollCalc : 0, mobile || !1 !== opts.insertMode || begin !== end || end++,
input.setSelectionRange) input.selectionStart = begin, input.selectionEnd = end; else if (window.getSelection) {
if (range = document.createRange(), input.firstChild === undefined || null === input.firstChild) {
var textNode = document.createTextNode("");
input.appendChild(textNode);
}
range.setStart(input.firstChild, begin < input.inputmask._valueGet().length ? begin : input.inputmask._valueGet().length),
range.setEnd(input.firstChild, end < input.inputmask._valueGet().length ? end : input.inputmask._valueGet().length),
range.collapse(!0);
var sel = window.getSelection();
sel.removeAllRanges(), sel.addRange(range);
} else input.createTextRange && ((range = input.createTextRange()).collapse(!0),
range.moveEnd("character", end), range.moveStart("character", begin), range.select());
renderColorMask(input, {
begin: begin,
end: end
});
}
}
function determineLastRequiredPosition(returnDefinition) {
var pos, testPos, buffer = getBuffer(), bl = buffer.length, lvp = getLastValidPosition(), positions = {}, lvTest = getMaskSet().validPositions[lvp], ndxIntlzr = lvTest !== undefined ? lvTest.locator.slice() : undefined;
for (pos = lvp + 1; pos < buffer.length; pos++) ndxIntlzr = (testPos = getTestTemplate(pos, ndxIntlzr, pos - 1)).locator.slice(),
positions[pos] = $.extend(!0, {}, testPos);
var lvTestAlt = lvTest && lvTest.alternation !== undefined ? lvTest.locator[lvTest.alternation] : undefined;
for (pos = bl - 1; pos > lvp && (((testPos = positions[pos]).match.optionality || testPos.match.optionalQuantifier && testPos.match.newBlockMarker || lvTestAlt && (lvTestAlt !== positions[pos].locator[lvTest.alternation] && null != testPos.match.fn || null === testPos.match.fn && testPos.locator[lvTest.alternation] && checkAlternationMatch(testPos.locator[lvTest.alternation].toString().split(","), lvTestAlt.toString().split(",")) && "" !== getTests(pos)[0].def)) && buffer[pos] === getPlaceholder(pos, testPos.match)); pos--) bl--;
return returnDefinition ? {
l: bl,
def: positions[bl] ? positions[bl].match : undefined
} : bl;
}
function clearOptionalTail(buffer) {
for (var validPos, rl = determineLastRequiredPosition(), bl = buffer.length, lv = getMaskSet().validPositions[getLastValidPosition()]; rl < bl && !isMask(rl, !0) && (validPos = lv !== undefined ? getTestTemplate(rl, lv.locator.slice(""), lv) : getTest(rl)) && !0 !== validPos.match.optionality && (!0 !== validPos.match.optionalQuantifier && !0 !== validPos.match.newBlockMarker || rl + 1 === bl && "" === (lv !== undefined ? getTestTemplate(rl + 1, lv.locator.slice(""), lv) : getTest(rl + 1)).match.def); ) rl++;
for (;(validPos = getMaskSet().validPositions[rl - 1]) && validPos && validPos.match.optionality && validPos.input === opts.skipOptionalPartCharacter; ) rl--;
return buffer.splice(rl), buffer;
}
function isComplete(buffer) {
if ($.isFunction(opts.isComplete)) return opts.isComplete(buffer, opts);
if ("*" === opts.repeat) return undefined;
var complete = !1, lrp = determineLastRequiredPosition(!0), aml = seekPrevious(lrp.l);
if (lrp.def === undefined || lrp.def.newBlockMarker || lrp.def.optionality || lrp.def.optionalQuantifier) {
complete = !0;
for (var i = 0; i <= aml; i++) {
var test = getTestTemplate(i).match;
if (null !== test.fn && getMaskSet().validPositions[i] === undefined && !0 !== test.optionality && !0 !== test.optionalQuantifier || null === test.fn && buffer[i] !== getPlaceholder(i, test)) {
complete = !1;
break;
}
}
}
return complete;
}
function handleRemove(input, k, pos, strict, fromIsValid) {
if ((opts.numericInput || isRTL) && (k === Inputmask.keyCode.BACKSPACE ? k = Inputmask.keyCode.DELETE : k === Inputmask.keyCode.DELETE && (k = Inputmask.keyCode.BACKSPACE),
isRTL)) {
var pend = pos.end;
pos.end = pos.begin, pos.begin = pend;
}
k === Inputmask.keyCode.BACKSPACE && (pos.end - pos.begin < 1 || !1 === opts.insertMode) ? (pos.begin = seekPrevious(pos.begin),
getMaskSet().validPositions[pos.begin] !== undefined && getMaskSet().validPositions[pos.begin].input === opts.groupSeparator && pos.begin--) : k === Inputmask.keyCode.DELETE && pos.begin === pos.end && (pos.end = isMask(pos.end, !0) && getMaskSet().validPositions[pos.end] && getMaskSet().validPositions[pos.end].input !== opts.radixPoint ? pos.end + 1 : seekNext(pos.end) + 1,
getMaskSet().validPositions[pos.begin] !== undefined && getMaskSet().validPositions[pos.begin].input === opts.groupSeparator && pos.end++),
stripValidPositions(pos.begin, pos.end, !1, strict), !0 !== strict && function() {
if (opts.keepStatic) {
for (var validInputs = [], lastAlt = getLastValidPosition(-1, !0), positionsClone = $.extend(!0, {}, getMaskSet().validPositions), prevAltPos = getMaskSet().validPositions[lastAlt]; lastAlt >= 0; lastAlt--) {
var altPos = getMaskSet().validPositions[lastAlt];
if (altPos) {
if (!0 !== altPos.generatedInput && /[0-9a-bA-Z]/.test(altPos.input) && validInputs.push(altPos.input),
delete getMaskSet().validPositions[lastAlt], altPos.alternation !== undefined && altPos.locator[altPos.alternation] !== prevAltPos.locator[altPos.alternation]) break;
prevAltPos = altPos;
}
}
if (lastAlt > -1) for (getMaskSet().p = seekNext(getLastValidPosition(-1, !0)); validInputs.length > 0; ) {
var keypress = new $.Event("keypress");
keypress.which = validInputs.pop().charCodeAt(0), EventHandlers.keypressEvent.call(input, keypress, !0, !1, !1, getMaskSet().p);
} else getMaskSet().validPositions = $.extend(!0, {}, positionsClone);
}
}();
var lvp = getLastValidPosition(pos.begin, !0);
if (lvp < pos.begin) getMaskSet().p = seekNext(lvp); else if (!0 !== strict && (getMaskSet().p = pos.begin,
!0 !== fromIsValid)) for (;getMaskSet().p < lvp && getMaskSet().validPositions[getMaskSet().p] === undefined; ) getMaskSet().p++;
}
function initializeColorMask(input) {
function findCaretPos(clientx) {
var caretPos, e = document.createElement("span");
for (var style in computedStyle) isNaN(style) && -1 !== style.indexOf("font") && (e.style[style] = computedStyle[style]);
e.style.textTransform = computedStyle.textTransform, e.style.letterSpacing = computedStyle.letterSpacing,
e.style.position = "absolute", e.style.height = "auto", e.style.width = "auto",
e.style.visibility = "hidden", e.style.whiteSpace = "nowrap", document.body.appendChild(e);
var itl, inputText = input.inputmask._valueGet(), previousWidth = 0;
for (caretPos = 0, itl = inputText.length; caretPos <= itl; caretPos++) {
if (e.innerHTML += inputText.charAt(caretPos) || "_", e.offsetWidth >= clientx) {
var offset1 = clientx - previousWidth, offset2 = e.offsetWidth - clientx;
e.innerHTML = inputText.charAt(caretPos), caretPos = (offset1 -= e.offsetWidth / 3) < offset2 ? caretPos - 1 : caretPos;
break;
}
previousWidth = e.offsetWidth;
}
return document.body.removeChild(e), caretPos;
}
var computedStyle = (input.ownerDocument.defaultView || window).getComputedStyle(input, null), template = document.createElement("div");
template.style.width = computedStyle.width, template.style.textAlign = computedStyle.textAlign,
(colorMask = document.createElement("div")).className = "im-colormask", input.parentNode.insertBefore(colorMask, input),
input.parentNode.removeChild(input), colorMask.appendChild(template), colorMask.appendChild(input),
input.style.left = template.offsetLeft + "px", $(input).on("click", function(e) {
return caret(input, findCaretPos(e.clientX)), EventHandlers.clickEvent.call(input, [ e ]);
}), $(input).on("keydown", function(e) {
e.shiftKey || !1 === opts.insertMode || setTimeout(function() {
renderColorMask(input);
}, 0);
});
}
function renderColorMask(input, caretPos, clear) {
function handleStatic() {
isStatic || null !== test.fn && testPos.input !== undefined ? isStatic && (null !== test.fn && testPos.input !== undefined || "" === test.def) && (isStatic = !1,
maskTemplate += "</span>") : (isStatic = !0, maskTemplate += "<span class='im-static'>");
}
function handleCaret(force) {
!0 !== force && pos !== caretPos.begin || document.activeElement !== input || (maskTemplate += "<span class='im-caret' style='border-right-width: 1px;border-right-style: solid;'></span>");
}
var test, testPos, ndxIntlzr, maskTemplate = "", isStatic = !1, pos = 0;
if (colorMask !== undefined) {
var buffer = getBuffer();
if (caretPos === undefined ? caretPos = caret(input) : caretPos.begin === undefined && (caretPos = {
begin: caretPos,
end: caretPos
}), !0 !== clear) {
var lvp = getLastValidPosition();
do {
handleCaret(), getMaskSet().validPositions[pos] ? (testPos = getMaskSet().validPositions[pos],
test = testPos.match, ndxIntlzr = testPos.locator.slice(), handleStatic(), maskTemplate += buffer[pos]) : (testPos = getTestTemplate(pos, ndxIntlzr, pos - 1),
test = testPos.match, ndxIntlzr = testPos.locator.slice(), (!1 === opts.jitMasking || pos < lvp || "number" == typeof opts.jitMasking && isFinite(opts.jitMasking) && opts.jitMasking > pos) && (handleStatic(),
maskTemplate += getPlaceholder(pos, test))), pos++;
} while ((maxLength === undefined || pos < maxLength) && (null !== test.fn || "" !== test.def) || lvp > pos || isStatic);
-1 === maskTemplate.indexOf("im-caret") && handleCaret(!0), isStatic && handleStatic();
}
var template = colorMask.getElementsByTagName("div")[0];
template.innerHTML = maskTemplate, input.inputmask.positionColorMask(input, template);
}
}
maskset = maskset || this.maskset, opts = opts || this.opts;
var undoValue, $el, maxLength, colorMask, inputmask = this, el = this.el, isRTL = this.isRTL, skipKeyPressEvent = !1, skipInputEvent = !1, ignorable = !1, mouseEnter = !1, EventRuler = {
on: function(input, eventName, eventHandler) {
var ev = function(e) {
if (this.inputmask === undefined && "FORM" !== this.nodeName) {
var imOpts = $.data(this, "_inputmask_opts");
imOpts ? new Inputmask(imOpts).mask(this) : EventRuler.off(this);
} else {
if ("setvalue" === e.type || "FORM" === this.nodeName || !(this.disabled || this.readOnly && !("keydown" === e.type && e.ctrlKey && 67 === e.keyCode || !1 === opts.tabThrough && e.keyCode === Inputmask.keyCode.TAB))) {
switch (e.type) {
case "input":
if (!0 === skipInputEvent) return skipInputEvent = !1, e.preventDefault();
break;
case "keydown":
skipKeyPressEvent = !1, skipInputEvent = !1;
break;
case "keypress":
if (!0 === skipKeyPressEvent) return e.preventDefault();
skipKeyPressEvent = !0;
break;
case "click":
if (iemobile || iphone) {
var that = this, args = arguments;
return setTimeout(function() {
eventHandler.apply(that, args);
}, 0), !1;
}
}
var returnVal = eventHandler.apply(this, arguments);
return !1 === returnVal && (e.preventDefault(), e.stopPropagation()), returnVal;
}
e.preventDefault();
}
};
input.inputmask.events[eventName] = input.inputmask.events[eventName] || [], input.inputmask.events[eventName].push(ev),
-1 !== $.inArray(eventName, [ "submit", "reset" ]) ? null !== input.form && $(input.form).on(eventName, ev) : $(input).on(eventName, ev);
},
off: function(input, event) {
if (input.inputmask && input.inputmask.events) {
var events;
event ? (events = [])[event] = input.inputmask.events[event] : events = input.inputmask.events,
$.each(events, function(eventName, evArr) {
for (;evArr.length > 0; ) {
var ev = evArr.pop();
-1 !== $.inArray(eventName, [ "submit", "reset" ]) ? null !== input.form && $(input.form).off(eventName, ev) : $(input).off(eventName, ev);
}
delete input.inputmask.events[eventName];
});
}
}
}, EventHandlers = {
keydownEvent: function(e) {
var input = this, $input = $(input), k = e.keyCode, pos = caret(input);
if (k === Inputmask.keyCode.BACKSPACE || k === Inputmask.keyCode.DELETE || iphone && k === Inputmask.keyCode.BACKSPACE_SAFARI || e.ctrlKey && k === Inputmask.keyCode.X && !function(eventName) {
var el = document.createElement("input"), evName = "on" + eventName, isSupported = evName in el;
return isSupported || (el.setAttribute(evName, "return;"), isSupported = "function" == typeof el[evName]),
el = null, isSupported;
}("cut")) e.preventDefault(), handleRemove(input, k, pos), writeBuffer(input, getBuffer(!0), getMaskSet().p, e, input.inputmask._valueGet() !== getBuffer().join("")),
input.inputmask._valueGet() === getBufferTemplate().join("") ? $input.trigger("cleared") : !0 === isComplete(getBuffer()) && $input.trigger("complete"); else if (k === Inputmask.keyCode.END || k === Inputmask.keyCode.PAGE_DOWN) {
e.preventDefault();
var caretPos = seekNext(getLastValidPosition());
opts.insertMode || caretPos !== getMaskSet().maskLength || e.shiftKey || caretPos--,
caret(input, e.shiftKey ? pos.begin : caretPos, caretPos, !0);
} else k === Inputmask.keyCode.HOME && !e.shiftKey || k === Inputmask.keyCode.PAGE_UP ? (e.preventDefault(),
caret(input, 0, e.shiftKey ? pos.begin : 0, !0)) : (opts.undoOnEscape && k === Inputmask.keyCode.ESCAPE || 90 === k && e.ctrlKey) && !0 !== e.altKey ? (checkVal(input, !0, !1, undoValue.split("")),
$input.trigger("click")) : k !== Inputmask.keyCode.INSERT || e.shiftKey || e.ctrlKey ? !0 === opts.tabThrough && k === Inputmask.keyCode.TAB ? (!0 === e.shiftKey ? (null === getTest(pos.begin).match.fn && (pos.begin = seekNext(pos.begin)),
pos.end = seekPrevious(pos.begin, !0), pos.begin = seekPrevious(pos.end, !0)) : (pos.begin = seekNext(pos.begin, !0),
pos.end = seekNext(pos.begin, !0), pos.end < getMaskSet().maskLength && pos.end--),
pos.begin < getMaskSet().maskLength && (e.preventDefault(), caret(input, pos.begin, pos.end))) : e.shiftKey || !1 === opts.insertMode && (k === Inputmask.keyCode.RIGHT ? setTimeout(function() {
var caretPos = caret(input);
caret(input, caretPos.begin);
}, 0) : k === Inputmask.keyCode.LEFT && setTimeout(function() {
var caretPos = caret(input);
caret(input, isRTL ? caretPos.begin + 1 : caretPos.begin - 1);
}, 0)) : (opts.insertMode = !opts.insertMode, caret(input, opts.insertMode || pos.begin !== getMaskSet().maskLength ? pos.begin : pos.begin - 1));
opts.onKeyDown.call(this, e, getBuffer(), caret(input).begin, opts), ignorable = -1 !== $.inArray(k, opts.ignorables);
},
keypressEvent: function(e, checkval, writeOut, strict, ndx) {
var input = this, $input = $(input), k = e.which || e.charCode || e.keyCode;
if (!(!0 === checkval || e.ctrlKey && e.altKey) && (e.ctrlKey || e.metaKey || ignorable)) return k === Inputmask.keyCode.ENTER && undoValue !== getBuffer().join("") && (undoValue = getBuffer().join(""),
setTimeout(function() {
$input.trigger("change");
}, 0)), !0;
if (k) {
46 === k && !1 === e.shiftKey && "" !== opts.radixPoint && (k = opts.radixPoint.charCodeAt(0));
var forwardPosition, pos = checkval ? {
begin: ndx,
end: ndx
} : caret(input), c = String.fromCharCode(k);
getMaskSet().writeOutBuffer = !0;
var valResult = isValid(pos, c, strict);
if (!1 !== valResult && (resetMaskSet(!0), forwardPosition = valResult.caret !== undefined ? valResult.caret : checkval ? valResult.pos + 1 : seekNext(valResult.pos),
getMaskSet().p = forwardPosition), !1 !== writeOut && (setTimeout(function() {
opts.onKeyValidation.call(input, k, valResult, opts);
}, 0), getMaskSet().writeOutBuffer && !1 !== valResult)) {
var buffer = getBuffer();
writeBuffer(input, buffer, opts.numericInput && valResult.caret === undefined ? seekPrevious(forwardPosition) : forwardPosition, e, !0 !== checkval),
!0 !== checkval && setTimeout(function() {
!0 === isComplete(buffer) && $input.trigger("complete");
}, 0);
}
if (e.preventDefault(), checkval) return !1 !== valResult && (valResult.forwardPosition = forwardPosition),
valResult;
}
},
pasteEvent: function(e) {
var tempValue, input = this, ev = e.originalEvent || e, $input = $(input), inputValue = input.inputmask._valueGet(!0), caretPos = caret(input);
isRTL && (tempValue = caretPos.end, caretPos.end = caretPos.begin, caretPos.begin = tempValue);
var valueBeforeCaret = inputValue.substr(0, caretPos.begin), valueAfterCaret = inputValue.substr(caretPos.end, inputValue.length);
if (valueBeforeCaret === (isRTL ? getBufferTemplate().reverse() : getBufferTemplate()).slice(0, caretPos.begin).join("") && (valueBeforeCaret = ""),
valueAfterCaret === (isRTL ? getBufferTemplate().reverse() : getBufferTemplate()).slice(caretPos.end).join("") && (valueAfterCaret = ""),
isRTL && (tempValue = valueBeforeCaret, valueBeforeCaret = valueAfterCaret, valueAfterCaret = tempValue),
window.clipboardData && window.clipboardData.getData) inputValue = valueBeforeCaret + window.clipboardData.getData("Text") + valueAfterCaret; else {
if (!ev.clipboardData || !ev.clipboardData.getData) return !0;
inputValue = valueBeforeCaret + ev.clipboardData.getData("text/plain") + valueAfterCaret;
}
var pasteValue = inputValue;
if ($.isFunction(opts.onBeforePaste)) {
if (!1 === (pasteValue = opts.onBeforePaste.call(inputmask, inputValue, opts))) return e.preventDefault();
pasteValue || (pasteValue = inputValue);
}
return checkVal(input, !1, !1, isRTL ? pasteValue.split("").reverse() : pasteValue.toString().split("")),
writeBuffer(input, getBuffer(), seekNext(getLastValidPosition()), e, undoValue !== getBuffer().join("")),
!0 === isComplete(getBuffer()) && $input.trigger("complete"), e.preventDefault();
},
inputFallBackEvent: function(e) {
var input = this, inputValue = input.inputmask._valueGet();
if (getBuffer().join("") !== inputValue) {
var caretPos = caret(input);
if (!1 === function(input, inputValue, caretPos) {
if ("." === inputValue.charAt(caretPos.begin - 1) && "" !== opts.radixPoint && ((inputValue = inputValue.split(""))[caretPos.begin - 1] = opts.radixPoint.charAt(0),
inputValue = inputValue.join("")), inputValue.charAt(caretPos.begin - 1) === opts.radixPoint && inputValue.length > getBuffer().length) {
var keypress = new $.Event("keypress");
return keypress.which = opts.radixPoint.charCodeAt(0), EventHandlers.keypressEvent.call(input, keypress, !0, !0, !1, caretPos.begin - 1),
!1;
}
}(input, inputValue, caretPos)) return !1;
if (inputValue = inputValue.replace(new RegExp("(" + Inputmask.escapeRegex(getBufferTemplate().join("")) + ")*"), ""),
!1 === function(input, inputValue, caretPos) {
if (iemobile) {
var inputChar = inputValue.replace(getBuffer().join(""), "");
if (1 === inputChar.length) {
var keypress = new $.Event("keypress");
return keypress.which = inputChar.charCodeAt(0), EventHandlers.keypressEvent.call(input, keypress, !0, !0, !1, getMaskSet().validPositions[caretPos.begin - 1] ? caretPos.begin : caretPos.begin - 1),
!1;
}
}
}(input, inputValue, caretPos)) return !1;
caretPos.begin > inputValue.length && (caret(input, inputValue.length), caretPos = caret(input));
var buffer = getBuffer().join(""), frontPart = inputValue.substr(0, caretPos.begin), backPart = inputValue.substr(caretPos.begin), frontBufferPart = buffer.substr(0, caretPos.begin), backBufferPart = buffer.substr(caretPos.begin), selection = caretPos, entries = "", isEntry = !1;
if (frontPart !== frontBufferPart) {
selection.begin = 0;
for (var fpl = (isEntry = frontPart.length >= frontBufferPart.length) ? frontPart.length : frontBufferPart.length, i = 0; frontPart.charAt(i) === frontBufferPart.charAt(i) && i < fpl; i++) selection.begin++;
isEntry && (entries += frontPart.slice(selection.begin, selection.end));
}
backPart !== backBufferPart && (backPart.length > backBufferPart.length ? isEntry && (selection.end = selection.begin) : backPart.length < backBufferPart.length ? selection.end += backBufferPart.length - backPart.length : backPart.charAt(0) !== backBufferPart.charAt(0) && selection.end++),
writeBuffer(input, getBuffer(), selection), entries.length > 0 ? $.each(entries.split(""), function(ndx, entry) {
var keypress = new $.Event("keypress");
keypress.which = entry.charCodeAt(0), ignorable = !1, EventHandlers.keypressEvent.call(input, keypress);
}) : (selection.begin === selection.end - 1 && caret(input, seekPrevious(selection.begin + 1), selection.end),
e.keyCode = Inputmask.keyCode.DELETE, EventHandlers.keydownEvent.call(input, e)),
e.preventDefault();
}
},
setValueEvent: function(e) {
this.inputmask.refreshValue = !1;
var input = this, value = input.inputmask._valueGet(!0);
$.isFunction(opts.onBeforeMask) && (value = opts.onBeforeMask.call(inputmask, value, opts) || value),
value = value.split(""), checkVal(input, !0, !1, isRTL ? value.reverse() : value),
undoValue = getBuffer().join(""), (opts.clearMaskOnLostFocus || opts.clearIncomplete) && input.inputmask._valueGet() === getBufferTemplate().join("") && input.inputmask._valueSet("");
},
focusEvent: function(e) {
var input = this, nptValue = input.inputmask._valueGet();
opts.showMaskOnFocus && (!opts.showMaskOnHover || opts.showMaskOnHover && "" === nptValue) && (input.inputmask._valueGet() !== getBuffer().join("") ? writeBuffer(input, getBuffer(), seekNext(getLastValidPosition())) : !1 === mouseEnter && caret(input, seekNext(getLastValidPosition()))),
!0 === opts.positionCaretOnTab && !1 === mouseEnter && "" !== nptValue && (writeBuffer(input, getBuffer(), caret(input)),
EventHandlers.clickEvent.apply(input, [ e, !0 ])), undoValue = getBuffer().join("");
},
mouseleaveEvent: function(e) {
var input = this;
if (mouseEnter = !1, opts.clearMaskOnLostFocus && document.activeElement !== input) {
var buffer = getBuffer().slice(), nptValue = input.inputmask._valueGet();
nptValue !== input.getAttribute("placeholder") && "" !== nptValue && (-1 === getLastValidPosition() && nptValue === getBufferTemplate().join("") ? buffer = [] : clearOptionalTail(buffer),
writeBuffer(input, buffer));
}
},
clickEvent: function(e, tabbed) {
function doRadixFocus(clickPos) {
if ("" !== opts.radixPoint) {
var vps = getMaskSet().validPositions;
if (vps[clickPos] === undefined || vps[clickPos].input === getPlaceholder(clickPos)) {
if (clickPos < seekNext(-1)) return !0;
var radixPos = $.inArray(opts.radixPoint, getBuffer());
if (-1 !== radixPos) {
for (var vp in vps) if (radixPos < vp && vps[vp].input !== getPlaceholder(vp)) return !1;
return !0;
}
}
}
return !1;
}
var input = this;
setTimeout(function() {
if (document.activeElement === input) {
var selectedCaret = caret(input);
if (tabbed && (isRTL ? selectedCaret.end = selectedCaret.begin : selectedCaret.begin = selectedCaret.end),
selectedCaret.begin === selectedCaret.end) switch (opts.positionCaretOnClick) {
case "none":
break;
case "radixFocus":
if (doRadixFocus(selectedCaret.begin)) {
var radixPos = getBuffer().join("").indexOf(opts.radixPoint);
caret(input, opts.numericInput ? seekNext(radixPos) : radixPos);
break;
}
default:
var clickPosition = selectedCaret.begin, lvclickPosition = getLastValidPosition(clickPosition, !0), lastPosition = seekNext(lvclickPosition);
if (clickPosition < lastPosition) caret(input, isMask(clickPosition, !0) || isMask(clickPosition - 1, !0) ? clickPosition : seekNext(clickPosition)); else {
var lvp = getMaskSet().validPositions[lvclickPosition], tt = getTestTemplate(lastPosition, lvp ? lvp.match.locator : undefined, lvp), placeholder = getPlaceholder(lastPosition, tt.match);
if ("" !== placeholder && getBuffer()[lastPosition] !== placeholder && !0 !== tt.match.optionalQuantifier && !0 !== tt.match.newBlockMarker || !isMask(lastPosition, !0) && tt.match.def === placeholder) {
var newPos = seekNext(lastPosition);
(clickPosition >= newPos || clickPosition === lastPosition) && (lastPosition = newPos);
}
caret(input, lastPosition);
}
}
}
}, 0);
},
dblclickEvent: function(e) {
var input = this;
setTimeout(function() {
caret(input, 0, seekNext(getLastValidPosition()));
}, 0);
},
cutEvent: function(e) {
var input = this, $input = $(input), pos = caret(input), ev = e.originalEvent || e, clipboardData = window.clipboardData || ev.clipboardData, clipData = isRTL ? getBuffer().slice(pos.end, pos.begin) : getBuffer().slice(pos.begin, pos.end);
clipboardData.setData("text", isRTL ? clipData.reverse().join("") : clipData.join("")),
document.execCommand && document.execCommand("copy"), handleRemove(input, Inputmask.keyCode.DELETE, pos),
writeBuffer(input, getBuffer(), getMaskSet().p, e, undoValue !== getBuffer().join("")),
input.inputmask._valueGet() === getBufferTemplate().join("") && $input.trigger("cleared");
},
blurEvent: function(e) {
var $input = $(this), input = this;
if (input.inputmask) {
var nptValue = input.inputmask._valueGet(), buffer = getBuffer().slice();
"" !== nptValue && (opts.clearMaskOnLostFocus && (-1 === getLastValidPosition() && nptValue === getBufferTemplate().join("") ? buffer = [] : clearOptionalTail(buffer)),
!1 === isComplete(buffer) && (setTimeout(function() {
$input.trigger("incomplete");
}, 0), opts.clearIncomplete && (resetMaskSet(), buffer = opts.clearMaskOnLostFocus ? [] : getBufferTemplate().slice())),
writeBuffer(input, buffer, undefined, e)), undoValue !== getBuffer().join("") && (undoValue = buffer.join(""),
$input.trigger("change"));
}
},
mouseenterEvent: function(e) {
var input = this;
mouseEnter = !0, document.activeElement !== input && opts.showMaskOnHover && input.inputmask._valueGet() !== getBuffer().join("") && writeBuffer(input, getBuffer());
},
submitEvent: function(e) {
undoValue !== getBuffer().join("") && $el.trigger("change"), opts.clearMaskOnLostFocus && -1 === getLastValidPosition() && el.inputmask._valueGet && el.inputmask._valueGet() === getBufferTemplate().join("") && el.inputmask._valueSet(""),
opts.removeMaskOnSubmit && (el.inputmask._valueSet(el.inputmask.unmaskedvalue(), !0),
setTimeout(function() {
writeBuffer(el, getBuffer());
}, 0));
},
resetEvent: function(e) {
el.inputmask.refreshValue = !0, setTimeout(function() {
$el.trigger("setvalue");
}, 0);
}
};
Inputmask.prototype.positionColorMask = function(input, template) {
input.style.left = template.offsetLeft + "px";
};
var valueBuffer;
if (actionObj !== undefined) switch (actionObj.action) {
case "isComplete":
return el = actionObj.el, isComplete(getBuffer());
case "unmaskedvalue":
return el !== undefined && actionObj.value === undefined || (valueBuffer = actionObj.value,
valueBuffer = ($.isFunction(opts.onBeforeMask) ? opts.onBeforeMask.call(inputmask, valueBuffer, opts) || valueBuffer : valueBuffer).split(""),
checkVal(undefined, !1, !1, isRTL ? valueBuffer.reverse() : valueBuffer), $.isFunction(opts.onBeforeWrite) && opts.onBeforeWrite.call(inputmask, undefined, getBuffer(), 0, opts)),
unmaskedvalue(el);
case "mask":
!function(elem) {
EventRuler.off(elem);
var isSupported = function(input, opts) {
var elementType = input.getAttribute("type"), isSupported = "INPUT" === input.tagName && -1 !== $.inArray(elementType, opts.supportsInputType) || input.isContentEditable || "TEXTAREA" === input.tagName;
if (!isSupported) if ("INPUT" === input.tagName) {
var el = document.createElement("input");
el.setAttribute("type", elementType), isSupported = "text" === el.type, el = null;
} else isSupported = "partial";
return !1 !== isSupported ? function(npt) {
function getter() {
return this.inputmask ? this.inputmask.opts.autoUnmask ? this.inputmask.unmaskedvalue() : -1 !== getLastValidPosition() || !0 !== opts.nullable ? document.activeElement === this && opts.clearMaskOnLostFocus ? (isRTL ? clearOptionalTail(getBuffer().slice()).reverse() : clearOptionalTail(getBuffer().slice())).join("") : valueGet.call(this) : "" : valueGet.call(this);
}
function setter(value) {
valueSet.call(this, value), this.inputmask && $(this).trigger("setvalue");
}
var valueGet, valueSet;
if (!npt.inputmask.__valueGet) {
if (!0 !== opts.noValuePatching) {
if (Object.getOwnPropertyDescriptor) {
"function" != typeof Object.getPrototypeOf && (Object.getPrototypeOf = "object" === _typeof("test".__proto__) ? function(object) {
return object.__proto__;
} : function(object) {
return object.constructor.prototype;
});
var valueProperty = Object.getPrototypeOf ? Object.getOwnPropertyDescriptor(Object.getPrototypeOf(npt), "value") : undefined;
valueProperty && valueProperty.get && valueProperty.set ? (valueGet = valueProperty.get,
valueSet = valueProperty.set, Object.defineProperty(npt, "value", {
get: getter,
set: setter,
configurable: !0
})) : "INPUT" !== npt.tagName && (valueGet = function() {
return this.textContent;
}, valueSet = function(value) {
this.textContent = value;
}, Object.defineProperty(npt, "value", {
get: getter,
set: setter,
configurable: !0
}));
} else document.__lookupGetter__ && npt.__lookupGetter__("value") && (valueGet = npt.__lookupGetter__("value"),
valueSet = npt.__lookupSetter__("value"), npt.__defineGetter__("value", getter),
npt.__defineSetter__("value", setter));
npt.inputmask.__valueGet = valueGet, npt.inputmask.__valueSet = valueSet;
}
npt.inputmask._valueGet = function(overruleRTL) {
return isRTL && !0 !== overruleRTL ? valueGet.call(this.el).split("").reverse().join("") : valueGet.call(this.el);
}, npt.inputmask._valueSet = function(value, overruleRTL) {
valueSet.call(this.el, null === value || value === undefined ? "" : !0 !== overruleRTL && isRTL ? value.split("").reverse().join("") : value);
}, valueGet === undefined && (valueGet = function() {
return this.value;
}, valueSet = function(value) {
this.value = value;
}, function(type) {
if ($.valHooks && ($.valHooks[type] === undefined || !0 !== $.valHooks[type].inputmaskpatch)) {
var valhookGet = $.valHooks[type] && $.valHooks[type].get ? $.valHooks[type].get : function(elem) {
return elem.value;
}, valhookSet = $.valHooks[type] && $.valHooks[type].set ? $.valHooks[type].set : function(elem, value) {
return elem.value = value, elem;
};
$.valHooks[type] = {
get: function(elem) {
if (elem.inputmask) {
if (elem.inputmask.opts.autoUnmask) return elem.inputmask.unmaskedvalue();
var result = valhookGet(elem);
return -1 !== getLastValidPosition(undefined, undefined, elem.inputmask.maskset.validPositions) || !0 !== opts.nullable ? result : "";
}
return valhookGet(elem);
},
set: function(elem, value) {
var result, $elem = $(elem);
return result = valhookSet(elem, value), elem.inputmask && $elem.trigger("setvalue"),
result;
},
inputmaskpatch: !0
};
}
}(npt.type), function(npt) {
EventRuler.on(npt, "mouseenter", function(event) {
var $input = $(this);
this.inputmask._valueGet() !== getBuffer().join("") && $input.trigger("setvalue");
});
}(npt));
}
}(input) : input.inputmask = undefined, isSupported;
}(elem, opts);
if (!1 !== isSupported && (el = elem, $el = $(el), -1 === (maxLength = el !== undefined ? el.maxLength : undefined) && (maxLength = undefined),
!0 === opts.colorMask && initializeColorMask(el), android && (el.hasOwnProperty("inputmode") && (el.inputmode = opts.inputmode,
el.setAttribute("inputmode", opts.inputmode)), "rtfm" === opts.androidHack && (!0 !== opts.colorMask && initializeColorMask(el),
el.type = "password")), !0 === isSupported && (EventRuler.on(el, "submit", EventHandlers.submitEvent),
EventRuler.on(el, "reset", EventHandlers.resetEvent), EventRuler.on(el, "mouseenter", EventHandlers.mouseenterEvent),
EventRuler.on(el, "blur", EventHandlers.blurEvent), EventRuler.on(el, "focus", EventHandlers.focusEvent),
EventRuler.on(el, "mouseleave", EventHandlers.mouseleaveEvent), !0 !== opts.colorMask && EventRuler.on(el, "click", EventHandlers.clickEvent),
EventRuler.on(el, "dblclick", EventHandlers.dblclickEvent), EventRuler.on(el, "paste", EventHandlers.pasteEvent),
EventRuler.on(el, "dragdrop", EventHandlers.pasteEvent), EventRuler.on(el, "drop", EventHandlers.pasteEvent),
EventRuler.on(el, "cut", EventHandlers.cutEvent), EventRuler.on(el, "complete", opts.oncomplete),
EventRuler.on(el, "incomplete", opts.onincomplete), EventRuler.on(el, "cleared", opts.oncleared),
android || !0 === opts.inputEventOnly ? el.removeAttribute("maxLength") : (EventRuler.on(el, "keydown", EventHandlers.keydownEvent),
EventRuler.on(el, "keypress", EventHandlers.keypressEvent)), EventRuler.on(el, "compositionstart", $.noop),
EventRuler.on(el, "compositionupdate", $.noop), EventRuler.on(el, "compositionend", $.noop),
EventRuler.on(el, "keyup", $.noop), EventRuler.on(el, "input", EventHandlers.inputFallBackEvent),
EventRuler.on(el, "beforeinput", $.noop)), EventRuler.on(el, "setvalue", EventHandlers.setValueEvent),
undoValue = getBufferTemplate().join(""), "" !== el.inputmask._valueGet(!0) || !1 === opts.clearMaskOnLostFocus || document.activeElement === el)) {
var initialValue = $.isFunction(opts.onBeforeMask) ? opts.onBeforeMask.call(inputmask, el.inputmask._valueGet(!0), opts) || el.inputmask._valueGet(!0) : el.inputmask._valueGet(!0);
"" !== initialValue && checkVal(el, !0, !1, isRTL ? initialValue.split("").reverse() : initialValue.split(""));
var buffer = getBuffer().slice();
undoValue = buffer.join(""), !1 === isComplete(buffer) && opts.clearIncomplete && resetMaskSet(),
opts.clearMaskOnLostFocus && document.activeElement !== el && (-1 === getLastValidPosition() ? buffer = [] : clearOptionalTail(buffer)),
writeBuffer(el, buffer), document.activeElement === el && caret(el, seekNext(getLastValidPosition()));
}
}(el);
break;
case "format":
return valueBuffer = ($.isFunction(opts.onBeforeMask) ? opts.onBeforeMask.call(inputmask, actionObj.value, opts) || actionObj.value : actionObj.value).split(""),
checkVal(undefined, !0, !1, isRTL ? valueBuffer.reverse() : valueBuffer), actionObj.metadata ? {
value: isRTL ? getBuffer().slice().reverse().join("") : getBuffer().join(""),
metadata: maskScope.call(this, {
action: "getmetadata"
}, maskset, opts)
} : isRTL ? getBuffer().slice().reverse().join("") : getBuffer().join("");
case "isValid":
actionObj.value ? (valueBuffer = actionObj.value.split(""), checkVal(undefined, !0, !0, isRTL ? valueBuffer.reverse() : valueBuffer)) : actionObj.value = getBuffer().join("");
for (var buffer = getBuffer(), rl = determineLastRequiredPosition(), lmib = buffer.length - 1; lmib > rl && !isMask(lmib); lmib--) ;
return buffer.splice(rl, lmib + 1 - rl), isComplete(buffer) && actionObj.value === getBuffer().join("");
case "getemptymask":
return getBufferTemplate().join("");
case "remove":
if (el && el.inputmask) {
$el = $(el), el.inputmask._valueSet(opts.autoUnmask ? unmaskedvalue(el) : el.inputmask._valueGet(!0)),
EventRuler.off(el);
Object.getOwnPropertyDescriptor && Object.getPrototypeOf ? Object.getOwnPropertyDescriptor(Object.getPrototypeOf(el), "value") && el.inputmask.__valueGet && Object.defineProperty(el, "value", {
get: el.inputmask.__valueGet,
set: el.inputmask.__valueSet,
configurable: !0
}) : document.__lookupGetter__ && el.__lookupGetter__("value") && el.inputmask.__valueGet && (el.__defineGetter__("value", el.inputmask.__valueGet),
el.__defineSetter__("value", el.inputmask.__valueSet)), el.inputmask = undefined;
}
return el;
case "getmetadata":
if ($.isArray(maskset.metadata)) {
var maskTarget = getMaskTemplate(!0, 0, !1).join("");
return $.each(maskset.metadata, function(ndx, mtdt) {
if (mtdt.mask === maskTarget) return maskTarget = mtdt, !1;
}), maskTarget;
}
return maskset.metadata;
}
}
var ua = navigator.userAgent, mobile = /mobile/i.test(ua), iemobile = /iemobile/i.test(ua), iphone = /iphone/i.test(ua) && !iemobile, android = /android/i.test(ua) && !iemobile;
return Inputmask.prototype = {
dataAttribute: "data-inputmask",
defaults: {
placeholder: "_",
optionalmarker: {
start: "[",
end: "]"
},
quantifiermarker: {
start: "{",
end: "}"
},
groupmarker: {
start: "(",
end: ")"
},
alternatormarker: "|",
escapeChar: "\\",
mask: null,
regex: null,
oncomplete: $.noop,
onincomplete: $.noop,
oncleared: $.noop,
repeat: 0,
greedy: !0,
autoUnmask: !1,
removeMaskOnSubmit: !1,
clearMaskOnLostFocus: !0,
insertMode: !0,
clearIncomplete: !1,
alias: null,
onKeyDown: $.noop,
onBeforeMask: null,
onBeforePaste: function(pastedValue, opts) {
return $.isFunction(opts.onBeforeMask) ? opts.onBeforeMask.call(this, pastedValue, opts) : pastedValue;
},
onBeforeWrite: null,
onUnMask: null,
showMaskOnFocus: !0,
showMaskOnHover: !0,
onKeyValidation: $.noop,
skipOptionalPartCharacter: " ",
numericInput: !1,
rightAlign: !1,
undoOnEscape: !0,
radixPoint: "",
radixPointDefinitionSymbol: undefined,
groupSeparator: "",
keepStatic: null,
positionCaretOnTab: !0,
tabThrough: !1,
supportsInputType: [ "text", "tel", "password" ],
ignorables: [ 8, 9, 13, 19, 27, 33, 34, 35, 36, 37, 38, 39, 40, 45, 46, 93, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 0, 229 ],
isComplete: null,
canClearPosition: $.noop,
preValidation: null,
postValidation: null,
staticDefinitionSymbol: undefined,
jitMasking: !1,
nullable: !0,
inputEventOnly: !1,
noValuePatching: !1,
positionCaretOnClick: "lvp",
casing: null,
inputmode: "verbatim",
colorMask: !1,
androidHack: !1,
importDataAttributes: !0
},
definitions: {
"9": {
validator: "[0-9-]",
cardinality: 1,
definitionSymbol: "*"
},
a: {
validator: "[A-Za-z--]",
cardinality: 1,
definitionSymbol: "*"
},
"*": {
validator: "[0-9-A-Za-z--]",
cardinality: 1
}
},
aliases: {},
masksCache: {},
mask: function(elems) {
function importAttributeOptions(npt, opts, userOptions, dataAttribute) {
if (!0 === opts.importDataAttributes) {
var option, dataoptions, optionData, p, importOption = function(option, optionData) {
null !== (optionData = optionData !== undefined ? optionData : npt.getAttribute(dataAttribute + "-" + option)) && ("string" == typeof optionData && (0 === option.indexOf("on") ? optionData = window[optionData] : "false" === optionData ? optionData = !1 : "true" === optionData && (optionData = !0)),
userOptions[option] = optionData);
}, attrOptions = npt.getAttribute(dataAttribute);
if (attrOptions && "" !== attrOptions && (attrOptions = attrOptions.replace(new RegExp("'", "g"), '"'),
dataoptions = JSON.parse("{" + attrOptions + "}")), dataoptions) {
optionData = undefined;
for (p in dataoptions) if ("alias" === p.toLowerCase()) {
optionData = dataoptions[p];
break;
}
}
importOption("alias", optionData), userOptions.alias && resolveAlias(userOptions.alias, userOptions, opts);
for (option in opts) {
if (dataoptions) {
optionData = undefined;
for (p in dataoptions) if (p.toLowerCase() === option.toLowerCase()) {
optionData = dataoptions[p];
break;
}
}
importOption(option, optionData);
}
}
return $.extend(!0, opts, userOptions), ("rtl" === npt.dir || opts.rightAlign) && (npt.style.textAlign = "right"),
("rtl" === npt.dir || opts.numericInput) && (npt.dir = "ltr", npt.removeAttribute("dir"),
opts.isRTL = !0), opts;
}
var that = this;
return "string" == typeof elems && (elems = document.getElementById(elems) || document.querySelectorAll(elems)),
elems = elems.nodeName ? [ elems ] : elems, $.each(elems, function(ndx, el) {
var scopedOpts = $.extend(!0, {}, that.opts);
importAttributeOptions(el, scopedOpts, $.extend(!0, {}, that.userOptions), that.dataAttribute);
var maskset = generateMaskSet(scopedOpts, that.noMasksCache);
maskset !== undefined && (el.inputmask !== undefined && (el.inputmask.opts.autoUnmask = !0,
el.inputmask.remove()), el.inputmask = new Inputmask(undefined, undefined, !0),
el.inputmask.opts = scopedOpts, el.inputmask.noMasksCache = that.noMasksCache, el.inputmask.userOptions = $.extend(!0, {}, that.userOptions),
el.inputmask.isRTL = scopedOpts.isRTL || scopedOpts.numericInput, el.inputmask.el = el,
el.inputmask.maskset = maskset, $.data(el, "_inputmask_opts", scopedOpts), maskScope.call(el.inputmask, {
action: "mask"
}));
}), elems && elems[0] ? elems[0].inputmask || this : this;
},
option: function(options, noremask) {
return "string" == typeof options ? this.opts[options] : "object" === (void 0 === options ? "undefined" : _typeof(options)) ? ($.extend(this.userOptions, options),
this.el && !0 !== noremask && this.mask(this.el), this) : void 0;
},
unmaskedvalue: function(value) {
return this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache),
maskScope.call(this, {
action: "unmaskedvalue",
value: value
});
},
remove: function() {
return maskScope.call(this, {
action: "remove"
});
},
getemptymask: function() {
return this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache),
maskScope.call(this, {
action: "getemptymask"
});
},
hasMaskedValue: function() {
return !this.opts.autoUnmask;
},
isComplete: function() {
return this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache),
maskScope.call(this, {
action: "isComplete"
});
},
getmetadata: function() {
return this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache),
maskScope.call(this, {
action: "getmetadata"
});
},
isValid: function(value) {
return this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache),
maskScope.call(this, {
action: "isValid",
value: value
});
},
format: function(value, metadata) {
return this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache),
maskScope.call(this, {
action: "format",
value: value,
metadata: metadata
});
},
analyseMask: function(mask, regexMask, opts) {
function MaskToken(isGroup, isOptional, isQuantifier, isAlternator) {
this.matches = [], this.openGroup = isGroup || !1, this.alternatorGroup = !1, this.isGroup = isGroup || !1,
this.isOptional = isOptional || !1, this.isQuantifier = isQuantifier || !1, this.isAlternator = isAlternator || !1,
this.quantifier = {
min: 1,
max: 1
};
}
function insertTestDefinition(mtoken, element, position) {
position = position !== undefined ? position : mtoken.matches.length;
var prevMatch = mtoken.matches[position - 1];
if (regexMask) 0 === element.indexOf("[") || escaped && /\\d|\\s|\\w]/i.test(element) || "." === element ? mtoken.matches.splice(position++, 0, {
fn: new RegExp(element, opts.casing ? "i" : ""),
cardinality: 1,
optionality: mtoken.isOptional,
newBlockMarker: prevMatch === undefined || prevMatch.def !== element,
casing: null,
def: element,
placeholder: undefined,
nativeDef: element
}) : (escaped && (element = element[element.length - 1]), $.each(element.split(""), function(ndx, lmnt) {
prevMatch = mtoken.matches[position - 1], mtoken.matches.splice(position++, 0, {
fn: null,
cardinality: 0,
optionality: mtoken.isOptional,
newBlockMarker: prevMatch === undefined || prevMatch.def !== lmnt && null !== prevMatch.fn,
casing: null,
def: opts.staticDefinitionSymbol || lmnt,
placeholder: opts.staticDefinitionSymbol !== undefined ? lmnt : undefined,
nativeDef: lmnt
});
})), escaped = !1; else {
var maskdef = (opts.definitions ? opts.definitions[element] : undefined) || Inputmask.prototype.definitions[element];
if (maskdef && !escaped) {
for (var prevalidators = maskdef.prevalidator, prevalidatorsL = prevalidators ? prevalidators.length : 0, i = 1; i < maskdef.cardinality; i++) {
var prevalidator = prevalidatorsL >= i ? prevalidators[i - 1] : [], validator = prevalidator.validator, cardinality = prevalidator.cardinality;
mtoken.matches.splice(position++, 0, {
fn: validator ? "string" == typeof validator ? new RegExp(validator, opts.casing ? "i" : "") : new function() {
this.test = validator;
}() : new RegExp("."),
cardinality: cardinality || 1,
optionality: mtoken.isOptional,
newBlockMarker: prevMatch === undefined || prevMatch.def !== (maskdef.definitionSymbol || element),
casing: maskdef.casing,
def: maskdef.definitionSymbol || element,
placeholder: maskdef.placeholder,
nativeDef: element
}), prevMatch = mtoken.matches[position - 1];
}
mtoken.matches.splice(position++, 0, {
fn: maskdef.validator ? "string" == typeof maskdef.validator ? new RegExp(maskdef.validator, opts.casing ? "i" : "") : new function() {
this.test = maskdef.validator;
}() : new RegExp("."),
cardinality: maskdef.cardinality,
optionality: mtoken.isOptional,
newBlockMarker: prevMatch === undefined || prevMatch.def !== (maskdef.definitionSymbol || element),
casing: maskdef.casing,
def: maskdef.definitionSymbol || element,
placeholder: maskdef.placeholder,
nativeDef: element
});
} else mtoken.matches.splice(position++, 0, {
fn: null,
cardinality: 0,
optionality: mtoken.isOptional,
newBlockMarker: prevMatch === undefined || prevMatch.def !== element && null !== prevMatch.fn,
casing: null,
def: opts.staticDefinitionSymbol || element,
placeholder: opts.staticDefinitionSymbol !== undefined ? element : undefined,
nativeDef: element
}), escaped = !1;
}
}
function verifyGroupMarker(maskToken) {
maskToken && maskToken.matches && $.each(maskToken.matches, function(ndx, token) {
var nextToken = maskToken.matches[ndx + 1];
(nextToken === undefined || nextToken.matches === undefined || !1 === nextToken.isQuantifier) && token && token.isGroup && (token.isGroup = !1,
regexMask || (insertTestDefinition(token, opts.groupmarker.start, 0), !0 !== token.openGroup && insertTestDefinition(token, opts.groupmarker.end))),
verifyGroupMarker(token);
});
}
function defaultCase() {
if (openenings.length > 0) {
if (currentOpeningToken = openenings[openenings.length - 1], insertTestDefinition(currentOpeningToken, m),
currentOpeningToken.isAlternator) {
alternator = openenings.pop();
for (var mndx = 0; mndx < alternator.matches.length; mndx++) alternator.matches[mndx].isGroup = !1;
openenings.length > 0 ? (currentOpeningToken = openenings[openenings.length - 1]).matches.push(alternator) : currentToken.matches.push(alternator);
}
} else insertTestDefinition(currentToken, m);
}
function reverseTokens(maskToken) {
maskToken.matches = maskToken.matches.reverse();
for (var match in maskToken.matches) if (maskToken.matches.hasOwnProperty(match)) {
var intMatch = parseInt(match);
if (maskToken.matches[match].isQuantifier && maskToken.matches[intMatch + 1] && maskToken.matches[intMatch + 1].isGroup) {
var qt = maskToken.matches[match];
maskToken.matches.splice(match, 1), maskToken.matches.splice(intMatch + 1, 0, qt);
}
maskToken.matches[match].matches !== undefined ? maskToken.matches[match] = reverseTokens(maskToken.matches[match]) : maskToken.matches[match] = function(st) {
return st === opts.optionalmarker.start ? st = opts.optionalmarker.end : st === opts.optionalmarker.end ? st = opts.optionalmarker.start : st === opts.groupmarker.start ? st = opts.groupmarker.end : st === opts.groupmarker.end && (st = opts.groupmarker.start),
st;
}(maskToken.matches[match]);
}
return maskToken;
}
var match, m, openingToken, currentOpeningToken, alternator, lastMatch, groupToken, tokenizer = /(?:[?*+]|\{[0-9\+\*]+(?:,[0-9\+\*]*)?\})|[^.?*+^${[]()|\\]+|./g, regexTokenizer = /\[\^?]?(?:[^\\\]]+|\\[\S\s]?)*]?|\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9][0-9]*|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}|c[A-Za-z]|[\S\s]?)|\((?:\?[:=!]?)?|(?:[?*+]|\{[0-9]+(?:,[0-9]*)?\})\??|[^.?*+^${[()|\\]+|./g, escaped = !1, currentToken = new MaskToken(), openenings = [], maskTokens = [];
for (regexMask && (opts.optionalmarker.start = undefined, opts.optionalmarker.end = undefined); match = regexMask ? regexTokenizer.exec(mask) : tokenizer.exec(mask); ) {
if (m = match[0], regexMask) switch (m.charAt(0)) {
case "?":
m = "{0,1}";
break;
case "+":
case "*":
m = "{" + m + "}";
}
if (escaped) defaultCase(); else switch (m.charAt(0)) {
case opts.escapeChar:
escaped = !0, regexMask && defaultCase();
break;
case opts.optionalmarker.end:
case opts.groupmarker.end:
if (openingToken = openenings.pop(), openingToken.openGroup = !1, openingToken !== undefined) if (openenings.length > 0) {
if ((currentOpeningToken = openenings[openenings.length - 1]).matches.push(openingToken),
currentOpeningToken.isAlternator) {
alternator = openenings.pop();
for (var mndx = 0; mndx < alternator.matches.length; mndx++) alternator.matches[mndx].isGroup = !1,
alternator.matches[mndx].alternatorGroup = !1;
openenings.length > 0 ? (currentOpeningToken = openenings[openenings.length - 1]).matches.push(alternator) : currentToken.matches.push(alternator);
}
} else currentToken.matches.push(openingToken); else defaultCase();
break;
case opts.optionalmarker.start:
openenings.push(new MaskToken(!1, !0));
break;
case opts.groupmarker.start:
openenings.push(new MaskToken(!0));
break;
case opts.quantifiermarker.start:
var quantifier = new MaskToken(!1, !1, !0), mq = (m = m.replace(/[{}]/g, "")).split(","), mq0 = isNaN(mq[0]) ? mq[0] : parseInt(mq[0]), mq1 = 1 === mq.length ? mq0 : isNaN(mq[1]) ? mq[1] : parseInt(mq[1]);
if ("*" !== mq1 && "+" !== mq1 || (mq0 = "*" === mq1 ? 0 : 1), quantifier.quantifier = {
min: mq0,
max: mq1
}, openenings.length > 0) {
var matches = openenings[openenings.length - 1].matches;
(match = matches.pop()).isGroup || ((groupToken = new MaskToken(!0)).matches.push(match),
match = groupToken), matches.push(match), matches.push(quantifier);
} else (match = currentToken.matches.pop()).isGroup || (regexMask && null === match.fn && "." === match.def && (match.fn = new RegExp(match.def, opts.casing ? "i" : "")),
(groupToken = new MaskToken(!0)).matches.push(match), match = groupToken), currentToken.matches.push(match),
currentToken.matches.push(quantifier);
break;
case opts.alternatormarker:
if (openenings.length > 0) {
var subToken = (currentOpeningToken = openenings[openenings.length - 1]).matches[currentOpeningToken.matches.length - 1];
lastMatch = currentOpeningToken.openGroup && (subToken.matches === undefined || !1 === subToken.isGroup && !1 === subToken.isAlternator) ? openenings.pop() : currentOpeningToken.matches.pop();
} else lastMatch = currentToken.matches.pop();
if (lastMatch.isAlternator) openenings.push(lastMatch); else if (lastMatch.alternatorGroup ? (alternator = openenings.pop(),
lastMatch.alternatorGroup = !1) : alternator = new MaskToken(!1, !1, !1, !0), alternator.matches.push(lastMatch),
openenings.push(alternator), lastMatch.openGroup) {
lastMatch.openGroup = !1;
var alternatorGroup = new MaskToken(!0);
alternatorGroup.alternatorGroup = !0, openenings.push(alternatorGroup);
}
break;
default:
defaultCase();
}
}
for (;openenings.length > 0; ) openingToken = openenings.pop(), currentToken.matches.push(openingToken);
return currentToken.matches.length > 0 && (verifyGroupMarker(currentToken), maskTokens.push(currentToken)),
(opts.numericInput || opts.isRTL) && reverseTokens(maskTokens[0]), maskTokens;
}
}, Inputmask.extendDefaults = function(options) {
$.extend(!0, Inputmask.prototype.defaults, options);
}, Inputmask.extendDefinitions = function(definition) {
$.extend(!0, Inputmask.prototype.definitions, definition);
}, Inputmask.extendAliases = function(alias) {
$.extend(!0, Inputmask.prototype.aliases, alias);
}, Inputmask.format = function(value, options, metadata) {
return Inputmask(options).format(value, metadata);
}, Inputmask.unmask = function(value, options) {
return Inputmask(options).unmaskedvalue(value);
}, Inputmask.isValid = function(value, options) {
return Inputmask(options).isValid(value);
}, Inputmask.remove = function(elems) {
$.each(elems, function(ndx, el) {
el.inputmask && el.inputmask.remove();
});
}, Inputmask.escapeRegex = function(str) {
var specials = [ "/", ".", "*", "+", "?", "|", "(", ")", "[", "]", "{", "}", "\\", "$", "^" ];
return str.replace(new RegExp("(\\" + specials.join("|\\") + ")", "gim"), "\\$1");
}, Inputmask.keyCode = {
ALT: 18,
BACKSPACE: 8,
BACKSPACE_SAFARI: 127,
CAPS_LOCK: 20,
COMMA: 188,
COMMAND: 91,
COMMAND_LEFT: 91,
COMMAND_RIGHT: 93,
CONTROL: 17,
DELETE: 46,
DOWN: 40,
END: 35,
ENTER: 13,
ESCAPE: 27,
HOME: 36,
INSERT: 45,
LEFT: 37,
MENU: 93,
NUMPAD_ADD: 107,
NUMPAD_DECIMAL: 110,
NUMPAD_DIVIDE: 111,
NUMPAD_ENTER: 108,
NUMPAD_MULTIPLY: 106,
NUMPAD_SUBTRACT: 109,
PAGE_DOWN: 34,
PAGE_UP: 33,
PERIOD: 190,
RIGHT: 39,
SHIFT: 16,
SPACE: 32,
TAB: 9,
UP: 38,
WINDOWS: 91,
X: 88
}, Inputmask;
});
}, function(module, exports) {
module.exports = jQuery;
}, function(module, exports, __webpack_require__) {
"use strict";
function _interopRequireDefault(obj) {
return obj && obj.__esModule ? obj : {
default: obj
};
}
__webpack_require__(4), __webpack_require__(9), __webpack_require__(12), __webpack_require__(13),
__webpack_require__(14), __webpack_require__(15);
var _inputmask2 = _interopRequireDefault(__webpack_require__(1)), _inputmask4 = _interopRequireDefault(__webpack_require__(0)), _jquery2 = _interopRequireDefault(__webpack_require__(2));
_inputmask4.default === _jquery2.default && __webpack_require__(16), window.Inputmask = _inputmask2.default;
}, function(module, exports, __webpack_require__) {
var content = __webpack_require__(5);
"string" == typeof content && (content = [ [ module.i, content, "" ] ]);
var options = {
hmr: !0
};
options.transform = void 0;
__webpack_require__(7)(content, options);
content.locals && (module.exports = content.locals);
}, function(module, exports, __webpack_require__) {
(module.exports = __webpack_require__(6)(void 0)).push([ module.i, "span.im-caret {\r\n    -webkit-animation: 1s blink step-end infinite;\r\n    animation: 1s blink step-end infinite;\r\n}\r\n\r\n@keyframes blink {\r\n    from, to {\r\n        border-right-color: black;\r\n    }\r\n    50% {\r\n        border-right-color: transparent;\r\n    }\r\n}\r\n\r\n@-webkit-keyframes blink {\r\n    from, to {\r\n        border-right-color: black;\r\n    }\r\n    50% {\r\n        border-right-color: transparent;\r\n    }\r\n}\r\n\r\nspan.im-static {\r\n    color: grey;\r\n}\r\n\r\ndiv.im-colormask {\r\n    display: inline-block;\r\n    border-style: inset;\r\n    border-width: 2px;\r\n    -webkit-appearance: textfield;\r\n    -moz-appearance: textfield;\r\n    appearance: textfield;\r\n}\r\n\r\ndiv.im-colormask > input {\r\n    position: absolute;\r\n    display: inline-block;\r\n    background-color: transparent;\r\n    color: transparent;\r\n    -webkit-appearance: caret;\r\n    -moz-appearance: caret;\r\n    appearance: caret;\r\n    border-style: none;\r\n    left: 0;\r\n}\r\n\r\ndiv.im-colormask > input:focus {\r\n    outline: none;\r\n}\r\n\r\ndiv.im-colormask > input::-moz-selection{\r\n    background: none;\r\n}\r\n\r\ndiv.im-colormask > input::selection{\r\n    background: none;\r\n}\r\ndiv.im-colormask > input::-moz-selection{\r\n    background: none;\r\n}\r\n\r\ndiv.im-colormask > div {\r\n    color: black;\r\n    display: inline-block;\r\n    width: 100px;\r\n}", "" ]);
}, function(module, exports) {
function cssWithMappingToString(item, useSourceMap) {
var content = item[1] || "", cssMapping = item[3];
if (!cssMapping) return content;
if (useSourceMap && "function" == typeof btoa) {
var sourceMapping = toComment(cssMapping), sourceURLs = cssMapping.sources.map(function(source) {
return "/*# sourceURL=" + cssMapping.sourceRoot + source + " */";
});
return [ content ].concat(sourceURLs).concat([ sourceMapping ]).join("\n");
}
return [ content ].join("\n");
}
function toComment(sourceMap) {
return "/*# " + ("sourceMappingURL=data:application/json;charset=utf-8;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))))) + " */";
}
module.exports = function(useSourceMap) {
var list = [];
return list.toString = function() {
return this.map(function(item) {
var content = cssWithMappingToString(item, useSourceMap);
return item[2] ? "@media " + item[2] + "{" + content + "}" : content;
}).join("");
}, list.i = function(modules, mediaQuery) {
"string" == typeof modules && (modules = [ [ null, modules, "" ] ]);
for (var alreadyImportedModules = {}, i = 0; i < this.length; i++) {
var id = this[i][0];
"number" == typeof id && (alreadyImportedModules[id] = !0);
}
for (i = 0; i < modules.length; i++) {
var item = modules[i];
"number" == typeof item[0] && alreadyImportedModules[item[0]] || (mediaQuery && !item[2] ? item[2] = mediaQuery : mediaQuery && (item[2] = "(" + item[2] + ") and (" + mediaQuery + ")"),
list.push(item));
}
}, list;
};
}, function(module, exports, __webpack_require__) {
function addStylesToDom(styles, options) {
for (var i = 0; i < styles.length; i++) {
var item = styles[i], domStyle = stylesInDom[item.id];
if (domStyle) {
domStyle.refs++;
for (j = 0; j < domStyle.parts.length; j++) domStyle.parts[j](item.parts[j]);
for (;j < item.parts.length; j++) domStyle.parts.push(addStyle(item.parts[j], options));
} else {
for (var parts = [], j = 0; j < item.parts.length; j++) parts.push(addStyle(item.parts[j], options));
stylesInDom[item.id] = {
id: item.id,
refs: 1,
parts: parts
};
}
}
}
function listToStyles(list, options) {
for (var styles = [], newStyles = {}, i = 0; i < list.length; i++) {
var item = list[i], id = options.base ? item[0] + options.base : item[0], part = {
css: item[1],
media: item[2],
sourceMap: item[3]
};
newStyles[id] ? newStyles[id].parts.push(part) : styles.push(newStyles[id] = {
id: id,
parts: [ part ]
});
}
return styles;
}
function insertStyleElement(options, style) {
var target = getElement(options.insertInto);
if (!target) throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];
if ("top" === options.insertAt) lastStyleElementInsertedAtTop ? lastStyleElementInsertedAtTop.nextSibling ? target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling) : target.appendChild(style) : target.insertBefore(style, target.firstChild),
stylesInsertedAtTop.push(style); else if ("bottom" === options.insertAt) target.appendChild(style); else {
if ("object" != typeof options.insertAt || !options.insertAt.before) throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
var nextSibling = getElement(options.insertInto + " " + options.insertAt.before);
target.insertBefore(style, nextSibling);
}
}
function removeStyleElement(style) {
if (null === style.parentNode) return !1;
style.parentNode.removeChild(style);
var idx = stylesInsertedAtTop.indexOf(style);
idx >= 0 && stylesInsertedAtTop.splice(idx, 1);
}
function createStyleElement(options) {
var style = document.createElement("style");
return options.attrs.type = "text/css", addAttrs(style, options.attrs), insertStyleElement(options, style),
style;
}
function createLinkElement(options) {
var link = document.createElement("link");
return options.attrs.type = "text/css", options.attrs.rel = "stylesheet", addAttrs(link, options.attrs),
insertStyleElement(options, link), link;
}
function addAttrs(el, attrs) {
Object.keys(attrs).forEach(function(key) {
el.setAttribute(key, attrs[key]);
});
}
function addStyle(obj, options) {
var style, update, remove, result;
if (options.transform && obj.css) {
if (!(result = options.transform(obj.css))) return function() {};
obj.css = result;
}
if (options.singleton) {
var styleIndex = singletonCounter++;
style = singleton || (singleton = createStyleElement(options)), update = applyToSingletonTag.bind(null, style, styleIndex, !1),
remove = applyToSingletonTag.bind(null, style, styleIndex, !0);
} else obj.sourceMap && "function" == typeof URL && "function" == typeof URL.createObjectURL && "function" == typeof URL.revokeObjectURL && "function" == typeof Blob && "function" == typeof btoa ? (style = createLinkElement(options),
update = updateLink.bind(null, style, options), remove = function() {
removeStyleElement(style), style.href && URL.revokeObjectURL(style.href);
}) : (style = createStyleElement(options), update = applyToTag.bind(null, style),
remove = function() {
removeStyleElement(style);
});
return update(obj), function(newObj) {
if (newObj) {
if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) return;
update(obj = newObj);
} else remove();
};
}
function applyToSingletonTag(style, index, remove, obj) {
var css = remove ? "" : obj.css;
if (style.styleSheet) style.styleSheet.cssText = replaceText(index, css); else {
var cssNode = document.createTextNode(css), childNodes = style.childNodes;
childNodes[index] && style.removeChild(childNodes[index]), childNodes.length ? style.insertBefore(cssNode, childNodes[index]) : style.appendChild(cssNode);
}
}
function applyToTag(style, obj) {
var css = obj.css, media = obj.media;
if (media && style.setAttribute("media", media), style.styleSheet) style.styleSheet.cssText = css; else {
for (;style.firstChild; ) style.removeChild(style.firstChild);
style.appendChild(document.createTextNode(css));
}
}
function updateLink(link, options, obj) {
var css = obj.css, sourceMap = obj.sourceMap, autoFixUrls = void 0 === options.convertToAbsoluteUrls && sourceMap;
(options.convertToAbsoluteUrls || autoFixUrls) && (css = fixUrls(css)), sourceMap && (css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */");
var blob = new Blob([ css ], {
type: "text/css"
}), oldSrc = link.href;
link.href = URL.createObjectURL(blob), oldSrc && URL.revokeObjectURL(oldSrc);
}
var stylesInDom = {}, isOldIE = function(fn) {
var memo;
return function() {
return void 0 === memo && (memo = fn.apply(this, arguments)), memo;
};
}(function() {
return window && document && document.all && !window.atob;
}), getElement = function(fn) {
var memo = {};
return function(selector) {
if (void 0 === memo[selector]) {
var styleTarget = fn.call(this, selector);
if (styleTarget instanceof window.HTMLIFrameElement) try {
styleTarget = styleTarget.contentDocument.head;
} catch (e) {
styleTarget = null;
}
memo[selector] = styleTarget;
}
return memo[selector];
};
}(function(target) {
return document.querySelector(target);
}), singleton = null, singletonCounter = 0, stylesInsertedAtTop = [], fixUrls = __webpack_require__(8);
module.exports = function(list, options) {
if ("undefined" != typeof DEBUG && DEBUG && "object" != typeof document) throw new Error("The style-loader cannot be used in a non-browser environment");
(options = options || {}).attrs = "object" == typeof options.attrs ? options.attrs : {},
options.singleton || (options.singleton = isOldIE()), options.insertInto || (options.insertInto = "head"),
options.insertAt || (options.insertAt = "bottom");
var styles = listToStyles(list, options);
return addStylesToDom(styles, options), function(newList) {
for (var mayRemove = [], i = 0; i < styles.length; i++) {
var item = styles[i];
(domStyle = stylesInDom[item.id]).refs--, mayRemove.push(domStyle);
}
newList && addStylesToDom(listToStyles(newList, options), options);
for (i = 0; i < mayRemove.length; i++) {
var domStyle = mayRemove[i];
if (0 === domStyle.refs) {
for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();
delete stylesInDom[domStyle.id];
}
}
};
};
var replaceText = function() {
var textStore = [];
return function(index, replacement) {
return textStore[index] = replacement, textStore.filter(Boolean).join("\n");
};
}();
}, function(module, exports) {
module.exports = function(css) {
var location = "undefined" != typeof window && window.location;
if (!location) throw new Error("fixUrls requires window.location");
if (!css || "string" != typeof css) return css;
var baseUrl = location.protocol + "//" + location.host, currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");
return css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
var unquotedOrigUrl = origUrl.trim().replace(/^"(.*)"$/, function(o, $1) {
return $1;
}).replace(/^'(.*)'$/, function(o, $1) {
return $1;
});
if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/)/i.test(unquotedOrigUrl)) return fullMatch;
var newUrl;
return newUrl = 0 === unquotedOrigUrl.indexOf("//") ? unquotedOrigUrl : 0 === unquotedOrigUrl.indexOf("/") ? baseUrl + unquotedOrigUrl : currentDir + unquotedOrigUrl.replace(/^\.\//, ""),
"url(" + JSON.stringify(newUrl) + ")";
});
};
}, function(module, exports, __webpack_require__) {
"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
"function" == typeof Symbol && Symbol.iterator;
!function(factory) {
__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(0), __webpack_require__(1) ],
void 0 !== (__WEBPACK_AMD_DEFINE_RESULT__ = "function" == typeof (__WEBPACK_AMD_DEFINE_FACTORY__ = factory) ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__) && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__);
}(function($, Inputmask) {
function isLeapYear(year) {
return isNaN(year) || 29 === new Date(year, 2, 0).getDate();
}
return Inputmask.extendAliases({
"dd/mm/yyyy": {
mask: "1/2/y",
placeholder: "dd/mm/yyyy",
regex: {
val1pre: new RegExp("[0-3]"),
val1: new RegExp("0[1-9]|[12][0-9]|3[01]"),
val2pre: function(separator) {
var escapedSeparator = Inputmask.escapeRegex.call(this, separator);
return new RegExp("((0[1-9]|[12][0-9]|3[01])" + escapedSeparator + "[01])");
},
val2: function(separator) {
var escapedSeparator = Inputmask.escapeRegex.call(this, separator);
return new RegExp("((0[1-9]|[12][0-9])" + escapedSeparator + "(0[1-9]|1[012]))|(30" + escapedSeparator + "(0[13-9]|1[012]))|(31" + escapedSeparator + "(0[13578]|1[02]))");
}
},
leapday: "29/02/",
separator: "/",
yearrange: {
minyear: 1900,
maxyear: 2099
},
isInYearRange: function(chrs, minyear, maxyear) {
if (isNaN(chrs)) return !1;
var enteredyear = parseInt(chrs.concat(minyear.toString().slice(chrs.length))), enteredyear2 = parseInt(chrs.concat(maxyear.toString().slice(chrs.length)));
return !isNaN(enteredyear) && (minyear <= enteredyear && enteredyear <= maxyear) || !isNaN(enteredyear2) && (minyear <= enteredyear2 && enteredyear2 <= maxyear);
},
determinebaseyear: function(minyear, maxyear, hint) {
var currentyear = new Date().getFullYear();
if (minyear > currentyear) return minyear;
if (maxyear < currentyear) {
for (var maxYearPrefix = maxyear.toString().slice(0, 2), maxYearPostfix = maxyear.toString().slice(2, 4); maxyear < maxYearPrefix + hint; ) maxYearPrefix--;
var maxxYear = maxYearPrefix + maxYearPostfix;
return minyear > maxxYear ? minyear : maxxYear;
}
if (minyear <= currentyear && currentyear <= maxyear) {
for (var currentYearPrefix = currentyear.toString().slice(0, 2); maxyear < currentYearPrefix + hint; ) currentYearPrefix--;
var currentYearAndHint = currentYearPrefix + hint;
return currentYearAndHint < minyear ? minyear : currentYearAndHint;
}
return currentyear;
},
onKeyDown: function(e, buffer, caretPos, opts) {
var $input = $(this);
if (e.ctrlKey && e.keyCode === Inputmask.keyCode.RIGHT) {
var today = new Date();
$input.val(today.getDate().toString() + (today.getMonth() + 1).toString() + today.getFullYear().toString()),
$input.trigger("setvalue");
}
},
getFrontValue: function(mask, buffer, opts) {
for (var start = 0, length = 0, i = 0; i < mask.length && "2" !== mask.charAt(i); i++) {
var definition = opts.definitions[mask.charAt(i)];
definition ? (start += length, length = definition.cardinality) : length++;
}
return buffer.join("").substr(start, length);
},
postValidation: function(buffer, currentResult, opts) {
var dayMonthValue, year, bufferStr = buffer.join("");
return 0 === opts.mask.indexOf("y") ? (year = bufferStr.substr(0, 4), dayMonthValue = bufferStr.substring(4, 10)) : (year = bufferStr.substring(6, 10),
dayMonthValue = bufferStr.substr(0, 6)), currentResult && (dayMonthValue !== opts.leapday || isLeapYear(year));
},
definitions: {
"1": {
validator: function(chrs, maskset, pos, strict, opts) {
var isValid = opts.regex.val1.test(chrs);
return strict || isValid || chrs.charAt(1) !== opts.separator && -1 === "-./".indexOf(chrs.charAt(1)) || !(isValid = opts.regex.val1.test("0" + chrs.charAt(0))) ? isValid : (maskset.buffer[pos - 1] = "0",
{
refreshFromBuffer: {
start: pos - 1,
end: pos
},
pos: pos,
c: chrs.charAt(0)
});
},
cardinality: 2,
prevalidator: [ {
validator: function(chrs, maskset, pos, strict, opts) {
var pchrs = chrs;
isNaN(maskset.buffer[pos + 1]) || (pchrs += maskset.buffer[pos + 1]);
var isValid = 1 === pchrs.length ? opts.regex.val1pre.test(pchrs) : opts.regex.val1.test(pchrs);
if (isValid && maskset.validPositions[pos] && (opts.regex.val2(opts.separator).test(chrs + maskset.validPositions[pos].input) || (maskset.validPositions[pos].input = "0" === chrs ? "1" : "0")),
!strict && !isValid) {
if (isValid = opts.regex.val1.test(chrs + "0")) return maskset.buffer[pos] = chrs,
maskset.buffer[++pos] = "0", {
pos: pos,
c: "0"
};
if (isValid = opts.regex.val1.test("0" + chrs)) return maskset.buffer[pos] = "0",
pos++, {
pos: pos
};
}
return isValid;
},
cardinality: 1
} ]
},
"2": {
validator: function(chrs, maskset, pos, strict, opts) {
var frontValue = opts.getFrontValue(maskset.mask, maskset.buffer, opts);
-1 !== frontValue.indexOf(opts.placeholder[0]) && (frontValue = "01" + opts.separator);
var isValid = opts.regex.val2(opts.separator).test(frontValue + chrs);
return strict || isValid || chrs.charAt(1) !== opts.separator && -1 === "-./".indexOf(chrs.charAt(1)) || !(isValid = opts.regex.val2(opts.separator).test(frontValue + "0" + chrs.charAt(0))) ? isValid : (maskset.buffer[pos - 1] = "0",
{
refreshFromBuffer: {
start: pos - 1,
end: pos
},
pos: pos,
c: chrs.charAt(0)
});
},
cardinality: 2,
prevalidator: [ {
validator: function(chrs, maskset, pos, strict, opts) {
isNaN(maskset.buffer[pos + 1]) || (chrs += maskset.buffer[pos + 1]);
var frontValue = opts.getFrontValue(maskset.mask, maskset.buffer, opts);
-1 !== frontValue.indexOf(opts.placeholder[0]) && (frontValue = "01" + opts.separator);
var isValid = 1 === chrs.length ? opts.regex.val2pre(opts.separator).test(frontValue + chrs) : opts.regex.val2(opts.separator).test(frontValue + chrs);
return isValid && maskset.validPositions[pos] && (opts.regex.val2(opts.separator).test(chrs + maskset.validPositions[pos].input) || (maskset.validPositions[pos].input = "0" === chrs ? "1" : "0")),
strict || isValid || !(isValid = opts.regex.val2(opts.separator).test(frontValue + "0" + chrs)) ? isValid : (maskset.buffer[pos] = "0",
pos++, {
pos: pos
});
},
cardinality: 1
} ]
},
y: {
validator: function(chrs, maskset, pos, strict, opts) {
return opts.isInYearRange(chrs, opts.yearrange.minyear, opts.yearrange.maxyear);
},
cardinality: 4,
prevalidator: [ {
validator: function(chrs, maskset, pos, strict, opts) {
var isValid = opts.isInYearRange(chrs, opts.yearrange.minyear, opts.yearrange.maxyear);
if (!strict && !isValid) {
var yearPrefix = opts.determinebaseyear(opts.yearrange.minyear, opts.yearrange.maxyear, chrs + "0").toString().slice(0, 1);
if (isValid = opts.isInYearRange(yearPrefix + chrs, opts.yearrange.minyear, opts.yearrange.maxyear)) return maskset.buffer[pos++] = yearPrefix.charAt(0),
{
pos: pos
};
if (yearPrefix = opts.determinebaseyear(opts.yearrange.minyear, opts.yearrange.maxyear, chrs + "0").toString().slice(0, 2),
isValid = opts.isInYearRange(yearPrefix + chrs, opts.yearrange.minyear, opts.yearrange.maxyear)) return maskset.buffer[pos++] = yearPrefix.charAt(0),
maskset.buffer[pos++] = yearPrefix.charAt(1), {
pos: pos
};
}
return isValid;
},
cardinality: 1
}, {
validator: function(chrs, maskset, pos, strict, opts) {
var isValid = opts.isInYearRange(chrs, opts.yearrange.minyear, opts.yearrange.maxyear);
if (!strict && !isValid) {
var yearPrefix = opts.determinebaseyear(opts.yearrange.minyear, opts.yearrange.maxyear, chrs).toString().slice(0, 2);
if (isValid = opts.isInYearRange(chrs[0] + yearPrefix[1] + chrs[1], opts.yearrange.minyear, opts.yearrange.maxyear)) return maskset.buffer[pos++] = yearPrefix.charAt(1),
{
pos: pos
};
if (yearPrefix = opts.determinebaseyear(opts.yearrange.minyear, opts.yearrange.maxyear, chrs).toString().slice(0, 2),
isValid = opts.isInYearRange(yearPrefix + chrs, opts.yearrange.minyear, opts.yearrange.maxyear)) return maskset.buffer[pos - 1] = yearPrefix.charAt(0),
maskset.buffer[pos++] = yearPrefix.charAt(1), maskset.buffer[pos++] = chrs.charAt(0),
{
refreshFromBuffer: {
start: pos - 3,
end: pos
},
pos: pos
};
}
return isValid;
},
cardinality: 2
}, {
validator: function(chrs, maskset, pos, strict, opts) {
return opts.isInYearRange(chrs, opts.yearrange.minyear, opts.yearrange.maxyear);
},
cardinality: 3
} ]
}
},
insertMode: !1,
autoUnmask: !1
},
"mm/dd/yyyy": {
placeholder: "mm/dd/yyyy",
alias: "dd/mm/yyyy",
regex: {
val2pre: function(separator) {
var escapedSeparator = Inputmask.escapeRegex.call(this, separator);
return new RegExp("((0[13-9]|1[012])" + escapedSeparator + "[0-3])|(02" + escapedSeparator + "[0-2])");
},
val2: function(separator) {
var escapedSeparator = Inputmask.escapeRegex.call(this, separator);
return new RegExp("((0[1-9]|1[012])" + escapedSeparator + "(0[1-9]|[12][0-9]))|((0[13-9]|1[012])" + escapedSeparator + "30)|((0[13578]|1[02])" + escapedSeparator + "31)");
},
val1pre: new RegExp("[01]"),
val1: new RegExp("0[1-9]|1[012]")
},
leapday: "02/29/",
onKeyDown: function(e, buffer, caretPos, opts) {
var $input = $(this);
if (e.ctrlKey && e.keyCode === Inputmask.keyCode.RIGHT) {
var today = new Date();
$input.val((today.getMonth() + 1).toString() + today.getDate().toString() + today.getFullYear().toString()),
$input.trigger("setvalue");
}
}
},
"yyyy/mm/dd": {
mask: "y/1/2",
placeholder: "yyyy/mm/dd",
alias: "mm/dd/yyyy",
leapday: "/02/29",
onKeyDown: function(e, buffer, caretPos, opts) {
var $input = $(this);
if (e.ctrlKey && e.keyCode === Inputmask.keyCode.RIGHT) {
var today = new Date();
$input.val(today.getFullYear().toString() + (today.getMonth() + 1).toString() + today.getDate().toString()),
$input.trigger("setvalue");
}
}
},
"dd.mm.yyyy": {
mask: "1.2.y",
placeholder: "dd.mm.yyyy",
leapday: "29.02.",
separator: ".",
alias: "dd/mm/yyyy"
},
"dd-mm-yyyy": {
mask: "1-2-y",
placeholder: "dd-mm-yyyy",
leapday: "29-02-",
separator: "-",
alias: "dd/mm/yyyy"
},
"mm.dd.yyyy": {
mask: "1.2.y",
placeholder: "mm.dd.yyyy",
leapday: "02.29.",
separator: ".",
alias: "mm/dd/yyyy"
},
"mm-dd-yyyy": {
mask: "1-2-y",
placeholder: "mm-dd-yyyy",
leapday: "02-29-",
separator: "-",
alias: "mm/dd/yyyy"
},
"yyyy.mm.dd": {
mask: "y.1.2",
placeholder: "yyyy.mm.dd",
leapday: ".02.29",
separator: ".",
alias: "yyyy/mm/dd"
},
"yyyy-mm-dd": {
mask: "y-1-2",
placeholder: "yyyy-mm-dd",
leapday: "-02-29",
separator: "-",
alias: "yyyy/mm/dd"
},
datetime: {
mask: "1/2/y h:s",
placeholder: "dd/mm/yyyy hh:mm",
alias: "dd/mm/yyyy",
regex: {
hrspre: new RegExp("[012]"),
hrs24: new RegExp("2[0-4]|1[3-9]"),
hrs: new RegExp("[01][0-9]|2[0-4]"),
ampm: new RegExp("^[a|p|A|P][m|M]"),
mspre: new RegExp("[0-5]"),
ms: new RegExp("[0-5][0-9]")
},
timeseparator: ":",
hourFormat: "24",
definitions: {
h: {
validator: function(chrs, maskset, pos, strict, opts) {
if ("24" === opts.hourFormat && 24 === parseInt(chrs, 10)) return maskset.buffer[pos - 1] = "0",
maskset.buffer[pos] = "0", {
refreshFromBuffer: {
start: pos - 1,
end: pos
},
c: "0"
};
var isValid = opts.regex.hrs.test(chrs);
if (!strict && !isValid && (chrs.charAt(1) === opts.timeseparator || -1 !== "-.:".indexOf(chrs.charAt(1))) && (isValid = opts.regex.hrs.test("0" + chrs.charAt(0)))) return maskset.buffer[pos - 1] = "0",
maskset.buffer[pos] = chrs.charAt(0), pos++, {
refreshFromBuffer: {
start: pos - 2,
end: pos
},
pos: pos,
c: opts.timeseparator
};
if (isValid && "24" !== opts.hourFormat && opts.regex.hrs24.test(chrs)) {
var tmp = parseInt(chrs, 10);
return 24 === tmp ? (maskset.buffer[pos + 5] = "a", maskset.buffer[pos + 6] = "m") : (maskset.buffer[pos + 5] = "p",
maskset.buffer[pos + 6] = "m"), (tmp -= 12) < 10 ? (maskset.buffer[pos] = tmp.toString(),
maskset.buffer[pos - 1] = "0") : (maskset.buffer[pos] = tmp.toString().charAt(1),
maskset.buffer[pos - 1] = tmp.toString().charAt(0)), {
refreshFromBuffer: {
start: pos - 1,
end: pos + 6
},
c: maskset.buffer[pos]
};
}
return isValid;
},
cardinality: 2,
prevalidator: [ {
validator: function(chrs, maskset, pos, strict, opts) {
var isValid = opts.regex.hrspre.test(chrs);
return strict || isValid || !(isValid = opts.regex.hrs.test("0" + chrs)) ? isValid : (maskset.buffer[pos] = "0",
pos++, {
pos: pos
});
},
cardinality: 1
} ]
},
s: {
validator: "[0-5][0-9]",
cardinality: 2,
prevalidator: [ {
validator: function(chrs, maskset, pos, strict, opts) {
var isValid = opts.regex.mspre.test(chrs);
return strict || isValid || !(isValid = opts.regex.ms.test("0" + chrs)) ? isValid : (maskset.buffer[pos] = "0",
pos++, {
pos: pos
});
},
cardinality: 1
} ]
},
t: {
validator: function(chrs, maskset, pos, strict, opts) {
return opts.regex.ampm.test(chrs + "m");
},
casing: "lower",
cardinality: 1
}
},
insertMode: !1,
autoUnmask: !1
},
datetime12: {
mask: "1/2/y h:s t\\m",
placeholder: "dd/mm/yyyy hh:mm xm",
alias: "datetime",
hourFormat: "12"
},
"mm/dd/yyyy hh:mm xm": {
mask: "1/2/y h:s t\\m",
placeholder: "mm/dd/yyyy hh:mm xm",
alias: "datetime12",
regex: {
val2pre: function(separator) {
var escapedSeparator = Inputmask.escapeRegex.call(this, separator);
return new RegExp("((0[13-9]|1[012])" + escapedSeparator + "[0-3])|(02" + escapedSeparator + "[0-2])");
},
val2: function(separator) {
var escapedSeparator = Inputmask.escapeRegex.call(this, separator);
return new RegExp("((0[1-9]|1[012])" + escapedSeparator + "(0[1-9]|[12][0-9]))|((0[13-9]|1[012])" + escapedSeparator + "30)|((0[13578]|1[02])" + escapedSeparator + "31)");
},
val1pre: new RegExp("[01]"),
val1: new RegExp("0[1-9]|1[012]")
},
leapday: "02/29/",
onKeyDown: function(e, buffer, caretPos, opts) {
var $input = $(this);
if (e.ctrlKey && e.keyCode === Inputmask.keyCode.RIGHT) {
var today = new Date();
$input.val((today.getMonth() + 1).toString() + today.getDate().toString() + today.getFullYear().toString()),
$input.trigger("setvalue");
}
}
},
"hh:mm t": {
mask: "h:s t\\m",
placeholder: "hh:mm xm",
alias: "datetime",
hourFormat: "12"
},
"h:s t": {
mask: "h:s t\\m",
placeholder: "hh:mm xm",
alias: "datetime",
hourFormat: "12"
},
"hh:mm:ss": {
mask: "h:s:s",
placeholder: "hh:mm:ss",
alias: "datetime",
autoUnmask: !1
},
"hh:mm": {
mask: "h:s",
placeholder: "hh:mm",
alias: "datetime",
autoUnmask: !1
},
date: {
alias: "dd/mm/yyyy"
},
"mm/yyyy": {
mask: "1/y",
placeholder: "mm/yyyy",
leapday: "donotuse",
separator: "/",
alias: "mm/dd/yyyy"
},
shamsi: {
regex: {
val2pre: function(separator) {
var escapedSeparator = Inputmask.escapeRegex.call(this, separator);
return new RegExp("((0[1-9]|1[012])" + escapedSeparator + "[0-3])");
},
val2: function(separator) {
var escapedSeparator = Inputmask.escapeRegex.call(this, separator);
return new RegExp("((0[1-9]|1[012])" + escapedSeparator + "(0[1-9]|[12][0-9]))|((0[1-9]|1[012])" + escapedSeparator + "30)|((0[1-6])" + escapedSeparator + "31)");
},
val1pre: new RegExp("[01]"),
val1: new RegExp("0[1-9]|1[012]")
},
yearrange: {
minyear: 1300,
maxyear: 1499
},
mask: "y/1/2",
leapday: "/12/30",
placeholder: "yyyy/mm/dd",
alias: "mm/dd/yyyy",
clearIncomplete: !0
},
"yyyy-mm-dd hh:mm:ss": {
mask: "y-1-2 h:s:s",
placeholder: "yyyy-mm-dd hh:mm:ss",
alias: "datetime",
separator: "-",
leapday: "-02-29",
regex: {
val2pre: function(separator) {
var escapedSeparator = Inputmask.escapeRegex.call(this, separator);
return new RegExp("((0[13-9]|1[012])" + escapedSeparator + "[0-3])|(02" + escapedSeparator + "[0-2])");
},
val2: function(separator) {
var escapedSeparator = Inputmask.escapeRegex.call(this, separator);
return new RegExp("((0[1-9]|1[012])" + escapedSeparator + "(0[1-9]|[12][0-9]))|((0[13-9]|1[012])" + escapedSeparator + "30)|((0[13578]|1[02])" + escapedSeparator + "31)");
},
val1pre: new RegExp("[01]"),
val1: new RegExp("0[1-9]|1[012]")
},
onKeyDown: function(e, buffer, caretPos, opts) {}
}
}), Inputmask;
});
}, function(module, exports, __webpack_require__) {
"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;
"function" == typeof Symbol && Symbol.iterator;
void 0 !== (__WEBPACK_AMD_DEFINE_RESULT__ = function() {
return window;
}.call(exports, __webpack_require__, exports, module)) && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__);
}, function(module, exports, __webpack_require__) {
"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;
"function" == typeof Symbol && Symbol.iterator;
void 0 !== (__WEBPACK_AMD_DEFINE_RESULT__ = function() {
return document;
}.call(exports, __webpack_require__, exports, module)) && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__);
}, function(module, exports, __webpack_require__) {
"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
"function" == typeof Symbol && Symbol.iterator;
!function(factory) {
__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(0), __webpack_require__(1) ],
void 0 !== (__WEBPACK_AMD_DEFINE_RESULT__ = "function" == typeof (__WEBPACK_AMD_DEFINE_FACTORY__ = factory) ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__) && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__);
}(function($, Inputmask) {
return Inputmask.extendDefinitions({
A: {
validator: "[A-Za-z--]",
cardinality: 1,
casing: "upper"
},
"&": {
validator: "[0-9A-Za-z--]",
cardinality: 1,
casing: "upper"
},
"#": {
validator: "[0-9A-Fa-f]",
cardinality: 1,
casing: "upper"
}
}), Inputmask.extendAliases({
url: {
definitions: {
i: {
validator: ".",
cardinality: 1
}
},
mask: "(\\http://)|(\\http\\s://)|(ftp://)|(ftp\\s://)i{+}",
insertMode: !1,
autoUnmask: !1,
inputmode: "url"
},
ip: {
mask: "i[i[i]].i[i[i]].i[i[i]].i[i[i]]",
definitions: {
i: {
validator: function(chrs, maskset, pos, strict, opts) {
return pos - 1 > -1 && "." !== maskset.buffer[pos - 1] ? (chrs = maskset.buffer[pos - 1] + chrs,
chrs = pos - 2 > -1 && "." !== maskset.buffer[pos - 2] ? maskset.buffer[pos - 2] + chrs : "0" + chrs) : chrs = "00" + chrs,
new RegExp("25[0-5]|2[0-4][0-9]|[01][0-9][0-9]").test(chrs);
},
cardinality: 1
}
},
onUnMask: function(maskedValue, unmaskedValue, opts) {
return maskedValue;
},
inputmode: "numeric"
},
email: {
mask: "*{1,64}[.*{1,64}][.*{1,64}][.*{1,63}]@-{1,63}.-{1,63}[.-{1,63}][.-{1,63}]",
greedy: !1,
onBeforePaste: function(pastedValue, opts) {
return (pastedValue = pastedValue.toLowerCase()).replace("mailto:", "");
},
definitions: {
"*": {
validator: "[0-9A-Za-z!#$%&'*+/=?^_`{|}~-]",
cardinality: 1,
casing: "lower"
},
"-": {
validator: "[0-9A-Za-z-]",
cardinality: 1,
casing: "lower"
}
},
onUnMask: function(maskedValue, unmaskedValue, opts) {
return maskedValue;
},
inputmode: "email"
},
mac: {
mask: "##:##:##:##:##:##"
},
vin: {
mask: "V{13}9{4}",
definitions: {
V: {
validator: "[A-HJ-NPR-Za-hj-npr-z\\d]",
cardinality: 1,
casing: "upper"
}
},
clearIncomplete: !0,
autoUnmask: !0
}
}), Inputmask;
});
}, function(module, exports, __webpack_require__) {
"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
"function" == typeof Symbol && Symbol.iterator;
!function(factory) {
__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(0), __webpack_require__(1) ],
void 0 !== (__WEBPACK_AMD_DEFINE_RESULT__ = "function" == typeof (__WEBPACK_AMD_DEFINE_FACTORY__ = factory) ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__) && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__);
}(function($, Inputmask, undefined) {
function autoEscape(txt, opts) {
for (var escapedTxt = "", i = 0; i < txt.length; i++) Inputmask.prototype.definitions[txt.charAt(i)] || opts.definitions[txt.charAt(i)] || opts.optionalmarker.start === txt.charAt(i) || opts.optionalmarker.end === txt.charAt(i) || opts.quantifiermarker.start === txt.charAt(i) || opts.quantifiermarker.end === txt.charAt(i) || opts.groupmarker.start === txt.charAt(i) || opts.groupmarker.end === txt.charAt(i) || opts.alternatormarker === txt.charAt(i) ? escapedTxt += "\\" + txt.charAt(i) : escapedTxt += txt.charAt(i);
return escapedTxt;
}
return Inputmask.extendAliases({
numeric: {
mask: function(opts) {
if (0 !== opts.repeat && isNaN(opts.integerDigits) && (opts.integerDigits = opts.repeat),
opts.repeat = 0, opts.groupSeparator === opts.radixPoint && ("." === opts.radixPoint ? opts.groupSeparator = "," : "," === opts.radixPoint ? opts.groupSeparator = "." : opts.groupSeparator = ""),
" " === opts.groupSeparator && (opts.skipOptionalPartCharacter = undefined), opts.autoGroup = opts.autoGroup && "" !== opts.groupSeparator,
opts.autoGroup && ("string" == typeof opts.groupSize && isFinite(opts.groupSize) && (opts.groupSize = parseInt(opts.groupSize)),
isFinite(opts.integerDigits))) {
var seps = Math.floor(opts.integerDigits / opts.groupSize), mod = opts.integerDigits % opts.groupSize;
opts.integerDigits = parseInt(opts.integerDigits) + (0 === mod ? seps - 1 : seps),
opts.integerDigits < 1 && (opts.integerDigits = "*");
}
opts.placeholder.length > 1 && (opts.placeholder = opts.placeholder.charAt(0)),
"radixFocus" === opts.positionCaretOnClick && "" === opts.placeholder && !1 === opts.integerOptional && (opts.positionCaretOnClick = "lvp"),
opts.definitions[";"] = opts.definitions["~"], opts.definitions[";"].definitionSymbol = "~",
!0 === opts.numericInput && (opts.positionCaretOnClick = "radixFocus" === opts.positionCaretOnClick ? "lvp" : opts.positionCaretOnClick,
opts.digitsOptional = !1, isNaN(opts.digits) && (opts.digits = 2), opts.decimalProtect = !1);
var mask = "[+]";
if (mask += autoEscape(opts.prefix, opts), !0 === opts.integerOptional ? mask += "~{1," + opts.integerDigits + "}" : mask += "~{" + opts.integerDigits + "}",
opts.digits !== undefined) {
opts.radixPointDefinitionSymbol = opts.decimalProtect ? ":" : opts.radixPoint;
var dq = opts.digits.toString().split(",");
isFinite(dq[0] && dq[1] && isFinite(dq[1])) ? mask += opts.radixPointDefinitionSymbol + ";{" + opts.digits + "}" : (isNaN(opts.digits) || parseInt(opts.digits) > 0) && (opts.digitsOptional ? mask += "[" + opts.radixPointDefinitionSymbol + ";{1," + opts.digits + "}]" : mask += opts.radixPointDefinitionSymbol + ";{" + opts.digits + "}");
}
return mask += autoEscape(opts.suffix, opts), mask += "[-]", opts.greedy = !1, mask;
},
placeholder: "",
greedy: !1,
digits: "*",
digitsOptional: !0,
enforceDigitsOnBlur: !1,
radixPoint: ".",
positionCaretOnClick: "radixFocus",
groupSize: 3,
groupSeparator: "",
autoGroup: !1,
allowMinus: !0,
negationSymbol: {
front: "-",
back: ""
},
integerDigits: "+",
integerOptional: !0,
prefix: "",
suffix: "",
rightAlign: !0,
decimalProtect: !0,
min: null,
max: null,
step: 1,
insertMode: !0,
autoUnmask: !1,
unmaskAsNumber: !1,
inputmode: "numeric",
preValidation: function(buffer, pos, c, isSelection, opts) {
if ("-" === c || c === opts.negationSymbol.front) return !0 === opts.allowMinus && (opts.isNegative = opts.isNegative === undefined || !opts.isNegative,
"" === buffer.join("") || {
caret: pos,
dopost: !0
});
if (!1 === isSelection && c === opts.radixPoint && opts.digits !== undefined && (isNaN(opts.digits) || parseInt(opts.digits) > 0)) {
var radixPos = $.inArray(opts.radixPoint, buffer);
if (-1 !== radixPos) return !0 === opts.numericInput ? pos === radixPos : {
caret: radixPos + 1
};
}
return !0;
},
postValidation: function(buffer, currentResult, opts) {
var suffix = opts.suffix.split(""), prefix = opts.prefix.split("");
if (currentResult.pos === undefined && currentResult.caret !== undefined && !0 !== currentResult.dopost) return currentResult;
var caretPos = currentResult.caret !== undefined ? currentResult.caret : currentResult.pos, maskedValue = buffer.slice();
opts.numericInput && (caretPos = maskedValue.length - caretPos - 1, maskedValue = maskedValue.reverse());
var charAtPos = maskedValue[caretPos];
if (charAtPos === opts.groupSeparator && (charAtPos = maskedValue[caretPos += 1]),
caretPos === maskedValue.length - opts.suffix.length - 1 && charAtPos === opts.radixPoint) return currentResult;
charAtPos !== undefined && charAtPos !== opts.radixPoint && charAtPos !== opts.negationSymbol.front && charAtPos !== opts.negationSymbol.back && (maskedValue[caretPos] = "?",
opts.prefix.length > 0 && caretPos >= (!1 === opts.isNegative ? 1 : 0) && caretPos < opts.prefix.length - 1 + (!1 === opts.isNegative ? 1 : 0) ? prefix[caretPos - (!1 === opts.isNegative ? 1 : 0)] = "?" : opts.suffix.length > 0 && caretPos >= maskedValue.length - opts.suffix.length - (!1 === opts.isNegative ? 1 : 0) && (suffix[caretPos - (maskedValue.length - opts.suffix.length - (!1 === opts.isNegative ? 1 : 0))] = "?")),
prefix = prefix.join(""), suffix = suffix.join("");
var processValue = maskedValue.join("").replace(prefix, "");
if (processValue = processValue.replace(suffix, ""), processValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), "g"), ""),
processValue = processValue.replace(new RegExp("[-" + Inputmask.escapeRegex(opts.negationSymbol.front) + "]", "g"), ""),
processValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.negationSymbol.back) + "$"), ""),
isNaN(opts.placeholder) && (processValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.placeholder), "g"), "")),
processValue.length > 1 && 1 !== processValue.indexOf(opts.radixPoint) && ("0" === charAtPos && (processValue = processValue.replace(/^\?/g, "")),
processValue = processValue.replace(/^0/g, "")), processValue.charAt(0) === opts.radixPoint && "" !== opts.radixPoint && !0 !== opts.numericInput && (processValue = "0" + processValue),
"" !== processValue) {
if (processValue = processValue.split(""), (!opts.digitsOptional || opts.enforceDigitsOnBlur && "blur" === currentResult.event) && isFinite(opts.digits)) {
var radixPosition = $.inArray(opts.radixPoint, processValue), rpb = $.inArray(opts.radixPoint, maskedValue);
-1 === radixPosition && (processValue.push(opts.radixPoint), radixPosition = processValue.length - 1);
for (var i = 1; i <= opts.digits; i++) opts.digitsOptional && (!opts.enforceDigitsOnBlur || "blur" !== currentResult.event) || processValue[radixPosition + i] !== undefined && processValue[radixPosition + i] !== opts.placeholder.charAt(0) ? -1 !== rpb && maskedValue[rpb + i] !== undefined && (processValue[radixPosition + i] = processValue[radixPosition + i] || maskedValue[rpb + i]) : processValue[radixPosition + i] = currentResult.placeholder || opts.placeholder.charAt(0);
}
if (!0 !== opts.autoGroup || "" === opts.groupSeparator || charAtPos === opts.radixPoint && currentResult.pos === undefined && !currentResult.dopost) processValue = processValue.join(""); else {
var addRadix = processValue[processValue.length - 1] === opts.radixPoint && currentResult.c === opts.radixPoint;
processValue = Inputmask(function(buffer, opts) {
var postMask = "";
if (postMask += "(" + opts.groupSeparator + "*{" + opts.groupSize + "}){*}", "" !== opts.radixPoint) {
var radixSplit = buffer.join("").split(opts.radixPoint);
radixSplit[1] && (postMask += opts.radixPoint + "*{" + radixSplit[1].match(/^\d*\??\d*/)[0].length + "}");
}
return postMask;
}(processValue, opts), {
numericInput: !0,
jitMasking: !0,
definitions: {
"*": {
validator: "[0-9?]",
cardinality: 1
}
}
}).format(processValue.join("")), addRadix && (processValue += opts.radixPoint),
processValue.charAt(0) === opts.groupSeparator && processValue.substr(1);
}
}
if (opts.isNegative && "blur" === currentResult.event && (opts.isNegative = "0" !== processValue),
processValue = prefix + processValue, processValue += suffix, opts.isNegative && (processValue = opts.negationSymbol.front + processValue,
processValue += opts.negationSymbol.back), processValue = processValue.split(""),
charAtPos !== undefined) if (charAtPos !== opts.radixPoint && charAtPos !== opts.negationSymbol.front && charAtPos !== opts.negationSymbol.back) (caretPos = $.inArray("?", processValue)) > -1 ? processValue[caretPos] = charAtPos : caretPos = currentResult.caret || 0; else if (charAtPos === opts.radixPoint || charAtPos === opts.negationSymbol.front || charAtPos === opts.negationSymbol.back) {
var newCaretPos = $.inArray(charAtPos, processValue);
-1 !== newCaretPos && (caretPos = newCaretPos);
}
opts.numericInput && (caretPos = processValue.length - caretPos - 1, processValue = processValue.reverse());
var rslt = {
caret: charAtPos === undefined || currentResult.pos !== undefined ? caretPos + (opts.numericInput ? -1 : 1) : caretPos,
buffer: processValue,
refreshFromBuffer: currentResult.dopost || buffer.join("") !== processValue.join("")
};
return rslt.refreshFromBuffer ? rslt : currentResult;
},
onBeforeWrite: function(e, buffer, caretPos, opts) {
if (e) switch (e.type) {
case "keydown":
return opts.postValidation(buffer, {
caret: caretPos,
dopost: !0
}, opts);
case "blur":
case "checkval":
var unmasked;
if (function(opts) {
opts.parseMinMaxOptions === undefined && (null !== opts.min && (opts.min = opts.min.toString().replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), "g"), ""),
"," === opts.radixPoint && (opts.min = opts.min.replace(opts.radixPoint, ".")),
opts.min = isFinite(opts.min) ? parseFloat(opts.min) : NaN, isNaN(opts.min) && (opts.min = Number.MIN_VALUE)),
null !== opts.max && (opts.max = opts.max.toString().replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), "g"), ""),
"," === opts.radixPoint && (opts.max = opts.max.replace(opts.radixPoint, ".")),
opts.max = isFinite(opts.max) ? parseFloat(opts.max) : NaN, isNaN(opts.max) && (opts.max = Number.MAX_VALUE)),
opts.parseMinMaxOptions = "done");
}(opts), null !== opts.min || null !== opts.max) {
if (unmasked = opts.onUnMask(buffer.join(""), undefined, $.extend({}, opts, {
unmaskAsNumber: !0
})), null !== opts.min && unmasked < opts.min) return opts.isNegative = opts.min < 0,
opts.postValidation(opts.min.toString().replace(".", opts.radixPoint).split(""), {
caret: caretPos,
dopost: !0,
placeholder: "0"
}, opts);
if (null !== opts.max && unmasked > opts.max) return opts.isNegative = opts.max < 0,
opts.postValidation(opts.max.toString().replace(".", opts.radixPoint).split(""), {
caret: caretPos,
dopost: !0,
placeholder: "0"
}, opts);
}
return opts.postValidation(buffer, {
caret: caretPos,
placeholder: "0",
event: "blur"
}, opts);
case "_checkval":
return {
caret: caretPos
};
}
},
regex: {
integerPart: function(opts, emptyCheck) {
return emptyCheck ? new RegExp("[" + Inputmask.escapeRegex(opts.negationSymbol.front) + "+]?") : new RegExp("[" + Inputmask.escapeRegex(opts.negationSymbol.front) + "+]?\\d+");
},
integerNPart: function(opts) {
return new RegExp("[\\d" + Inputmask.escapeRegex(opts.groupSeparator) + Inputmask.escapeRegex(opts.placeholder.charAt(0)) + "]+");
}
},
definitions: {
"~": {
validator: function(chrs, maskset, pos, strict, opts, isSelection) {
var isValid = strict ? new RegExp("[0-9" + Inputmask.escapeRegex(opts.groupSeparator) + "]").test(chrs) : new RegExp("[0-9]").test(chrs);
if (!0 === isValid) {
if (!0 !== opts.numericInput && maskset.validPositions[pos] !== undefined && "~" === maskset.validPositions[pos].match.def && !isSelection) {
var processValue = maskset.buffer.join(""), pvRadixSplit = (processValue = (processValue = processValue.replace(new RegExp("[-" + Inputmask.escapeRegex(opts.negationSymbol.front) + "]", "g"), "")).replace(new RegExp(Inputmask.escapeRegex(opts.negationSymbol.back) + "$"), "")).split(opts.radixPoint);
pvRadixSplit.length > 1 && (pvRadixSplit[1] = pvRadixSplit[1].replace(/0/g, opts.placeholder.charAt(0))),
"0" === pvRadixSplit[0] && (pvRadixSplit[0] = pvRadixSplit[0].replace(/0/g, opts.placeholder.charAt(0))),
processValue = pvRadixSplit[0] + opts.radixPoint + pvRadixSplit[1] || "";
var bufferTemplate = maskset._buffer.join("");
for (processValue === opts.radixPoint && (processValue = bufferTemplate); null === processValue.match(Inputmask.escapeRegex(bufferTemplate) + "$"); ) bufferTemplate = bufferTemplate.slice(1);
isValid = (processValue = (processValue = processValue.replace(bufferTemplate, "")).split(""))[pos] === undefined ? {
pos: pos,
remove: pos
} : {
pos: pos
};
}
} else strict || chrs !== opts.radixPoint || maskset.validPositions[pos - 1] !== undefined || (maskset.buffer[pos] = "0",
isValid = {
pos: pos + 1
});
return isValid;
},
cardinality: 1
},
"+": {
validator: function(chrs, maskset, pos, strict, opts) {
return opts.allowMinus && ("-" === chrs || chrs === opts.negationSymbol.front);
},
cardinality: 1,
placeholder: ""
},
"-": {
validator: function(chrs, maskset, pos, strict, opts) {
return opts.allowMinus && chrs === opts.negationSymbol.back;
},
cardinality: 1,
placeholder: ""
},
":": {
validator: function(chrs, maskset, pos, strict, opts) {
var radix = "[" + Inputmask.escapeRegex(opts.radixPoint) + "]", isValid = new RegExp(radix).test(chrs);
return isValid && maskset.validPositions[pos] && maskset.validPositions[pos].match.placeholder === opts.radixPoint && (isValid = {
caret: pos + 1
}), isValid;
},
cardinality: 1,
placeholder: function(opts) {
return opts.radixPoint;
}
}
},
onUnMask: function(maskedValue, unmaskedValue, opts) {
if ("" === unmaskedValue && !0 === opts.nullable) return unmaskedValue;
var processValue = maskedValue.replace(opts.prefix, "");
return processValue = processValue.replace(opts.suffix, ""), processValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), "g"), ""),
"" !== opts.placeholder.charAt(0) && (processValue = processValue.replace(new RegExp(opts.placeholder.charAt(0), "g"), "0")),
opts.unmaskAsNumber ? ("" !== opts.radixPoint && -1 !== processValue.indexOf(opts.radixPoint) && (processValue = processValue.replace(Inputmask.escapeRegex.call(this, opts.radixPoint), ".")),
processValue = processValue.replace(new RegExp("^" + Inputmask.escapeRegex(opts.negationSymbol.front)), "-"),
processValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.negationSymbol.back) + "$"), ""),
Number(processValue)) : processValue;
},
isComplete: function(buffer, opts) {
var maskedValue = buffer.join("");
if (buffer.slice().join("") !== maskedValue) return !1;
var processValue = maskedValue.replace(opts.prefix, "");
return processValue = processValue.replace(opts.suffix, ""), processValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), "g"), ""),
"," === opts.radixPoint && (processValue = processValue.replace(Inputmask.escapeRegex(opts.radixPoint), ".")),
isFinite(processValue);
},
onBeforeMask: function(initialValue, opts) {
if (opts.isNegative = undefined, initialValue = initialValue.toString().charAt(initialValue.length - 1) === opts.radixPoint ? initialValue.toString().substr(0, initialValue.length - 1) : initialValue.toString(),
"" !== opts.radixPoint && isFinite(initialValue)) {
var vs = initialValue.split("."), groupSize = "" !== opts.groupSeparator ? parseInt(opts.groupSize) : 0;
2 === vs.length && (vs[0].length > groupSize || vs[1].length > groupSize || vs[0].length <= groupSize && vs[1].length < groupSize) && (initialValue = initialValue.replace(".", opts.radixPoint));
}
var kommaMatches = initialValue.match(/,/g), dotMatches = initialValue.match(/\./g);
if (initialValue = dotMatches && kommaMatches ? dotMatches.length > kommaMatches.length ? (initialValue = initialValue.replace(/\./g, "")).replace(",", opts.radixPoint) : kommaMatches.length > dotMatches.length ? (initialValue = initialValue.replace(/,/g, "")).replace(".", opts.radixPoint) : initialValue.indexOf(".") < initialValue.indexOf(",") ? initialValue.replace(/\./g, "") : initialValue.replace(/,/g, "") : initialValue.replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), "g"), ""),
0 === opts.digits && (-1 !== initialValue.indexOf(".") ? initialValue = initialValue.substring(0, initialValue.indexOf(".")) : -1 !== initialValue.indexOf(",") && (initialValue = initialValue.substring(0, initialValue.indexOf(",")))),
"" !== opts.radixPoint && isFinite(opts.digits) && -1 !== initialValue.indexOf(opts.radixPoint)) {
var decPart = initialValue.split(opts.radixPoint)[1].match(new RegExp("\\d*"))[0];
if (parseInt(opts.digits) < decPart.toString().length) {
var digitsFactor = Math.pow(10, parseInt(opts.digits));
initialValue = initialValue.replace(Inputmask.escapeRegex(opts.radixPoint), "."),
initialValue = (initialValue = Math.round(parseFloat(initialValue) * digitsFactor) / digitsFactor).toString().replace(".", opts.radixPoint);
}
}
return initialValue;
},
canClearPosition: function(maskset, position, lvp, strict, opts) {
var vp = maskset.validPositions[position], canClear = vp.input !== opts.radixPoint || null !== maskset.validPositions[position].match.fn && !1 === opts.decimalProtect || vp.input === opts.radixPoint && maskset.validPositions[position + 1] && null === maskset.validPositions[position + 1].match.fn || isFinite(vp.input) || position === lvp || vp.input === opts.groupSeparator || vp.input === opts.negationSymbol.front || vp.input === opts.negationSymbol.back;
return !canClear || "+" !== vp.match.nativeDef && "-" !== vp.match.nativeDef || (opts.isNegative = !1),
canClear;
},
onKeyDown: function(e, buffer, caretPos, opts) {
var $input = $(this);
if (e.ctrlKey) switch (e.keyCode) {
case Inputmask.keyCode.UP:
$input.val(parseFloat(this.inputmask.unmaskedvalue()) + parseInt(opts.step)), $input.trigger("setvalue");
break;
case Inputmask.keyCode.DOWN:
$input.val(parseFloat(this.inputmask.unmaskedvalue()) - parseInt(opts.step)), $input.trigger("setvalue");
}
}
},
currency: {
prefix: "$ ",
groupSeparator: ",",
alias: "numeric",
placeholder: "0",
autoGroup: !0,
digits: 2,
digitsOptional: !1,
clearMaskOnLostFocus: !1
},
decimal: {
alias: "numeric"
},
integer: {
alias: "numeric",
digits: 0,
radixPoint: ""
},
percentage: {
alias: "numeric",
digits: 2,
digitsOptional: !0,
radixPoint: ".",
placeholder: "0",
autoGroup: !1,
min: 0,
max: 100,
suffix: " %",
allowMinus: !1
}
}), Inputmask;
});
}, function(module, exports, __webpack_require__) {
"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
"function" == typeof Symbol && Symbol.iterator;
!function(factory) {
__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(0), __webpack_require__(1) ],
void 0 !== (__WEBPACK_AMD_DEFINE_RESULT__ = "function" == typeof (__WEBPACK_AMD_DEFINE_FACTORY__ = factory) ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__) && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__);
}(function($, Inputmask) {
function maskSort(a, b) {
var maska = (a.mask || a).replace(/#/g, "9").replace(/\)/, "9").replace(/[+()#-]/g, ""), maskb = (b.mask || b).replace(/#/g, "9").replace(/\)/, "9").replace(/[+()#-]/g, ""), maskas = (a.mask || a).split("#")[0], maskbs = (b.mask || b).split("#")[0];
return 0 === maskbs.indexOf(maskas) ? -1 : 0 === maskas.indexOf(maskbs) ? 1 : maska.localeCompare(maskb);
}
var analyseMaskBase = Inputmask.prototype.analyseMask;
return Inputmask.prototype.analyseMask = function(mask, regexMask, opts) {
function reduceVariations(masks, previousVariation, previousmaskGroup) {
previousVariation = previousVariation || "", previousmaskGroup = previousmaskGroup || maskGroups,
"" !== previousVariation && (previousmaskGroup[previousVariation] = {});
for (var variation = "", maskGroup = previousmaskGroup[previousVariation] || previousmaskGroup, i = masks.length - 1; i >= 0; i--) maskGroup[variation = (mask = masks[i].mask || masks[i]).substr(0, 1)] = maskGroup[variation] || [],
maskGroup[variation].unshift(mask.substr(1)), masks.splice(i, 1);
for (var ndx in maskGroup) maskGroup[ndx].length > 500 && reduceVariations(maskGroup[ndx].slice(), ndx, maskGroup);
}
function rebuild(maskGroup) {
var mask = "", submasks = [];
for (var ndx in maskGroup) $.isArray(maskGroup[ndx]) ? 1 === maskGroup[ndx].length ? submasks.push(ndx + maskGroup[ndx]) : submasks.push(ndx + opts.groupmarker.start + maskGroup[ndx].join(opts.groupmarker.end + opts.alternatormarker + opts.groupmarker.start) + opts.groupmarker.end) : submasks.push(ndx + rebuild(maskGroup[ndx]));
return 1 === submasks.length ? mask += submasks[0] : mask += opts.groupmarker.start + submasks.join(opts.groupmarker.end + opts.alternatormarker + opts.groupmarker.start) + opts.groupmarker.end,
mask;
}
var maskGroups = {};
return opts.phoneCodes && (opts.phoneCodes && opts.phoneCodes.length > 1e3 && (reduceVariations((mask = mask.substr(1, mask.length - 2)).split(opts.groupmarker.end + opts.alternatormarker + opts.groupmarker.start)),
mask = rebuild(maskGroups)), mask = mask.replace(/9/g, "\\9")), analyseMaskBase.call(this, mask, regexMask, opts);
}, Inputmask.extendAliases({
abstractphone: {
groupmarker: {
start: "<",
end: ">"
},
countrycode: "",
phoneCodes: [],
mask: function(opts) {
return opts.definitions = {
"#": Inputmask.prototype.definitions[9]
}, opts.phoneCodes.sort(maskSort);
},
keepStatic: !0,
onBeforeMask: function(value, opts) {
var processedValue = value.replace(/^0{1,2}/, "").replace(/[\s]/g, "");
return (processedValue.indexOf(opts.countrycode) > 1 || -1 === processedValue.indexOf(opts.countrycode)) && (processedValue = "+" + opts.countrycode + processedValue),
processedValue;
},
onUnMask: function(maskedValue, unmaskedValue, opts) {
return maskedValue.replace(/[()#-]/g, "");
},
inputmode: "tel"
}
}), Inputmask;
});
}, function(module, exports, __webpack_require__) {
"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
"function" == typeof Symbol && Symbol.iterator;
!function(factory) {
__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(0), __webpack_require__(1) ],
void 0 !== (__WEBPACK_AMD_DEFINE_RESULT__ = "function" == typeof (__WEBPACK_AMD_DEFINE_FACTORY__ = factory) ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__) && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__);
}(function($, Inputmask) {
return Inputmask.extendAliases({
Regex: {
mask: "r",
greedy: !1,
repeat: "*",
regex: null,
regexTokens: null,
tokenizer: /\[\^?]?(?:[^\\\]]+|\\[\S\s]?)*]?|\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9][0-9]*|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}|c[A-Za-z]|[\S\s]?)|\((?:\?[:=!]?)?|(?:[?*+]|\{[0-9]+(?:,[0-9]*)?\})\??|[^.?*+^${[()|\\]+|./g,
quantifierFilter: /[0-9]+[^,]/,
isComplete: function(buffer, opts) {
return new RegExp(opts.regex, opts.casing ? "i" : "").test(buffer.join(""));
},
definitions: {
r: {
validator: function(chrs, maskset, pos, strict, opts) {
function RegexToken(isGroup, isQuantifier) {
this.matches = [], this.isGroup = isGroup || !1, this.isQuantifier = isQuantifier || !1,
this.quantifier = {
min: 1,
max: 1
}, this.repeaterPart = void 0;
}
function validateRegexToken(token, fromGroup) {
var isvalid = !1;
fromGroup && (regexPart += "(", openGroupCount++);
for (var mndx = 0; mndx < token.matches.length; mndx++) {
var matchToken = token.matches[mndx];
if (!0 === matchToken.isGroup) isvalid = validateRegexToken(matchToken, !0); else if (!0 === matchToken.isQuantifier) {
var crrntndx = $.inArray(matchToken, token.matches), matchGroup = token.matches[crrntndx - 1], regexPartBak = regexPart;
if (isNaN(matchToken.quantifier.max)) {
for (;matchToken.repeaterPart && matchToken.repeaterPart !== regexPart && matchToken.repeaterPart.length > regexPart.length && !(isvalid = validateRegexToken(matchGroup, !0)); ) ;
(isvalid = isvalid || validateRegexToken(matchGroup, !0)) && (matchToken.repeaterPart = regexPart),
regexPart = regexPartBak + matchToken.quantifier.max;
} else {
for (var i = 0, qm = matchToken.quantifier.max - 1; i < qm && !(isvalid = validateRegexToken(matchGroup, !0)); i++) ;
regexPart = regexPartBak + "{" + matchToken.quantifier.min + "," + matchToken.quantifier.max + "}";
}
} else if (void 0 !== matchToken.matches) for (var k = 0; k < matchToken.length && !(isvalid = validateRegexToken(matchToken[k], fromGroup)); k++) ; else {
var testExp;
if ("[" == matchToken.charAt(0)) {
testExp = regexPart, testExp += matchToken;
for (j = 0; j < openGroupCount; j++) testExp += ")";
isvalid = (exp = new RegExp("^(" + testExp + ")$", opts.casing ? "i" : "")).test(bufferStr);
} else for (var l = 0, tl = matchToken.length; l < tl; l++) if ("\\" !== matchToken.charAt(l)) {
testExp = regexPart, testExp = (testExp += matchToken.substr(0, l + 1)).replace(/\|$/, "");
for (var j = 0; j < openGroupCount; j++) testExp += ")";
var exp = new RegExp("^(" + testExp + ")$", opts.casing ? "i" : "");
if (isvalid = exp.test(bufferStr)) break;
}
regexPart += matchToken;
}
if (isvalid) break;
}
return fromGroup && (regexPart += ")", openGroupCount--), isvalid;
}
var bufferStr, groupToken, cbuffer = maskset.buffer.slice(), regexPart = "", isValid = !1, openGroupCount = 0;
null === opts.regexTokens && function() {
var match, m, currentToken = new RegexToken(), opengroups = [];
for (opts.regexTokens = []; match = opts.tokenizer.exec(opts.regex); ) switch ((m = match[0]).charAt(0)) {
case "(":
opengroups.push(new RegexToken(!0));
break;
case ")":
groupToken = opengroups.pop(), opengroups.length > 0 ? opengroups[opengroups.length - 1].matches.push(groupToken) : currentToken.matches.push(groupToken);
break;
case "{":
case "+":
case "*":
var quantifierToken = new RegexToken(!1, !0), mq = (m = m.replace(/[{}]/g, "")).split(","), mq0 = isNaN(mq[0]) ? mq[0] : parseInt(mq[0]), mq1 = 1 === mq.length ? mq0 : isNaN(mq[1]) ? mq[1] : parseInt(mq[1]);
if (quantifierToken.quantifier = {
min: mq0,
max: mq1
}, opengroups.length > 0) {
var matches = opengroups[opengroups.length - 1].matches;
(match = matches.pop()).isGroup || ((groupToken = new RegexToken(!0)).matches.push(match),
match = groupToken), matches.push(match), matches.push(quantifierToken);
} else (match = currentToken.matches.pop()).isGroup || ((groupToken = new RegexToken(!0)).matches.push(match),
match = groupToken), currentToken.matches.push(match), currentToken.matches.push(quantifierToken);
break;
default:
opengroups.length > 0 ? opengroups[opengroups.length - 1].matches.push(m) : currentToken.matches.push(m);
}
currentToken.matches.length > 0 && opts.regexTokens.push(currentToken);
}(), cbuffer.splice(pos, 0, chrs), bufferStr = cbuffer.join("");
for (var i = 0; i < opts.regexTokens.length; i++) {
var regexToken = opts.regexTokens[i];
if (isValid = validateRegexToken(regexToken, regexToken.isGroup)) break;
}
return isValid;
},
cardinality: 1
}
}
}
}), Inputmask;
});
}, function(module, exports, __webpack_require__) {
"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__, _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
return typeof obj;
} : function(obj) {
return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};
!function(factory) {
__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(2), __webpack_require__(1) ],
void 0 !== (__WEBPACK_AMD_DEFINE_RESULT__ = "function" == typeof (__WEBPACK_AMD_DEFINE_FACTORY__ = factory) ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__) && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__);
}(function($, Inputmask) {
return void 0 === $.fn.inputmask && ($.fn.inputmask = function(fn, options) {
var nptmask, input = this[0];
if (void 0 === options && (options = {}), "string" == typeof fn) switch (fn) {
case "unmaskedvalue":
return input && input.inputmask ? input.inputmask.unmaskedvalue() : $(input).val();
case "remove":
return this.each(function() {
this.inputmask && this.inputmask.remove();
});
case "getemptymask":
return input && input.inputmask ? input.inputmask.getemptymask() : "";
case "hasMaskedValue":
return !(!input || !input.inputmask) && input.inputmask.hasMaskedValue();
case "isComplete":
return !input || !input.inputmask || input.inputmask.isComplete();
case "getmetadata":
return input && input.inputmask ? input.inputmask.getmetadata() : void 0;
case "setvalue":
$(input).val(options), input && void 0 === input.inputmask && $(input).triggerHandler("setvalue");
break;
case "option":
if ("string" != typeof options) return this.each(function() {
if (void 0 !== this.inputmask) return this.inputmask.option(options);
});
if (input && void 0 !== input.inputmask) return input.inputmask.option(options);
break;
default:
return options.alias = fn, nptmask = new Inputmask(options), this.each(function() {
nptmask.mask(this);
});
} else {
if ("object" == (void 0 === fn ? "undefined" : _typeof(fn))) return nptmask = new Inputmask(fn),
void 0 === fn.mask && void 0 === fn.alias ? this.each(function() {
if (void 0 !== this.inputmask) return this.inputmask.option(fn);
nptmask.mask(this);
}) : this.each(function() {
nptmask.mask(this);
});
if (void 0 === fn) return this.each(function() {
(nptmask = new Inputmask(options)).mask(this);
});
}
}), $.fn.inputmask;
});
} ]);
!function(factory) {
"function" == typeof define && define.amd ? define([ "./dependencyLibs/inputmask.dependencyLib", "./inputmask" ], factory) : "object" == typeof exports ? module.exports = factory(require("./dependencyLibs/inputmask.dependencyLib"), require("./inputmask")) : factory(window.dependencyLib || jQuery, window.Inputmask);
}(function($, Inputmask) {
function isLeapYear(year) {
return isNaN(year) || 29 === new Date(year, 2, 0).getDate();
}
return Inputmask.extendAliases({
"dd/mm/yyyy": {
mask: "1/2/y",
placeholder: "dd/mm/yyyy",
regex: {
val1pre: new RegExp("[0-3]"),
val1: new RegExp("0[1-9]|[12][0-9]|3[01]"),
val2pre: function(separator) {
var escapedSeparator = Inputmask.escapeRegex.call(this, separator);
return new RegExp("((0[1-9]|[12][0-9]|3[01])" + escapedSeparator + "[01])");
},
val2: function(separator) {
var escapedSeparator = Inputmask.escapeRegex.call(this, separator);
return new RegExp("((0[1-9]|[12][0-9])" + escapedSeparator + "(0[1-9]|1[012]))|(30" + escapedSeparator + "(0[13-9]|1[012]))|(31" + escapedSeparator + "(0[13578]|1[02]))");
}
},
leapday: "29/02/",
separator: "/",
yearrange: {
minyear: 1900,
maxyear: 2099
},
isInYearRange: function(chrs, minyear, maxyear) {
if (isNaN(chrs)) return !1;
var enteredyear = parseInt(chrs.concat(minyear.toString().slice(chrs.length))), enteredyear2 = parseInt(chrs.concat(maxyear.toString().slice(chrs.length)));
return !isNaN(enteredyear) && (minyear <= enteredyear && enteredyear <= maxyear) || !isNaN(enteredyear2) && (minyear <= enteredyear2 && enteredyear2 <= maxyear);
},
determinebaseyear: function(minyear, maxyear, hint) {
var currentyear = new Date().getFullYear();
if (minyear > currentyear) return minyear;
if (maxyear < currentyear) {
for (var maxYearPrefix = maxyear.toString().slice(0, 2), maxYearPostfix = maxyear.toString().slice(2, 4); maxyear < maxYearPrefix + hint; ) maxYearPrefix--;
var maxxYear = maxYearPrefix + maxYearPostfix;
return minyear > maxxYear ? minyear : maxxYear;
}
if (minyear <= currentyear && currentyear <= maxyear) {
for (var currentYearPrefix = currentyear.toString().slice(0, 2); maxyear < currentYearPrefix + hint; ) currentYearPrefix--;
var currentYearAndHint = currentYearPrefix + hint;
return currentYearAndHint < minyear ? minyear : currentYearAndHint;
}
return currentyear;
},
onKeyDown: function(e, buffer, caretPos, opts) {
var $input = $(this);
if (e.ctrlKey && e.keyCode === Inputmask.keyCode.RIGHT) {
var today = new Date();
$input.val(today.getDate().toString() + (today.getMonth() + 1).toString() + today.getFullYear().toString()),
$input.trigger("setvalue");
}
},
getFrontValue: function(mask, buffer, opts) {
for (var start = 0, length = 0, i = 0; i < mask.length && "2" !== mask.charAt(i); i++) {
var definition = opts.definitions[mask.charAt(i)];
definition ? (start += length, length = definition.cardinality) : length++;
}
return buffer.join("").substr(start, length);
},
postValidation: function(buffer, currentResult, opts) {
var dayMonthValue, year, bufferStr = buffer.join("");
return 0 === opts.mask.indexOf("y") ? (year = bufferStr.substr(0, 4), dayMonthValue = bufferStr.substring(4, 10)) : (year = bufferStr.substring(6, 10),
dayMonthValue = bufferStr.substr(0, 6)), currentResult && (dayMonthValue !== opts.leapday || isLeapYear(year));
},
definitions: {
"1": {
validator: function(chrs, maskset, pos, strict, opts) {
var isValid = opts.regex.val1.test(chrs);
return strict || isValid || chrs.charAt(1) !== opts.separator && -1 === "-./".indexOf(chrs.charAt(1)) || !(isValid = opts.regex.val1.test("0" + chrs.charAt(0))) ? isValid : (maskset.buffer[pos - 1] = "0",
{
refreshFromBuffer: {
start: pos - 1,
end: pos
},
pos: pos,
c: chrs.charAt(0)
});
},
cardinality: 2,
prevalidator: [ {
validator: function(chrs, maskset, pos, strict, opts) {
var pchrs = chrs;
isNaN(maskset.buffer[pos + 1]) || (pchrs += maskset.buffer[pos + 1]);
var isValid = 1 === pchrs.length ? opts.regex.val1pre.test(pchrs) : opts.regex.val1.test(pchrs);
if (isValid && maskset.validPositions[pos] && (opts.regex.val2(opts.separator).test(chrs + maskset.validPositions[pos].input) || (maskset.validPositions[pos].input = "0" === chrs ? "1" : "0")),
!strict && !isValid) {
if (isValid = opts.regex.val1.test(chrs + "0")) return maskset.buffer[pos] = chrs,
maskset.buffer[++pos] = "0", {
pos: pos,
c: "0"
};
if (isValid = opts.regex.val1.test("0" + chrs)) return maskset.buffer[pos] = "0",
pos++, {
pos: pos
};
}
return isValid;
},
cardinality: 1
} ]
},
"2": {
validator: function(chrs, maskset, pos, strict, opts) {
var frontValue = opts.getFrontValue(maskset.mask, maskset.buffer, opts);
-1 !== frontValue.indexOf(opts.placeholder[0]) && (frontValue = "01" + opts.separator);
var isValid = opts.regex.val2(opts.separator).test(frontValue + chrs);
return strict || isValid || chrs.charAt(1) !== opts.separator && -1 === "-./".indexOf(chrs.charAt(1)) || !(isValid = opts.regex.val2(opts.separator).test(frontValue + "0" + chrs.charAt(0))) ? isValid : (maskset.buffer[pos - 1] = "0",
{
refreshFromBuffer: {
start: pos - 1,
end: pos
},
pos: pos,
c: chrs.charAt(0)
});
},
cardinality: 2,
prevalidator: [ {
validator: function(chrs, maskset, pos, strict, opts) {
isNaN(maskset.buffer[pos + 1]) || (chrs += maskset.buffer[pos + 1]);
var frontValue = opts.getFrontValue(maskset.mask, maskset.buffer, opts);
-1 !== frontValue.indexOf(opts.placeholder[0]) && (frontValue = "01" + opts.separator);
var isValid = 1 === chrs.length ? opts.regex.val2pre(opts.separator).test(frontValue + chrs) : opts.regex.val2(opts.separator).test(frontValue + chrs);
return isValid && maskset.validPositions[pos] && (opts.regex.val2(opts.separator).test(chrs + maskset.validPositions[pos].input) || (maskset.validPositions[pos].input = "0" === chrs ? "1" : "0")),
strict || isValid || !(isValid = opts.regex.val2(opts.separator).test(frontValue + "0" + chrs)) ? isValid : (maskset.buffer[pos] = "0",
pos++, {
pos: pos
});
},
cardinality: 1
} ]
},
y: {
validator: function(chrs, maskset, pos, strict, opts) {
return opts.isInYearRange(chrs, opts.yearrange.minyear, opts.yearrange.maxyear);
},
cardinality: 4,
prevalidator: [ {
validator: function(chrs, maskset, pos, strict, opts) {
var isValid = opts.isInYearRange(chrs, opts.yearrange.minyear, opts.yearrange.maxyear);
if (!strict && !isValid) {
var yearPrefix = opts.determinebaseyear(opts.yearrange.minyear, opts.yearrange.maxyear, chrs + "0").toString().slice(0, 1);
if (isValid = opts.isInYearRange(yearPrefix + chrs, opts.yearrange.minyear, opts.yearrange.maxyear)) return maskset.buffer[pos++] = yearPrefix.charAt(0),
{
pos: pos
};
if (yearPrefix = opts.determinebaseyear(opts.yearrange.minyear, opts.yearrange.maxyear, chrs + "0").toString().slice(0, 2),
isValid = opts.isInYearRange(yearPrefix + chrs, opts.yearrange.minyear, opts.yearrange.maxyear)) return maskset.buffer[pos++] = yearPrefix.charAt(0),
maskset.buffer[pos++] = yearPrefix.charAt(1), {
pos: pos
};
}
return isValid;
},
cardinality: 1
}, {
validator: function(chrs, maskset, pos, strict, opts) {
var isValid = opts.isInYearRange(chrs, opts.yearrange.minyear, opts.yearrange.maxyear);
if (!strict && !isValid) {
var yearPrefix = opts.determinebaseyear(opts.yearrange.minyear, opts.yearrange.maxyear, chrs).toString().slice(0, 2);
if (isValid = opts.isInYearRange(chrs[0] + yearPrefix[1] + chrs[1], opts.yearrange.minyear, opts.yearrange.maxyear)) return maskset.buffer[pos++] = yearPrefix.charAt(1),
{
pos: pos
};
if (yearPrefix = opts.determinebaseyear(opts.yearrange.minyear, opts.yearrange.maxyear, chrs).toString().slice(0, 2),
isValid = opts.isInYearRange(yearPrefix + chrs, opts.yearrange.minyear, opts.yearrange.maxyear)) return maskset.buffer[pos - 1] = yearPrefix.charAt(0),
maskset.buffer[pos++] = yearPrefix.charAt(1), maskset.buffer[pos++] = chrs.charAt(0),
{
refreshFromBuffer: {
start: pos - 3,
end: pos
},
pos: pos
};
}
return isValid;
},
cardinality: 2
}, {
validator: function(chrs, maskset, pos, strict, opts) {
return opts.isInYearRange(chrs, opts.yearrange.minyear, opts.yearrange.maxyear);
},
cardinality: 3
} ]
}
},
insertMode: !1,
autoUnmask: !1
},
"mm/dd/yyyy": {
placeholder: "mm/dd/yyyy",
alias: "dd/mm/yyyy",
regex: {
val2pre: function(separator) {
var escapedSeparator = Inputmask.escapeRegex.call(this, separator);
return new RegExp("((0[13-9]|1[012])" + escapedSeparator + "[0-3])|(02" + escapedSeparator + "[0-2])");
},
val2: function(separator) {
var escapedSeparator = Inputmask.escapeRegex.call(this, separator);
return new RegExp("((0[1-9]|1[012])" + escapedSeparator + "(0[1-9]|[12][0-9]))|((0[13-9]|1[012])" + escapedSeparator + "30)|((0[13578]|1[02])" + escapedSeparator + "31)");
},
val1pre: new RegExp("[01]"),
val1: new RegExp("0[1-9]|1[012]")
},
leapday: "02/29/",
onKeyDown: function(e, buffer, caretPos, opts) {
var $input = $(this);
if (e.ctrlKey && e.keyCode === Inputmask.keyCode.RIGHT) {
var today = new Date();
$input.val((today.getMonth() + 1).toString() + today.getDate().toString() + today.getFullYear().toString()),
$input.trigger("setvalue");
}
}
},
"yyyy/mm/dd": {
mask: "y/1/2",
placeholder: "yyyy/mm/dd",
alias: "mm/dd/yyyy",
leapday: "/02/29",
onKeyDown: function(e, buffer, caretPos, opts) {
var $input = $(this);
if (e.ctrlKey && e.keyCode === Inputmask.keyCode.RIGHT) {
var today = new Date();
$input.val(today.getFullYear().toString() + (today.getMonth() + 1).toString() + today.getDate().toString()),
$input.trigger("setvalue");
}
}
},
"dd.mm.yyyy": {
mask: "1.2.y",
placeholder: "dd.mm.yyyy",
leapday: "29.02.",
separator: ".",
alias: "dd/mm/yyyy"
},
"dd-mm-yyyy": {
mask: "1-2-y",
placeholder: "dd-mm-yyyy",
leapday: "29-02-",
separator: "-",
alias: "dd/mm/yyyy"
},
"mm.dd.yyyy": {
mask: "1.2.y",
placeholder: "mm.dd.yyyy",
leapday: "02.29.",
separator: ".",
alias: "mm/dd/yyyy"
},
"mm-dd-yyyy": {
mask: "1-2-y",
placeholder: "mm-dd-yyyy",
leapday: "02-29-",
separator: "-",
alias: "mm/dd/yyyy"
},
"yyyy.mm.dd": {
mask: "y.1.2",
placeholder: "yyyy.mm.dd",
leapday: ".02.29",
separator: ".",
alias: "yyyy/mm/dd"
},
"yyyy-mm-dd": {
mask: "y-1-2",
placeholder: "yyyy-mm-dd",
leapday: "-02-29",
separator: "-",
alias: "yyyy/mm/dd"
},
datetime: {
mask: "1/2/y h:s",
placeholder: "dd/mm/yyyy hh:mm",
alias: "dd/mm/yyyy",
regex: {
hrspre: new RegExp("[012]"),
hrs24: new RegExp("2[0-4]|1[3-9]"),
hrs: new RegExp("[01][0-9]|2[0-4]"),
ampm: new RegExp("^[a|p|A|P][m|M]"),
mspre: new RegExp("[0-5]"),
ms: new RegExp("[0-5][0-9]")
},
timeseparator: ":",
hourFormat: "24",
definitions: {
h: {
validator: function(chrs, maskset, pos, strict, opts) {
if ("24" === opts.hourFormat && 24 === parseInt(chrs, 10)) return maskset.buffer[pos - 1] = "0",
maskset.buffer[pos] = "0", {
refreshFromBuffer: {
start: pos - 1,
end: pos
},
c: "0"
};
var isValid = opts.regex.hrs.test(chrs);
if (!strict && !isValid && (chrs.charAt(1) === opts.timeseparator || -1 !== "-.:".indexOf(chrs.charAt(1))) && (isValid = opts.regex.hrs.test("0" + chrs.charAt(0)))) return maskset.buffer[pos - 1] = "0",
maskset.buffer[pos] = chrs.charAt(0), pos++, {
refreshFromBuffer: {
start: pos - 2,
end: pos
},
pos: pos,
c: opts.timeseparator
};
if (isValid && "24" !== opts.hourFormat && opts.regex.hrs24.test(chrs)) {
var tmp = parseInt(chrs, 10);
return 24 === tmp ? (maskset.buffer[pos + 5] = "a", maskset.buffer[pos + 6] = "m") : (maskset.buffer[pos + 5] = "p",
maskset.buffer[pos + 6] = "m"), (tmp -= 12) < 10 ? (maskset.buffer[pos] = tmp.toString(),
maskset.buffer[pos - 1] = "0") : (maskset.buffer[pos] = tmp.toString().charAt(1),
maskset.buffer[pos - 1] = tmp.toString().charAt(0)), {
refreshFromBuffer: {
start: pos - 1,
end: pos + 6
},
c: maskset.buffer[pos]
};
}
return isValid;
},
cardinality: 2,
prevalidator: [ {
validator: function(chrs, maskset, pos, strict, opts) {
var isValid = opts.regex.hrspre.test(chrs);
return strict || isValid || !(isValid = opts.regex.hrs.test("0" + chrs)) ? isValid : (maskset.buffer[pos] = "0",
pos++, {
pos: pos
});
},
cardinality: 1
} ]
},
s: {
validator: "[0-5][0-9]",
cardinality: 2,
prevalidator: [ {
validator: function(chrs, maskset, pos, strict, opts) {
var isValid = opts.regex.mspre.test(chrs);
return strict || isValid || !(isValid = opts.regex.ms.test("0" + chrs)) ? isValid : (maskset.buffer[pos] = "0",
pos++, {
pos: pos
});
},
cardinality: 1
} ]
},
t: {
validator: function(chrs, maskset, pos, strict, opts) {
return opts.regex.ampm.test(chrs + "m");
},
casing: "lower",
cardinality: 1
}
},
insertMode: !1,
autoUnmask: !1
},
datetime12: {
mask: "1/2/y h:s t\\m",
placeholder: "dd/mm/yyyy hh:mm xm",
alias: "datetime",
hourFormat: "12"
},
"mm/dd/yyyy hh:mm xm": {
mask: "1/2/y h:s t\\m",
placeholder: "mm/dd/yyyy hh:mm xm",
alias: "datetime12",
regex: {
val2pre: function(separator) {
var escapedSeparator = Inputmask.escapeRegex.call(this, separator);
return new RegExp("((0[13-9]|1[012])" + escapedSeparator + "[0-3])|(02" + escapedSeparator + "[0-2])");
},
val2: function(separator) {
var escapedSeparator = Inputmask.escapeRegex.call(this, separator);
return new RegExp("((0[1-9]|1[012])" + escapedSeparator + "(0[1-9]|[12][0-9]))|((0[13-9]|1[012])" + escapedSeparator + "30)|((0[13578]|1[02])" + escapedSeparator + "31)");
},
val1pre: new RegExp("[01]"),
val1: new RegExp("0[1-9]|1[012]")
},
leapday: "02/29/",
onKeyDown: function(e, buffer, caretPos, opts) {
var $input = $(this);
if (e.ctrlKey && e.keyCode === Inputmask.keyCode.RIGHT) {
var today = new Date();
$input.val((today.getMonth() + 1).toString() + today.getDate().toString() + today.getFullYear().toString()),
$input.trigger("setvalue");
}
}
},
"hh:mm t": {
mask: "h:s t\\m",
placeholder: "hh:mm xm",
alias: "datetime",
hourFormat: "12"
},
"h:s t": {
mask: "h:s t\\m",
placeholder: "hh:mm xm",
alias: "datetime",
hourFormat: "12"
},
"hh:mm:ss": {
mask: "h:s:s",
placeholder: "hh:mm:ss",
alias: "datetime",
autoUnmask: !1
},
"hh:mm": {
mask: "h:s",
placeholder: "hh:mm",
alias: "datetime",
autoUnmask: !1
},
date: {
alias: "dd/mm/yyyy"
},
"mm/yyyy": {
mask: "1/y",
placeholder: "mm/yyyy",
leapday: "donotuse",
separator: "/",
alias: "mm/dd/yyyy"
},
shamsi: {
regex: {
val2pre: function(separator) {
var escapedSeparator = Inputmask.escapeRegex.call(this, separator);
return new RegExp("((0[1-9]|1[012])" + escapedSeparator + "[0-3])");
},
val2: function(separator) {
var escapedSeparator = Inputmask.escapeRegex.call(this, separator);
return new RegExp("((0[1-9]|1[012])" + escapedSeparator + "(0[1-9]|[12][0-9]))|((0[1-9]|1[012])" + escapedSeparator + "30)|((0[1-6])" + escapedSeparator + "31)");
},
val1pre: new RegExp("[01]"),
val1: new RegExp("0[1-9]|1[012]")
},
yearrange: {
minyear: 1300,
maxyear: 1499
},
mask: "y/1/2",
leapday: "/12/30",
placeholder: "yyyy/mm/dd",
alias: "mm/dd/yyyy",
clearIncomplete: !0
},
"yyyy-mm-dd hh:mm:ss": {
mask: "y-1-2 h:s:s",
placeholder: "yyyy-mm-dd hh:mm:ss",
alias: "datetime",
separator: "-",
leapday: "-02-29",
regex: {
val2pre: function(separator) {
var escapedSeparator = Inputmask.escapeRegex.call(this, separator);
return new RegExp("((0[13-9]|1[012])" + escapedSeparator + "[0-3])|(02" + escapedSeparator + "[0-2])");
},
val2: function(separator) {
var escapedSeparator = Inputmask.escapeRegex.call(this, separator);
return new RegExp("((0[1-9]|1[012])" + escapedSeparator + "(0[1-9]|[12][0-9]))|((0[13-9]|1[012])" + escapedSeparator + "30)|((0[13578]|1[02])" + escapedSeparator + "31)");
},
val1pre: new RegExp("[01]"),
val1: new RegExp("0[1-9]|1[012]")
},
onKeyDown: function(e, buffer, caretPos, opts) {}
}
}), Inputmask;
});
!function(factory) {
"function" == typeof define && define.amd ? define([ "./dependencyLibs/inputmask.dependencyLib", "./inputmask" ], factory) : "object" == typeof exports ? module.exports = factory(require("./dependencyLibs/inputmask.dependencyLib"), require("./inputmask")) : factory(window.dependencyLib || jQuery, window.Inputmask);
}(function($, Inputmask, undefined) {
function autoEscape(txt, opts) {
for (var escapedTxt = "", i = 0; i < txt.length; i++) Inputmask.prototype.definitions[txt.charAt(i)] || opts.definitions[txt.charAt(i)] || opts.optionalmarker.start === txt.charAt(i) || opts.optionalmarker.end === txt.charAt(i) || opts.quantifiermarker.start === txt.charAt(i) || opts.quantifiermarker.end === txt.charAt(i) || opts.groupmarker.start === txt.charAt(i) || opts.groupmarker.end === txt.charAt(i) || opts.alternatormarker === txt.charAt(i) ? escapedTxt += "\\" + txt.charAt(i) : escapedTxt += txt.charAt(i);
return escapedTxt;
}
return Inputmask.extendAliases({
numeric: {
mask: function(opts) {
if (0 !== opts.repeat && isNaN(opts.integerDigits) && (opts.integerDigits = opts.repeat),
opts.repeat = 0, opts.groupSeparator === opts.radixPoint && ("." === opts.radixPoint ? opts.groupSeparator = "," : "," === opts.radixPoint ? opts.groupSeparator = "." : opts.groupSeparator = ""),
" " === opts.groupSeparator && (opts.skipOptionalPartCharacter = undefined), opts.autoGroup = opts.autoGroup && "" !== opts.groupSeparator,
opts.autoGroup && ("string" == typeof opts.groupSize && isFinite(opts.groupSize) && (opts.groupSize = parseInt(opts.groupSize)),
isFinite(opts.integerDigits))) {
var seps = Math.floor(opts.integerDigits / opts.groupSize), mod = opts.integerDigits % opts.groupSize;
opts.integerDigits = parseInt(opts.integerDigits) + (0 === mod ? seps - 1 : seps),
opts.integerDigits < 1 && (opts.integerDigits = "*");
}
opts.placeholder.length > 1 && (opts.placeholder = opts.placeholder.charAt(0)),
"radixFocus" === opts.positionCaretOnClick && "" === opts.placeholder && !1 === opts.integerOptional && (opts.positionCaretOnClick = "lvp"),
opts.definitions[";"] = opts.definitions["~"], opts.definitions[";"].definitionSymbol = "~",
!0 === opts.numericInput && (opts.positionCaretOnClick = "radixFocus" === opts.positionCaretOnClick ? "lvp" : opts.positionCaretOnClick,
opts.digitsOptional = !1, isNaN(opts.digits) && (opts.digits = 2), opts.decimalProtect = !1);
var mask = "[+]";
if (mask += autoEscape(opts.prefix, opts), !0 === opts.integerOptional ? mask += "~{1," + opts.integerDigits + "}" : mask += "~{" + opts.integerDigits + "}",
opts.digits !== undefined) {
opts.radixPointDefinitionSymbol = opts.decimalProtect ? ":" : opts.radixPoint;
var dq = opts.digits.toString().split(",");
isFinite(dq[0] && dq[1] && isFinite(dq[1])) ? mask += opts.radixPointDefinitionSymbol + ";{" + opts.digits + "}" : (isNaN(opts.digits) || parseInt(opts.digits) > 0) && (opts.digitsOptional ? mask += "[" + opts.radixPointDefinitionSymbol + ";{1," + opts.digits + "}]" : mask += opts.radixPointDefinitionSymbol + ";{" + opts.digits + "}");
}
return mask += autoEscape(opts.suffix, opts), mask += "[-]", opts.greedy = !1, mask;
},
placeholder: "",
greedy: !1,
digits: "*",
digitsOptional: !0,
enforceDigitsOnBlur: !1,
radixPoint: ".",
positionCaretOnClick: "radixFocus",
groupSize: 3,
groupSeparator: "",
autoGroup: !1,
allowMinus: !0,
negationSymbol: {
front: "-",
back: ""
},
integerDigits: "+",
integerOptional: !0,
prefix: "",
suffix: "",
rightAlign: !0,
decimalProtect: !0,
min: null,
max: null,
step: 1,
insertMode: !0,
autoUnmask: !1,
unmaskAsNumber: !1,
inputmode: "numeric",
preValidation: function(buffer, pos, c, isSelection, opts) {
if ("-" === c || c === opts.negationSymbol.front) return !0 === opts.allowMinus && (opts.isNegative = opts.isNegative === undefined || !opts.isNegative,
"" === buffer.join("") || {
caret: pos,
dopost: !0
});
if (!1 === isSelection && c === opts.radixPoint && opts.digits !== undefined && (isNaN(opts.digits) || parseInt(opts.digits) > 0)) {
var radixPos = $.inArray(opts.radixPoint, buffer);
if (-1 !== radixPos) return !0 === opts.numericInput ? pos === radixPos : {
caret: radixPos + 1
};
}
return !0;
},
postValidation: function(buffer, currentResult, opts) {
var suffix = opts.suffix.split(""), prefix = opts.prefix.split("");
if (currentResult.pos === undefined && currentResult.caret !== undefined && !0 !== currentResult.dopost) return currentResult;
var caretPos = currentResult.caret !== undefined ? currentResult.caret : currentResult.pos, maskedValue = buffer.slice();
opts.numericInput && (caretPos = maskedValue.length - caretPos - 1, maskedValue = maskedValue.reverse());
var charAtPos = maskedValue[caretPos];
if (charAtPos === opts.groupSeparator && (charAtPos = maskedValue[caretPos += 1]),
caretPos === maskedValue.length - opts.suffix.length - 1 && charAtPos === opts.radixPoint) return currentResult;
charAtPos !== undefined && charAtPos !== opts.radixPoint && charAtPos !== opts.negationSymbol.front && charAtPos !== opts.negationSymbol.back && (maskedValue[caretPos] = "?",
opts.prefix.length > 0 && caretPos >= (!1 === opts.isNegative ? 1 : 0) && caretPos < opts.prefix.length - 1 + (!1 === opts.isNegative ? 1 : 0) ? prefix[caretPos - (!1 === opts.isNegative ? 1 : 0)] = "?" : opts.suffix.length > 0 && caretPos >= maskedValue.length - opts.suffix.length - (!1 === opts.isNegative ? 1 : 0) && (suffix[caretPos - (maskedValue.length - opts.suffix.length - (!1 === opts.isNegative ? 1 : 0))] = "?")),
prefix = prefix.join(""), suffix = suffix.join("");
var processValue = maskedValue.join("").replace(prefix, "");
if (processValue = processValue.replace(suffix, ""), processValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), "g"), ""),
processValue = processValue.replace(new RegExp("[-" + Inputmask.escapeRegex(opts.negationSymbol.front) + "]", "g"), ""),
processValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.negationSymbol.back) + "$"), ""),
isNaN(opts.placeholder) && (processValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.placeholder), "g"), "")),
processValue.length > 1 && 1 !== processValue.indexOf(opts.radixPoint) && ("0" === charAtPos && (processValue = processValue.replace(/^\?/g, "")),
processValue = processValue.replace(/^0/g, "")), processValue.charAt(0) === opts.radixPoint && "" !== opts.radixPoint && !0 !== opts.numericInput && (processValue = "0" + processValue),
"" !== processValue) {
if (processValue = processValue.split(""), (!opts.digitsOptional || opts.enforceDigitsOnBlur && "blur" === currentResult.event) && isFinite(opts.digits)) {
var radixPosition = $.inArray(opts.radixPoint, processValue), rpb = $.inArray(opts.radixPoint, maskedValue);
-1 === radixPosition && (processValue.push(opts.radixPoint), radixPosition = processValue.length - 1);
for (var i = 1; i <= opts.digits; i++) opts.digitsOptional && (!opts.enforceDigitsOnBlur || "blur" !== currentResult.event) || processValue[radixPosition + i] !== undefined && processValue[radixPosition + i] !== opts.placeholder.charAt(0) ? -1 !== rpb && maskedValue[rpb + i] !== undefined && (processValue[radixPosition + i] = processValue[radixPosition + i] || maskedValue[rpb + i]) : processValue[radixPosition + i] = currentResult.placeholder || opts.placeholder.charAt(0);
}
if (!0 !== opts.autoGroup || "" === opts.groupSeparator || charAtPos === opts.radixPoint && currentResult.pos === undefined && !currentResult.dopost) processValue = processValue.join(""); else {
var addRadix = processValue[processValue.length - 1] === opts.radixPoint && currentResult.c === opts.radixPoint;
processValue = Inputmask(function(buffer, opts) {
var postMask = "";
if (postMask += "(" + opts.groupSeparator + "*{" + opts.groupSize + "}){*}", "" !== opts.radixPoint) {
var radixSplit = buffer.join("").split(opts.radixPoint);
radixSplit[1] && (postMask += opts.radixPoint + "*{" + radixSplit[1].match(/^\d*\??\d*/)[0].length + "}");
}
return postMask;
}(processValue, opts), {
numericInput: !0,
jitMasking: !0,
definitions: {
"*": {
validator: "[0-9?]",
cardinality: 1
}
}
}).format(processValue.join("")), addRadix && (processValue += opts.radixPoint),
processValue.charAt(0) === opts.groupSeparator && processValue.substr(1);
}
}
if (opts.isNegative && "blur" === currentResult.event && (opts.isNegative = "0" !== processValue),
processValue = prefix + processValue, processValue += suffix, opts.isNegative && (processValue = opts.negationSymbol.front + processValue,
processValue += opts.negationSymbol.back), processValue = processValue.split(""),
charAtPos !== undefined) if (charAtPos !== opts.radixPoint && charAtPos !== opts.negationSymbol.front && charAtPos !== opts.negationSymbol.back) (caretPos = $.inArray("?", processValue)) > -1 ? processValue[caretPos] = charAtPos : caretPos = currentResult.caret || 0; else if (charAtPos === opts.radixPoint || charAtPos === opts.negationSymbol.front || charAtPos === opts.negationSymbol.back) {
var newCaretPos = $.inArray(charAtPos, processValue);
-1 !== newCaretPos && (caretPos = newCaretPos);
}
opts.numericInput && (caretPos = processValue.length - caretPos - 1, processValue = processValue.reverse());
var rslt = {
caret: charAtPos === undefined || currentResult.pos !== undefined ? caretPos + (opts.numericInput ? -1 : 1) : caretPos,
buffer: processValue,
refreshFromBuffer: currentResult.dopost || buffer.join("") !== processValue.join("")
};
return rslt.refreshFromBuffer ? rslt : currentResult;
},
onBeforeWrite: function(e, buffer, caretPos, opts) {
if (e) switch (e.type) {
case "keydown":
return opts.postValidation(buffer, {
caret: caretPos,
dopost: !0
}, opts);
case "blur":
case "checkval":
var unmasked;
if (function(opts) {
opts.parseMinMaxOptions === undefined && (null !== opts.min && (opts.min = opts.min.toString().replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), "g"), ""),
"," === opts.radixPoint && (opts.min = opts.min.replace(opts.radixPoint, ".")),
opts.min = isFinite(opts.min) ? parseFloat(opts.min) : NaN, isNaN(opts.min) && (opts.min = Number.MIN_VALUE)),
null !== opts.max && (opts.max = opts.max.toString().replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), "g"), ""),
"," === opts.radixPoint && (opts.max = opts.max.replace(opts.radixPoint, ".")),
opts.max = isFinite(opts.max) ? parseFloat(opts.max) : NaN, isNaN(opts.max) && (opts.max = Number.MAX_VALUE)),
opts.parseMinMaxOptions = "done");
}(opts), null !== opts.min || null !== opts.max) {
if (unmasked = opts.onUnMask(buffer.join(""), undefined, $.extend({}, opts, {
unmaskAsNumber: !0
})), null !== opts.min && unmasked < opts.min) return opts.isNegative = opts.min < 0,
opts.postValidation(opts.min.toString().replace(".", opts.radixPoint).split(""), {
caret: caretPos,
dopost: !0,
placeholder: "0"
}, opts);
if (null !== opts.max && unmasked > opts.max) return opts.isNegative = opts.max < 0,
opts.postValidation(opts.max.toString().replace(".", opts.radixPoint).split(""), {
caret: caretPos,
dopost: !0,
placeholder: "0"
}, opts);
}
return opts.postValidation(buffer, {
caret: caretPos,
placeholder: "0",
event: "blur"
}, opts);
case "_checkval":
return {
caret: caretPos
};
}
},
regex: {
integerPart: function(opts, emptyCheck) {
return emptyCheck ? new RegExp("[" + Inputmask.escapeRegex(opts.negationSymbol.front) + "+]?") : new RegExp("[" + Inputmask.escapeRegex(opts.negationSymbol.front) + "+]?\\d+");
},
integerNPart: function(opts) {
return new RegExp("[\\d" + Inputmask.escapeRegex(opts.groupSeparator) + Inputmask.escapeRegex(opts.placeholder.charAt(0)) + "]+");
}
},
definitions: {
"~": {
validator: function(chrs, maskset, pos, strict, opts, isSelection) {
var isValid = strict ? new RegExp("[0-9" + Inputmask.escapeRegex(opts.groupSeparator) + "]").test(chrs) : new RegExp("[0-9]").test(chrs);
if (!0 === isValid) {
if (!0 !== opts.numericInput && maskset.validPositions[pos] !== undefined && "~" === maskset.validPositions[pos].match.def && !isSelection) {
var processValue = maskset.buffer.join(""), pvRadixSplit = (processValue = (processValue = processValue.replace(new RegExp("[-" + Inputmask.escapeRegex(opts.negationSymbol.front) + "]", "g"), "")).replace(new RegExp(Inputmask.escapeRegex(opts.negationSymbol.back) + "$"), "")).split(opts.radixPoint);
pvRadixSplit.length > 1 && (pvRadixSplit[1] = pvRadixSplit[1].replace(/0/g, opts.placeholder.charAt(0))),
"0" === pvRadixSplit[0] && (pvRadixSplit[0] = pvRadixSplit[0].replace(/0/g, opts.placeholder.charAt(0))),
processValue = pvRadixSplit[0] + opts.radixPoint + pvRadixSplit[1] || "";
var bufferTemplate = maskset._buffer.join("");
for (processValue === opts.radixPoint && (processValue = bufferTemplate); null === processValue.match(Inputmask.escapeRegex(bufferTemplate) + "$"); ) bufferTemplate = bufferTemplate.slice(1);
isValid = (processValue = (processValue = processValue.replace(bufferTemplate, "")).split(""))[pos] === undefined ? {
pos: pos,
remove: pos
} : {
pos: pos
};
}
} else strict || chrs !== opts.radixPoint || maskset.validPositions[pos - 1] !== undefined || (maskset.buffer[pos] = "0",
isValid = {
pos: pos + 1
});
return isValid;
},
cardinality: 1
},
"+": {
validator: function(chrs, maskset, pos, strict, opts) {
return opts.allowMinus && ("-" === chrs || chrs === opts.negationSymbol.front);
},
cardinality: 1,
placeholder: ""
},
"-": {
validator: function(chrs, maskset, pos, strict, opts) {
return opts.allowMinus && chrs === opts.negationSymbol.back;
},
cardinality: 1,
placeholder: ""
},
":": {
validator: function(chrs, maskset, pos, strict, opts) {
var radix = "[" + Inputmask.escapeRegex(opts.radixPoint) + "]", isValid = new RegExp(radix).test(chrs);
return isValid && maskset.validPositions[pos] && maskset.validPositions[pos].match.placeholder === opts.radixPoint && (isValid = {
caret: pos + 1
}), isValid;
},
cardinality: 1,
placeholder: function(opts) {
return opts.radixPoint;
}
}
},
onUnMask: function(maskedValue, unmaskedValue, opts) {
if ("" === unmaskedValue && !0 === opts.nullable) return unmaskedValue;
var processValue = maskedValue.replace(opts.prefix, "");
return processValue = processValue.replace(opts.suffix, ""), processValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), "g"), ""),
"" !== opts.placeholder.charAt(0) && (processValue = processValue.replace(new RegExp(opts.placeholder.charAt(0), "g"), "0")),
opts.unmaskAsNumber ? ("" !== opts.radixPoint && -1 !== processValue.indexOf(opts.radixPoint) && (processValue = processValue.replace(Inputmask.escapeRegex.call(this, opts.radixPoint), ".")),
processValue = processValue.replace(new RegExp("^" + Inputmask.escapeRegex(opts.negationSymbol.front)), "-"),
processValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.negationSymbol.back) + "$"), ""),
Number(processValue)) : processValue;
},
isComplete: function(buffer, opts) {
var maskedValue = buffer.join("");
if (buffer.slice().join("") !== maskedValue) return !1;
var processValue = maskedValue.replace(opts.prefix, "");
return processValue = processValue.replace(opts.suffix, ""), processValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), "g"), ""),
"," === opts.radixPoint && (processValue = processValue.replace(Inputmask.escapeRegex(opts.radixPoint), ".")),
isFinite(processValue);
},
onBeforeMask: function(initialValue, opts) {
if (opts.isNegative = undefined, initialValue = initialValue.toString().charAt(initialValue.length - 1) === opts.radixPoint ? initialValue.toString().substr(0, initialValue.length - 1) : initialValue.toString(),
"" !== opts.radixPoint && isFinite(initialValue)) {
var vs = initialValue.split("."), groupSize = "" !== opts.groupSeparator ? parseInt(opts.groupSize) : 0;
2 === vs.length && (vs[0].length > groupSize || vs[1].length > groupSize || vs[0].length <= groupSize && vs[1].length < groupSize) && (initialValue = initialValue.replace(".", opts.radixPoint));
}
var kommaMatches = initialValue.match(/,/g), dotMatches = initialValue.match(/\./g);
if (initialValue = dotMatches && kommaMatches ? dotMatches.length > kommaMatches.length ? (initialValue = initialValue.replace(/\./g, "")).replace(",", opts.radixPoint) : kommaMatches.length > dotMatches.length ? (initialValue = initialValue.replace(/,/g, "")).replace(".", opts.radixPoint) : initialValue.indexOf(".") < initialValue.indexOf(",") ? initialValue.replace(/\./g, "") : initialValue.replace(/,/g, "") : initialValue.replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), "g"), ""),
0 === opts.digits && (-1 !== initialValue.indexOf(".") ? initialValue = initialValue.substring(0, initialValue.indexOf(".")) : -1 !== initialValue.indexOf(",") && (initialValue = initialValue.substring(0, initialValue.indexOf(",")))),
"" !== opts.radixPoint && isFinite(opts.digits) && -1 !== initialValue.indexOf(opts.radixPoint)) {
var decPart = initialValue.split(opts.radixPoint)[1].match(new RegExp("\\d*"))[0];
if (parseInt(opts.digits) < decPart.toString().length) {
var digitsFactor = Math.pow(10, parseInt(opts.digits));
initialValue = initialValue.replace(Inputmask.escapeRegex(opts.radixPoint), "."),
initialValue = (initialValue = Math.round(parseFloat(initialValue) * digitsFactor) / digitsFactor).toString().replace(".", opts.radixPoint);
}
}
return initialValue;
},
canClearPosition: function(maskset, position, lvp, strict, opts) {
var vp = maskset.validPositions[position], canClear = vp.input !== opts.radixPoint || null !== maskset.validPositions[position].match.fn && !1 === opts.decimalProtect || vp.input === opts.radixPoint && maskset.validPositions[position + 1] && null === maskset.validPositions[position + 1].match.fn || isFinite(vp.input) || position === lvp || vp.input === opts.groupSeparator || vp.input === opts.negationSymbol.front || vp.input === opts.negationSymbol.back;
return !canClear || "+" !== vp.match.nativeDef && "-" !== vp.match.nativeDef || (opts.isNegative = !1),
canClear;
},
onKeyDown: function(e, buffer, caretPos, opts) {
var $input = $(this);
if (e.ctrlKey) switch (e.keyCode) {
case Inputmask.keyCode.UP:
$input.val(parseFloat(this.inputmask.unmaskedvalue()) + parseInt(opts.step)), $input.trigger("setvalue");
break;
case Inputmask.keyCode.DOWN:
$input.val(parseFloat(this.inputmask.unmaskedvalue()) - parseInt(opts.step)), $input.trigger("setvalue");
}
}
},
currency: {
prefix: "$ ",
groupSeparator: ",",
alias: "numeric",
placeholder: "0",
autoGroup: !0,
digits: 2,
digitsOptional: !1,
clearMaskOnLostFocus: !1
},
decimal: {
alias: "numeric"
},
integer: {
alias: "numeric",
digits: 0,
radixPoint: ""
},
percentage: {
alias: "numeric",
digits: 2,
digitsOptional: !0,
radixPoint: ".",
placeholder: "0",
autoGroup: !1,
min: 0,
max: 100,
suffix: " %",
allowMinus: !1
}
}), Inputmask;
});
!function(factory) {
"function" == typeof define && define.amd ? define([ "./dependencyLibs/inputmask.dependencyLib", "./inputmask" ], factory) : "object" == typeof exports ? module.exports = factory(require("./dependencyLibs/inputmask.dependencyLib"), require("./inputmask")) : factory(window.dependencyLib || jQuery, window.Inputmask);
}(function($, Inputmask) {
function maskSort(a, b) {
var maska = (a.mask || a).replace(/#/g, "9").replace(/\)/, "9").replace(/[+()#-]/g, ""), maskb = (b.mask || b).replace(/#/g, "9").replace(/\)/, "9").replace(/[+()#-]/g, ""), maskas = (a.mask || a).split("#")[0], maskbs = (b.mask || b).split("#")[0];
return 0 === maskbs.indexOf(maskas) ? -1 : 0 === maskas.indexOf(maskbs) ? 1 : maska.localeCompare(maskb);
}
var analyseMaskBase = Inputmask.prototype.analyseMask;
return Inputmask.prototype.analyseMask = function(mask, regexMask, opts) {
function reduceVariations(masks, previousVariation, previousmaskGroup) {
previousVariation = previousVariation || "", previousmaskGroup = previousmaskGroup || maskGroups,
"" !== previousVariation && (previousmaskGroup[previousVariation] = {});
for (var variation = "", maskGroup = previousmaskGroup[previousVariation] || previousmaskGroup, i = masks.length - 1; i >= 0; i--) maskGroup[variation = (mask = masks[i].mask || masks[i]).substr(0, 1)] = maskGroup[variation] || [],
maskGroup[variation].unshift(mask.substr(1)), masks.splice(i, 1);
for (var ndx in maskGroup) maskGroup[ndx].length > 500 && reduceVariations(maskGroup[ndx].slice(), ndx, maskGroup);
}
function rebuild(maskGroup) {
var mask = "", submasks = [];
for (var ndx in maskGroup) $.isArray(maskGroup[ndx]) ? 1 === maskGroup[ndx].length ? submasks.push(ndx + maskGroup[ndx]) : submasks.push(ndx + opts.groupmarker.start + maskGroup[ndx].join(opts.groupmarker.end + opts.alternatormarker + opts.groupmarker.start) + opts.groupmarker.end) : submasks.push(ndx + rebuild(maskGroup[ndx]));
return 1 === submasks.length ? mask += submasks[0] : mask += opts.groupmarker.start + submasks.join(opts.groupmarker.end + opts.alternatormarker + opts.groupmarker.start) + opts.groupmarker.end,
mask;
}
var maskGroups = {};
return opts.phoneCodes && (opts.phoneCodes && opts.phoneCodes.length > 1e3 && (reduceVariations((mask = mask.substr(1, mask.length - 2)).split(opts.groupmarker.end + opts.alternatormarker + opts.groupmarker.start)),
mask = rebuild(maskGroups)), mask = mask.replace(/9/g, "\\9")), analyseMaskBase.call(this, mask, regexMask, opts);
}, Inputmask.extendAliases({
abstractphone: {
groupmarker: {
start: "<",
end: ">"
},
countrycode: "",
phoneCodes: [],
mask: function(opts) {
return opts.definitions = {
"#": Inputmask.prototype.definitions[9]
}, opts.phoneCodes.sort(maskSort);
},
keepStatic: !0,
onBeforeMask: function(value, opts) {
var processedValue = value.replace(/^0{1,2}/, "").replace(/[\s]/g, "");
return (processedValue.indexOf(opts.countrycode) > 1 || -1 === processedValue.indexOf(opts.countrycode)) && (processedValue = "+" + opts.countrycode + processedValue),
processedValue;
},
onUnMask: function(maskedValue, unmaskedValue, opts) {
return maskedValue.replace(/[()#-]/g, "");
},
inputmode: "tel"
}
}), Inputmask;
});
(function (factory) {
if ( typeof define === 'function' && define.amd ) {
define([], factory);
} else if ( typeof exports === 'object' ) {
module.exports = factory();
} else {
window.noUiSlider = factory();
}
}(function( ){
'use strict';
var VERSION = '10.1.0';
function isValidFormatter ( entry ) {
return typeof entry === 'object' && typeof entry.to === 'function' && typeof entry.from === 'function';
}
function removeElement ( el ) {
el.parentElement.removeChild(el);
}
function preventDefault ( e ) {
e.preventDefault();
}
function unique ( array ) {
return array.filter(function(a){
return !this[a] ? this[a] = true : false;
}, {});
}
function closest ( value, to ) {
return Math.round(value / to) * to;
}
function offset ( elem, orientation ) {
var rect = elem.getBoundingClientRect();
var doc = elem.ownerDocument;
var docElem = doc.documentElement;
var pageOffset = getPageOffset(doc);
if ( /webkit.*Chrome.*Mobile/i.test(navigator.userAgent) ) {
pageOffset.x = 0;
}
return orientation ? (rect.top + pageOffset.y - docElem.clientTop) : (rect.left + pageOffset.x - docElem.clientLeft);
}
function isNumeric ( a ) {
return typeof a === 'number' && !isNaN( a ) && isFinite( a );
}
function addClassFor ( element, className, duration ) {
if (duration > 0) {
addClass(element, className);
setTimeout(function(){
removeClass(element, className);
}, duration);
}
}
function limit ( a ) {
return Math.max(Math.min(a, 100), 0);
}
function asArray ( a ) {
return Array.isArray(a) ? a : [a];
}
function countDecimals ( numStr ) {
numStr = String(numStr);
var pieces = numStr.split(".");
return pieces.length > 1 ? pieces[1].length : 0;
}
function addClass ( el, className ) {
if ( el.classList ) {
el.classList.add(className);
} else {
el.className += ' ' + className;
}
}
function removeClass ( el, className ) {
if ( el.classList ) {
el.classList.remove(className);
} else {
el.className = el.className.replace(new RegExp('(^|\\b)' + className.split(' ').join('|') + '(\\b|$)', 'gi'), ' ');
}
}
function hasClass ( el, className ) {
return el.classList ? el.classList.contains(className) : new RegExp('\\b' + className + '\\b').test(el.className);
}
function getPageOffset ( doc ) {
var supportPageOffset = window.pageXOffset !== undefined;
var isCSS1Compat = ((doc.compatMode || "") === "CSS1Compat");
var x = supportPageOffset ? window.pageXOffset : isCSS1Compat ? doc.documentElement.scrollLeft : doc.body.scrollLeft;
var y = supportPageOffset ? window.pageYOffset : isCSS1Compat ? doc.documentElement.scrollTop : doc.body.scrollTop;
return {
x: x,
y: y
};
}
function getActions ( ) {
return window.navigator.pointerEnabled ? {
start: 'pointerdown',
move: 'pointermove',
end: 'pointerup'
} : window.navigator.msPointerEnabled ? {
start: 'MSPointerDown',
move: 'MSPointerMove',
end: 'MSPointerUp'
} : {
start: 'mousedown touchstart',
move: 'mousemove touchmove',
end: 'mouseup touchend'
};
}
function getSupportsPassive ( ) {
var supportsPassive = false;
try {
var opts = Object.defineProperty({}, 'passive', {
get: function() {
supportsPassive = true;
}
});
window.addEventListener('test', null, opts);
} catch (e) {}
return supportsPassive;
}
function getSupportsTouchActionNone ( ) {
return window.CSS && CSS.supports && CSS.supports('touch-action', 'none');
}
function subRangeRatio ( pa, pb ) {
return (100 / (pb - pa));
}
function fromPercentage ( range, value ) {
return (value * 100) / ( range[1] - range[0] );
}
function toPercentage ( range, value ) {
return fromPercentage( range, range[0] < 0 ?
value + Math.abs(range[0]) :
value - range[0] );
}
function isPercentage ( range, value ) {
return ((value * ( range[1] - range[0] )) / 100) + range[0];
}
function getJ ( value, arr ) {
var j = 1;
while ( value >= arr[j] ){
j += 1;
}
return j;
}
function toStepping ( xVal, xPct, value ) {
if ( value >= xVal.slice(-1)[0] ){
return 100;
}
var j = getJ( value, xVal ), va, vb, pa, pb;
va = xVal[j-1];
vb = xVal[j];
pa = xPct[j-1];
pb = xPct[j];
return pa + (toPercentage([va, vb], value) / subRangeRatio (pa, pb));
}
function fromStepping ( xVal, xPct, value ) {
if ( value >= 100 ){
return xVal.slice(-1)[0];
}
var j = getJ( value, xPct ), va, vb, pa, pb;
va = xVal[j-1];
vb = xVal[j];
pa = xPct[j-1];
pb = xPct[j];
return isPercentage([va, vb], (value - pa) * subRangeRatio (pa, pb));
}
function getStep ( xPct, xSteps, snap, value ) {
if ( value === 100 ) {
return value;
}
var j = getJ( value, xPct ), a, b;
if ( snap ) {
a = xPct[j-1];
b = xPct[j];
if ((value - a) > ((b-a)/2)){
return b;
}
return a;
}
if ( !xSteps[j-1] ){
return value;
}
return xPct[j-1] + closest(
value - xPct[j-1],
xSteps[j-1]
);
}
function handleEntryPoint ( index, value, that ) {
var percentage;
if ( typeof value === "number" ) {
value = [value];
}
if ( Object.prototype.toString.call( value ) !== '[object Array]' ){
throw new Error("noUiSlider (" + VERSION + "): 'range' contains invalid value.");
}
if ( index === 'min' ) {
percentage = 0;
} else if ( index === 'max' ) {
percentage = 100;
} else {
percentage = parseFloat( index );
}
if ( !isNumeric( percentage ) || !isNumeric( value[0] ) ) {
throw new Error("noUiSlider (" + VERSION + "): 'range' value isn't numeric.");
}
that.xPct.push( percentage );
that.xVal.push( value[0] );
if ( !percentage ) {
if ( !isNaN( value[1] ) ) {
that.xSteps[0] = value[1];
}
} else {
that.xSteps.push( isNaN(value[1]) ? false : value[1] );
}
that.xHighestCompleteStep.push(0);
}
function handleStepPoint ( i, n, that ) {
if ( !n ) {
return true;
}
that.xSteps[i] = fromPercentage([
that.xVal[i]
,that.xVal[i+1]
], n) / subRangeRatio (
that.xPct[i],
that.xPct[i+1] );
var totalSteps = (that.xVal[i+1] - that.xVal[i]) / that.xNumSteps[i];
var highestStep = Math.ceil(Number(totalSteps.toFixed(3)) - 1);
var step = that.xVal[i] + (that.xNumSteps[i] * highestStep);
that.xHighestCompleteStep[i] = step;
}
function Spectrum ( entry, snap, singleStep ) {
this.xPct = [];
this.xVal = [];
this.xSteps = [ singleStep || false ];
this.xNumSteps = [ false ];
this.xHighestCompleteStep = [];
this.snap = snap;
var index, ordered = [ ];
for ( index in entry ) {
if ( entry.hasOwnProperty(index) ) {
ordered.push([entry[index], index]);
}
}
if ( ordered.length && typeof ordered[0][0] === "object" ) {
ordered.sort(function(a, b) { return a[0][0] - b[0][0]; });
} else {
ordered.sort(function(a, b) { return a[0] - b[0]; });
}
for ( index = 0; index < ordered.length; index++ ) {
handleEntryPoint(ordered[index][1], ordered[index][0], this);
}
this.xNumSteps = this.xSteps.slice(0);
for ( index = 0; index < this.xNumSteps.length; index++ ) {
handleStepPoint(index, this.xNumSteps[index], this);
}
}
Spectrum.prototype.getMargin = function ( value ) {
var step = this.xNumSteps[0];
if ( step && ((value / step) % 1) !== 0 ) {
throw new Error("noUiSlider (" + VERSION + "): 'limit', 'margin' and 'padding' must be divisible by step.");
}
return this.xPct.length === 2 ? fromPercentage(this.xVal, value) : false;
};
Spectrum.prototype.toStepping = function ( value ) {
value = toStepping( this.xVal, this.xPct, value );
return value;
};
Spectrum.prototype.fromStepping = function ( value ) {
return fromStepping( this.xVal, this.xPct, value );
};
Spectrum.prototype.getStep = function ( value ) {
value = getStep(this.xPct, this.xSteps, this.snap, value );
return value;
};
Spectrum.prototype.getNearbySteps = function ( value ) {
var j = getJ(value, this.xPct);
return {
stepBefore: { startValue: this.xVal[j-2], step: this.xNumSteps[j-2], highestStep: this.xHighestCompleteStep[j-2] },
thisStep: { startValue: this.xVal[j-1], step: this.xNumSteps[j-1], highestStep: this.xHighestCompleteStep[j-1] },
stepAfter: { startValue: this.xVal[j-0], step: this.xNumSteps[j-0], highestStep: this.xHighestCompleteStep[j-0] }
};
};
Spectrum.prototype.countStepDecimals = function () {
var stepDecimals = this.xNumSteps.map(countDecimals);
return Math.max.apply(null, stepDecimals);
};
Spectrum.prototype.convert = function ( value ) {
return this.getStep(this.toStepping(value));
};
var defaultFormatter = { 'to': function( value ){
return value !== undefined && value.toFixed(2);
}, 'from': Number };
function validateFormat ( entry ) {
if ( isValidFormatter(entry) ) {
return true;
}
throw new Error("noUiSlider (" + VERSION + "): 'format' requires 'to' and 'from' methods.");
}
function testStep ( parsed, entry ) {
if ( !isNumeric( entry ) ) {
throw new Error("noUiSlider (" + VERSION + "): 'step' is not numeric.");
}
parsed.singleStep = entry;
}
function testRange ( parsed, entry ) {
if ( typeof entry !== 'object' || Array.isArray(entry) ) {
throw new Error("noUiSlider (" + VERSION + "): 'range' is not an object.");
}
if ( entry.min === undefined || entry.max === undefined ) {
throw new Error("noUiSlider (" + VERSION + "): Missing 'min' or 'max' in 'range'.");
}
if ( entry.min === entry.max ) {
throw new Error("noUiSlider (" + VERSION + "): 'range' 'min' and 'max' cannot be equal.");
}
parsed.spectrum = new Spectrum(entry, parsed.snap, parsed.singleStep);
}
function testStart ( parsed, entry ) {
entry = asArray(entry);
if ( !Array.isArray( entry ) || !entry.length ) {
throw new Error("noUiSlider (" + VERSION + "): 'start' option is incorrect.");
}
parsed.handles = entry.length;
parsed.start = entry;
}
function testSnap ( parsed, entry ) {
parsed.snap = entry;
if ( typeof entry !== 'boolean' ){
throw new Error("noUiSlider (" + VERSION + "): 'snap' option must be a boolean.");
}
}
function testAnimate ( parsed, entry ) {
parsed.animate = entry;
if ( typeof entry !== 'boolean' ){
throw new Error("noUiSlider (" + VERSION + "): 'animate' option must be a boolean.");
}
}
function testAnimationDuration ( parsed, entry ) {
parsed.animationDuration = entry;
if ( typeof entry !== 'number' ){
throw new Error("noUiSlider (" + VERSION + "): 'animationDuration' option must be a number.");
}
}
function testConnect ( parsed, entry ) {
var connect = [false];
var i;
if ( entry === 'lower' ) {
entry = [true, false];
}
else if ( entry === 'upper' ) {
entry = [false, true];
}
if ( entry === true || entry === false ) {
for ( i = 1; i < parsed.handles; i++ ) {
connect.push(entry);
}
connect.push(false);
}
else if ( !Array.isArray( entry ) || !entry.length || entry.length !== parsed.handles + 1 ) {
throw new Error("noUiSlider (" + VERSION + "): 'connect' option doesn't match handle count.");
}
else {
connect = entry;
}
parsed.connect = connect;
}
function testOrientation ( parsed, entry ) {
switch ( entry ){
case 'horizontal':
parsed.ort = 0;
break;
case 'vertical':
parsed.ort = 1;
break;
default:
throw new Error("noUiSlider (" + VERSION + "): 'orientation' option is invalid.");
}
}
function testMargin ( parsed, entry ) {
if ( !isNumeric(entry) ){
throw new Error("noUiSlider (" + VERSION + "): 'margin' option must be numeric.");
}
if ( entry === 0 ) {
return;
}
parsed.margin = parsed.spectrum.getMargin(entry);
if ( !parsed.margin ) {
throw new Error("noUiSlider (" + VERSION + "): 'margin' option is only supported on linear sliders.");
}
}
function testLimit ( parsed, entry ) {
if ( !isNumeric(entry) ){
throw new Error("noUiSlider (" + VERSION + "): 'limit' option must be numeric.");
}
parsed.limit = parsed.spectrum.getMargin(entry);
if ( !parsed.limit || parsed.handles < 2 ) {
throw new Error("noUiSlider (" + VERSION + "): 'limit' option is only supported on linear sliders with 2 or more handles.");
}
}
function testPadding ( parsed, entry ) {
if ( !isNumeric(entry) ){
throw new Error("noUiSlider (" + VERSION + "): 'padding' option must be numeric.");
}
if ( entry === 0 ) {
return;
}
parsed.padding = parsed.spectrum.getMargin(entry);
if ( !parsed.padding ) {
throw new Error("noUiSlider (" + VERSION + "): 'padding' option is only supported on linear sliders.");
}
if ( parsed.padding < 0 ) {
throw new Error("noUiSlider (" + VERSION + "): 'padding' option must be a positive number.");
}
if ( parsed.padding >= 50 ) {
throw new Error("noUiSlider (" + VERSION + "): 'padding' option must be less than half the range.");
}
}
function testDirection ( parsed, entry ) {
switch ( entry ) {
case 'ltr':
parsed.dir = 0;
break;
case 'rtl':
parsed.dir = 1;
break;
default:
throw new Error("noUiSlider (" + VERSION + "): 'direction' option was not recognized.");
}
}
function testBehaviour ( parsed, entry ) {
if ( typeof entry !== 'string' ) {
throw new Error("noUiSlider (" + VERSION + "): 'behaviour' must be a string containing options.");
}
var tap = entry.indexOf('tap') >= 0;
var drag = entry.indexOf('drag') >= 0;
var fixed = entry.indexOf('fixed') >= 0;
var snap = entry.indexOf('snap') >= 0;
var hover = entry.indexOf('hover') >= 0;
if ( fixed ) {
if ( parsed.handles !== 2 ) {
throw new Error("noUiSlider (" + VERSION + "): 'fixed' behaviour must be used with 2 handles");
}
testMargin(parsed, parsed.start[1] - parsed.start[0]);
}
parsed.events = {
tap: tap || snap,
drag: drag,
fixed: fixed,
snap: snap,
hover: hover
};
}
function testMultitouch ( parsed, entry ) {
parsed.multitouch = entry;
if ( typeof entry !== 'boolean' ){
throw new Error("noUiSlider (" + VERSION + "): 'multitouch' option must be a boolean.");
}
}
function testTooltips ( parsed, entry ) {
if ( entry === false ) {
return;
}
else if ( entry === true ) {
parsed.tooltips = [];
for ( var i = 0; i < parsed.handles; i++ ) {
parsed.tooltips.push(true);
}
}
else {
parsed.tooltips = asArray(entry);
if ( parsed.tooltips.length !== parsed.handles ) {
throw new Error("noUiSlider (" + VERSION + "): must pass a formatter for all handles.");
}
parsed.tooltips.forEach(function(formatter){
if ( typeof formatter !== 'boolean' && (typeof formatter !== 'object' || typeof formatter.to !== 'function') ) {
throw new Error("noUiSlider (" + VERSION + "): 'tooltips' must be passed a formatter or 'false'.");
}
});
}
}
function testAriaFormat ( parsed, entry ) {
parsed.ariaFormat = entry;
validateFormat(entry);
}
function testFormat ( parsed, entry ) {
parsed.format = entry;
validateFormat(entry);
}
function testCssPrefix ( parsed, entry ) {
if ( entry !== undefined && typeof entry !== 'string' && entry !== false ) {
throw new Error("noUiSlider (" + VERSION + "): 'cssPrefix' must be a string or `false`.");
}
parsed.cssPrefix = entry;
}
function testCssClasses ( parsed, entry ) {
if ( entry !== undefined && typeof entry !== 'object' ) {
throw new Error("noUiSlider (" + VERSION + "): 'cssClasses' must be an object.");
}
if ( typeof parsed.cssPrefix === 'string' ) {
parsed.cssClasses = {};
for ( var key in entry ) {
if ( !entry.hasOwnProperty(key) ) { continue; }
parsed.cssClasses[key] = parsed.cssPrefix + entry[key];
}
} else {
parsed.cssClasses = entry;
}
}
function testUseRaf ( parsed, entry ) {
if ( entry === true || entry === false ) {
parsed.useRequestAnimationFrame = entry;
} else {
throw new Error("noUiSlider (" + VERSION + "): 'useRequestAnimationFrame' option should be true (default) or false.");
}
}
function testOptions ( options ) {
var parsed = {
margin: 0,
limit: 0,
padding: 0,
animate: true,
animationDuration: 300,
ariaFormat: defaultFormatter,
format: defaultFormatter
};
var tests = {
'step': { r: false, t: testStep },
'start': { r: true, t: testStart },
'connect': { r: true, t: testConnect },
'direction': { r: true, t: testDirection },
'snap': { r: false, t: testSnap },
'animate': { r: false, t: testAnimate },
'animationDuration': { r: false, t: testAnimationDuration },
'range': { r: true, t: testRange },
'orientation': { r: false, t: testOrientation },
'margin': { r: false, t: testMargin },
'limit': { r: false, t: testLimit },
'padding': { r: false, t: testPadding },
'behaviour': { r: true, t: testBehaviour },
'multitouch': { r: true, t: testMultitouch },
'ariaFormat': { r: false, t: testAriaFormat },
'format': { r: false, t: testFormat },
'tooltips': { r: false, t: testTooltips },
'cssPrefix': { r: false, t: testCssPrefix },
'cssClasses': { r: false, t: testCssClasses },
'useRequestAnimationFrame': { r: false, t: testUseRaf }
};
var defaults = {
'connect': false,
'direction': 'ltr',
'behaviour': 'tap',
'multitouch': false,
'orientation': 'horizontal',
'cssPrefix' : 'noUi-',
'cssClasses': {
target: 'target',
base: 'base',
origin: 'origin',
handle: 'handle',
handleLower: 'handle-lower',
handleUpper: 'handle-upper',
horizontal: 'horizontal',
vertical: 'vertical',
background: 'background',
connect: 'connect',
ltr: 'ltr',
rtl: 'rtl',
draggable: 'draggable',
drag: 'state-drag',
tap: 'state-tap',
active: 'active',
tooltip: 'tooltip',
pips: 'pips',
pipsHorizontal: 'pips-horizontal',
pipsVertical: 'pips-vertical',
marker: 'marker',
markerHorizontal: 'marker-horizontal',
markerVertical: 'marker-vertical',
markerNormal: 'marker-normal',
markerLarge: 'marker-large',
markerSub: 'marker-sub',
value: 'value',
valueHorizontal: 'value-horizontal',
valueVertical: 'value-vertical',
valueNormal: 'value-normal',
valueLarge: 'value-large',
valueSub: 'value-sub'
},
'useRequestAnimationFrame': true
};
if ( options.format && !options.ariaFormat ) {
options.ariaFormat = options.format;
}
Object.keys(tests).forEach(function( name ){
if ( options[name] === undefined && defaults[name] === undefined ) {
if ( tests[name].r ) {
throw new Error("noUiSlider (" + VERSION + "): '" + name + "' is required.");
}
return true;
}
tests[name].t( parsed, options[name] === undefined ? defaults[name] : options[name] );
});
parsed.pips = options.pips;
var styles = [['left', 'top'], ['right', 'bottom']];
parsed.style = styles[parsed.dir][parsed.ort];
parsed.styleOposite = styles[parsed.dir?0:1][parsed.ort];
return parsed;
}
function closure ( target, options, originalOptions ){
var actions = getActions();
var supportsTouchActionNone = getSupportsTouchActionNone();
var supportsPassive = supportsTouchActionNone && getSupportsPassive();
var scope_Target = target;
var scope_Locations = [];
var scope_Base;
var scope_Handles;
var scope_HandleNumbers = [];
var scope_ActiveHandlesCount = 0;
var scope_Connects;
var scope_Spectrum = options.spectrum;
var scope_Values = [];
var scope_Events = {};
var scope_Self;
var scope_Pips;
var scope_Document = target.ownerDocument;
var scope_DocumentElement = scope_Document.documentElement;
var scope_Body = scope_Document.body;
function addNodeTo ( target, className ) {
var div = scope_Document.createElement('div');
if ( className ) {
addClass(div, className);
}
target.appendChild(div);
return div;
}
function addOrigin ( base, handleNumber ) {
var origin = addNodeTo(base, options.cssClasses.origin);
var handle = addNodeTo(origin, options.cssClasses.handle);
handle.setAttribute('data-handle', handleNumber);
handle.setAttribute('tabindex', '0');
handle.setAttribute('role', 'slider');
handle.setAttribute('aria-orientation', options.ort ? 'vertical' : 'horizontal');
if ( handleNumber === 0 ) {
addClass(handle, options.cssClasses.handleLower);
}
else if ( handleNumber === options.handles - 1 ) {
addClass(handle, options.cssClasses.handleUpper);
}
return origin;
}
function addConnect ( base, add ) {
if ( !add ) {
return false;
}
return addNodeTo(base, options.cssClasses.connect);
}
function addElements ( connectOptions, base ) {
scope_Handles = [];
scope_Connects = [];
scope_Connects.push(addConnect(base, connectOptions[0]));
for ( var i = 0; i < options.handles; i++ ) {
scope_Handles.push(addOrigin(base, i));
scope_HandleNumbers[i] = i;
scope_Connects.push(addConnect(base, connectOptions[i + 1]));
}
}
function addSlider ( target ) {
addClass(target, options.cssClasses.target);
if ( options.dir === 0 ) {
addClass(target, options.cssClasses.ltr);
} else {
addClass(target, options.cssClasses.rtl);
}
if ( options.ort === 0 ) {
addClass(target, options.cssClasses.horizontal);
} else {
addClass(target, options.cssClasses.vertical);
}
scope_Base = addNodeTo(target, options.cssClasses.base);
}
function addTooltip ( handle, handleNumber ) {
if ( !options.tooltips[handleNumber] ) {
return false;
}
return addNodeTo(handle.firstChild, options.cssClasses.tooltip);
}
function tooltips ( ) {
var tips = scope_Handles.map(addTooltip);
bindEvent('update', function(values, handleNumber, unencoded) {
if ( !tips[handleNumber] ) {
return;
}
var formattedValue = values[handleNumber];
if ( options.tooltips[handleNumber] !== true ) {
formattedValue = options.tooltips[handleNumber].to(unencoded[handleNumber]);
}
tips[handleNumber].innerHTML = formattedValue;
});
}
function aria ( ) {
bindEvent('update', function ( values, handleNumber, unencoded, tap, positions ) {
scope_HandleNumbers.forEach(function( handleNumber ){
var handle = scope_Handles[handleNumber];
var min = checkHandlePosition(scope_Locations, handleNumber, 0, true, true, true);
var max = checkHandlePosition(scope_Locations, handleNumber, 100, true, true, true);
var now = positions[handleNumber];
var text = options.ariaFormat.to(unencoded[handleNumber]);
handle.children[0].setAttribute('aria-valuemin', min.toFixed(1));
handle.children[0].setAttribute('aria-valuemax', max.toFixed(1));
handle.children[0].setAttribute('aria-valuenow', now.toFixed(1));
handle.children[0].setAttribute('aria-valuetext', text);
});
});
}
function getGroup ( mode, values, stepped ) {
if ( mode === 'range' || mode === 'steps' ) {
return scope_Spectrum.xVal;
}
if ( mode === 'count' ) {
if ( !values ) {
throw new Error("noUiSlider (" + VERSION + "): 'values' required for mode 'count'.");
}
var spread = ( 100 / (values - 1) );
var v;
var i = 0;
values = [];
while ( (v = i++ * spread) <= 100 ) {
values.push(v);
}
mode = 'positions';
}
if ( mode === 'positions' ) {
return values.map(function( value ){
return scope_Spectrum.fromStepping( stepped ? scope_Spectrum.getStep( value ) : value );
});
}
if ( mode === 'values' ) {
if ( stepped ) {
return values.map(function( value ){
return scope_Spectrum.fromStepping( scope_Spectrum.getStep( scope_Spectrum.toStepping( value ) ) );
});
}
return values;
}
}
function generateSpread ( density, mode, group ) {
function safeIncrement(value, increment) {
return (value + increment).toFixed(7) / 1;
}
var indexes = {};
var firstInRange = scope_Spectrum.xVal[0];
var lastInRange = scope_Spectrum.xVal[scope_Spectrum.xVal.length-1];
var ignoreFirst = false;
var ignoreLast = false;
var prevPct = 0;
group = unique(group.slice().sort(function(a, b){ return a - b; }));
if ( group[0] !== firstInRange ) {
group.unshift(firstInRange);
ignoreFirst = true;
}
if ( group[group.length - 1] !== lastInRange ) {
group.push(lastInRange);
ignoreLast = true;
}
group.forEach(function ( current, index ) {
var step;
var i;
var q;
var low = current;
var high = group[index+1];
var newPct;
var pctDifference;
var pctPos;
var type;
var steps;
var realSteps;
var stepsize;
if ( mode === 'steps' ) {
step = scope_Spectrum.xNumSteps[ index ];
}
if ( !step ) {
step = high-low;
}
if ( low === false || high === undefined ) {
return;
}
step = Math.max(step, 0.0000001);
for ( i = low; i <= high; i = safeIncrement(i, step) ) {
newPct = scope_Spectrum.toStepping( i );
pctDifference = newPct - prevPct;
steps = pctDifference / density;
realSteps = Math.round(steps);
stepsize = pctDifference/realSteps;
for ( q = 1; q <= realSteps; q += 1 ) {
pctPos = prevPct + ( q * stepsize );
indexes[pctPos.toFixed(5)] = ['x', 0];
}
type = (group.indexOf(i) > -1) ? 1 : ( mode === 'steps' ? 2 : 0 );
if ( !index && ignoreFirst ) {
type = 0;
}
if ( !(i === high && ignoreLast)) {
indexes[newPct.toFixed(5)] = [i, type];
}
prevPct = newPct;
}
});
return indexes;
}
function addMarking ( spread, filterFunc, formatter ) {
var element = scope_Document.createElement('div');
var valueSizeClasses = [
options.cssClasses.valueNormal,
options.cssClasses.valueLarge,
options.cssClasses.valueSub
];
var markerSizeClasses = [
options.cssClasses.markerNormal,
options.cssClasses.markerLarge,
options.cssClasses.markerSub
];
var valueOrientationClasses = [
options.cssClasses.valueHorizontal,
options.cssClasses.valueVertical
];
var markerOrientationClasses = [
options.cssClasses.markerHorizontal,
options.cssClasses.markerVertical
];
addClass(element, options.cssClasses.pips);
addClass(element, options.ort === 0 ? options.cssClasses.pipsHorizontal : options.cssClasses.pipsVertical);
function getClasses( type, source ){
var a = source === options.cssClasses.value;
var orientationClasses = a ? valueOrientationClasses : markerOrientationClasses;
var sizeClasses = a ? valueSizeClasses : markerSizeClasses;
return source + ' ' + orientationClasses[options.ort] + ' ' + sizeClasses[type];
}
function addSpread ( offset, values ){
values[1] = (values[1] && filterFunc) ? filterFunc(values[0], values[1]) : values[1];
var node = addNodeTo(element, false);
node.className = getClasses(values[1], options.cssClasses.marker);
node.style[options.style] = offset + '%';
if ( values[1] ) {
node = addNodeTo(element, false);
node.className = getClasses(values[1], options.cssClasses.value);
node.style[options.style] = offset + '%';
node.innerText = formatter.to(values[0]);
}
}
Object.keys(spread).forEach(function(a){
addSpread(a, spread[a]);
});
return element;
}
function removePips ( ) {
if ( scope_Pips ) {
removeElement(scope_Pips);
scope_Pips = null;
}
}
function pips ( grid ) {
removePips();
var mode = grid.mode;
var density = grid.density || 1;
var filter = grid.filter || false;
var values = grid.values || false;
var stepped = grid.stepped || false;
var group = getGroup( mode, values, stepped );
var spread = generateSpread( density, mode, group );
var format = grid.format || {
to: Math.round
};
scope_Pips = scope_Target.appendChild(addMarking(
spread,
filter,
format
));
return scope_Pips;
}
function baseSize ( ) {
var rect = scope_Base.getBoundingClientRect(), alt = 'offset' + ['Width', 'Height'][options.ort];
return options.ort === 0 ? (rect.width||scope_Base[alt]) : (rect.height||scope_Base[alt]);
}
function attachEvent ( events, element, callback, data ) {
var method = function ( e ){
if ( scope_Target.hasAttribute('disabled') ) {
return false;
}
if ( hasClass(scope_Target, options.cssClasses.tap) ) {
return false;
}
e = fixEvent(e, data.pageOffset, data.target || element);
if ( !e ) {
return false;
}
if ( events === actions.start && e.buttons !== undefined && e.buttons > 1 ) {
return false;
}
if ( data.hover && e.buttons ) {
return false;
}
if ( !supportsPassive ) {
e.preventDefault();
}
e.calcPoint = e.points[ options.ort ];
callback ( e, data );
};
var methods = [];
events.split(' ').forEach(function( eventName ){
element.addEventListener(eventName, method, supportsPassive ? { passive: true } : false);
methods.push([eventName, method]);
});
return methods;
}
function fixEvent ( e, pageOffset, target ) {
var touch = e.type.indexOf('touch') === 0;
var mouse = e.type.indexOf('mouse') === 0;
var pointer = e.type.indexOf('pointer') === 0;
var x;
var y;
if ( e.type.indexOf('MSPointer') === 0 ) {
pointer = true;
}
if ( touch && options.multitouch ) {
var isTouchOnTarget = function (touch) {
return touch.target === target || target.contains(touch.target);
};
if (e.type === 'touchstart') {
var targetTouches = Array.prototype.filter.call(e.touches, isTouchOnTarget);
if ( targetTouches.length > 1 ) {
return false;
}
x = targetTouches[0].pageX;
y = targetTouches[0].pageY;
} else {
var targetTouch = Array.prototype.find.call(e.changedTouches, isTouchOnTarget);
if ( !targetTouch ) {
return false;
}
x = targetTouch.pageX;
y = targetTouch.pageY;
}
} else if ( touch ) {
if ( e.touches.length > 1 ) {
return false;
}
x = e.changedTouches[0].pageX;
y = e.changedTouches[0].pageY;
}
pageOffset = pageOffset || getPageOffset(scope_Document);
if ( mouse || pointer ) {
x = e.clientX + pageOffset.x;
y = e.clientY + pageOffset.y;
}
e.pageOffset = pageOffset;
e.points = [x, y];
e.cursor = mouse || pointer; // Fix #435
return e;
}
function calcPointToPercentage ( calcPoint ) {
var location = calcPoint - offset(scope_Base, options.ort);
var proposal = ( location * 100 ) / baseSize();
return options.dir ? 100 - proposal : proposal;
}
function getClosestHandle ( proposal ) {
var closest = 100;
var handleNumber = false;
scope_Handles.forEach(function(handle, index){
if ( handle.hasAttribute('disabled') ) {
return;
}
var pos = Math.abs(scope_Locations[index] - proposal);
if ( pos < closest ) {
handleNumber = index;
closest = pos;
}
});
return handleNumber;
}
function moveHandles ( upward, proposal, locations, handleNumbers ) {
var proposals = locations.slice();
var b = [!upward, upward];
var f = [upward, !upward];
handleNumbers = handleNumbers.slice();
if ( upward ) {
handleNumbers.reverse();
}
if ( handleNumbers.length > 1 ) {
handleNumbers.forEach(function(handleNumber, o) {
var to = checkHandlePosition(proposals, handleNumber, proposals[handleNumber] + proposal, b[o], f[o], false);
if ( to === false ) {
proposal = 0;
} else {
proposal = to - proposals[handleNumber];
proposals[handleNumber] = to;
}
});
}
else {
b = f = [true];
}
var state = false;
handleNumbers.forEach(function(handleNumber, o) {
state = setHandle(handleNumber, locations[handleNumber] + proposal, b[o], f[o]) || state;
});
if ( state ) {
handleNumbers.forEach(function(handleNumber){
fireEvent('update', handleNumber);
fireEvent('slide', handleNumber);
});
}
}
function fireEvent ( eventName, handleNumber, tap ) {
Object.keys(scope_Events).forEach(function( targetEvent ) {
var eventType = targetEvent.split('.')[0];
if ( eventName === eventType ) {
scope_Events[targetEvent].forEach(function( callback ) {
callback.call(
scope_Self,
scope_Values.map(options.format.to),
handleNumber,
scope_Values.slice(),
tap || false,
scope_Locations.slice()
);
});
}
});
}
function documentLeave ( event, data ) {
if ( event.type === "mouseout" && event.target.nodeName === "HTML" && event.relatedTarget === null ){
eventEnd (event, data);
}
}
function eventMove ( event, data ) {
if ( navigator.appVersion.indexOf("MSIE 9") === -1 && event.buttons === 0 && data.buttonsProperty !== 0 ) {
return eventEnd(event, data);
}
var movement = (options.dir ? -1 : 1) * (event.calcPoint - data.startCalcPoint);
var proposal = (movement * 100) / data.baseSize;
moveHandles(movement > 0, proposal, data.locations, data.handleNumbers);
}
function eventEnd ( event, data ) {
if ( data.handle ) {
removeClass(data.handle, options.cssClasses.active);
scope_ActiveHandlesCount -= 1;
}
data.listeners.forEach(function( c ) {
scope_DocumentElement.removeEventListener(c[0], c[1]);
});
if ( scope_ActiveHandlesCount === 0 ) {
removeClass(scope_Target, options.cssClasses.drag);
setZindex();
if ( event.cursor ) {
scope_Body.style.cursor = '';
scope_Body.removeEventListener('selectstart', preventDefault);
}
}
data.handleNumbers.forEach(function(handleNumber){
fireEvent('change', handleNumber);
fireEvent('set', handleNumber);
fireEvent('end', handleNumber);
});
}
function eventStart ( event, data ) {
var handle;
if ( data.handleNumbers.length === 1 ) {
var handleOrigin = scope_Handles[data.handleNumbers[0]];
if ( handleOrigin.hasAttribute('disabled') ) {
return false;
}
handle = handleOrigin.children[0];
scope_ActiveHandlesCount += 1;
addClass(handle, options.cssClasses.active);
}
event.stopPropagation();
var listeners = [];
var moveEvent = attachEvent(actions.move, scope_DocumentElement, eventMove, {
target: event.target,
handle: handle,
listeners: listeners,
startCalcPoint: event.calcPoint,
baseSize: baseSize(),
pageOffset: event.pageOffset,
handleNumbers: data.handleNumbers,
buttonsProperty: event.buttons,
locations: scope_Locations.slice()
});
var endEvent = attachEvent(actions.end, scope_DocumentElement, eventEnd, {
target: event.target,
handle: handle,
listeners: listeners,
handleNumbers: data.handleNumbers
});
var outEvent = attachEvent("mouseout", scope_DocumentElement, documentLeave, {
target: event.target,
handle: handle,
listeners: listeners,
handleNumbers: data.handleNumbers
});
listeners.push.apply(listeners, moveEvent.concat(endEvent, outEvent));
if ( event.cursor ) {
scope_Body.style.cursor = getComputedStyle(event.target).cursor;
if ( scope_Handles.length > 1 ) {
addClass(scope_Target, options.cssClasses.drag);
}
scope_Body.addEventListener('selectstart', preventDefault, false);
}
data.handleNumbers.forEach(function(handleNumber){
fireEvent('start', handleNumber);
});
}
function eventTap ( event ) {
event.stopPropagation();
var proposal = calcPointToPercentage(event.calcPoint);
var handleNumber = getClosestHandle(proposal);
if ( handleNumber === false ) {
return false;
}
if ( !options.events.snap ) {
addClassFor(scope_Target, options.cssClasses.tap, options.animationDuration);
}
setHandle(handleNumber, proposal, true, true);
setZindex();
fireEvent('slide', handleNumber, true);
fireEvent('update', handleNumber, true);
fireEvent('change', handleNumber, true);
fireEvent('set', handleNumber, true);
if ( options.events.snap ) {
eventStart(event, { handleNumbers: [handleNumber] });
}
}
function eventHover ( event ) {
var proposal = calcPointToPercentage(event.calcPoint);
var to = scope_Spectrum.getStep(proposal);
var value = scope_Spectrum.fromStepping(to);
Object.keys(scope_Events).forEach(function( targetEvent ) {
if ( 'hover' === targetEvent.split('.')[0] ) {
scope_Events[targetEvent].forEach(function( callback ) {
callback.call( scope_Self, value );
});
}
});
}
function bindSliderEvents ( behaviour ) {
if ( !behaviour.fixed ) {
scope_Handles.forEach(function( handle, index ){
attachEvent ( actions.start, handle.children[0], eventStart, {
handleNumbers: [index]
});
});
}
if ( behaviour.tap ) {
attachEvent (actions.start, scope_Base, eventTap, {});
}
if ( behaviour.hover ) {
attachEvent (actions.move, scope_Base, eventHover, { hover: true });
}
if ( behaviour.drag ){
scope_Connects.forEach(function( connect, index ){
if ( connect === false || index === 0 || index === scope_Connects.length - 1 ) {
return;
}
var handleBefore = scope_Handles[index - 1];
var handleAfter = scope_Handles[index];
var eventHolders = [connect];
addClass(connect, options.cssClasses.draggable);
if ( behaviour.fixed ) {
eventHolders.push(handleBefore.children[0]);
eventHolders.push(handleAfter.children[0]);
}
eventHolders.forEach(function( eventHolder ) {
attachEvent ( actions.start, eventHolder, eventStart, {
handles: [handleBefore, handleAfter],
handleNumbers: [index - 1, index]
});
});
});
}
}
function checkHandlePosition ( reference, handleNumber, to, lookBackward, lookForward, getValue ) {
if ( scope_Handles.length > 1 ) {
if ( lookBackward && handleNumber > 0 ) {
to = Math.max(to, reference[handleNumber - 1] + options.margin);
}
if ( lookForward && handleNumber < scope_Handles.length - 1 ) {
to = Math.min(to, reference[handleNumber + 1] - options.margin);
}
}
if ( scope_Handles.length > 1 && options.limit ) {
if ( lookBackward && handleNumber > 0 ) {
to = Math.min(to, reference[handleNumber - 1] + options.limit);
}
if ( lookForward && handleNumber < scope_Handles.length - 1 ) {
to = Math.max(to, reference[handleNumber + 1] - options.limit);
}
}
if ( options.padding ) {
if ( handleNumber === 0 ) {
to = Math.max(to, options.padding);
}
if ( handleNumber === scope_Handles.length - 1 ) {
to = Math.min(to, 100 - options.padding);
}
}
to = scope_Spectrum.getStep(to);
to = limit(to);
if ( to === reference[handleNumber] && !getValue ) {
return false;
}
return to;
}
function toPct ( pct ) {
return pct + '%';
}
function updateHandlePosition ( handleNumber, to ) {
scope_Locations[handleNumber] = to;
scope_Values[handleNumber] = scope_Spectrum.fromStepping(to);
var stateUpdate = function() {
scope_Handles[handleNumber].style[options.style] = toPct(to);
updateConnect(handleNumber);
updateConnect(handleNumber + 1);
};
if ( window.requestAnimationFrame && options.useRequestAnimationFrame ) {
window.requestAnimationFrame(stateUpdate);
} else {
stateUpdate();
}
}
function setZindex ( ) {
scope_HandleNumbers.forEach(function(handleNumber){
var dir = (scope_Locations[handleNumber] > 50 ? -1 : 1);
var zIndex = 3 + (scope_Handles.length + (dir * handleNumber));
scope_Handles[handleNumber].childNodes[0].style.zIndex = zIndex;
});
}
function setHandle ( handleNumber, to, lookBackward, lookForward ) {
to = checkHandlePosition(scope_Locations, handleNumber, to, lookBackward, lookForward, false);
if ( to === false ) {
return false;
}
updateHandlePosition(handleNumber, to);
return true;
}
function updateConnect ( index ) {
if ( !scope_Connects[index] ) {
return;
}
var l = 0;
var h = 100;
if ( index !== 0 ) {
l = scope_Locations[index - 1];
}
if ( index !== scope_Connects.length - 1 ) {
h = scope_Locations[index];
}
scope_Connects[index].style[options.style] = toPct(l);
scope_Connects[index].style[options.styleOposite] = toPct(100 - h);
}
function setValue ( to, handleNumber ) {
if ( to === null || to === false ) {
return;
}
if ( typeof to === 'number' ) {
to = String(to);
}
to = options.format.from(to);
if ( to !== false && !isNaN(to) ) {
setHandle(handleNumber, scope_Spectrum.toStepping(to), false, false);
}
}
function valueSet ( input, fireSetEvent ) {
var values = asArray(input);
var isInit = scope_Locations[0] === undefined;
fireSetEvent = (fireSetEvent === undefined ? true : !!fireSetEvent);
values.forEach(setValue);
if ( options.animate && !isInit ) {
addClassFor(scope_Target, options.cssClasses.tap, options.animationDuration);
}
scope_HandleNumbers.forEach(function(handleNumber){
setHandle(handleNumber, scope_Locations[handleNumber], true, false);
});
setZindex();
scope_HandleNumbers.forEach(function(handleNumber){
fireEvent('update', handleNumber);
if ( values[handleNumber] !== null && fireSetEvent ) {
fireEvent('set', handleNumber);
}
});
}
function valueReset ( fireSetEvent ) {
valueSet(options.start, fireSetEvent);
}
function valueGet ( ) {
var values = scope_Values.map(options.format.to);
if ( values.length === 1 ){
return values[0];
}
return values;
}
function destroy ( ) {
for ( var key in options.cssClasses ) {
if ( !options.cssClasses.hasOwnProperty(key) ) { continue; }
removeClass(scope_Target, options.cssClasses[key]);
}
while (scope_Target.firstChild) {
scope_Target.removeChild(scope_Target.firstChild);
}
delete scope_Target.noUiSlider;
}
function getCurrentStep ( ) {
return scope_Locations.map(function( location, index ){
var nearbySteps = scope_Spectrum.getNearbySteps( location );
var value = scope_Values[index];
var increment = nearbySteps.thisStep.step;
var decrement = null;
if ( increment !== false ) {
if ( value + increment > nearbySteps.stepAfter.startValue ) {
increment = nearbySteps.stepAfter.startValue - value;
}
}
if ( value > nearbySteps.thisStep.startValue ) {
decrement = nearbySteps.thisStep.step;
}
else if ( nearbySteps.stepBefore.step === false ) {
decrement = false;
}
else {
decrement = value - nearbySteps.stepBefore.highestStep;
}
if ( location === 100 ) {
increment = null;
}
else if ( location === 0 ) {
decrement = null;
}
var stepDecimals = scope_Spectrum.countStepDecimals();
if ( increment !== null && increment !== false ) {
increment = Number(increment.toFixed(stepDecimals));
}
if ( decrement !== null && decrement !== false ) {
decrement = Number(decrement.toFixed(stepDecimals));
}
return [decrement, increment];
});
}
function bindEvent ( namespacedEvent, callback ) {
scope_Events[namespacedEvent] = scope_Events[namespacedEvent] || [];
scope_Events[namespacedEvent].push(callback);
if ( namespacedEvent.split('.')[0] === 'update' ) {
scope_Handles.forEach(function(a, index){
fireEvent('update', index);
});
}
}
function removeEvent ( namespacedEvent ) {
var event = namespacedEvent && namespacedEvent.split('.')[0];
var namespace = event && namespacedEvent.substring(event.length);
Object.keys(scope_Events).forEach(function( bind ){
var tEvent = bind.split('.')[0],
tNamespace = bind.substring(tEvent.length);
if ( (!event || event === tEvent) && (!namespace || namespace === tNamespace) ) {
delete scope_Events[bind];
}
});
}
function updateOptions ( optionsToUpdate, fireSetEvent ) {
var v = valueGet();
var updateAble = ['margin', 'limit', 'padding', 'range', 'animate', 'snap', 'step', 'format'];
updateAble.forEach(function(name){
if ( optionsToUpdate[name] !== undefined ) {
originalOptions[name] = optionsToUpdate[name];
}
});
var newOptions = testOptions(originalOptions);
updateAble.forEach(function(name){
if ( optionsToUpdate[name] !== undefined ) {
options[name] = newOptions[name];
}
});
scope_Spectrum = newOptions.spectrum;
options.margin = newOptions.margin;
options.limit = newOptions.limit;
options.padding = newOptions.padding;
if ( options.pips ) {
pips(options.pips);
}
scope_Locations = [];
valueSet(optionsToUpdate.start || v, fireSetEvent);
}
if ( scope_Target.noUiSlider ) {
throw new Error("noUiSlider (" + VERSION + "): Slider was already initialized.");
}
addSlider(scope_Target);
addElements(options.connect, scope_Base);
scope_Self = {
destroy: destroy,
steps: getCurrentStep,
on: bindEvent,
off: removeEvent,
get: valueGet,
set: valueSet,
reset: valueReset,
__moveHandles: function(a, b, c) { moveHandles(a, b, scope_Locations, c); },
options: originalOptions, // Issue #600, #678
updateOptions: updateOptions,
target: scope_Target, // Issue #597
removePips: removePips,
pips: pips // Issue #594
};
bindSliderEvents(options.events);
valueSet(options.start);
if ( options.pips ) {
pips(options.pips);
}
if ( options.tooltips ) {
tooltips();
}
aria();
return scope_Self;
}
function initialize ( target, originalOptions ) {
if ( !target || !target.nodeName ) {
throw new Error("noUiSlider (" + VERSION + "): create requires a single element, got: " + target);
}
var options = testOptions( originalOptions, target );
var api = closure( target, options, originalOptions );
target.noUiSlider = api;
return api;
}
return {
version: VERSION,
create: initialize
};
}));
(function (global, factory) {
if (typeof define === 'function' && define.amd) {
define(['exports', 'module'], factory);
} else if (typeof exports !== 'undefined' && typeof module !== 'undefined') {
factory(exports, module);
} else {
var mod = {
exports: {}
};
factory(mod.exports, mod);
global.autosize = mod.exports;
}
})(this, function (exports, module) {
'use strict';
var map = typeof Map === "function" ? new Map() : (function () {
var keys = [];
var values = [];
return {
has: function has(key) {
return keys.indexOf(key) > -1;
},
get: function get(key) {
return values[keys.indexOf(key)];
},
set: function set(key, value) {
if (keys.indexOf(key) === -1) {
keys.push(key);
values.push(value);
}
},
'delete': function _delete(key) {
var index = keys.indexOf(key);
if (index > -1) {
keys.splice(index, 1);
values.splice(index, 1);
}
}
};
})();
var createEvent = function createEvent(name) {
return new Event(name, { bubbles: true });
};
try {
new Event('test');
} catch (e) {
createEvent = function (name) {
var evt = document.createEvent('Event');
evt.initEvent(name, true, false);
return evt;
};
}
function assign(ta) {
if (!ta || !ta.nodeName || ta.nodeName !== 'TEXTAREA' || map.has(ta)) return;
var heightOffset = null;
var clientWidth = ta.clientWidth;
var cachedHeight = null;
function init() {
var style = window.getComputedStyle(ta, null);
if (style.resize === 'vertical') {
ta.style.resize = 'none';
} else if (style.resize === 'both') {
ta.style.resize = 'horizontal';
}
if (style.boxSizing === 'content-box') {
heightOffset = -(parseFloat(style.paddingTop) + parseFloat(style.paddingBottom));
} else {
heightOffset = parseFloat(style.borderTopWidth) + parseFloat(style.borderBottomWidth);
}
if (isNaN(heightOffset)) {
heightOffset = 0;
}
update();
}
function changeOverflow(value) {
{
var width = ta.style.width;
ta.style.width = '0px';
ta.offsetWidth;
ta.style.width = width;
}
ta.style.overflowY = value;
}
function getParentOverflows(el) {
var arr = [];
while (el && el.parentNode && el.parentNode instanceof Element) {
if (el.parentNode.scrollTop) {
arr.push({
node: el.parentNode,
scrollTop: el.parentNode.scrollTop
});
}
el = el.parentNode;
}
return arr;
}
function resize() {
var originalHeight = ta.style.height;
var overflows = getParentOverflows(ta);
var docTop = document.documentElement && document.documentElement.scrollTop; // Needed for Mobile IE (ticket #240)
ta.style.height = '';
var endHeight = ta.scrollHeight + heightOffset;
if (ta.scrollHeight === 0) {
ta.style.height = originalHeight;
return;
}
ta.style.height = endHeight + 'px';
clientWidth = ta.clientWidth;
overflows.forEach(function (el) {
el.node.scrollTop = el.scrollTop;
});
if (docTop) {
document.documentElement.scrollTop = docTop;
}
}
function update() {
resize();
var styleHeight = Math.round(parseFloat(ta.style.height));
var computed = window.getComputedStyle(ta, null);
var actualHeight = computed.boxSizing === 'content-box' ? Math.round(parseFloat(computed.height)) : ta.offsetHeight;
if (actualHeight !== styleHeight) {
if (computed.overflowY === 'hidden') {
changeOverflow('scroll');
resize();
actualHeight = computed.boxSizing === 'content-box' ? Math.round(parseFloat(window.getComputedStyle(ta, null).height)) : ta.offsetHeight;
}
} else {
if (computed.overflowY !== 'hidden') {
changeOverflow('hidden');
resize();
actualHeight = computed.boxSizing === 'content-box' ? Math.round(parseFloat(window.getComputedStyle(ta, null).height)) : ta.offsetHeight;
}
}
if (cachedHeight !== actualHeight) {
cachedHeight = actualHeight;
var evt = createEvent('autosize:resized');
try {
ta.dispatchEvent(evt);
} catch (err) {
}
}
}
var pageResize = function pageResize() {
if (ta.clientWidth !== clientWidth) {
update();
}
};
var destroy = (function (style) {
window.removeEventListener('resize', pageResize, false);
ta.removeEventListener('input', update, false);
ta.removeEventListener('keyup', update, false);
ta.removeEventListener('autosize:destroy', destroy, false);
ta.removeEventListener('autosize:update', update, false);
Object.keys(style).forEach(function (key) {
ta.style[key] = style[key];
});
map['delete'](ta);
}).bind(ta, {
height: ta.style.height,
resize: ta.style.resize,
overflowY: ta.style.overflowY,
overflowX: ta.style.overflowX,
wordWrap: ta.style.wordWrap
});
ta.addEventListener('autosize:destroy', destroy, false);
if ('onpropertychange' in ta && 'oninput' in ta) {
ta.addEventListener('keyup', update, false);
}
window.addEventListener('resize', pageResize, false);
ta.addEventListener('input', update, false);
ta.addEventListener('autosize:update', update, false);
ta.style.overflowX = 'hidden';
ta.style.wordWrap = 'break-word';
map.set(ta, {
destroy: destroy,
update: update
});
init();
}
function destroy(ta) {
var methods = map.get(ta);
if (methods) {
methods.destroy();
}
}
function update(ta) {
var methods = map.get(ta);
if (methods) {
methods.update();
}
}
var autosize = null;
if (typeof window === 'undefined' || typeof window.getComputedStyle !== 'function') {
autosize = function (el) {
return el;
};
autosize.destroy = function (el) {
return el;
};
autosize.update = function (el) {
return el;
};
} else {
autosize = function (el, options) {
if (el) {
Array.prototype.forEach.call(el.length ? el : [el], function (x) {
return assign(x, options);
});
}
return el;
};
autosize.destroy = function (el) {
if (el) {
Array.prototype.forEach.call(el.length ? el : [el], destroy);
}
return el;
};
autosize.update = function (el) {
if (el) {
Array.prototype.forEach.call(el.length ? el : [el], update);
}
return el;
};
}
module.exports = autosize;
});
!function(t){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=t();else if("function"==typeof define&&define.amd)define([],t);else{var e;e="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this,e.Clipboard=t()}}(function(){var t,e,n;return function t(e,n,o){function i(a,c){if(!n[a]){if(!e[a]){var l="function"==typeof require&&require;if(!c&&l)return l(a,!0);if(r)return r(a,!0);var s=new Error("Cannot find module '"+a+"'");throw s.code="MODULE_NOT_FOUND",s}var u=n[a]={exports:{}};e[a][0].call(u.exports,function(t){var n=e[a][1][t];return i(n||t)},u,u.exports,t,e,n,o)}return n[a].exports}for(var r="function"==typeof require&&require,a=0;a<o.length;a++)i(o[a]);return i}({1:[function(t,e,n){function o(t,e){for(;t&&t.nodeType!==i;){if("function"==typeof t.matches&&t.matches(e))return t;t=t.parentNode}}var i=9;if("undefined"!=typeof Element&&!Element.prototype.matches){var r=Element.prototype;r.matches=r.matchesSelector||r.mozMatchesSelector||r.msMatchesSelector||r.oMatchesSelector||r.webkitMatchesSelector}e.exports=o},{}],2:[function(t,e,n){function o(t,e,n,o,r){var a=i.apply(this,arguments);return t.addEventListener(n,a,r),{destroy:function(){t.removeEventListener(n,a,r)}}}function i(t,e,n,o){return function(n){n.delegateTarget=r(n.target,e),n.delegateTarget&&o.call(t,n)}}var r=t("./closest");e.exports=o},{"./closest":1}],3:[function(t,e,n){n.node=function(t){return void 0!==t&&t instanceof HTMLElement&&1===t.nodeType},n.nodeList=function(t){var e=Object.prototype.toString.call(t);return void 0!==t&&("[object NodeList]"===e||"[object HTMLCollection]"===e)&&"length"in t&&(0===t.length||n.node(t[0]))},n.string=function(t){return"string"==typeof t||t instanceof String},n.fn=function(t){return"[object Function]"===Object.prototype.toString.call(t)}},{}],4:[function(t,e,n){function o(t,e,n){if(!t&&!e&&!n)throw new Error("Missing required arguments");if(!c.string(e))throw new TypeError("Second argument must be a String");if(!c.fn(n))throw new TypeError("Third argument must be a Function");if(c.node(t))return i(t,e,n);if(c.nodeList(t))return r(t,e,n);if(c.string(t))return a(t,e,n);throw new TypeError("First argument must be a String, HTMLElement, HTMLCollection, or NodeList")}function i(t,e,n){return t.addEventListener(e,n),{destroy:function(){t.removeEventListener(e,n)}}}function r(t,e,n){return Array.prototype.forEach.call(t,function(t){t.addEventListener(e,n)}),{destroy:function(){Array.prototype.forEach.call(t,function(t){t.removeEventListener(e,n)})}}}function a(t,e,n){return l(document.body,t,e,n)}var c=t("./is"),l=t("delegate");e.exports=o},{"./is":3,delegate:2}],5:[function(t,e,n){function o(t){var e;if("SELECT"===t.nodeName)t.focus(),e=t.value;else if("INPUT"===t.nodeName||"TEXTAREA"===t.nodeName){var n=t.hasAttribute("readonly");n||t.setAttribute("readonly",""),t.select(),t.setSelectionRange(0,t.value.length),n||t.removeAttribute("readonly"),e=t.value}else{t.hasAttribute("contenteditable")&&t.focus();var o=window.getSelection(),i=document.createRange();i.selectNodeContents(t),o.removeAllRanges(),o.addRange(i),e=o.toString()}return e}e.exports=o},{}],6:[function(t,e,n){function o(){}o.prototype={on:function(t,e,n){var o=this.e||(this.e={});return(o[t]||(o[t]=[])).push({fn:e,ctx:n}),this},once:function(t,e,n){function o(){i.off(t,o),e.apply(n,arguments)}var i=this;return o._=e,this.on(t,o,n)},emit:function(t){var e=[].slice.call(arguments,1),n=((this.e||(this.e={}))[t]||[]).slice(),o=0,i=n.length;for(o;o<i;o++)n[o].fn.apply(n[o].ctx,e);return this},off:function(t,e){var n=this.e||(this.e={}),o=n[t],i=[];if(o&&e)for(var r=0,a=o.length;r<a;r++)o[r].fn!==e&&o[r].fn._!==e&&i.push(o[r]);return i.length?n[t]=i:delete n[t],this}},e.exports=o},{}],7:[function(e,n,o){!function(i,r){if("function"==typeof t&&t.amd)t(["module","select"],r);else if(void 0!==o)r(n,e("select"));else{var a={exports:{}};r(a,i.select),i.clipboardAction=a.exports}}(this,function(t,e){"use strict";function n(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}var i=n(e),r="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},a=function(){function t(t,e){for(var n=0;n<e.length;n++){var o=e[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(t,o.key,o)}}return function(e,n,o){return n&&t(e.prototype,n),o&&t(e,o),e}}(),c=function(){function t(e){o(this,t),this.resolveOptions(e),this.initSelection()}return a(t,[{key:"resolveOptions",value:function t(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};this.action=e.action,this.container=e.container,this.emitter=e.emitter,this.target=e.target,this.text=e.text,this.trigger=e.trigger,this.selectedText=""}},{key:"initSelection",value:function t(){this.text?this.selectFake():this.target&&this.selectTarget()}},{key:"selectFake",value:function t(){var e=this,n="rtl"==document.documentElement.getAttribute("dir");this.removeFake(),this.fakeHandlerCallback=function(){return e.removeFake()},this.fakeHandler=this.container.addEventListener("click",this.fakeHandlerCallback)||!0,this.fakeElem=document.createElement("textarea"),this.fakeElem.style.fontSize="12pt",this.fakeElem.style.border="0",this.fakeElem.style.padding="0",this.fakeElem.style.margin="0",this.fakeElem.style.position="absolute",this.fakeElem.style[n?"right":"left"]="-9999px";var o=window.pageYOffset||document.documentElement.scrollTop;this.fakeElem.style.top=o+"px",this.fakeElem.setAttribute("readonly",""),this.fakeElem.value=this.text,this.container.appendChild(this.fakeElem),this.selectedText=(0,i.default)(this.fakeElem),this.copyText()}},{key:"removeFake",value:function t(){this.fakeHandler&&(this.container.removeEventListener("click",this.fakeHandlerCallback),this.fakeHandler=null,this.fakeHandlerCallback=null),this.fakeElem&&(this.container.removeChild(this.fakeElem),this.fakeElem=null)}},{key:"selectTarget",value:function t(){this.selectedText=(0,i.default)(this.target),this.copyText()}},{key:"copyText",value:function t(){var e=void 0;try{e=document.execCommand(this.action)}catch(t){e=!1}this.handleResult(e)}},{key:"handleResult",value:function t(e){this.emitter.emit(e?"success":"error",{action:this.action,text:this.selectedText,trigger:this.trigger,clearSelection:this.clearSelection.bind(this)})}},{key:"clearSelection",value:function t(){this.trigger&&this.trigger.focus(),window.getSelection().removeAllRanges()}},{key:"destroy",value:function t(){this.removeFake()}},{key:"action",set:function t(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"copy";if(this._action=e,"copy"!==this._action&&"cut"!==this._action)throw new Error('Invalid "action" value, use either "copy" or "cut"')},get:function t(){return this._action}},{key:"target",set:function t(e){if(void 0!==e){if(!e||"object"!==(void 0===e?"undefined":r(e))||1!==e.nodeType)throw new Error('Invalid "target" value, use a valid Element');if("copy"===this.action&&e.hasAttribute("disabled"))throw new Error('Invalid "target" attribute. Please use "readonly" instead of "disabled" attribute');if("cut"===this.action&&(e.hasAttribute("readonly")||e.hasAttribute("disabled")))throw new Error('Invalid "target" attribute. You can\'t cut text from elements with "readonly" or "disabled" attributes');this._target=e}},get:function t(){return this._target}}]),t}();t.exports=c})},{select:5}],8:[function(e,n,o){!function(i,r){if("function"==typeof t&&t.amd)t(["module","./clipboard-action","tiny-emitter","good-listener"],r);else if(void 0!==o)r(n,e("./clipboard-action"),e("tiny-emitter"),e("good-listener"));else{var a={exports:{}};r(a,i.clipboardAction,i.tinyEmitter,i.goodListener),i.clipboard=a.exports}}(this,function(t,e,n,o){"use strict";function i(t){return t&&t.__esModule?t:{default:t}}function r(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function a(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function c(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}function l(t,e){var n="data-clipboard-"+t;if(e.hasAttribute(n))return e.getAttribute(n)}var s=i(e),u=i(n),f=i(o),d="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},h=function(){function t(t,e){for(var n=0;n<e.length;n++){var o=e[n];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(t,o.key,o)}}return function(e,n,o){return n&&t(e.prototype,n),o&&t(e,o),e}}(),p=function(t){function e(t,n){r(this,e);var o=a(this,(e.__proto__||Object.getPrototypeOf(e)).call(this));return o.resolveOptions(n),o.listenClick(t),o}return c(e,t),h(e,[{key:"resolveOptions",value:function t(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};this.action="function"==typeof e.action?e.action:this.defaultAction,this.target="function"==typeof e.target?e.target:this.defaultTarget,this.text="function"==typeof e.text?e.text:this.defaultText,this.container="object"===d(e.container)?e.container:document.body}},{key:"listenClick",value:function t(e){var n=this;this.listener=(0,f.default)(e,"click",function(t){return n.onClick(t)})}},{key:"onClick",value:function t(e){var n=e.delegateTarget||e.currentTarget;this.clipboardAction&&(this.clipboardAction=null),this.clipboardAction=new s.default({action:this.action(n),target:this.target(n),text:this.text(n),container:this.container,trigger:n,emitter:this})}},{key:"defaultAction",value:function t(e){return l("action",e)}},{key:"defaultTarget",value:function t(e){var n=l("target",e);if(n)return document.querySelector(n)}},{key:"defaultText",value:function t(e){return l("text",e)}},{key:"destroy",value:function t(){this.listener.destroy(),this.clipboardAction&&(this.clipboardAction.destroy(),this.clipboardAction=null)}}],[{key:"isSupported",value:function t(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:["copy","cut"],n="string"==typeof e?[e]:e,o=!!document.queryCommandSupported;return n.forEach(function(t){o=o&&!!document.queryCommandSupported(t)}),o}}]),e}(u.default);t.exports=p})},{"./clipboard-action":7,"good-listener":4,"tiny-emitter":6}]},{},[8])(8)});
;(function(factory) {
if (typeof define === "function" && define.amd) {
define(["jquery"], function (jQuery) {
return factory(jQuery, document, window, navigator);
});
} else if (typeof exports === "object") {
factory(require("jquery"), document, window, navigator);
} else {
factory(jQuery, document, window, navigator);
}
} (function ($, document, window, navigator, undefined) {
"use strict";
var plugin_count = 0;
var is_old_ie = (function () {
var n = navigator.userAgent,
r = /msie\s\d+/i,
v;
if (n.search(r) > 0) {
v = r.exec(n).toString();
v = v.split(" ")[1];
if (v < 9) {
$("html").addClass("lt-ie9");
return true;
}
}
return false;
} ());
if (!Function.prototype.bind) {
Function.prototype.bind = function bind(that) {
var target = this;
var slice = [].slice;
if (typeof target != "function") {
throw new TypeError();
}
var args = slice.call(arguments, 1),
bound = function () {
if (this instanceof bound) {
var F = function(){};
F.prototype = target.prototype;
var self = new F();
var result = target.apply(
self,
args.concat(slice.call(arguments))
);
if (Object(result) === result) {
return result;
}
return self;
} else {
return target.apply(
that,
args.concat(slice.call(arguments))
);
}
};
return bound;
};
}
if (!Array.prototype.indexOf) {
Array.prototype.indexOf = function(searchElement, fromIndex) {
var k;
if (this == null) {
throw new TypeError('"this" is null or not defined');
}
var O = Object(this);
var len = O.length >>> 0;
if (len === 0) {
return -1;
}
var n = +fromIndex || 0;
if (Math.abs(n) === Infinity) {
n = 0;
}
if (n >= len) {
return -1;
}
k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);
while (k < len) {
if (k in O && O[k] === searchElement) {
return k;
}
k++;
}
return -1;
};
}
var base_html =
'<span class="irs">' +
'<span class="irs-line" tabindex="0"><span class="irs-line-left"></span><span class="irs-line-mid"></span><span class="irs-line-right"></span></span>' +
'<span class="irs-min">0</span><span class="irs-max">1</span>' +
'<span class="irs-from">0</span><span class="irs-to">0</span><span class="irs-single">0</span>' +
'</span>' +
'<span class="irs-grid"></span>' +
'<span class="irs-bar"></span>';
var single_html =
'<span class="irs-bar-edge"></span>' +
'<span class="irs-shadow shadow-single"></span>' +
'<span class="irs-slider single"></span>';
var double_html =
'<span class="irs-shadow shadow-from"></span>' +
'<span class="irs-shadow shadow-to"></span>' +
'<span class="irs-slider from"></span>' +
'<span class="irs-slider to"></span>';
var disable_html =
'<span class="irs-disable-mask"></span>';
var IonRangeSlider = function (input, options, plugin_count) {
this.VERSION = "2.2.0";
this.input = input;
this.plugin_count = plugin_count;
this.current_plugin = 0;
this.calc_count = 0;
this.update_tm = 0;
this.old_from = 0;
this.old_to = 0;
this.old_min_interval = null;
this.raf_id = null;
this.dragging = false;
this.force_redraw = false;
this.no_diapason = false;
this.has_tab_index = true;
this.is_key = false;
this.is_update = false;
this.is_start = true;
this.is_finish = false;
this.is_active = false;
this.is_resize = false;
this.is_click = false;
options = options || {};
this.$cache = {
win: $(window),
body: $(document.body),
input: $(input),
cont: null,
rs: null,
min: null,
max: null,
from: null,
to: null,
single: null,
bar: null,
line: null,
s_single: null,
s_from: null,
s_to: null,
shad_single: null,
shad_from: null,
shad_to: null,
edge: null,
grid: null,
grid_labels: []
};
this.coords = {
x_gap: 0,
x_pointer: 0,
w_rs: 0,
w_rs_old: 0,
w_handle: 0,
p_gap: 0,
p_gap_left: 0,
p_gap_right: 0,
p_step: 0,
p_pointer: 0,
p_handle: 0,
p_single_fake: 0,
p_single_real: 0,
p_from_fake: 0,
p_from_real: 0,
p_to_fake: 0,
p_to_real: 0,
p_bar_x: 0,
p_bar_w: 0,
grid_gap: 0,
big_num: 0,
big: [],
big_w: [],
big_p: [],
big_x: []
};
this.labels = {
w_min: 0,
w_max: 0,
w_from: 0,
w_to: 0,
w_single: 0,
p_min: 0,
p_max: 0,
p_from_fake: 0,
p_from_left: 0,
p_to_fake: 0,
p_to_left: 0,
p_single_fake: 0,
p_single_left: 0
};
var $inp = this.$cache.input,
val = $inp.prop("value"),
config, config_from_data, prop;
config = {
type: "single",
min: 10,
max: 100,
from: null,
to: null,
step: 1,
min_interval: 0,
max_interval: 0,
drag_interval: false,
values: [],
p_values: [],
from_fixed: false,
from_min: null,
from_max: null,
from_shadow: false,
to_fixed: false,
to_min: null,
to_max: null,
to_shadow: false,
prettify_enabled: true,
prettify_separator: " ",
prettify: null,
force_edges: false,
keyboard: true,
grid: false,
grid_margin: true,
grid_num: 4,
grid_snap: false,
hide_min_max: false,
hide_from_to: false,
prefix: "",
postfix: "",
max_postfix: "",
decorate_both: true,
values_separator: "  ",
input_values_separator: ";",
disable: false,
block: false,
extra_classes: "",
scope: null,
onStart: null,
onChange: null,
onFinish: null,
onUpdate: null
};
if ($inp[0].nodeName !== "INPUT") {
console && console.warn && console.warn("Base element should be <input>!", $inp[0]);
}
config_from_data = {
type: $inp.data("type"),
min: $inp.data("min"),
max: $inp.data("max"),
from: $inp.data("from"),
to: $inp.data("to"),
step: $inp.data("step"),
min_interval: $inp.data("minInterval"),
max_interval: $inp.data("maxInterval"),
drag_interval: $inp.data("dragInterval"),
values: $inp.data("values"),
from_fixed: $inp.data("fromFixed"),
from_min: $inp.data("fromMin"),
from_max: $inp.data("fromMax"),
from_shadow: $inp.data("fromShadow"),
to_fixed: $inp.data("toFixed"),
to_min: $inp.data("toMin"),
to_max: $inp.data("toMax"),
to_shadow: $inp.data("toShadow"),
prettify_enabled: $inp.data("prettifyEnabled"),
prettify_separator: $inp.data("prettifySeparator"),
force_edges: $inp.data("forceEdges"),
keyboard: $inp.data("keyboard"),
grid: $inp.data("grid"),
grid_margin: $inp.data("gridMargin"),
grid_num: $inp.data("gridNum"),
grid_snap: $inp.data("gridSnap"),
hide_min_max: $inp.data("hideMinMax"),
hide_from_to: $inp.data("hideFromTo"),
prefix: $inp.data("prefix"),
postfix: $inp.data("postfix"),
max_postfix: $inp.data("maxPostfix"),
decorate_both: $inp.data("decorateBoth"),
values_separator: $inp.data("valuesSeparator"),
input_values_separator: $inp.data("inputValuesSeparator"),
disable: $inp.data("disable"),
block: $inp.data("block"),
extra_classes: $inp.data("extraClasses"),
};
config_from_data.values = config_from_data.values && config_from_data.values.split(",");
for (prop in config_from_data) {
if (config_from_data.hasOwnProperty(prop)) {
if (config_from_data[prop] === undefined || config_from_data[prop] === "") {
delete config_from_data[prop];
}
}
}
if (val !== undefined && val !== "") {
val = val.split(config_from_data.input_values_separator || options.input_values_separator || ";");
if (val[0] && val[0] == +val[0]) {
val[0] = +val[0];
}
if (val[1] && val[1] == +val[1]) {
val[1] = +val[1];
}
if (options && options.values && options.values.length) {
config.from = val[0] && options.values.indexOf(val[0]);
config.to = val[1] && options.values.indexOf(val[1]);
} else {
config.from = val[0] && +val[0];
config.to = val[1] && +val[1];
}
}
$.extend(config, options);
$.extend(config, config_from_data);
this.options = config;
this.update_check = {};
this.validate();
this.result = {
input: this.$cache.input,
slider: null,
min: this.options.min,
max: this.options.max,
from: this.options.from,
from_percent: 0,
from_value: null,
to: this.options.to,
to_percent: 0,
to_value: null
};
this.init();
};
IonRangeSlider.prototype = {
init: function (is_update) {
this.no_diapason = false;
this.coords.p_step = this.convertToPercent(this.options.step, true);
this.target = "base";
this.toggleInput();
this.append();
this.setMinMax();
if (is_update) {
this.force_redraw = true;
this.calc(true);
this.callOnUpdate();
} else {
this.force_redraw = true;
this.calc(true);
this.callOnStart();
}
this.updateScene();
},
append: function () {
var container_html = '<span class="irs js-irs-' + this.plugin_count + ' ' + this.options.extra_classes + '"></span>';
this.$cache.input.before(container_html);
this.$cache.input.prop("readonly", true);
this.$cache.cont = this.$cache.input.prev();
this.result.slider = this.$cache.cont;
this.$cache.cont.html(base_html);
this.$cache.rs = this.$cache.cont.find(".irs");
this.$cache.min = this.$cache.cont.find(".irs-min");
this.$cache.max = this.$cache.cont.find(".irs-max");
this.$cache.from = this.$cache.cont.find(".irs-from");
this.$cache.to = this.$cache.cont.find(".irs-to");
this.$cache.single = this.$cache.cont.find(".irs-single");
this.$cache.bar = this.$cache.cont.find(".irs-bar");
this.$cache.line = this.$cache.cont.find(".irs-line");
this.$cache.grid = this.$cache.cont.find(".irs-grid");
if (this.options.type === "single") {
this.$cache.cont.append(single_html);
this.$cache.edge = this.$cache.cont.find(".irs-bar-edge");
this.$cache.s_single = this.$cache.cont.find(".single");
this.$cache.from[0].style.visibility = "hidden";
this.$cache.to[0].style.visibility = "hidden";
this.$cache.shad_single = this.$cache.cont.find(".shadow-single");
} else {
this.$cache.cont.append(double_html);
this.$cache.s_from = this.$cache.cont.find(".from");
this.$cache.s_to = this.$cache.cont.find(".to");
this.$cache.shad_from = this.$cache.cont.find(".shadow-from");
this.$cache.shad_to = this.$cache.cont.find(".shadow-to");
this.setTopHandler();
}
if (this.options.hide_from_to) {
this.$cache.from[0].style.display = "none";
this.$cache.to[0].style.display = "none";
this.$cache.single[0].style.display = "none";
}
this.appendGrid();
if (this.options.disable) {
this.appendDisableMask();
this.$cache.input[0].disabled = true;
} else {
this.$cache.input[0].disabled = false;
this.removeDisableMask();
this.bindEvents();
}
if (!this.options.disable) {
if (this.options.block) {
this.appendDisableMask();
} else {
this.removeDisableMask();
}
}
if (this.options.drag_interval) {
this.$cache.bar[0].style.cursor = "ew-resize";
}
},
setTopHandler: function () {
var min = this.options.min,
max = this.options.max,
from = this.options.from,
to = this.options.to;
if (from > min && to === max) {
this.$cache.s_from.addClass("type_last");
} else if (to < max) {
this.$cache.s_to.addClass("type_last");
}
},
changeLevel: function (target) {
switch (target) {
case "single":
this.coords.p_gap = this.toFixed(this.coords.p_pointer - this.coords.p_single_fake);
this.$cache.s_single.addClass("state_hover");
break;
case "from":
this.coords.p_gap = this.toFixed(this.coords.p_pointer - this.coords.p_from_fake);
this.$cache.s_from.addClass("state_hover");
this.$cache.s_from.addClass("type_last");
this.$cache.s_to.removeClass("type_last");
break;
case "to":
this.coords.p_gap = this.toFixed(this.coords.p_pointer - this.coords.p_to_fake);
this.$cache.s_to.addClass("state_hover");
this.$cache.s_to.addClass("type_last");
this.$cache.s_from.removeClass("type_last");
break;
case "both":
this.coords.p_gap_left = this.toFixed(this.coords.p_pointer - this.coords.p_from_fake);
this.coords.p_gap_right = this.toFixed(this.coords.p_to_fake - this.coords.p_pointer);
this.$cache.s_to.removeClass("type_last");
this.$cache.s_from.removeClass("type_last");
break;
}
},
appendDisableMask: function () {
this.$cache.cont.append(disable_html);
this.$cache.cont.addClass("irs-disabled");
},
removeDisableMask: function () {
this.$cache.cont.remove(".irs-disable-mask");
this.$cache.cont.removeClass("irs-disabled");
},
remove: function () {
this.$cache.cont.remove();
this.$cache.cont = null;
this.$cache.line.off("keydown.irs_" + this.plugin_count);
this.$cache.body.off("touchmove.irs_" + this.plugin_count);
this.$cache.body.off("mousemove.irs_" + this.plugin_count);
this.$cache.win.off("touchend.irs_" + this.plugin_count);
this.$cache.win.off("mouseup.irs_" + this.plugin_count);
if (is_old_ie) {
this.$cache.body.off("mouseup.irs_" + this.plugin_count);
this.$cache.body.off("mouseleave.irs_" + this.plugin_count);
}
this.$cache.grid_labels = [];
this.coords.big = [];
this.coords.big_w = [];
this.coords.big_p = [];
this.coords.big_x = [];
cancelAnimationFrame(this.raf_id);
},
bindEvents: function () {
if (this.no_diapason) {
return;
}
this.$cache.body.on("touchmove.irs_" + this.plugin_count, this.pointerMove.bind(this));
this.$cache.body.on("mousemove.irs_" + this.plugin_count, this.pointerMove.bind(this));
this.$cache.win.on("touchend.irs_" + this.plugin_count, this.pointerUp.bind(this));
this.$cache.win.on("mouseup.irs_" + this.plugin_count, this.pointerUp.bind(this));
this.$cache.line.on("touchstart.irs_" + this.plugin_count, this.pointerClick.bind(this, "click"));
this.$cache.line.on("mousedown.irs_" + this.plugin_count, this.pointerClick.bind(this, "click"));
this.$cache.line.on("focus.irs_" + this.plugin_count, this.pointerFocus.bind(this));
if (this.options.drag_interval && this.options.type === "double") {
this.$cache.bar.on("touchstart.irs_" + this.plugin_count, this.pointerDown.bind(this, "both"));
this.$cache.bar.on("mousedown.irs_" + this.plugin_count, this.pointerDown.bind(this, "both"));
} else {
this.$cache.bar.on("touchstart.irs_" + this.plugin_count, this.pointerClick.bind(this, "click"));
this.$cache.bar.on("mousedown.irs_" + this.plugin_count, this.pointerClick.bind(this, "click"));
}
if (this.options.type === "single") {
this.$cache.single.on("touchstart.irs_" + this.plugin_count, this.pointerDown.bind(this, "single"));
this.$cache.s_single.on("touchstart.irs_" + this.plugin_count, this.pointerDown.bind(this, "single"));
this.$cache.shad_single.on("touchstart.irs_" + this.plugin_count, this.pointerClick.bind(this, "click"));
this.$cache.single.on("mousedown.irs_" + this.plugin_count, this.pointerDown.bind(this, "single"));
this.$cache.s_single.on("mousedown.irs_" + this.plugin_count, this.pointerDown.bind(this, "single"));
this.$cache.edge.on("mousedown.irs_" + this.plugin_count, this.pointerClick.bind(this, "click"));
this.$cache.shad_single.on("mousedown.irs_" + this.plugin_count, this.pointerClick.bind(this, "click"));
} else {
this.$cache.single.on("touchstart.irs_" + this.plugin_count, this.pointerDown.bind(this, null));
this.$cache.single.on("mousedown.irs_" + this.plugin_count, this.pointerDown.bind(this, null));
this.$cache.from.on("touchstart.irs_" + this.plugin_count, this.pointerDown.bind(this, "from"));
this.$cache.s_from.on("touchstart.irs_" + this.plugin_count, this.pointerDown.bind(this, "from"));
this.$cache.to.on("touchstart.irs_" + this.plugin_count, this.pointerDown.bind(this, "to"));
this.$cache.s_to.on("touchstart.irs_" + this.plugin_count, this.pointerDown.bind(this, "to"));
this.$cache.shad_from.on("touchstart.irs_" + this.plugin_count, this.pointerClick.bind(this, "click"));
this.$cache.shad_to.on("touchstart.irs_" + this.plugin_count, this.pointerClick.bind(this, "click"));
this.$cache.from.on("mousedown.irs_" + this.plugin_count, this.pointerDown.bind(this, "from"));
this.$cache.s_from.on("mousedown.irs_" + this.plugin_count, this.pointerDown.bind(this, "from"));
this.$cache.to.on("mousedown.irs_" + this.plugin_count, this.pointerDown.bind(this, "to"));
this.$cache.s_to.on("mousedown.irs_" + this.plugin_count, this.pointerDown.bind(this, "to"));
this.$cache.shad_from.on("mousedown.irs_" + this.plugin_count, this.pointerClick.bind(this, "click"));
this.$cache.shad_to.on("mousedown.irs_" + this.plugin_count, this.pointerClick.bind(this, "click"));
}
if (this.options.keyboard) {
this.$cache.line.on("keydown.irs_" + this.plugin_count, this.key.bind(this, "keyboard"));
}
if (is_old_ie) {
this.$cache.body.on("mouseup.irs_" + this.plugin_count, this.pointerUp.bind(this));
this.$cache.body.on("mouseleave.irs_" + this.plugin_count, this.pointerUp.bind(this));
}
},
pointerFocus: function (e) {
if (!this.target) {
var x;
var $handle;
if (this.options.type === "single") {
$handle = this.$cache.single;
} else {
$handle = this.$cache.from;
}
x = $handle.offset().left;
x += ($handle.width() / 2) - 1;
this.pointerClick("single", {preventDefault: function () {}, pageX: x});
}
},
pointerMove: function (e) {
if (!this.dragging) {
return;
}
var x = e.pageX || e.originalEvent.touches && e.originalEvent.touches[0].pageX;
this.coords.x_pointer = x - this.coords.x_gap;
this.calc();
},
pointerUp: function (e) {
if (this.current_plugin !== this.plugin_count) {
return;
}
if (this.is_active) {
this.is_active = false;
} else {
return;
}
this.$cache.cont.find(".state_hover").removeClass("state_hover");
this.force_redraw = true;
if (is_old_ie) {
$("*").prop("unselectable", false);
}
this.updateScene();
this.restoreOriginalMinInterval();
if ($.contains(this.$cache.cont[0], e.target) || this.dragging) {
this.callOnFinish();
}
this.dragging = false;
},
pointerDown: function (target, e) {
e.preventDefault();
var x = e.pageX || e.originalEvent.touches && e.originalEvent.touches[0].pageX;
if (e.button === 2) {
return;
}
if (target === "both") {
this.setTempMinInterval();
}
if (!target) {
target = this.target || "from";
}
this.current_plugin = this.plugin_count;
this.target = target;
this.is_active = true;
this.dragging = true;
this.coords.x_gap = this.$cache.rs.offset().left;
this.coords.x_pointer = x - this.coords.x_gap;
this.calcPointerPercent();
this.changeLevel(target);
if (is_old_ie) {
$("*").prop("unselectable", true);
}
this.$cache.line.trigger("focus");
this.updateScene();
},
pointerClick: function (target, e) {
e.preventDefault();
var x = e.pageX || e.originalEvent.touches && e.originalEvent.touches[0].pageX;
if (e.button === 2) {
return;
}
this.current_plugin = this.plugin_count;
this.target = target;
this.is_click = true;
this.coords.x_gap = this.$cache.rs.offset().left;
this.coords.x_pointer = +(x - this.coords.x_gap).toFixed();
this.force_redraw = true;
this.calc();
this.$cache.line.trigger("focus");
},
key: function (target, e) {
if (this.current_plugin !== this.plugin_count || e.altKey || e.ctrlKey || e.shiftKey || e.metaKey) {
return;
}
switch (e.which) {
case 83: // W
case 65: // A
case 40: // DOWN
case 37: // LEFT
e.preventDefault();
this.moveByKey(false);
break;
case 87: // S
case 68: // D
case 38: // UP
case 39: // RIGHT
e.preventDefault();
this.moveByKey(true);
break;
}
return true;
},
moveByKey: function (right) {
var p = this.coords.p_pointer;
var p_step = (this.options.max - this.options.min) / 100;
p_step = this.options.step / p_step;
if (right) {
p += p_step;
} else {
p -= p_step;
}
this.coords.x_pointer = this.toFixed(this.coords.w_rs / 100 * p);
this.is_key = true;
this.calc();
},
setMinMax: function () {
if (!this.options) {
return;
}
if (this.options.hide_min_max) {
this.$cache.min[0].style.display = "none";
this.$cache.max[0].style.display = "none";
return;
}
if (this.options.values.length) {
this.$cache.min.html(this.decorate(this.options.p_values[this.options.min]));
this.$cache.max.html(this.decorate(this.options.p_values[this.options.max]));
} else {
var min_pretty = this._prettify(this.options.min);
var max_pretty = this._prettify(this.options.max);
this.result.min_pretty = min_pretty;
this.result.max_pretty = max_pretty;
this.$cache.min.html(this.decorate(min_pretty, this.options.min));
this.$cache.max.html(this.decorate(max_pretty, this.options.max));
}
this.labels.w_min = this.$cache.min.outerWidth(false);
this.labels.w_max = this.$cache.max.outerWidth(false);
},
setTempMinInterval: function () {
var interval = this.result.to - this.result.from;
if (this.old_min_interval === null) {
this.old_min_interval = this.options.min_interval;
}
this.options.min_interval = interval;
},
restoreOriginalMinInterval: function () {
if (this.old_min_interval !== null) {
this.options.min_interval = this.old_min_interval;
this.old_min_interval = null;
}
},
calc: function (update) {
if (!this.options) {
return;
}
this.calc_count++;
if (this.calc_count === 10 || update) {
this.calc_count = 0;
this.coords.w_rs = this.$cache.rs.outerWidth(false);
this.calcHandlePercent();
}
if (!this.coords.w_rs) {
return;
}
this.calcPointerPercent();
var handle_x = this.getHandleX();
if (this.target === "both") {
this.coords.p_gap = 0;
handle_x = this.getHandleX();
}
if (this.target === "click") {
this.coords.p_gap = this.coords.p_handle / 2;
handle_x = this.getHandleX();
if (this.options.drag_interval) {
this.target = "both_one";
} else {
this.target = this.chooseHandle(handle_x);
}
}
switch (this.target) {
case "base":
var w = (this.options.max - this.options.min) / 100,
f = (this.result.from - this.options.min) / w,
t = (this.result.to - this.options.min) / w;
this.coords.p_single_real = this.toFixed(f);
this.coords.p_from_real = this.toFixed(f);
this.coords.p_to_real = this.toFixed(t);
this.coords.p_single_real = this.checkDiapason(this.coords.p_single_real, this.options.from_min, this.options.from_max);
this.coords.p_from_real = this.checkDiapason(this.coords.p_from_real, this.options.from_min, this.options.from_max);
this.coords.p_to_real = this.checkDiapason(this.coords.p_to_real, this.options.to_min, this.options.to_max);
this.coords.p_single_fake = this.convertToFakePercent(this.coords.p_single_real);
this.coords.p_from_fake = this.convertToFakePercent(this.coords.p_from_real);
this.coords.p_to_fake = this.convertToFakePercent(this.coords.p_to_real);
this.target = null;
break;
case "single":
if (this.options.from_fixed) {
break;
}
this.coords.p_single_real = this.convertToRealPercent(handle_x);
this.coords.p_single_real = this.calcWithStep(this.coords.p_single_real);
this.coords.p_single_real = this.checkDiapason(this.coords.p_single_real, this.options.from_min, this.options.from_max);
this.coords.p_single_fake = this.convertToFakePercent(this.coords.p_single_real);
break;
case "from":
if (this.options.from_fixed) {
break;
}
this.coords.p_from_real = this.convertToRealPercent(handle_x);
this.coords.p_from_real = this.calcWithStep(this.coords.p_from_real);
if (this.coords.p_from_real > this.coords.p_to_real) {
this.coords.p_from_real = this.coords.p_to_real;
}
this.coords.p_from_real = this.checkDiapason(this.coords.p_from_real, this.options.from_min, this.options.from_max);
this.coords.p_from_real = this.checkMinInterval(this.coords.p_from_real, this.coords.p_to_real, "from");
this.coords.p_from_real = this.checkMaxInterval(this.coords.p_from_real, this.coords.p_to_real, "from");
this.coords.p_from_fake = this.convertToFakePercent(this.coords.p_from_real);
break;
case "to":
if (this.options.to_fixed) {
break;
}
this.coords.p_to_real = this.convertToRealPercent(handle_x);
this.coords.p_to_real = this.calcWithStep(this.coords.p_to_real);
if (this.coords.p_to_real < this.coords.p_from_real) {
this.coords.p_to_real = this.coords.p_from_real;
}
this.coords.p_to_real = this.checkDiapason(this.coords.p_to_real, this.options.to_min, this.options.to_max);
this.coords.p_to_real = this.checkMinInterval(this.coords.p_to_real, this.coords.p_from_real, "to");
this.coords.p_to_real = this.checkMaxInterval(this.coords.p_to_real, this.coords.p_from_real, "to");
this.coords.p_to_fake = this.convertToFakePercent(this.coords.p_to_real);
break;
case "both":
if (this.options.from_fixed || this.options.to_fixed) {
break;
}
handle_x = this.toFixed(handle_x + (this.coords.p_handle * 0.001));
this.coords.p_from_real = this.convertToRealPercent(handle_x) - this.coords.p_gap_left;
this.coords.p_from_real = this.calcWithStep(this.coords.p_from_real);
this.coords.p_from_real = this.checkDiapason(this.coords.p_from_real, this.options.from_min, this.options.from_max);
this.coords.p_from_real = this.checkMinInterval(this.coords.p_from_real, this.coords.p_to_real, "from");
this.coords.p_from_fake = this.convertToFakePercent(this.coords.p_from_real);
this.coords.p_to_real = this.convertToRealPercent(handle_x) + this.coords.p_gap_right;
this.coords.p_to_real = this.calcWithStep(this.coords.p_to_real);
this.coords.p_to_real = this.checkDiapason(this.coords.p_to_real, this.options.to_min, this.options.to_max);
this.coords.p_to_real = this.checkMinInterval(this.coords.p_to_real, this.coords.p_from_real, "to");
this.coords.p_to_fake = this.convertToFakePercent(this.coords.p_to_real);
break;
case "both_one":
if (this.options.from_fixed || this.options.to_fixed) {
break;
}
var real_x = this.convertToRealPercent(handle_x),
from = this.result.from_percent,
to = this.result.to_percent,
full = to - from,
half = full / 2,
new_from = real_x - half,
new_to = real_x + half;
if (new_from < 0) {
new_from = 0;
new_to = new_from + full;
}
if (new_to > 100) {
new_to = 100;
new_from = new_to - full;
}
this.coords.p_from_real = this.calcWithStep(new_from);
this.coords.p_from_real = this.checkDiapason(this.coords.p_from_real, this.options.from_min, this.options.from_max);
this.coords.p_from_fake = this.convertToFakePercent(this.coords.p_from_real);
this.coords.p_to_real = this.calcWithStep(new_to);
this.coords.p_to_real = this.checkDiapason(this.coords.p_to_real, this.options.to_min, this.options.to_max);
this.coords.p_to_fake = this.convertToFakePercent(this.coords.p_to_real);
break;
}
if (this.options.type === "single") {
this.coords.p_bar_x = (this.coords.p_handle / 2);
this.coords.p_bar_w = this.coords.p_single_fake;
this.result.from_percent = this.coords.p_single_real;
this.result.from = this.convertToValue(this.coords.p_single_real);
this.result.from_pretty = this._prettify(this.result.from);
if (this.options.values.length) {
this.result.from_value = this.options.values[this.result.from];
}
} else {
this.coords.p_bar_x = this.toFixed(this.coords.p_from_fake + (this.coords.p_handle / 2));
this.coords.p_bar_w = this.toFixed(this.coords.p_to_fake - this.coords.p_from_fake);
this.result.from_percent = this.coords.p_from_real;
this.result.from = this.convertToValue(this.coords.p_from_real);
this.result.from_pretty = this._prettify(this.result.from);
this.result.to_percent = this.coords.p_to_real;
this.result.to = this.convertToValue(this.coords.p_to_real);
this.result.to_pretty = this._prettify(this.result.to);
if (this.options.values.length) {
this.result.from_value = this.options.values[this.result.from];
this.result.to_value = this.options.values[this.result.to];
}
}
this.calcMinMax();
this.calcLabels();
},
calcPointerPercent: function () {
if (!this.coords.w_rs) {
this.coords.p_pointer = 0;
return;
}
if (this.coords.x_pointer < 0 || isNaN(this.coords.x_pointer)  ) {
this.coords.x_pointer = 0;
} else if (this.coords.x_pointer > this.coords.w_rs) {
this.coords.x_pointer = this.coords.w_rs;
}
this.coords.p_pointer = this.toFixed(this.coords.x_pointer / this.coords.w_rs * 100);
},
convertToRealPercent: function (fake) {
var full = 100 - this.coords.p_handle;
return fake / full * 100;
},
convertToFakePercent: function (real) {
var full = 100 - this.coords.p_handle;
return real / 100 * full;
},
getHandleX: function () {
var max = 100 - this.coords.p_handle,
x = this.toFixed(this.coords.p_pointer - this.coords.p_gap);
if (x < 0) {
x = 0;
} else if (x > max) {
x = max;
}
return x;
},
calcHandlePercent: function () {
if (this.options.type === "single") {
this.coords.w_handle = this.$cache.s_single.outerWidth(false);
} else {
this.coords.w_handle = this.$cache.s_from.outerWidth(false);
}
this.coords.p_handle = this.toFixed(this.coords.w_handle / this.coords.w_rs * 100);
},
chooseHandle: function (real_x) {
if (this.options.type === "single") {
return "single";
} else {
var m_point = this.coords.p_from_real + ((this.coords.p_to_real - this.coords.p_from_real) / 2);
if (real_x >= m_point) {
return this.options.to_fixed ? "from" : "to";
} else {
return this.options.from_fixed ? "to" : "from";
}
}
},
calcMinMax: function () {
if (!this.coords.w_rs) {
return;
}
this.labels.p_min = this.labels.w_min / this.coords.w_rs * 100;
this.labels.p_max = this.labels.w_max / this.coords.w_rs * 100;
},
calcLabels: function () {
if (!this.coords.w_rs || this.options.hide_from_to) {
return;
}
if (this.options.type === "single") {
this.labels.w_single = this.$cache.single.outerWidth(false);
this.labels.p_single_fake = this.labels.w_single / this.coords.w_rs * 100;
this.labels.p_single_left = this.coords.p_single_fake + (this.coords.p_handle / 2) - (this.labels.p_single_fake / 2);
this.labels.p_single_left = this.checkEdges(this.labels.p_single_left, this.labels.p_single_fake);
} else {
this.labels.w_from = this.$cache.from.outerWidth(false);
this.labels.p_from_fake = this.labels.w_from / this.coords.w_rs * 100;
this.labels.p_from_left = this.coords.p_from_fake + (this.coords.p_handle / 2) - (this.labels.p_from_fake / 2);
this.labels.p_from_left = this.toFixed(this.labels.p_from_left);
this.labels.p_from_left = this.checkEdges(this.labels.p_from_left, this.labels.p_from_fake);
this.labels.w_to = this.$cache.to.outerWidth(false);
this.labels.p_to_fake = this.labels.w_to / this.coords.w_rs * 100;
this.labels.p_to_left = this.coords.p_to_fake + (this.coords.p_handle / 2) - (this.labels.p_to_fake / 2);
this.labels.p_to_left = this.toFixed(this.labels.p_to_left);
this.labels.p_to_left = this.checkEdges(this.labels.p_to_left, this.labels.p_to_fake);
this.labels.w_single = this.$cache.single.outerWidth(false);
this.labels.p_single_fake = this.labels.w_single / this.coords.w_rs * 100;
this.labels.p_single_left = ((this.labels.p_from_left + this.labels.p_to_left + this.labels.p_to_fake) / 2) - (this.labels.p_single_fake / 2);
this.labels.p_single_left = this.toFixed(this.labels.p_single_left);
this.labels.p_single_left = this.checkEdges(this.labels.p_single_left, this.labels.p_single_fake);
}
},
updateScene: function () {
if (this.raf_id) {
cancelAnimationFrame(this.raf_id);
this.raf_id = null;
}
clearTimeout(this.update_tm);
this.update_tm = null;
if (!this.options) {
return;
}
this.drawHandles();
if (this.is_active) {
this.raf_id = requestAnimationFrame(this.updateScene.bind(this));
} else {
this.update_tm = setTimeout(this.updateScene.bind(this), 300);
}
},
drawHandles: function () {
this.coords.w_rs = this.$cache.rs.outerWidth(false);
if (!this.coords.w_rs) {
return;
}
if (this.coords.w_rs !== this.coords.w_rs_old) {
this.target = "base";
this.is_resize = true;
}
if (this.coords.w_rs !== this.coords.w_rs_old || this.force_redraw) {
this.setMinMax();
this.calc(true);
this.drawLabels();
if (this.options.grid) {
this.calcGridMargin();
this.calcGridLabels();
}
this.force_redraw = true;
this.coords.w_rs_old = this.coords.w_rs;
this.drawShadow();
}
if (!this.coords.w_rs) {
return;
}
if (!this.dragging && !this.force_redraw && !this.is_key) {
return;
}
if (this.old_from !== this.result.from || this.old_to !== this.result.to || this.force_redraw || this.is_key) {
this.drawLabels();
this.$cache.bar[0].style.left = this.coords.p_bar_x + "%";
this.$cache.bar[0].style.width = this.coords.p_bar_w + "%";
if (this.options.type === "single") {
this.$cache.s_single[0].style.left = this.coords.p_single_fake + "%";
this.$cache.single[0].style.left = this.labels.p_single_left + "%";
} else {
this.$cache.s_from[0].style.left = this.coords.p_from_fake + "%";
this.$cache.s_to[0].style.left = this.coords.p_to_fake + "%";
if (this.old_from !== this.result.from || this.force_redraw) {
this.$cache.from[0].style.left = this.labels.p_from_left + "%";
}
if (this.old_to !== this.result.to || this.force_redraw) {
this.$cache.to[0].style.left = this.labels.p_to_left + "%";
}
this.$cache.single[0].style.left = this.labels.p_single_left + "%";
}
this.writeToInput();
if ((this.old_from !== this.result.from || this.old_to !== this.result.to) && !this.is_start) {
this.$cache.input.trigger("change");
this.$cache.input.trigger("input");
}
this.old_from = this.result.from;
this.old_to = this.result.to;
if (!this.is_resize && !this.is_update && !this.is_start && !this.is_finish) {
this.callOnChange();
}
if (this.is_key || this.is_click) {
this.is_key = false;
this.is_click = false;
this.callOnFinish();
}
this.is_update = false;
this.is_resize = false;
this.is_finish = false;
}
this.is_start = false;
this.is_key = false;
this.is_click = false;
this.force_redraw = false;
},
drawLabels: function () {
if (!this.options) {
return;
}
var values_num = this.options.values.length;
var p_values = this.options.p_values;
var text_single;
var text_from;
var text_to;
var from_pretty;
var to_pretty;
if (this.options.hide_from_to) {
return;
}
if (this.options.type === "single") {
if (values_num) {
text_single = this.decorate(p_values[this.result.from]);
this.$cache.single.html(text_single);
} else {
from_pretty = this._prettify(this.result.from);
text_single = this.decorate(from_pretty, this.result.from);
this.$cache.single.html(text_single);
}
this.calcLabels();
if (this.labels.p_single_left < this.labels.p_min + 1) {
this.$cache.min[0].style.visibility = "hidden";
} else {
this.$cache.min[0].style.visibility = "visible";
}
if (this.labels.p_single_left + this.labels.p_single_fake > 100 - this.labels.p_max - 1) {
this.$cache.max[0].style.visibility = "hidden";
} else {
this.$cache.max[0].style.visibility = "visible";
}
} else {
if (values_num) {
if (this.options.decorate_both) {
text_single = this.decorate(p_values[this.result.from]);
text_single += this.options.values_separator;
text_single += this.decorate(p_values[this.result.to]);
} else {
text_single = this.decorate(p_values[this.result.from] + this.options.values_separator + p_values[this.result.to]);
}
text_from = this.decorate(p_values[this.result.from]);
text_to = this.decorate(p_values[this.result.to]);
this.$cache.single.html(text_single);
this.$cache.from.html(text_from);
this.$cache.to.html(text_to);
} else {
from_pretty = this._prettify(this.result.from);
to_pretty = this._prettify(this.result.to);
if (this.options.decorate_both) {
text_single = this.decorate(from_pretty, this.result.from);
text_single += this.options.values_separator;
text_single += this.decorate(to_pretty, this.result.to);
} else {
text_single = this.decorate(from_pretty + this.options.values_separator + to_pretty, this.result.to);
}
text_from = this.decorate(from_pretty, this.result.from);
text_to = this.decorate(to_pretty, this.result.to);
this.$cache.single.html(text_single);
this.$cache.from.html(text_from);
this.$cache.to.html(text_to);
}
this.calcLabels();
var min = Math.min(this.labels.p_single_left, this.labels.p_from_left),
single_left = this.labels.p_single_left + this.labels.p_single_fake,
to_left = this.labels.p_to_left + this.labels.p_to_fake,
max = Math.max(single_left, to_left);
if (this.labels.p_from_left + this.labels.p_from_fake >= this.labels.p_to_left) {
this.$cache.from[0].style.visibility = "hidden";
this.$cache.to[0].style.visibility = "hidden";
this.$cache.single[0].style.visibility = "visible";
if (this.result.from === this.result.to) {
if (this.target === "from") {
this.$cache.from[0].style.visibility = "visible";
} else if (this.target === "to") {
this.$cache.to[0].style.visibility = "visible";
} else if (!this.target) {
this.$cache.from[0].style.visibility = "visible";
}
this.$cache.single[0].style.visibility = "hidden";
max = to_left;
} else {
this.$cache.from[0].style.visibility = "hidden";
this.$cache.to[0].style.visibility = "hidden";
this.$cache.single[0].style.visibility = "visible";
max = Math.max(single_left, to_left);
}
} else {
this.$cache.from[0].style.visibility = "visible";
this.$cache.to[0].style.visibility = "visible";
this.$cache.single[0].style.visibility = "hidden";
}
if (min < this.labels.p_min + 1) {
this.$cache.min[0].style.visibility = "hidden";
} else {
this.$cache.min[0].style.visibility = "visible";
}
if (max > 100 - this.labels.p_max - 1) {
this.$cache.max[0].style.visibility = "hidden";
} else {
this.$cache.max[0].style.visibility = "visible";
}
}
},
drawShadow: function () {
var o = this.options,
c = this.$cache,
is_from_min = typeof o.from_min === "number" && !isNaN(o.from_min),
is_from_max = typeof o.from_max === "number" && !isNaN(o.from_max),
is_to_min = typeof o.to_min === "number" && !isNaN(o.to_min),
is_to_max = typeof o.to_max === "number" && !isNaN(o.to_max),
from_min,
from_max,
to_min,
to_max;
if (o.type === "single") {
if (o.from_shadow && (is_from_min || is_from_max)) {
from_min = this.convertToPercent(is_from_min ? o.from_min : o.min);
from_max = this.convertToPercent(is_from_max ? o.from_max : o.max) - from_min;
from_min = this.toFixed(from_min - (this.coords.p_handle / 100 * from_min));
from_max = this.toFixed(from_max - (this.coords.p_handle / 100 * from_max));
from_min = from_min + (this.coords.p_handle / 2);
c.shad_single[0].style.display = "block";
c.shad_single[0].style.left = from_min + "%";
c.shad_single[0].style.width = from_max + "%";
} else {
c.shad_single[0].style.display = "none";
}
} else {
if (o.from_shadow && (is_from_min || is_from_max)) {
from_min = this.convertToPercent(is_from_min ? o.from_min : o.min);
from_max = this.convertToPercent(is_from_max ? o.from_max : o.max) - from_min;
from_min = this.toFixed(from_min - (this.coords.p_handle / 100 * from_min));
from_max = this.toFixed(from_max - (this.coords.p_handle / 100 * from_max));
from_min = from_min + (this.coords.p_handle / 2);
c.shad_from[0].style.display = "block";
c.shad_from[0].style.left = from_min + "%";
c.shad_from[0].style.width = from_max + "%";
} else {
c.shad_from[0].style.display = "none";
}
if (o.to_shadow && (is_to_min || is_to_max)) {
to_min = this.convertToPercent(is_to_min ? o.to_min : o.min);
to_max = this.convertToPercent(is_to_max ? o.to_max : o.max) - to_min;
to_min = this.toFixed(to_min - (this.coords.p_handle / 100 * to_min));
to_max = this.toFixed(to_max - (this.coords.p_handle / 100 * to_max));
to_min = to_min + (this.coords.p_handle / 2);
c.shad_to[0].style.display = "block";
c.shad_to[0].style.left = to_min + "%";
c.shad_to[0].style.width = to_max + "%";
} else {
c.shad_to[0].style.display = "none";
}
}
},
writeToInput: function () {
if (this.options.type === "single") {
if (this.options.values.length) {
this.$cache.input.prop("value", this.result.from_value);
} else {
this.$cache.input.prop("value", this.result.from);
}
this.$cache.input.data("from", this.result.from);
} else {
if (this.options.values.length) {
this.$cache.input.prop("value", this.result.from_value + this.options.input_values_separator + this.result.to_value);
} else {
this.$cache.input.prop("value", this.result.from + this.options.input_values_separator + this.result.to);
}
this.$cache.input.data("from", this.result.from);
this.$cache.input.data("to", this.result.to);
}
},
callOnStart: function () {
this.writeToInput();
if (this.options.onStart && typeof this.options.onStart === "function") {
if (this.options.scope) {
this.options.onStart.call(this.options.scope, this.result);
} else {
this.options.onStart(this.result);
}
}
},
callOnChange: function () {
this.writeToInput();
if (this.options.onChange && typeof this.options.onChange === "function") {
if (this.options.scope) {
this.options.onChange.call(this.options.scope, this.result);
} else {
this.options.onChange(this.result);
}
}
},
callOnFinish: function () {
this.writeToInput();
if (this.options.onFinish && typeof this.options.onFinish === "function") {
if (this.options.scope) {
this.options.onFinish.call(this.options.scope, this.result);
} else {
this.options.onFinish(this.result);
}
}
},
callOnUpdate: function () {
this.writeToInput();
if (this.options.onUpdate && typeof this.options.onUpdate === "function") {
if (this.options.scope) {
this.options.onUpdate.call(this.options.scope, this.result);
} else {
this.options.onUpdate(this.result);
}
}
},
toggleInput: function () {
this.$cache.input.toggleClass("irs-hidden-input");
if (this.has_tab_index) {
this.$cache.input.prop("tabindex", -1);
} else {
this.$cache.input.removeProp("tabindex");
}
this.has_tab_index = !this.has_tab_index;
},
convertToPercent: function (value, no_min) {
var diapason = this.options.max - this.options.min,
one_percent = diapason / 100,
val, percent;
if (!diapason) {
this.no_diapason = true;
return 0;
}
if (no_min) {
val = value;
} else {
val = value - this.options.min;
}
percent = val / one_percent;
return this.toFixed(percent);
},
convertToValue: function (percent) {
var min = this.options.min,
max = this.options.max,
min_decimals = min.toString().split(".")[1],
max_decimals = max.toString().split(".")[1],
min_length, max_length,
avg_decimals = 0,
abs = 0;
if (percent === 0) {
return this.options.min;
}
if (percent === 100) {
return this.options.max;
}
if (min_decimals) {
min_length = min_decimals.length;
avg_decimals = min_length;
}
if (max_decimals) {
max_length = max_decimals.length;
avg_decimals = max_length;
}
if (min_length && max_length) {
avg_decimals = (min_length >= max_length) ? min_length : max_length;
}
if (min < 0) {
abs = Math.abs(min);
min = +(min + abs).toFixed(avg_decimals);
max = +(max + abs).toFixed(avg_decimals);
}
var number = ((max - min) / 100 * percent) + min,
string = this.options.step.toString().split(".")[1],
result;
if (string) {
number = +number.toFixed(string.length);
} else {
number = number / this.options.step;
number = number * this.options.step;
number = +number.toFixed(0);
}
if (abs) {
number -= abs;
}
if (string) {
result = +number.toFixed(string.length);
} else {
result = this.toFixed(number);
}
if (result < this.options.min) {
result = this.options.min;
} else if (result > this.options.max) {
result = this.options.max;
}
return result;
},
calcWithStep: function (percent) {
var rounded = Math.round(percent / this.coords.p_step) * this.coords.p_step;
if (rounded > 100) {
rounded = 100;
}
if (percent === 100) {
rounded = 100;
}
return this.toFixed(rounded);
},
checkMinInterval: function (p_current, p_next, type) {
var o = this.options,
current,
next;
if (!o.min_interval) {
return p_current;
}
current = this.convertToValue(p_current);
next = this.convertToValue(p_next);
if (type === "from") {
if (next - current < o.min_interval) {
current = next - o.min_interval;
}
} else {
if (current - next < o.min_interval) {
current = next + o.min_interval;
}
}
return this.convertToPercent(current);
},
checkMaxInterval: function (p_current, p_next, type) {
var o = this.options,
current,
next;
if (!o.max_interval) {
return p_current;
}
current = this.convertToValue(p_current);
next = this.convertToValue(p_next);
if (type === "from") {
if (next - current > o.max_interval) {
current = next - o.max_interval;
}
} else {
if (current - next > o.max_interval) {
current = next + o.max_interval;
}
}
return this.convertToPercent(current);
},
checkDiapason: function (p_num, min, max) {
var num = this.convertToValue(p_num),
o = this.options;
if (typeof min !== "number") {
min = o.min;
}
if (typeof max !== "number") {
max = o.max;
}
if (num < min) {
num = min;
}
if (num > max) {
num = max;
}
return this.convertToPercent(num);
},
toFixed: function (num) {
num = num.toFixed(20);
return +num;
},
_prettify: function (num) {
if (!this.options.prettify_enabled) {
return num;
}
if (this.options.prettify && typeof this.options.prettify === "function") {
return this.options.prettify(num);
} else {
return this.prettify(num);
}
},
prettify: function (num) {
var n = num.toString();
return n.replace(/(\d{1,3}(?=(?:\d\d\d)+(?!\d)))/g, "$1" + this.options.prettify_separator);
},
checkEdges: function (left, width) {
if (!this.options.force_edges) {
return this.toFixed(left);
}
if (left < 0) {
left = 0;
} else if (left > 100 - width) {
left = 100 - width;
}
return this.toFixed(left);
},
validate: function () {
var o = this.options,
r = this.result,
v = o.values,
vl = v.length,
value,
i;
if (typeof o.min === "string") o.min = +o.min;
if (typeof o.max === "string") o.max = +o.max;
if (typeof o.from === "string") o.from = +o.from;
if (typeof o.to === "string") o.to = +o.to;
if (typeof o.step === "string") o.step = +o.step;
if (typeof o.from_min === "string") o.from_min = +o.from_min;
if (typeof o.from_max === "string") o.from_max = +o.from_max;
if (typeof o.to_min === "string") o.to_min = +o.to_min;
if (typeof o.to_max === "string") o.to_max = +o.to_max;
if (typeof o.grid_num === "string") o.grid_num = +o.grid_num;
if (o.max < o.min) {
o.max = o.min;
}
if (vl) {
o.p_values = [];
o.min = 0;
o.max = vl - 1;
o.step = 1;
o.grid_num = o.max;
o.grid_snap = true;
for (i = 0; i < vl; i++) {
value = +v[i];
if (!isNaN(value)) {
v[i] = value;
value = this._prettify(value);
} else {
value = v[i];
}
o.p_values.push(value);
}
}
if (typeof o.from !== "number" || isNaN(o.from)) {
o.from = o.min;
}
if (typeof o.to !== "number" || isNaN(o.to)) {
o.to = o.max;
}
if (o.type === "single") {
if (o.from < o.min) o.from = o.min;
if (o.from > o.max) o.from = o.max;
} else {
if (o.from < o.min) o.from = o.min;
if (o.from > o.max) o.from = o.max;
if (o.to < o.min) o.to = o.min;
if (o.to > o.max) o.to = o.max;
if (this.update_check.from) {
if (this.update_check.from !== o.from) {
if (o.from > o.to) o.from = o.to;
}
if (this.update_check.to !== o.to) {
if (o.to < o.from) o.to = o.from;
}
}
if (o.from > o.to) o.from = o.to;
if (o.to < o.from) o.to = o.from;
}
if (typeof o.step !== "number" || isNaN(o.step) || !o.step || o.step < 0) {
o.step = 1;
}
if (typeof o.from_min === "number" && o.from < o.from_min) {
o.from = o.from_min;
}
if (typeof o.from_max === "number" && o.from > o.from_max) {
o.from = o.from_max;
}
if (typeof o.to_min === "number" && o.to < o.to_min) {
o.to = o.to_min;
}
if (typeof o.to_max === "number" && o.from > o.to_max) {
o.to = o.to_max;
}
if (r) {
if (r.min !== o.min) {
r.min = o.min;
}
if (r.max !== o.max) {
r.max = o.max;
}
if (r.from < r.min || r.from > r.max) {
r.from = o.from;
}
if (r.to < r.min || r.to > r.max) {
r.to = o.to;
}
}
if (typeof o.min_interval !== "number" || isNaN(o.min_interval) || !o.min_interval || o.min_interval < 0) {
o.min_interval = 0;
}
if (typeof o.max_interval !== "number" || isNaN(o.max_interval) || !o.max_interval || o.max_interval < 0) {
o.max_interval = 0;
}
if (o.min_interval && o.min_interval > o.max - o.min) {
o.min_interval = o.max - o.min;
}
if (o.max_interval && o.max_interval > o.max - o.min) {
o.max_interval = o.max - o.min;
}
},
decorate: function (num, original) {
var decorated = "",
o = this.options;
if (o.prefix) {
decorated += o.prefix;
}
decorated += num;
if (o.max_postfix) {
if (o.values.length && num === o.p_values[o.max]) {
decorated += o.max_postfix;
if (o.postfix) {
decorated += " ";
}
} else if (original === o.max) {
decorated += o.max_postfix;
if (o.postfix) {
decorated += " ";
}
}
}
if (o.postfix) {
decorated += o.postfix;
}
return decorated;
},
updateFrom: function () {
this.result.from = this.options.from;
this.result.from_percent = this.convertToPercent(this.result.from);
this.result.from_pretty = this._prettify(this.result.from);
if (this.options.values) {
this.result.from_value = this.options.values[this.result.from];
}
},
updateTo: function () {
this.result.to = this.options.to;
this.result.to_percent = this.convertToPercent(this.result.to);
this.result.to_pretty = this._prettify(this.result.to);
if (this.options.values) {
this.result.to_value = this.options.values[this.result.to];
}
},
updateResult: function () {
this.result.min = this.options.min;
this.result.max = this.options.max;
this.updateFrom();
this.updateTo();
},
appendGrid: function () {
if (!this.options.grid) {
return;
}
var o = this.options,
i, z,
total = o.max - o.min,
big_num = o.grid_num,
big_p = 0,
big_w = 0,
small_max = 4,
local_small_max,
small_p,
small_w = 0,
result,
html = '';
this.calcGridMargin();
if (o.grid_snap) {
if (total > 50) {
big_num = 50 / o.step;
big_p = this.toFixed(o.step / 0.5);
} else {
big_num = total / o.step;
big_p = this.toFixed(o.step / (total / 100));
}
} else {
big_p = this.toFixed(100 / big_num);
}
if (big_num > 4) {
small_max = 3;
}
if (big_num > 7) {
small_max = 2;
}
if (big_num > 14) {
small_max = 1;
}
if (big_num > 28) {
small_max = 0;
}
for (i = 0; i < big_num + 1; i++) {
local_small_max = small_max;
big_w = this.toFixed(big_p * i);
if (big_w > 100) {
big_w = 100;
}
this.coords.big[i] = big_w;
small_p = (big_w - (big_p * (i - 1))) / (local_small_max + 1);
for (z = 1; z <= local_small_max; z++) {
if (big_w === 0) {
break;
}
small_w = this.toFixed(big_w - (small_p * z));
html += '<span class="irs-grid-pol small" style="left: ' + small_w + '%"></span>';
}
html += '<span class="irs-grid-pol" style="left: ' + big_w + '%"></span>';
result = this.convertToValue(big_w);
if (o.values.length) {
result = o.p_values[result];
} else {
result = this._prettify(result);
}
html += '<span class="irs-grid-text js-grid-text-' + i + '" style="left: ' + big_w + '%">' + result + '</span>';
}
this.coords.big_num = Math.ceil(big_num + 1);
this.$cache.cont.addClass("irs-with-grid");
this.$cache.grid.html(html);
this.cacheGridLabels();
},
cacheGridLabels: function () {
var $label, i,
num = this.coords.big_num;
for (i = 0; i < num; i++) {
$label = this.$cache.grid.find(".js-grid-text-" + i);
this.$cache.grid_labels.push($label);
}
this.calcGridLabels();
},
calcGridLabels: function () {
var i, label, start = [], finish = [],
num = this.coords.big_num;
for (i = 0; i < num; i++) {
this.coords.big_w[i] = this.$cache.grid_labels[i].outerWidth(false);
this.coords.big_p[i] = this.toFixed(this.coords.big_w[i] / this.coords.w_rs * 100);
this.coords.big_x[i] = this.toFixed(this.coords.big_p[i] / 2);
start[i] = this.toFixed(this.coords.big[i] - this.coords.big_x[i]);
finish[i] = this.toFixed(start[i] + this.coords.big_p[i]);
}
if (this.options.force_edges) {
if (start[0] < -this.coords.grid_gap) {
start[0] = -this.coords.grid_gap;
finish[0] = this.toFixed(start[0] + this.coords.big_p[0]);
this.coords.big_x[0] = this.coords.grid_gap;
}
if (finish[num - 1] > 100 + this.coords.grid_gap) {
finish[num - 1] = 100 + this.coords.grid_gap;
start[num - 1] = this.toFixed(finish[num - 1] - this.coords.big_p[num - 1]);
this.coords.big_x[num - 1] = this.toFixed(this.coords.big_p[num - 1] - this.coords.grid_gap);
}
}
this.calcGridCollision(2, start, finish);
this.calcGridCollision(4, start, finish);
for (i = 0; i < num; i++) {
label = this.$cache.grid_labels[i][0];
if (this.coords.big_x[i] !== Number.POSITIVE_INFINITY) {
label.style.marginLeft = -this.coords.big_x[i] + "%";
}
}
},
calcGridCollision: function (step, start, finish) {
var i, next_i, label,
num = this.coords.big_num;
for (i = 0; i < num; i += step) {
next_i = i + (step / 2);
if (next_i >= num) {
break;
}
label = this.$cache.grid_labels[next_i][0];
if (finish[i] <= start[next_i]) {
label.style.visibility = "visible";
} else {
label.style.visibility = "hidden";
}
}
},
calcGridMargin: function () {
if (!this.options.grid_margin) {
return;
}
this.coords.w_rs = this.$cache.rs.outerWidth(false);
if (!this.coords.w_rs) {
return;
}
if (this.options.type === "single") {
this.coords.w_handle = this.$cache.s_single.outerWidth(false);
} else {
this.coords.w_handle = this.$cache.s_from.outerWidth(false);
}
this.coords.p_handle = this.toFixed(this.coords.w_handle  / this.coords.w_rs * 100);
this.coords.grid_gap = this.toFixed((this.coords.p_handle / 2) - 0.1);
this.$cache.grid[0].style.width = this.toFixed(100 - this.coords.p_handle) + "%";
this.$cache.grid[0].style.left = this.coords.grid_gap + "%";
},
update: function (options) {
if (!this.input) {
return;
}
this.is_update = true;
this.options.from = this.result.from;
this.options.to = this.result.to;
this.update_check.from = this.result.from;
this.update_check.to = this.result.to;
this.options = $.extend(this.options, options);
this.validate();
this.updateResult(options);
this.toggleInput();
this.remove();
this.init(true);
},
reset: function () {
if (!this.input) {
return;
}
this.updateResult();
this.update();
},
destroy: function () {
if (!this.input) {
return;
}
this.toggleInput();
this.$cache.input.prop("readonly", false);
$.data(this.input, "ionRangeSlider", null);
this.remove();
this.input = null;
this.options = null;
}
};
$.fn.ionRangeSlider = function (options) {
return this.each(function() {
if (!$.data(this, "ionRangeSlider")) {
$.data(this, "ionRangeSlider", new IonRangeSlider(this, options, plugin_count++));
}
});
};
(function() {
var lastTime = 0;
var vendors = ['ms', 'moz', 'webkit', 'o'];
for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];
window.cancelAnimationFrame = window[vendors[x]+'CancelAnimationFrame']
|| window[vendors[x]+'CancelRequestAnimationFrame'];
}
if (!window.requestAnimationFrame)
window.requestAnimationFrame = function(callback, element) {
var currTime = new Date().getTime();
var timeToCall = Math.max(0, 16 - (currTime - lastTime));
var id = window.setTimeout(function() { callback(currTime + timeToCall); },
timeToCall);
lastTime = currTime + timeToCall;
return id;
};
if (!window.cancelAnimationFrame)
window.cancelAnimationFrame = function(id) {
clearTimeout(id);
};
}());
}));
"use strict";
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
var Emitter = function () {
function Emitter() {
_classCallCheck(this, Emitter);
}
_createClass(Emitter, [{
key: "on",
value: function on(event, fn) {
this._callbacks = this._callbacks || {};
if (!this._callbacks[event]) {
this._callbacks[event] = [];
}
this._callbacks[event].push(fn);
return this;
}
}, {
key: "emit",
value: function emit(event) {
this._callbacks = this._callbacks || {};
var callbacks = this._callbacks[event];
if (callbacks) {
for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
args[_key - 1] = arguments[_key];
}
for (var _iterator = callbacks, _isArray = true, _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
var _ref;
if (_isArray) {
if (_i >= _iterator.length) break;
_ref = _iterator[_i++];
} else {
_i = _iterator.next();
if (_i.done) break;
_ref = _i.value;
}
var callback = _ref;
callback.apply(this, args);
}
}
return this;
}
}, {
key: "off",
value: function off(event, fn) {
if (!this._callbacks || arguments.length === 0) {
this._callbacks = {};
return this;
}
var callbacks = this._callbacks[event];
if (!callbacks) {
return this;
}
if (arguments.length === 1) {
delete this._callbacks[event];
return this;
}
for (var i = 0; i < callbacks.length; i++) {
var callback = callbacks[i];
if (callback === fn) {
callbacks.splice(i, 1);
break;
}
}
return this;
}
}]);
return Emitter;
}();
var Dropzone = function (_Emitter) {
_inherits(Dropzone, _Emitter);
_createClass(Dropzone, null, [{
key: "initClass",
value: function initClass() {
this.prototype.Emitter = Emitter;
this.prototype.events = ["drop", "dragstart", "dragend", "dragenter", "dragover", "dragleave", "addedfile", "addedfiles", "removedfile", "thumbnail", "error", "errormultiple", "processing", "processingmultiple", "uploadprogress", "totaluploadprogress", "sending", "sendingmultiple", "success", "successmultiple", "canceled", "canceledmultiple", "complete", "completemultiple", "reset", "maxfilesexceeded", "maxfilesreached", "queuecomplete"];
this.prototype.defaultOptions = {
url: null,
method: "post",
withCredentials: false,
timeout: 30000,
parallelUploads: 2,
uploadMultiple: false,
chunking: false,
forceChunking: false,
chunkSize: 2000000,
parallelChunkUploads: false,
retryChunks: false,
retryChunksLimit: 3,
maxFilesize: 256,
paramName: "file",
createImageThumbnails: true,
maxThumbnailFilesize: 10,
thumbnailWidth: 120,
thumbnailHeight: 120,
thumbnailMethod: 'crop',
resizeWidth: null,
resizeHeight: null,
resizeMimeType: null,
resizeQuality: 0.8,
resizeMethod: 'contain',
filesizeBase: 1000,
maxFiles: null,
headers: null,
clickable: true,
ignoreHiddenFiles: true,
acceptedFiles: null,
acceptedMimeTypes: null,
autoProcessQueue: true,
autoQueue: true,
addRemoveLinks: false,
previewsContainer: null,
hiddenInputContainer: "body",
capture: null,
renameFilename: null,
renameFile: null,
forceFallback: false,
dictDefaultMessage: "Drop files here to upload",
dictFallbackMessage: "Your browser does not support drag'n'drop file uploads.",
dictFallbackText: "Please use the fallback form below to upload your files like in the olden days.",
dictFileTooBig: "File is too big ({{filesize}}MiB). Max filesize: {{maxFilesize}}MiB.",
dictInvalidFileType: "You can't upload files of this type.",
dictResponseError: "Server responded with {{statusCode}} code.",
dictCancelUpload: "Cancel upload",
dictCancelUploadConfirmation: "Are you sure you want to cancel this upload?",
dictRemoveFile: "Remove file",
dictRemoveFileConfirmation: null,
dictMaxFilesExceeded: "You can not upload any more files.",
dictFileSizeUnits: { tb: "TB", gb: "GB", mb: "MB", kb: "KB", b: "b" },
init: function init() {},
params: function params(files, xhr, chunk) {
if (chunk) {
return {
dzuuid: chunk.file.upload.uuid,
dzchunkindex: chunk.index,
dztotalfilesize: chunk.file.size,
dzchunksize: this.options.chunkSize,
dztotalchunkcount: chunk.file.upload.totalChunkCount,
dzchunkbyteoffset: chunk.index * this.options.chunkSize
};
}
},
accept: function accept(file, done) {
return done();
},
chunksUploaded: function chunksUploaded(file, done) {
done();
},
fallback: function fallback() {
var messageElement = void 0;
this.element.className = this.element.className + " dz-browser-not-supported";
for (var _iterator2 = this.element.getElementsByTagName("div"), _isArray2 = true, _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
var _ref2;
if (_isArray2) {
if (_i2 >= _iterator2.length) break;
_ref2 = _iterator2[_i2++];
} else {
_i2 = _iterator2.next();
if (_i2.done) break;
_ref2 = _i2.value;
}
var child = _ref2;
if (/(^| )dz-message($| )/.test(child.className)) {
messageElement = child;
child.className = "dz-message"; // Removes the 'dz-default' class
break;
}
}
if (!messageElement) {
messageElement = Dropzone.createElement("<div class=\"dz-message\"><span></span></div>");
this.element.appendChild(messageElement);
}
var span = messageElement.getElementsByTagName("span")[0];
if (span) {
if (span.textContent != null) {
span.textContent = this.options.dictFallbackMessage;
} else if (span.innerText != null) {
span.innerText = this.options.dictFallbackMessage;
}
}
return this.element.appendChild(this.getFallbackForm());
},
resize: function resize(file, width, height, resizeMethod) {
var info = {
srcX: 0,
srcY: 0,
srcWidth: file.width,
srcHeight: file.height
};
var srcRatio = file.width / file.height;
if (width == null && height == null) {
width = info.srcWidth;
height = info.srcHeight;
} else if (width == null) {
width = height * srcRatio;
} else if (height == null) {
height = width / srcRatio;
}
width = Math.min(width, info.srcWidth);
height = Math.min(height, info.srcHeight);
var trgRatio = width / height;
if (info.srcWidth > width || info.srcHeight > height) {
if (resizeMethod === 'crop') {
if (srcRatio > trgRatio) {
info.srcHeight = file.height;
info.srcWidth = info.srcHeight * trgRatio;
} else {
info.srcWidth = file.width;
info.srcHeight = info.srcWidth / trgRatio;
}
} else if (resizeMethod === 'contain') {
if (srcRatio > trgRatio) {
height = width / srcRatio;
} else {
width = height * srcRatio;
}
} else {
throw new Error("Unknown resizeMethod '" + resizeMethod + "'");
}
}
info.srcX = (file.width - info.srcWidth) / 2;
info.srcY = (file.height - info.srcHeight) / 2;
info.trgWidth = width;
info.trgHeight = height;
return info;
},
transformFile: function transformFile(file, done) {
if ((this.options.resizeWidth || this.options.resizeHeight) && file.type.match(/image.*/)) {
return this.resizeImage(file, this.options.resizeWidth, this.options.resizeHeight, this.options.resizeMethod, done);
} else {
return done(file);
}
},
previewTemplate: "<div class=\"dz-preview dz-file-preview\">\n  <div class=\"dz-image\"><img data-dz-thumbnail /></div>\n  <div class=\"dz-details\">\n    <div class=\"dz-size\"><span data-dz-size></span></div>\n    <div class=\"dz-filename\"><span data-dz-name></span></div>\n  </div>\n  <div class=\"dz-progress\"><span class=\"dz-upload\" data-dz-uploadprogress></span></div>\n  <div class=\"dz-error-message\"><span data-dz-errormessage></span></div>\n  <div class=\"dz-success-mark\">\n    <svg width=\"54px\" height=\"54px\" viewBox=\"0 0 54 54\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns:sketch=\"http://www.bohemiancoding.com/sketch/ns\">\n      <title>Check</title>\n      <defs></defs>\n      <g id=\"Page-1\" stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\" sketch:type=\"MSPage\">\n        <path d=\"M23.5,31.8431458 L17.5852419,25.9283877 C16.0248253,24.3679711 13.4910294,24.366835 11.9289322,25.9289322 C10.3700136,27.4878508 10.3665912,30.0234455 11.9283877,31.5852419 L20.4147581,40.0716123 C20.5133999,40.1702541 20.6159315,40.2626649 20.7218615,40.3488435 C22.2835669,41.8725651 24.794234,41.8626202 26.3461564,40.3106978 L43.3106978,23.3461564 C44.8771021,21.7797521 44.8758057,19.2483887 43.3137085,17.6862915 C41.7547899,16.1273729 39.2176035,16.1255422 37.6538436,17.6893022 L23.5,31.8431458 Z M27,53 C41.3594035,53 53,41.3594035 53,27 C53,12.6405965 41.3594035,1 27,1 C12.6405965,1 1,12.6405965 1,27 C1,41.3594035 12.6405965,53 27,53 Z\" id=\"Oval-2\" stroke-opacity=\"0.198794158\" stroke=\"#747474\" fill-opacity=\"0.816519475\" fill=\"#FFFFFF\" sketch:type=\"MSShapeGroup\"></path>\n      </g>\n    </svg>\n  </div>\n  <div class=\"dz-error-mark\">\n    <svg width=\"54px\" height=\"54px\" viewBox=\"0 0 54 54\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns:sketch=\"http://www.bohemiancoding.com/sketch/ns\">\n      <title>Error</title>\n      <defs></defs>\n      <g id=\"Page-1\" stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\" sketch:type=\"MSPage\">\n        <g id=\"Check-+-Oval-2\" sketch:type=\"MSLayerGroup\" stroke=\"#747474\" stroke-opacity=\"0.198794158\" fill=\"#FFFFFF\" fill-opacity=\"0.816519475\">\n          <path d=\"M32.6568542,29 L38.3106978,23.3461564 C39.8771021,21.7797521 39.8758057,19.2483887 38.3137085,17.6862915 C36.7547899,16.1273729 34.2176035,16.1255422 32.6538436,17.6893022 L27,23.3431458 L21.3461564,17.6893022 C19.7823965,16.1255422 17.2452101,16.1273729 15.6862915,17.6862915 C14.1241943,19.2483887 14.1228979,21.7797521 15.6893022,23.3461564 L21.3431458,29 L15.6893022,34.6538436 C14.1228979,36.2202479 14.1241943,38.7516113 15.6862915,40.3137085 C17.2452101,41.8726271 19.7823965,41.8744578 21.3461564,40.3106978 L27,34.6568542 L32.6538436,40.3106978 C34.2176035,41.8744578 36.7547899,41.8726271 38.3137085,40.3137085 C39.8758057,38.7516113 39.8771021,36.2202479 38.3106978,34.6538436 L32.6568542,29 Z M27,53 C41.3594035,53 53,41.3594035 53,27 C53,12.6405965 41.3594035,1 27,1 C12.6405965,1 1,12.6405965 1,27 C1,41.3594035 12.6405965,53 27,53 Z\" id=\"Oval-2\" sketch:type=\"MSShapeGroup\"></path>\n        </g>\n      </g>\n    </svg>\n  </div>\n</div>",
drop: function drop(e) {
return this.element.classList.remove("dz-drag-hover");
},
dragstart: function dragstart(e) {},
dragend: function dragend(e) {
return this.element.classList.remove("dz-drag-hover");
},
dragenter: function dragenter(e) {
return this.element.classList.add("dz-drag-hover");
},
dragover: function dragover(e) {
return this.element.classList.add("dz-drag-hover");
},
dragleave: function dragleave(e) {
return this.element.classList.remove("dz-drag-hover");
},
paste: function paste(e) {},
reset: function reset() {
return this.element.classList.remove("dz-started");
},
addedfile: function addedfile(file) {
var _this2 = this;
if (this.element === this.previewsContainer) {
this.element.classList.add("dz-started");
}
if (this.previewsContainer) {
file.previewElement = Dropzone.createElement(this.options.previewTemplate.trim());
file.previewTemplate = file.previewElement; // Backwards compatibility
this.previewsContainer.appendChild(file.previewElement);
for (var _iterator3 = file.previewElement.querySelectorAll("[data-dz-name]"), _isArray3 = true, _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
var _ref3;
if (_isArray3) {
if (_i3 >= _iterator3.length) break;
_ref3 = _iterator3[_i3++];
} else {
_i3 = _iterator3.next();
if (_i3.done) break;
_ref3 = _i3.value;
}
var node = _ref3;
node.textContent = file.name;
}
for (var _iterator4 = file.previewElement.querySelectorAll("[data-dz-size]"), _isArray4 = true, _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {
if (_isArray4) {
if (_i4 >= _iterator4.length) break;
node = _iterator4[_i4++];
} else {
_i4 = _iterator4.next();
if (_i4.done) break;
node = _i4.value;
}
node.innerHTML = this.filesize(file.size);
}
if (this.options.addRemoveLinks) {
file._removeLink = Dropzone.createElement("<a class=\"dz-remove\" href=\"javascript:undefined;\" data-dz-remove>" + this.options.dictRemoveFile + "</a>");
file.previewElement.appendChild(file._removeLink);
}
var removeFileEvent = function removeFileEvent(e) {
e.preventDefault();
e.stopPropagation();
if (file.status === Dropzone.UPLOADING) {
return Dropzone.confirm(_this2.options.dictCancelUploadConfirmation, function () {
return _this2.removeFile(file);
});
} else {
if (_this2.options.dictRemoveFileConfirmation) {
return Dropzone.confirm(_this2.options.dictRemoveFileConfirmation, function () {
return _this2.removeFile(file);
});
} else {
return _this2.removeFile(file);
}
}
};
for (var _iterator5 = file.previewElement.querySelectorAll("[data-dz-remove]"), _isArray5 = true, _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;) {
var _ref4;
if (_isArray5) {
if (_i5 >= _iterator5.length) break;
_ref4 = _iterator5[_i5++];
} else {
_i5 = _iterator5.next();
if (_i5.done) break;
_ref4 = _i5.value;
}
var removeLink = _ref4;
removeLink.addEventListener("click", removeFileEvent);
}
}
},
removedfile: function removedfile(file) {
if (file.previewElement != null && file.previewElement.parentNode != null) {
file.previewElement.parentNode.removeChild(file.previewElement);
}
return this._updateMaxFilesReachedClass();
},
thumbnail: function thumbnail(file, dataUrl) {
if (file.previewElement) {
file.previewElement.classList.remove("dz-file-preview");
for (var _iterator6 = file.previewElement.querySelectorAll("[data-dz-thumbnail]"), _isArray6 = true, _i6 = 0, _iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator]();;) {
var _ref5;
if (_isArray6) {
if (_i6 >= _iterator6.length) break;
_ref5 = _iterator6[_i6++];
} else {
_i6 = _iterator6.next();
if (_i6.done) break;
_ref5 = _i6.value;
}
var thumbnailElement = _ref5;
thumbnailElement.alt = file.name;
thumbnailElement.src = dataUrl;
}
return setTimeout(function () {
return file.previewElement.classList.add("dz-image-preview");
}, 1);
}
},
error: function error(file, message) {
if (file.previewElement) {
file.previewElement.classList.add("dz-error");
if (typeof message !== "String" && message.error) {
message = message.error;
}
for (var _iterator7 = file.previewElement.querySelectorAll("[data-dz-errormessage]"), _isArray7 = true, _i7 = 0, _iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator]();;) {
var _ref6;
if (_isArray7) {
if (_i7 >= _iterator7.length) break;
_ref6 = _iterator7[_i7++];
} else {
_i7 = _iterator7.next();
if (_i7.done) break;
_ref6 = _i7.value;
}
var node = _ref6;
node.textContent = message;
}
}
},
errormultiple: function errormultiple() {},
processing: function processing(file) {
if (file.previewElement) {
file.previewElement.classList.add("dz-processing");
if (file._removeLink) {
return file._removeLink.textContent = this.options.dictCancelUpload;
}
}
},
processingmultiple: function processingmultiple() {},
uploadprogress: function uploadprogress(file, progress, bytesSent) {
if (file.previewElement) {
for (var _iterator8 = file.previewElement.querySelectorAll("[data-dz-uploadprogress]"), _isArray8 = true, _i8 = 0, _iterator8 = _isArray8 ? _iterator8 : _iterator8[Symbol.iterator]();;) {
var _ref7;
if (_isArray8) {
if (_i8 >= _iterator8.length) break;
_ref7 = _iterator8[_i8++];
} else {
_i8 = _iterator8.next();
if (_i8.done) break;
_ref7 = _i8.value;
}
var node = _ref7;
node.nodeName === 'PROGRESS' ? node.value = progress : node.style.width = progress + "%";
}
}
},
totaluploadprogress: function totaluploadprogress() {},
sending: function sending() {},
sendingmultiple: function sendingmultiple() {},
success: function success(file) {
if (file.previewElement) {
return file.previewElement.classList.add("dz-success");
}
},
successmultiple: function successmultiple() {},
canceled: function canceled(file) {
return this.emit("error", file, "Upload canceled.");
},
canceledmultiple: function canceledmultiple() {},
complete: function complete(file) {
if (file._removeLink) {
file._removeLink.textContent = this.options.dictRemoveFile;
}
if (file.previewElement) {
return file.previewElement.classList.add("dz-complete");
}
},
completemultiple: function completemultiple() {},
maxfilesexceeded: function maxfilesexceeded() {},
maxfilesreached: function maxfilesreached() {},
queuecomplete: function queuecomplete() {},
addedfiles: function addedfiles() {}
};
this.prototype._thumbnailQueue = [];
this.prototype._processingThumbnail = false;
}
}, {
key: "extend",
value: function extend(target) {
for (var _len2 = arguments.length, objects = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
objects[_key2 - 1] = arguments[_key2];
}
for (var _iterator9 = objects, _isArray9 = true, _i9 = 0, _iterator9 = _isArray9 ? _iterator9 : _iterator9[Symbol.iterator]();;) {
var _ref8;
if (_isArray9) {
if (_i9 >= _iterator9.length) break;
_ref8 = _iterator9[_i9++];
} else {
_i9 = _iterator9.next();
if (_i9.done) break;
_ref8 = _i9.value;
}
var object = _ref8;
for (var key in object) {
var val = object[key];
target[key] = val;
}
}
return target;
}
}]);
function Dropzone(el, options) {
_classCallCheck(this, Dropzone);
var _this = _possibleConstructorReturn(this, (Dropzone.__proto__ || Object.getPrototypeOf(Dropzone)).call(this));
var fallback = void 0,
left = void 0;
_this.element = el;
_this.version = Dropzone.version;
_this.defaultOptions.previewTemplate = _this.defaultOptions.previewTemplate.replace(/\n*/g, "");
_this.clickableElements = [];
_this.listeners = [];
_this.files = []; // All files
if (typeof _this.element === "string") {
_this.element = document.querySelector(_this.element);
}
if (!_this.element || _this.element.nodeType == null) {
throw new Error("Invalid dropzone element.");
}
if (_this.element.dropzone) {
throw new Error("Dropzone already attached.");
}
Dropzone.instances.push(_this);
_this.element.dropzone = _this;
var elementOptions = (left = Dropzone.optionsForElement(_this.element)) != null ? left : {};
_this.options = Dropzone.extend({}, _this.defaultOptions, elementOptions, options != null ? options : {});
if (_this.options.forceFallback || !Dropzone.isBrowserSupported()) {
var _ret;
return _ret = _this.options.fallback.call(_this), _possibleConstructorReturn(_this, _ret);
}
if (_this.options.url == null) {
_this.options.url = _this.element.getAttribute("action");
}
if (!_this.options.url) {
throw new Error("No URL provided.");
}
if (_this.options.acceptedFiles && _this.options.acceptedMimeTypes) {
throw new Error("You can't provide both 'acceptedFiles' and 'acceptedMimeTypes'. 'acceptedMimeTypes' is deprecated.");
}
if (_this.options.uploadMultiple && _this.options.chunking) {
throw new Error('You cannot set both: uploadMultiple and chunking.');
}
if (_this.options.acceptedMimeTypes) {
_this.options.acceptedFiles = _this.options.acceptedMimeTypes;
delete _this.options.acceptedMimeTypes;
}
if (_this.options.renameFilename != null) {
_this.options.renameFile = function (file) {
return _this.options.renameFilename.call(_this, file.name, file);
};
}
_this.options.method = _this.options.method.toUpperCase();
if ((fallback = _this.getExistingFallback()) && fallback.parentNode) {
fallback.parentNode.removeChild(fallback);
}
if (_this.options.previewsContainer !== false) {
if (_this.options.previewsContainer) {
_this.previewsContainer = Dropzone.getElement(_this.options.previewsContainer, "previewsContainer");
} else {
_this.previewsContainer = _this.element;
}
}
if (_this.options.clickable) {
if (_this.options.clickable === true) {
_this.clickableElements = [_this.element];
} else {
_this.clickableElements = Dropzone.getElements(_this.options.clickable, "clickable");
}
}
_this.init();
return _this;
}
_createClass(Dropzone, [{
key: "getAcceptedFiles",
value: function getAcceptedFiles() {
return this.files.filter(function (file) {
return file.accepted;
}).map(function (file) {
return file;
});
}
}, {
key: "getRejectedFiles",
value: function getRejectedFiles() {
return this.files.filter(function (file) {
return !file.accepted;
}).map(function (file) {
return file;
});
}
}, {
key: "getFilesWithStatus",
value: function getFilesWithStatus(status) {
return this.files.filter(function (file) {
return file.status === status;
}).map(function (file) {
return file;
});
}
}, {
key: "getQueuedFiles",
value: function getQueuedFiles() {
return this.getFilesWithStatus(Dropzone.QUEUED);
}
}, {
key: "getUploadingFiles",
value: function getUploadingFiles() {
return this.getFilesWithStatus(Dropzone.UPLOADING);
}
}, {
key: "getAddedFiles",
value: function getAddedFiles() {
return this.getFilesWithStatus(Dropzone.ADDED);
}
}, {
key: "getActiveFiles",
value: function getActiveFiles() {
return this.files.filter(function (file) {
return file.status === Dropzone.UPLOADING || file.status === Dropzone.QUEUED;
}).map(function (file) {
return file;
});
}
}, {
key: "init",
value: function init() {
var _this3 = this;
if (this.element.tagName === "form") {
this.element.setAttribute("enctype", "multipart/form-data");
}
if (this.element.classList.contains("dropzone") && !this.element.querySelector(".dz-message")) {
this.element.appendChild(Dropzone.createElement("<div class=\"dz-default dz-message\"><span>" + this.options.dictDefaultMessage + "</span></div>"));
}
if (this.clickableElements.length) {
var setupHiddenFileInput = function setupHiddenFileInput() {
if (_this3.hiddenFileInput) {
_this3.hiddenFileInput.parentNode.removeChild(_this3.hiddenFileInput);
}
_this3.hiddenFileInput = document.createElement("input");
_this3.hiddenFileInput.setAttribute("type", "file");
if (_this3.options.maxFiles === null || _this3.options.maxFiles > 1) {
_this3.hiddenFileInput.setAttribute("multiple", "multiple");
}
_this3.hiddenFileInput.className = "dz-hidden-input";
if (_this3.options.acceptedFiles !== null) {
_this3.hiddenFileInput.setAttribute("accept", _this3.options.acceptedFiles);
}
if (_this3.options.capture !== null) {
_this3.hiddenFileInput.setAttribute("capture", _this3.options.capture);
}
_this3.hiddenFileInput.style.visibility = "hidden";
_this3.hiddenFileInput.style.position = "absolute";
_this3.hiddenFileInput.style.top = "0";
_this3.hiddenFileInput.style.left = "0";
_this3.hiddenFileInput.style.height = "0";
_this3.hiddenFileInput.style.width = "0";
document.querySelector(_this3.options.hiddenInputContainer).appendChild(_this3.hiddenFileInput);
return _this3.hiddenFileInput.addEventListener("change", function () {
var files = _this3.hiddenFileInput.files;
if (files.length) {
for (var _iterator10 = files, _isArray10 = true, _i10 = 0, _iterator10 = _isArray10 ? _iterator10 : _iterator10[Symbol.iterator]();;) {
var _ref9;
if (_isArray10) {
if (_i10 >= _iterator10.length) break;
_ref9 = _iterator10[_i10++];
} else {
_i10 = _iterator10.next();
if (_i10.done) break;
_ref9 = _i10.value;
}
var file = _ref9;
_this3.addFile(file);
}
}
_this3.emit("addedfiles", files);
return setupHiddenFileInput();
});
};
setupHiddenFileInput();
}
this.URL = window.URL !== null ? window.URL : window.webkitURL;
for (var _iterator11 = this.events, _isArray11 = true, _i11 = 0, _iterator11 = _isArray11 ? _iterator11 : _iterator11[Symbol.iterator]();;) {
var _ref10;
if (_isArray11) {
if (_i11 >= _iterator11.length) break;
_ref10 = _iterator11[_i11++];
} else {
_i11 = _iterator11.next();
if (_i11.done) break;
_ref10 = _i11.value;
}
var eventName = _ref10;
this.on(eventName, this.options[eventName]);
}
this.on("uploadprogress", function () {
return _this3.updateTotalUploadProgress();
});
this.on("removedfile", function () {
return _this3.updateTotalUploadProgress();
});
this.on("canceled", function (file) {
return _this3.emit("complete", file);
});
this.on("complete", function (file) {
if (_this3.getAddedFiles().length === 0 && _this3.getUploadingFiles().length === 0 && _this3.getQueuedFiles().length === 0) {
return setTimeout(function () {
return _this3.emit("queuecomplete");
}, 0);
}
});
var noPropagation = function noPropagation(e) {
e.stopPropagation();
if (e.preventDefault) {
return e.preventDefault();
} else {
return e.returnValue = false;
}
};
this.listeners = [{
element: this.element,
events: {
"dragstart": function dragstart(e) {
return _this3.emit("dragstart", e);
},
"dragenter": function dragenter(e) {
noPropagation(e);
return _this3.emit("dragenter", e);
},
"dragover": function dragover(e) {
var efct = void 0;
try {
efct = e.dataTransfer.effectAllowed;
} catch (error) {}
e.dataTransfer.dropEffect = 'move' === efct || 'linkMove' === efct ? 'move' : 'copy';
noPropagation(e);
return _this3.emit("dragover", e);
},
"dragleave": function dragleave(e) {
return _this3.emit("dragleave", e);
},
"drop": function drop(e) {
noPropagation(e);
return _this3.drop(e);
},
"dragend": function dragend(e) {
return _this3.emit("dragend", e);
}
} }];
this.clickableElements.forEach(function (clickableElement) {
return _this3.listeners.push({
element: clickableElement,
events: {
"click": function click(evt) {
if (clickableElement !== _this3.element || evt.target === _this3.element || Dropzone.elementInside(evt.target, _this3.element.querySelector(".dz-message"))) {
_this3.hiddenFileInput.click(); // Forward the click
}
return true;
}
}
});
});
this.enable();
return this.options.init.call(this);
}
}, {
key: "destroy",
value: function destroy() {
this.disable();
this.removeAllFiles(true);
if (this.hiddenFileInput != null ? this.hiddenFileInput.parentNode : undefined) {
this.hiddenFileInput.parentNode.removeChild(this.hiddenFileInput);
this.hiddenFileInput = null;
}
delete this.element.dropzone;
return Dropzone.instances.splice(Dropzone.instances.indexOf(this), 1);
}
}, {
key: "updateTotalUploadProgress",
value: function updateTotalUploadProgress() {
var totalUploadProgress = void 0;
var totalBytesSent = 0;
var totalBytes = 0;
var activeFiles = this.getActiveFiles();
if (activeFiles.length) {
for (var _iterator12 = this.getActiveFiles(), _isArray12 = true, _i12 = 0, _iterator12 = _isArray12 ? _iterator12 : _iterator12[Symbol.iterator]();;) {
var _ref11;
if (_isArray12) {
if (_i12 >= _iterator12.length) break;
_ref11 = _iterator12[_i12++];
} else {
_i12 = _iterator12.next();
if (_i12.done) break;
_ref11 = _i12.value;
}
var file = _ref11;
totalBytesSent += file.upload.bytesSent;
totalBytes += file.upload.total;
}
totalUploadProgress = 100 * totalBytesSent / totalBytes;
} else {
totalUploadProgress = 100;
}
return this.emit("totaluploadprogress", totalUploadProgress, totalBytes, totalBytesSent);
}
}, {
key: "_getParamName",
value: function _getParamName(n) {
if (typeof this.options.paramName === "function") {
return this.options.paramName(n);
} else {
return "" + this.options.paramName + (this.options.uploadMultiple ? "[" + n + "]" : "");
}
}
}, {
key: "_renameFile",
value: function _renameFile(file) {
if (typeof this.options.renameFile !== "function") {
return file.name;
}
return this.options.renameFile(file);
}
}, {
key: "getFallbackForm",
value: function getFallbackForm() {
var existingFallback = void 0,
form = void 0;
if (existingFallback = this.getExistingFallback()) {
return existingFallback;
}
var fieldsString = "<div class=\"dz-fallback\">";
if (this.options.dictFallbackText) {
fieldsString += "<p>" + this.options.dictFallbackText + "</p>";
}
fieldsString += "<input type=\"file\" name=\"" + this._getParamName(0) + "\" " + (this.options.uploadMultiple ? 'multiple="multiple"' : undefined) + " /><input type=\"submit\" value=\"Upload!\"></div>";
var fields = Dropzone.createElement(fieldsString);
if (this.element.tagName !== "FORM") {
form = Dropzone.createElement("<form action=\"" + this.options.url + "\" enctype=\"multipart/form-data\" method=\"" + this.options.method + "\"></form>");
form.appendChild(fields);
} else {
this.element.setAttribute("enctype", "multipart/form-data");
this.element.setAttribute("method", this.options.method);
}
return form != null ? form : fields;
}
}, {
key: "getExistingFallback",
value: function getExistingFallback() {
var getFallback = function getFallback(elements) {
for (var _iterator13 = elements, _isArray13 = true, _i13 = 0, _iterator13 = _isArray13 ? _iterator13 : _iterator13[Symbol.iterator]();;) {
var _ref12;
if (_isArray13) {
if (_i13 >= _iterator13.length) break;
_ref12 = _iterator13[_i13++];
} else {
_i13 = _iterator13.next();
if (_i13.done) break;
_ref12 = _i13.value;
}
var el = _ref12;
if (/(^| )fallback($| )/.test(el.className)) {
return el;
}
}
};
var _arr = ["div", "form"];
for (var _i14 = 0; _i14 < _arr.length; _i14++) {
var tagName = _arr[_i14];
var fallback;
if (fallback = getFallback(this.element.getElementsByTagName(tagName))) {
return fallback;
}
}
}
}, {
key: "setupEventListeners",
value: function setupEventListeners() {
return this.listeners.map(function (elementListeners) {
return function () {
var result = [];
for (var event in elementListeners.events) {
var listener = elementListeners.events[event];
result.push(elementListeners.element.addEventListener(event, listener, false));
}
return result;
}();
});
}
}, {
key: "removeEventListeners",
value: function removeEventListeners() {
return this.listeners.map(function (elementListeners) {
return function () {
var result = [];
for (var event in elementListeners.events) {
var listener = elementListeners.events[event];
result.push(elementListeners.element.removeEventListener(event, listener, false));
}
return result;
}();
});
}
}, {
key: "disable",
value: function disable() {
var _this4 = this;
this.clickableElements.forEach(function (element) {
return element.classList.remove("dz-clickable");
});
this.removeEventListeners();
return this.files.map(function (file) {
return _this4.cancelUpload(file);
});
}
}, {
key: "enable",
value: function enable() {
this.clickableElements.forEach(function (element) {
return element.classList.add("dz-clickable");
});
return this.setupEventListeners();
}
}, {
key: "filesize",
value: function filesize(size) {
var selectedSize = 0;
var selectedUnit = "b";
if (size > 0) {
var units = ['tb', 'gb', 'mb', 'kb', 'b'];
for (var i = 0; i < units.length; i++) {
var unit = units[i];
var cutoff = Math.pow(this.options.filesizeBase, 4 - i) / 10;
if (size >= cutoff) {
selectedSize = size / Math.pow(this.options.filesizeBase, 4 - i);
selectedUnit = unit;
break;
}
}
selectedSize = Math.round(10 * selectedSize) / 10; // Cutting of digits
}
return "<strong>" + selectedSize + "</strong> " + this.options.dictFileSizeUnits[selectedUnit];
}
}, {
key: "_updateMaxFilesReachedClass",
value: function _updateMaxFilesReachedClass() {
if (this.options.maxFiles != null && this.getAcceptedFiles().length >= this.options.maxFiles) {
if (this.getAcceptedFiles().length === this.options.maxFiles) {
this.emit('maxfilesreached', this.files);
}
return this.element.classList.add("dz-max-files-reached");
} else {
return this.element.classList.remove("dz-max-files-reached");
}
}
}, {
key: "drop",
value: function drop(e) {
if (!e.dataTransfer) {
return;
}
this.emit("drop", e);
var files = e.dataTransfer.files;
this.emit("addedfiles", files);
if (files.length) {
var items = e.dataTransfer.items;
if (items && items.length && items[0].webkitGetAsEntry != null) {
this._addFilesFromItems(items);
} else {
this.handleFiles(files);
}
}
}
}, {
key: "paste",
value: function paste(e) {
if (__guard__(e != null ? e.clipboardData : undefined, function (x) {
return x.items;
}) == null) {
return;
}
this.emit("paste", e);
var items = e.clipboardData.items;
if (items.length) {
return this._addFilesFromItems(items);
}
}
}, {
key: "handleFiles",
value: function handleFiles(files) {
var _this5 = this;
return files.map(function (file) {
return _this5.addFile(file);
});
}
}, {
key: "_addFilesFromItems",
value: function _addFilesFromItems(items) {
var _this6 = this;
return function () {
var result = [];
for (var _iterator14 = items, _isArray14 = true, _i15 = 0, _iterator14 = _isArray14 ? _iterator14 : _iterator14[Symbol.iterator]();;) {
var _ref13;
if (_isArray14) {
if (_i15 >= _iterator14.length) break;
_ref13 = _iterator14[_i15++];
} else {
_i15 = _iterator14.next();
if (_i15.done) break;
_ref13 = _i15.value;
}
var item = _ref13;
var entry;
if (item.webkitGetAsEntry != null && (entry = item.webkitGetAsEntry())) {
if (entry.isFile) {
result.push(_this6.addFile(item.getAsFile()));
} else if (entry.isDirectory) {
result.push(_this6._addFilesFromDirectory(entry, entry.name));
} else {
result.push(undefined);
}
} else if (item.getAsFile != null) {
if (item.kind == null || item.kind === "file") {
result.push(_this6.addFile(item.getAsFile()));
} else {
result.push(undefined);
}
} else {
result.push(undefined);
}
}
return result;
}();
}
}, {
key: "_addFilesFromDirectory",
value: function _addFilesFromDirectory(directory, path) {
var _this7 = this;
var dirReader = directory.createReader();
var errorHandler = function errorHandler(error) {
return __guardMethod__(console, 'log', function (o) {
return o.log(error);
});
};
var readEntries = function readEntries() {
return dirReader.readEntries(function (entries) {
if (entries.length > 0) {
for (var _iterator15 = entries, _isArray15 = true, _i16 = 0, _iterator15 = _isArray15 ? _iterator15 : _iterator15[Symbol.iterator]();;) {
var _ref14;
if (_isArray15) {
if (_i16 >= _iterator15.length) break;
_ref14 = _iterator15[_i16++];
} else {
_i16 = _iterator15.next();
if (_i16.done) break;
_ref14 = _i16.value;
}
var entry = _ref14;
if (entry.isFile) {
entry.file(function (file) {
if (_this7.options.ignoreHiddenFiles && file.name.substring(0, 1) === '.') {
return;
}
file.fullPath = path + "/" + file.name;
return _this7.addFile(file);
});
} else if (entry.isDirectory) {
_this7._addFilesFromDirectory(entry, path + "/" + entry.name);
}
}
readEntries();
}
return null;
}, errorHandler);
};
return readEntries();
}
}, {
key: "accept",
value: function accept(file, done) {
if (file.size > this.options.maxFilesize * 1024 * 1024) {
return done(this.options.dictFileTooBig.replace("{{filesize}}", Math.round(file.size / 1024 / 10.24) / 100).replace("{{maxFilesize}}", this.options.maxFilesize));
} else if (!Dropzone.isValidFile(file, this.options.acceptedFiles)) {
return done(this.options.dictInvalidFileType);
} else if (this.options.maxFiles != null && this.getAcceptedFiles().length >= this.options.maxFiles) {
done(this.options.dictMaxFilesExceeded.replace("{{maxFiles}}", this.options.maxFiles));
return this.emit("maxfilesexceeded", file);
} else {
return this.options.accept.call(this, file, done);
}
}
}, {
key: "addFile",
value: function addFile(file) {
var _this8 = this;
file.upload = {
uuid: Dropzone.uuidv4(),
progress: 0,
total: file.size,
bytesSent: 0,
filename: this._renameFile(file),
chunked: this.options.chunking && (this.options.forceChunking || file.size > this.options.chunkSize),
totalChunkCount: Math.ceil(file.size / this.options.chunkSize)
};
this.files.push(file);
file.status = Dropzone.ADDED;
this.emit("addedfile", file);
this._enqueueThumbnail(file);
return this.accept(file, function (error) {
if (error) {
file.accepted = false;
_this8._errorProcessing([file], error); // Will set the file.status
} else {
file.accepted = true;
if (_this8.options.autoQueue) {
_this8.enqueueFile(file);
} // Will set .accepted = true
}
return _this8._updateMaxFilesReachedClass();
});
}
}, {
key: "enqueueFiles",
value: function enqueueFiles(files) {
for (var _iterator16 = files, _isArray16 = true, _i17 = 0, _iterator16 = _isArray16 ? _iterator16 : _iterator16[Symbol.iterator]();;) {
var _ref15;
if (_isArray16) {
if (_i17 >= _iterator16.length) break;
_ref15 = _iterator16[_i17++];
} else {
_i17 = _iterator16.next();
if (_i17.done) break;
_ref15 = _i17.value;
}
var file = _ref15;
this.enqueueFile(file);
}
return null;
}
}, {
key: "enqueueFile",
value: function enqueueFile(file) {
var _this9 = this;
if (file.status === Dropzone.ADDED && file.accepted === true) {
file.status = Dropzone.QUEUED;
if (this.options.autoProcessQueue) {
return setTimeout(function () {
return _this9.processQueue();
}, 0); // Deferring the call
}
} else {
throw new Error("This file can't be queued because it has already been processed or was rejected.");
}
}
}, {
key: "_enqueueThumbnail",
value: function _enqueueThumbnail(file) {
var _this10 = this;
if (this.options.createImageThumbnails && file.type.match(/image.*/) && file.size <= this.options.maxThumbnailFilesize * 1024 * 1024) {
this._thumbnailQueue.push(file);
return setTimeout(function () {
return _this10._processThumbnailQueue();
}, 0); // Deferring the call
}
}
}, {
key: "_processThumbnailQueue",
value: function _processThumbnailQueue() {
var _this11 = this;
if (this._processingThumbnail || this._thumbnailQueue.length === 0) {
return;
}
this._processingThumbnail = true;
var file = this._thumbnailQueue.shift();
return this.createThumbnail(file, this.options.thumbnailWidth, this.options.thumbnailHeight, this.options.thumbnailMethod, true, function (dataUrl) {
_this11.emit("thumbnail", file, dataUrl);
_this11._processingThumbnail = false;
return _this11._processThumbnailQueue();
});
}
}, {
key: "removeFile",
value: function removeFile(file) {
if (file.status === Dropzone.UPLOADING) {
this.cancelUpload(file);
}
this.files = without(this.files, file);
this.emit("removedfile", file);
if (this.files.length === 0) {
return this.emit("reset");
}
}
}, {
key: "removeAllFiles",
value: function removeAllFiles(cancelIfNecessary) {
if (cancelIfNecessary == null) {
cancelIfNecessary = false;
}
for (var _iterator17 = this.files.slice(), _isArray17 = true, _i18 = 0, _iterator17 = _isArray17 ? _iterator17 : _iterator17[Symbol.iterator]();;) {
var _ref16;
if (_isArray17) {
if (_i18 >= _iterator17.length) break;
_ref16 = _iterator17[_i18++];
} else {
_i18 = _iterator17.next();
if (_i18.done) break;
_ref16 = _i18.value;
}
var file = _ref16;
if (file.status !== Dropzone.UPLOADING || cancelIfNecessary) {
this.removeFile(file);
}
}
return null;
}
}, {
key: "resizeImage",
value: function resizeImage(file, width, height, resizeMethod, callback) {
var _this12 = this;
return this.createThumbnail(file, width, height, resizeMethod, false, function (dataUrl, canvas) {
if (canvas === null) {
return callback(file);
} else {
var resizeMimeType = _this12.options.resizeMimeType;
if (resizeMimeType == null) {
resizeMimeType = file.type;
}
var resizedDataURL = canvas.toDataURL(resizeMimeType, _this12.options.resizeQuality);
if (resizeMimeType === 'image/jpeg' || resizeMimeType === 'image/jpg') {
resizedDataURL = ExifRestore.restore(file.dataURL, resizedDataURL);
}
return callback(Dropzone.dataURItoBlob(resizedDataURL));
}
});
}
}, {
key: "createThumbnail",
value: function createThumbnail(file, width, height, resizeMethod, fixOrientation, callback) {
var _this13 = this;
var fileReader = new FileReader();
fileReader.onload = function () {
file.dataURL = fileReader.result;
if (file.type === "image/svg+xml") {
if (callback != null) {
callback(fileReader.result);
}
return;
}
return _this13.createThumbnailFromUrl(file, width, height, resizeMethod, fixOrientation, callback);
};
return fileReader.readAsDataURL(file);
}
}, {
key: "createThumbnailFromUrl",
value: function createThumbnailFromUrl(file, width, height, resizeMethod, fixOrientation, callback, crossOrigin) {
var _this14 = this;
var img = document.createElement("img");
if (crossOrigin) {
img.crossOrigin = crossOrigin;
}
img.onload = function () {
var loadExif = function loadExif(callback) {
return callback(1);
};
if (typeof EXIF !== 'undefined' && EXIF !== null && fixOrientation) {
loadExif = function loadExif(callback) {
return EXIF.getData(img, function () {
return callback(EXIF.getTag(this, 'Orientation'));
});
};
}
return loadExif(function (orientation) {
file.width = img.width;
file.height = img.height;
var resizeInfo = _this14.options.resize.call(_this14, file, width, height, resizeMethod);
var canvas = document.createElement("canvas");
var ctx = canvas.getContext("2d");
canvas.width = resizeInfo.trgWidth;
canvas.height = resizeInfo.trgHeight;
if (orientation > 4) {
canvas.width = resizeInfo.trgHeight;
canvas.height = resizeInfo.trgWidth;
}
switch (orientation) {
case 2:
ctx.translate(canvas.width, 0);
ctx.scale(-1, 1);
break;
case 3:
ctx.translate(canvas.width, canvas.height);
ctx.rotate(Math.PI);
break;
case 4:
ctx.translate(0, canvas.height);
ctx.scale(1, -1);
break;
case 5:
ctx.rotate(0.5 * Math.PI);
ctx.scale(1, -1);
break;
case 6:
ctx.rotate(0.5 * Math.PI);
ctx.translate(0, -canvas.height);
break;
case 7:
ctx.rotate(0.5 * Math.PI);
ctx.translate(canvas.width, -canvas.height);
ctx.scale(-1, 1);
break;
case 8:
ctx.rotate(-0.5 * Math.PI);
ctx.translate(-canvas.width, 0);
break;
}
drawImageIOSFix(ctx, img, resizeInfo.srcX != null ? resizeInfo.srcX : 0, resizeInfo.srcY != null ? resizeInfo.srcY : 0, resizeInfo.srcWidth, resizeInfo.srcHeight, resizeInfo.trgX != null ? resizeInfo.trgX : 0, resizeInfo.trgY != null ? resizeInfo.trgY : 0, resizeInfo.trgWidth, resizeInfo.trgHeight);
var thumbnail = canvas.toDataURL("image/png");
if (callback != null) {
return callback(thumbnail, canvas);
}
});
};
if (callback != null) {
img.onerror = callback;
}
return img.src = file.dataURL;
}
}, {
key: "processQueue",
value: function processQueue() {
var parallelUploads = this.options.parallelUploads;
var processingLength = this.getUploadingFiles().length;
var i = processingLength;
if (processingLength >= parallelUploads) {
return;
}
var queuedFiles = this.getQueuedFiles();
if (!(queuedFiles.length > 0)) {
return;
}
if (this.options.uploadMultiple) {
return this.processFiles(queuedFiles.slice(0, parallelUploads - processingLength));
} else {
while (i < parallelUploads) {
if (!queuedFiles.length) {
return;
} // Nothing left to process
this.processFile(queuedFiles.shift());
i++;
}
}
}
}, {
key: "processFile",
value: function processFile(file) {
return this.processFiles([file]);
}
}, {
key: "processFiles",
value: function processFiles(files) {
for (var _iterator18 = files, _isArray18 = true, _i19 = 0, _iterator18 = _isArray18 ? _iterator18 : _iterator18[Symbol.iterator]();;) {
var _ref17;
if (_isArray18) {
if (_i19 >= _iterator18.length) break;
_ref17 = _iterator18[_i19++];
} else {
_i19 = _iterator18.next();
if (_i19.done) break;
_ref17 = _i19.value;
}
var file = _ref17;
file.processing = true; // Backwards compatibility
file.status = Dropzone.UPLOADING;
this.emit("processing", file);
}
if (this.options.uploadMultiple) {
this.emit("processingmultiple", files);
}
return this.uploadFiles(files);
}
}, {
key: "_getFilesWithXhr",
value: function _getFilesWithXhr(xhr) {
var files = void 0;
return files = this.files.filter(function (file) {
return file.xhr === xhr;
}).map(function (file) {
return file;
});
}
}, {
key: "cancelUpload",
value: function cancelUpload(file) {
if (file.status === Dropzone.UPLOADING) {
var groupedFiles = this._getFilesWithXhr(file.xhr);
for (var _iterator19 = groupedFiles, _isArray19 = true, _i20 = 0, _iterator19 = _isArray19 ? _iterator19 : _iterator19[Symbol.iterator]();;) {
var _ref18;
if (_isArray19) {
if (_i20 >= _iterator19.length) break;
_ref18 = _iterator19[_i20++];
} else {
_i20 = _iterator19.next();
if (_i20.done) break;
_ref18 = _i20.value;
}
var groupedFile = _ref18;
groupedFile.status = Dropzone.CANCELED;
}
if (typeof file.xhr !== 'undefined') {
file.xhr.abort();
}
for (var _iterator20 = groupedFiles, _isArray20 = true, _i21 = 0, _iterator20 = _isArray20 ? _iterator20 : _iterator20[Symbol.iterator]();;) {
var _ref19;
if (_isArray20) {
if (_i21 >= _iterator20.length) break;
_ref19 = _iterator20[_i21++];
} else {
_i21 = _iterator20.next();
if (_i21.done) break;
_ref19 = _i21.value;
}
var _groupedFile = _ref19;
this.emit("canceled", _groupedFile);
}
if (this.options.uploadMultiple) {
this.emit("canceledmultiple", groupedFiles);
}
} else if (file.status === Dropzone.ADDED || file.status === Dropzone.QUEUED) {
file.status = Dropzone.CANCELED;
this.emit("canceled", file);
if (this.options.uploadMultiple) {
this.emit("canceledmultiple", [file]);
}
}
if (this.options.autoProcessQueue) {
return this.processQueue();
}
}
}, {
key: "resolveOption",
value: function resolveOption(option) {
if (typeof option === 'function') {
for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
args[_key3 - 1] = arguments[_key3];
}
return option.apply(this, args);
}
return option;
}
}, {
key: "uploadFile",
value: function uploadFile(file) {
return this.uploadFiles([file]);
}
}, {
key: "uploadFiles",
value: function uploadFiles(files) {
var _this15 = this;
this._transformFiles(files, function (transformedFiles) {
if (files[0].upload.chunked) {
var file = files[0];
var transformedFile = transformedFiles[0];
var startedChunkCount = 0;
file.upload.chunks = [];
var handleNextChunk = function handleNextChunk() {
var chunkIndex = 0;
while (file.upload.chunks[chunkIndex] !== undefined) {
chunkIndex++;
}
if (chunkIndex >= file.upload.totalChunkCount) return;
startedChunkCount++;
var start = chunkIndex * _this15.options.chunkSize;
var end = Math.min(start + _this15.options.chunkSize, file.size);
var dataBlock = {
name: _this15._getParamName(0),
data: transformedFile.webkitSlice ? transformedFile.webkitSlice(start, end) : transformedFile.slice(start, end),
filename: file.upload.filename,
chunkIndex: chunkIndex
};
file.upload.chunks[chunkIndex] = {
file: file,
index: chunkIndex,
dataBlock: dataBlock, // In case we want to retry.
status: Dropzone.UPLOADING,
progress: 0,
retries: 0 // The number of times this block has been retried.
};
_this15._uploadData(files, [dataBlock]);
};
file.upload.finishedChunkUpload = function (chunk) {
var allFinished = true;
chunk.status = Dropzone.SUCCESS;
chunk.dataBlock = null;
for (var i = 0; i < file.upload.totalChunkCount; i++) {
if (file.upload.chunks[i] === undefined) {
return handleNextChunk();
}
if (file.upload.chunks[i].status !== Dropzone.SUCCESS) {
allFinished = false;
}
}
if (allFinished) {
_this15.options.chunksUploaded(file, function () {
_this15._finished(files, '', null);
});
}
};
if (_this15.options.parallelChunkUploads) {
for (var i = 0; i < file.upload.totalChunkCount; i++) {
handleNextChunk();
}
} else {
handleNextChunk();
}
} else {
var dataBlocks = [];
for (var _i22 = 0; _i22 < files.length; _i22++) {
dataBlocks[_i22] = {
name: _this15._getParamName(_i22),
data: transformedFiles[_i22],
filename: files[_i22].upload.filename
};
}
_this15._uploadData(files, dataBlocks);
}
});
}
}, {
key: "_getChunk",
value: function _getChunk(file, xhr) {
for (var i = 0; i < file.upload.totalChunkCount; i++) {
if (file.upload.chunks[i] !== undefined && file.upload.chunks[i].xhr === xhr) {
return file.upload.chunks[i];
}
}
}
}, {
key: "_uploadData",
value: function _uploadData(files, dataBlocks) {
var _this16 = this;
var xhr = new XMLHttpRequest();
for (var _iterator21 = files, _isArray21 = true, _i23 = 0, _iterator21 = _isArray21 ? _iterator21 : _iterator21[Symbol.iterator]();;) {
var _ref20;
if (_isArray21) {
if (_i23 >= _iterator21.length) break;
_ref20 = _iterator21[_i23++];
} else {
_i23 = _iterator21.next();
if (_i23.done) break;
_ref20 = _i23.value;
}
var file = _ref20;
file.xhr = xhr;
}
if (files[0].upload.chunked) {
files[0].upload.chunks[dataBlocks[0].chunkIndex].xhr = xhr;
}
var method = this.resolveOption(this.options.method, files);
var url = this.resolveOption(this.options.url, files);
xhr.open(method, url, true);
xhr.timeout = this.resolveOption(this.options.timeout, files);
xhr.withCredentials = !!this.options.withCredentials;
xhr.onload = function (e) {
_this16._finishedUploading(files, xhr, e);
};
xhr.onerror = function () {
_this16._handleUploadError(files, xhr);
};
var progressObj = xhr.upload != null ? xhr.upload : xhr;
progressObj.onprogress = function (e) {
return _this16._updateFilesUploadProgress(files, xhr, e);
};
var headers = {
"Accept": "application/json",
"Cache-Control": "no-cache",
"X-Requested-With": "XMLHttpRequest"
};
if (this.options.headers) {
Dropzone.extend(headers, this.options.headers);
}
for (var headerName in headers) {
var headerValue = headers[headerName];
if (headerValue) {
xhr.setRequestHeader(headerName, headerValue);
}
}
var formData = new FormData();
if (this.options.params) {
var additionalParams = this.options.params;
if (typeof additionalParams === 'function') {
additionalParams = additionalParams.call(this, files, xhr, files[0].upload.chunked ? this._getChunk(files[0], xhr) : null);
}
for (var key in additionalParams) {
var value = additionalParams[key];
formData.append(key, value);
}
}
for (var _iterator22 = files, _isArray22 = true, _i24 = 0, _iterator22 = _isArray22 ? _iterator22 : _iterator22[Symbol.iterator]();;) {
var _ref21;
if (_isArray22) {
if (_i24 >= _iterator22.length) break;
_ref21 = _iterator22[_i24++];
} else {
_i24 = _iterator22.next();
if (_i24.done) break;
_ref21 = _i24.value;
}
var _file = _ref21;
this.emit("sending", _file, xhr, formData);
}
if (this.options.uploadMultiple) {
this.emit("sendingmultiple", files, xhr, formData);
}
this._addFormElementData(formData);
for (var i = 0; i < dataBlocks.length; i++) {
var dataBlock = dataBlocks[i];
formData.append(dataBlock.name, dataBlock.data, dataBlock.filename);
}
this.submitRequest(xhr, formData, files);
}
}, {
key: "_transformFiles",
value: function _transformFiles(files, done) {
var _this17 = this;
var transformedFiles = [];
var doneCounter = 0;
var _loop = function _loop(i) {
_this17.options.transformFile.call(_this17, files[i], function (transformedFile) {
transformedFiles[i] = transformedFile;
if (++doneCounter === files.length) {
done(transformedFiles);
}
});
};
for (var i = 0; i < files.length; i++) {
_loop(i);
}
}
}, {
key: "_addFormElementData",
value: function _addFormElementData(formData) {
if (this.element.tagName === "FORM") {
for (var _iterator23 = this.element.querySelectorAll("input, textarea, select, button"), _isArray23 = true, _i25 = 0, _iterator23 = _isArray23 ? _iterator23 : _iterator23[Symbol.iterator]();;) {
var _ref22;
if (_isArray23) {
if (_i25 >= _iterator23.length) break;
_ref22 = _iterator23[_i25++];
} else {
_i25 = _iterator23.next();
if (_i25.done) break;
_ref22 = _i25.value;
}
var input = _ref22;
var inputName = input.getAttribute("name");
var inputType = input.getAttribute("type");
if (inputType) inputType = inputType.toLowerCase();
if (typeof inputName === 'undefined' || inputName === null) continue;
if (input.tagName === "SELECT" && input.hasAttribute("multiple")) {
for (var _iterator24 = input.options, _isArray24 = true, _i26 = 0, _iterator24 = _isArray24 ? _iterator24 : _iterator24[Symbol.iterator]();;) {
var _ref23;
if (_isArray24) {
if (_i26 >= _iterator24.length) break;
_ref23 = _iterator24[_i26++];
} else {
_i26 = _iterator24.next();
if (_i26.done) break;
_ref23 = _i26.value;
}
var option = _ref23;
if (option.selected) {
formData.append(inputName, option.value);
}
}
} else if (!inputType || inputType !== "checkbox" && inputType !== "radio" || input.checked) {
formData.append(inputName, input.value);
}
}
}
}
}, {
key: "_updateFilesUploadProgress",
value: function _updateFilesUploadProgress(files, xhr, e) {
var progress = void 0;
if (typeof e !== 'undefined') {
progress = 100 * e.loaded / e.total;
if (files[0].upload.chunked) {
var file = files[0];
var chunk = this._getChunk(file, xhr);
chunk.progress = progress;
chunk.total = e.total;
chunk.bytesSent = e.loaded;
var fileProgress = 0,
fileTotal = void 0,
fileBytesSent = void 0;
file.upload.progress = 0;
file.upload.total = 0;
file.upload.bytesSent = 0;
for (var i = 0; i < file.upload.totalChunkCount; i++) {
if (file.upload.chunks[i] !== undefined && file.upload.chunks[i].progress !== undefined) {
file.upload.progress += file.upload.chunks[i].progress;
file.upload.total += file.upload.chunks[i].total;
file.upload.bytesSent += file.upload.chunks[i].bytesSent;
}
}
file.upload.progress = file.upload.progress / file.upload.totalChunkCount;
} else {
for (var _iterator25 = files, _isArray25 = true, _i27 = 0, _iterator25 = _isArray25 ? _iterator25 : _iterator25[Symbol.iterator]();;) {
var _ref24;
if (_isArray25) {
if (_i27 >= _iterator25.length) break;
_ref24 = _iterator25[_i27++];
} else {
_i27 = _iterator25.next();
if (_i27.done) break;
_ref24 = _i27.value;
}
var _file2 = _ref24;
_file2.upload.progress = progress;
_file2.upload.total = e.total;
_file2.upload.bytesSent = e.loaded;
}
}
for (var _iterator26 = files, _isArray26 = true, _i28 = 0, _iterator26 = _isArray26 ? _iterator26 : _iterator26[Symbol.iterator]();;) {
var _ref25;
if (_isArray26) {
if (_i28 >= _iterator26.length) break;
_ref25 = _iterator26[_i28++];
} else {
_i28 = _iterator26.next();
if (_i28.done) break;
_ref25 = _i28.value;
}
var _file3 = _ref25;
this.emit("uploadprogress", _file3, _file3.upload.progress, _file3.upload.bytesSent);
}
} else {
var allFilesFinished = true;
progress = 100;
for (var _iterator27 = files, _isArray27 = true, _i29 = 0, _iterator27 = _isArray27 ? _iterator27 : _iterator27[Symbol.iterator]();;) {
var _ref26;
if (_isArray27) {
if (_i29 >= _iterator27.length) break;
_ref26 = _iterator27[_i29++];
} else {
_i29 = _iterator27.next();
if (_i29.done) break;
_ref26 = _i29.value;
}
var _file4 = _ref26;
if (_file4.upload.progress !== 100 || _file4.upload.bytesSent !== _file4.upload.total) {
allFilesFinished = false;
}
_file4.upload.progress = progress;
_file4.upload.bytesSent = _file4.upload.total;
}
if (allFilesFinished) {
return;
}
for (var _iterator28 = files, _isArray28 = true, _i30 = 0, _iterator28 = _isArray28 ? _iterator28 : _iterator28[Symbol.iterator]();;) {
var _ref27;
if (_isArray28) {
if (_i30 >= _iterator28.length) break;
_ref27 = _iterator28[_i30++];
} else {
_i30 = _iterator28.next();
if (_i30.done) break;
_ref27 = _i30.value;
}
var _file5 = _ref27;
this.emit("uploadprogress", _file5, progress, _file5.upload.bytesSent);
}
}
}
}, {
key: "_finishedUploading",
value: function _finishedUploading(files, xhr, e) {
var response = void 0;
if (files[0].status === Dropzone.CANCELED) {
return;
}
if (xhr.readyState !== 4) {
return;
}
if (xhr.responseType !== 'arraybuffer' && xhr.responseType !== 'blob') {
response = xhr.responseText;
if (xhr.getResponseHeader("content-type") && ~xhr.getResponseHeader("content-type").indexOf("application/json")) {
try {
response = JSON.parse(response);
} catch (error) {
e = error;
response = "Invalid JSON response from server.";
}
}
}
this._updateFilesUploadProgress(files);
if (!(200 <= xhr.status && xhr.status < 300)) {
this._handleUploadError(files, xhr, response);
} else {
if (files[0].upload.chunked) {
files[0].upload.finishedChunkUpload(this._getChunk(files[0], xhr));
} else {
this._finished(files, response, e);
}
}
}
}, {
key: "_handleUploadError",
value: function _handleUploadError(files, xhr, response) {
if (files[0].status === Dropzone.CANCELED) {
return;
}
if (files[0].upload.chunked && this.options.retryChunks) {
var chunk = this._getChunk(files[0], xhr);
if (chunk.retries++ < this.options.retryChunksLimit) {
this._uploadData(files, [chunk.dataBlock]);
return;
} else {
console.warn('Retried this chunk too often. Giving up.');
}
}
for (var _iterator29 = files, _isArray29 = true, _i31 = 0, _iterator29 = _isArray29 ? _iterator29 : _iterator29[Symbol.iterator]();;) {
var _ref28;
if (_isArray29) {
if (_i31 >= _iterator29.length) break;
_ref28 = _iterator29[_i31++];
} else {
_i31 = _iterator29.next();
if (_i31.done) break;
_ref28 = _i31.value;
}
var file = _ref28;
this._errorProcessing(files, response || this.options.dictResponseError.replace("{{statusCode}}", xhr.status), xhr);
}
}
}, {
key: "submitRequest",
value: function submitRequest(xhr, formData, files) {
xhr.send(formData);
}
}, {
key: "_finished",
value: function _finished(files, responseText, e) {
for (var _iterator30 = files, _isArray30 = true, _i32 = 0, _iterator30 = _isArray30 ? _iterator30 : _iterator30[Symbol.iterator]();;) {
var _ref29;
if (_isArray30) {
if (_i32 >= _iterator30.length) break;
_ref29 = _iterator30[_i32++];
} else {
_i32 = _iterator30.next();
if (_i32.done) break;
_ref29 = _i32.value;
}
var file = _ref29;
file.status = Dropzone.SUCCESS;
this.emit("success", file, responseText, e);
this.emit("complete", file);
}
if (this.options.uploadMultiple) {
this.emit("successmultiple", files, responseText, e);
this.emit("completemultiple", files);
}
if (this.options.autoProcessQueue) {
return this.processQueue();
}
}
}, {
key: "_errorProcessing",
value: function _errorProcessing(files, message, xhr) {
for (var _iterator31 = files, _isArray31 = true, _i33 = 0, _iterator31 = _isArray31 ? _iterator31 : _iterator31[Symbol.iterator]();;) {
var _ref30;
if (_isArray31) {
if (_i33 >= _iterator31.length) break;
_ref30 = _iterator31[_i33++];
} else {
_i33 = _iterator31.next();
if (_i33.done) break;
_ref30 = _i33.value;
}
var file = _ref30;
file.status = Dropzone.ERROR;
this.emit("error", file, message, xhr);
this.emit("complete", file);
}
if (this.options.uploadMultiple) {
this.emit("errormultiple", files, message, xhr);
this.emit("completemultiple", files);
}
if (this.options.autoProcessQueue) {
return this.processQueue();
}
}
}], [{
key: "uuidv4",
value: function uuidv4() {
return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
var r = Math.random() * 16 | 0,
v = c === 'x' ? r : r & 0x3 | 0x8;
return v.toString(16);
});
}
}]);
return Dropzone;
}(Emitter);
Dropzone.initClass();
Dropzone.version = "5.2.0";
Dropzone.options = {};
Dropzone.optionsForElement = function (element) {
if (element.getAttribute("id")) {
return Dropzone.options[camelize(element.getAttribute("id"))];
} else {
return undefined;
}
};
Dropzone.instances = [];
Dropzone.forElement = function (element) {
if (typeof element === "string") {
element = document.querySelector(element);
}
if ((element != null ? element.dropzone : undefined) == null) {
throw new Error("No Dropzone found for given element. This is probably because you're trying to access it before Dropzone had the time to initialize. Use the `init` option to setup any additional observers on your Dropzone.");
}
return element.dropzone;
};
Dropzone.autoDiscover = true;
Dropzone.discover = function () {
var dropzones = void 0;
if (document.querySelectorAll) {
dropzones = document.querySelectorAll(".dropzone");
} else {
dropzones = [];
var checkElements = function checkElements(elements) {
return function () {
var result = [];
for (var _iterator32 = elements, _isArray32 = true, _i34 = 0, _iterator32 = _isArray32 ? _iterator32 : _iterator32[Symbol.iterator]();;) {
var _ref31;
if (_isArray32) {
if (_i34 >= _iterator32.length) break;
_ref31 = _iterator32[_i34++];
} else {
_i34 = _iterator32.next();
if (_i34.done) break;
_ref31 = _i34.value;
}
var el = _ref31;
if (/(^| )dropzone($| )/.test(el.className)) {
result.push(dropzones.push(el));
} else {
result.push(undefined);
}
}
return result;
}();
};
checkElements(document.getElementsByTagName("div"));
checkElements(document.getElementsByTagName("form"));
}
return function () {
var result = [];
for (var _iterator33 = dropzones, _isArray33 = true, _i35 = 0, _iterator33 = _isArray33 ? _iterator33 : _iterator33[Symbol.iterator]();;) {
var _ref32;
if (_isArray33) {
if (_i35 >= _iterator33.length) break;
_ref32 = _iterator33[_i35++];
} else {
_i35 = _iterator33.next();
if (_i35.done) break;
_ref32 = _i35.value;
}
var dropzone = _ref32;
if (Dropzone.optionsForElement(dropzone) !== false) {
result.push(new Dropzone(dropzone));
} else {
result.push(undefined);
}
}
return result;
}();
};
Dropzone.blacklistedBrowsers = [
/opera.*(Macintosh|Windows Phone).*version\/12/i];
Dropzone.isBrowserSupported = function () {
var capableBrowser = true;
if (window.File && window.FileReader && window.FileList && window.Blob && window.FormData && document.querySelector) {
if (!("classList" in document.createElement("a"))) {
capableBrowser = false;
} else {
for (var _iterator34 = Dropzone.blacklistedBrowsers, _isArray34 = true, _i36 = 0, _iterator34 = _isArray34 ? _iterator34 : _iterator34[Symbol.iterator]();;) {
var _ref33;
if (_isArray34) {
if (_i36 >= _iterator34.length) break;
_ref33 = _iterator34[_i36++];
} else {
_i36 = _iterator34.next();
if (_i36.done) break;
_ref33 = _i36.value;
}
var regex = _ref33;
if (regex.test(navigator.userAgent)) {
capableBrowser = false;
continue;
}
}
}
} else {
capableBrowser = false;
}
return capableBrowser;
};
Dropzone.dataURItoBlob = function (dataURI) {
var byteString = atob(dataURI.split(',')[1]);
var mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0];
var ab = new ArrayBuffer(byteString.length);
var ia = new Uint8Array(ab);
for (var i = 0, end = byteString.length, asc = 0 <= end; asc ? i <= end : i >= end; asc ? i++ : i--) {
ia[i] = byteString.charCodeAt(i);
}
return new Blob([ab], { type: mimeString });
};
var without = function without(list, rejectedItem) {
return list.filter(function (item) {
return item !== rejectedItem;
}).map(function (item) {
return item;
});
};
var camelize = function camelize(str) {
return str.replace(/[\-_](\w)/g, function (match) {
return match.charAt(1).toUpperCase();
});
};
Dropzone.createElement = function (string) {
var div = document.createElement("div");
div.innerHTML = string;
return div.childNodes[0];
};
Dropzone.elementInside = function (element, container) {
if (element === container) {
return true;
} // Coffeescript doesn't support do/while loops
while (element = element.parentNode) {
if (element === container) {
return true;
}
}
return false;
};
Dropzone.getElement = function (el, name) {
var element = void 0;
if (typeof el === "string") {
element = document.querySelector(el);
} else if (el.nodeType != null) {
element = el;
}
if (element == null) {
throw new Error("Invalid `" + name + "` option provided. Please provide a CSS selector or a plain HTML element.");
}
return element;
};
Dropzone.getElements = function (els, name) {
var el = void 0,
elements = void 0;
if (els instanceof Array) {
elements = [];
try {
for (var _iterator35 = els, _isArray35 = true, _i37 = 0, _iterator35 = _isArray35 ? _iterator35 : _iterator35[Symbol.iterator]();;) {
if (_isArray35) {
if (_i37 >= _iterator35.length) break;
el = _iterator35[_i37++];
} else {
_i37 = _iterator35.next();
if (_i37.done) break;
el = _i37.value;
}
elements.push(this.getElement(el, name));
}
} catch (e) {
elements = null;
}
} else if (typeof els === "string") {
elements = [];
for (var _iterator36 = document.querySelectorAll(els), _isArray36 = true, _i38 = 0, _iterator36 = _isArray36 ? _iterator36 : _iterator36[Symbol.iterator]();;) {
if (_isArray36) {
if (_i38 >= _iterator36.length) break;
el = _iterator36[_i38++];
} else {
_i38 = _iterator36.next();
if (_i38.done) break;
el = _i38.value;
}
elements.push(el);
}
} else if (els.nodeType != null) {
elements = [els];
}
if (elements == null || !elements.length) {
throw new Error("Invalid `" + name + "` option provided. Please provide a CSS selector, a plain HTML element or a list of those.");
}
return elements;
};
Dropzone.confirm = function (question, accepted, rejected) {
if (window.confirm(question)) {
return accepted();
} else if (rejected != null) {
return rejected();
}
};
Dropzone.isValidFile = function (file, acceptedFiles) {
if (!acceptedFiles) {
return true;
} // If there are no accepted mime types, it's OK
acceptedFiles = acceptedFiles.split(",");
var mimeType = file.type;
var baseMimeType = mimeType.replace(/\/.*$/, "");
for (var _iterator37 = acceptedFiles, _isArray37 = true, _i39 = 0, _iterator37 = _isArray37 ? _iterator37 : _iterator37[Symbol.iterator]();;) {
var _ref34;
if (_isArray37) {
if (_i39 >= _iterator37.length) break;
_ref34 = _iterator37[_i39++];
} else {
_i39 = _iterator37.next();
if (_i39.done) break;
_ref34 = _i39.value;
}
var validType = _ref34;
validType = validType.trim();
if (validType.charAt(0) === ".") {
if (file.name.toLowerCase().indexOf(validType.toLowerCase(), file.name.length - validType.length) !== -1) {
return true;
}
} else if (/\/\*$/.test(validType)) {
if (baseMimeType === validType.replace(/\/.*$/, "")) {
return true;
}
} else {
if (mimeType === validType) {
return true;
}
}
}
return false;
};
if (typeof jQuery !== 'undefined' && jQuery !== null) {
jQuery.fn.dropzone = function (options) {
return this.each(function () {
return new Dropzone(this, options);
});
};
}
if (typeof module !== 'undefined' && module !== null) {
module.exports = Dropzone;
} else {
window.Dropzone = Dropzone;
}
Dropzone.ADDED = "added";
Dropzone.QUEUED = "queued";
Dropzone.ACCEPTED = Dropzone.QUEUED;
Dropzone.UPLOADING = "uploading";
Dropzone.PROCESSING = Dropzone.UPLOADING; // alias
Dropzone.CANCELED = "canceled";
Dropzone.ERROR = "error";
Dropzone.SUCCESS = "success";
var detectVerticalSquash = function detectVerticalSquash(img) {
var iw = img.naturalWidth;
var ih = img.naturalHeight;
var canvas = document.createElement("canvas");
canvas.width = 1;
canvas.height = ih;
var ctx = canvas.getContext("2d");
ctx.drawImage(img, 0, 0);
var _ctx$getImageData = ctx.getImageData(1, 0, 1, ih),
data = _ctx$getImageData.data;
var sy = 0;
var ey = ih;
var py = ih;
while (py > sy) {
var alpha = data[(py - 1) * 4 + 3];
if (alpha === 0) {
ey = py;
} else {
sy = py;
}
py = ey + sy >> 1;
}
var ratio = py / ih;
if (ratio === 0) {
return 1;
} else {
return ratio;
}
};
var drawImageIOSFix = function drawImageIOSFix(ctx, img, sx, sy, sw, sh, dx, dy, dw, dh) {
var vertSquashRatio = detectVerticalSquash(img);
return ctx.drawImage(img, sx, sy, sw, sh, dx, dy, dw, dh / vertSquashRatio);
};
var ExifRestore = function () {
function ExifRestore() {
_classCallCheck(this, ExifRestore);
}
_createClass(ExifRestore, null, [{
key: "initClass",
value: function initClass() {
this.KEY_STR = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
}
}, {
key: "encode64",
value: function encode64(input) {
var output = '';
var chr1 = undefined;
var chr2 = undefined;
var chr3 = '';
var enc1 = undefined;
var enc2 = undefined;
var enc3 = undefined;
var enc4 = '';
var i = 0;
while (true) {
chr1 = input[i++];
chr2 = input[i++];
chr3 = input[i++];
enc1 = chr1 >> 2;
enc2 = (chr1 & 3) << 4 | chr2 >> 4;
enc3 = (chr2 & 15) << 2 | chr3 >> 6;
enc4 = chr3 & 63;
if (isNaN(chr2)) {
enc3 = enc4 = 64;
} else if (isNaN(chr3)) {
enc4 = 64;
}
output = output + this.KEY_STR.charAt(enc1) + this.KEY_STR.charAt(enc2) + this.KEY_STR.charAt(enc3) + this.KEY_STR.charAt(enc4);
chr1 = chr2 = chr3 = '';
enc1 = enc2 = enc3 = enc4 = '';
if (!(i < input.length)) {
break;
}
}
return output;
}
}, {
key: "restore",
value: function restore(origFileBase64, resizedFileBase64) {
if (!origFileBase64.match('data:image/jpeg;base64,')) {
return resizedFileBase64;
}
var rawImage = this.decode64(origFileBase64.replace('data:image/jpeg;base64,', ''));
var segments = this.slice2Segments(rawImage);
var image = this.exifManipulation(resizedFileBase64, segments);
return "data:image/jpeg;base64," + this.encode64(image);
}
}, {
key: "exifManipulation",
value: function exifManipulation(resizedFileBase64, segments) {
var exifArray = this.getExifArray(segments);
var newImageArray = this.insertExif(resizedFileBase64, exifArray);
var aBuffer = new Uint8Array(newImageArray);
return aBuffer;
}
}, {
key: "getExifArray",
value: function getExifArray(segments) {
var seg = undefined;
var x = 0;
while (x < segments.length) {
seg = segments[x];
if (seg[0] === 255 & seg[1] === 225) {
return seg;
}
x++;
}
return [];
}
}, {
key: "insertExif",
value: function insertExif(resizedFileBase64, exifArray) {
var imageData = resizedFileBase64.replace('data:image/jpeg;base64,', '');
var buf = this.decode64(imageData);
var separatePoint = buf.indexOf(255, 3);
var mae = buf.slice(0, separatePoint);
var ato = buf.slice(separatePoint);
var array = mae;
array = array.concat(exifArray);
array = array.concat(ato);
return array;
}
}, {
key: "slice2Segments",
value: function slice2Segments(rawImageArray) {
var head = 0;
var segments = [];
while (true) {
var length;
if (rawImageArray[head] === 255 & rawImageArray[head + 1] === 218) {
break;
}
if (rawImageArray[head] === 255 & rawImageArray[head + 1] === 216) {
head += 2;
} else {
length = rawImageArray[head + 2] * 256 + rawImageArray[head + 3];
var endPoint = head + length + 2;
var seg = rawImageArray.slice(head, endPoint);
segments.push(seg);
head = endPoint;
}
if (head > rawImageArray.length) {
break;
}
}
return segments;
}
}, {
key: "decode64",
value: function decode64(input) {
var output = '';
var chr1 = undefined;
var chr2 = undefined;
var chr3 = '';
var enc1 = undefined;
var enc2 = undefined;
var enc3 = undefined;
var enc4 = '';
var i = 0;
var buf = [];
var base64test = /[^A-Za-z0-9\+\/\=]/g;
if (base64test.exec(input)) {
console.warn('There were invalid base64 characters in the input text.\nValid base64 characters are A-Z, a-z, 0-9, \'+\', \'/\',and \'=\'\nExpect errors in decoding.');
}
input = input.replace(/[^A-Za-z0-9\+\/\=]/g, '');
while (true) {
enc1 = this.KEY_STR.indexOf(input.charAt(i++));
enc2 = this.KEY_STR.indexOf(input.charAt(i++));
enc3 = this.KEY_STR.indexOf(input.charAt(i++));
enc4 = this.KEY_STR.indexOf(input.charAt(i++));
chr1 = enc1 << 2 | enc2 >> 4;
chr2 = (enc2 & 15) << 4 | enc3 >> 2;
chr3 = (enc3 & 3) << 6 | enc4;
buf.push(chr1);
if (enc3 !== 64) {
buf.push(chr2);
}
if (enc4 !== 64) {
buf.push(chr3);
}
chr1 = chr2 = chr3 = '';
enc1 = enc2 = enc3 = enc4 = '';
if (!(i < input.length)) {
break;
}
}
return buf;
}
}]);
return ExifRestore;
}();
ExifRestore.initClass();
var contentLoaded = function contentLoaded(win, fn) {
var done = false;
var top = true;
var doc = win.document;
var root = doc.documentElement;
var add = doc.addEventListener ? "addEventListener" : "attachEvent";
var rem = doc.addEventListener ? "removeEventListener" : "detachEvent";
var pre = doc.addEventListener ? "" : "on";
var init = function init(e) {
if (e.type === "readystatechange" && doc.readyState !== "complete") {
return;
}
(e.type === "load" ? win : doc)[rem](pre + e.type, init, false);
if (!done && (done = true)) {
return fn.call(win, e.type || e);
}
};
var poll = function poll() {
try {
root.doScroll("left");
} catch (e) {
setTimeout(poll, 50);
return;
}
return init("poll");
};
if (doc.readyState !== "complete") {
if (doc.createEventObject && root.doScroll) {
try {
top = !win.frameElement;
} catch (error) {}
if (top) {
poll();
}
}
doc[add](pre + "DOMContentLoaded", init, false);
doc[add](pre + "readystatechange", init, false);
return win[add](pre + "load", init, false);
}
};
Dropzone._autoDiscoverFunction = function () {
if (Dropzone.autoDiscover) {
return Dropzone.discover();
}
};
contentLoaded(window, Dropzone._autoDiscoverFunction);
function __guard__(value, transform) {
return typeof value !== 'undefined' && value !== null ? transform(value) : undefined;
}
function __guardMethod__(obj, methodName, transform) {
if (typeof obj !== 'undefined' && obj !== null && typeof obj[methodName] === 'function') {
return transform(obj, methodName);
} else {
return undefined;
}
}
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('jquery')) :
typeof define === 'function' && define.amd ? define(['jquery'], factory) :
(factory(global.jQuery));
}(this, (function ($$1) { 'use strict';
$$1 = $$1 && $$1.hasOwnProperty('default') ? $$1['default'] : $$1;
var Renderer = (function () {
function Renderer(markup, children, options, callback) {
this.markup = markup;
this.children = children;
this.options = options;
this.callback = callback;
}
Renderer.prototype.render = function ($parent) {
var $node = $$1(this.markup);
if (this.options && this.options.contents) {
$node.html(this.options.contents);
}
if (this.options && this.options.className) {
$node.addClass(this.options.className);
}
if (this.options && this.options.data) {
$$1.each(this.options.data, function (k, v) {
$node.attr('data-' + k, v);
});
}
if (this.options && this.options.click) {
$node.on('click', this.options.click);
}
if (this.children) {
var $container_1 = $node.find('.note-children-container');
this.children.forEach(function (child) {
child.render($container_1.length ? $container_1 : $node);
});
}
if (this.callback) {
this.callback($node, this.options);
}
if (this.options && this.options.callback) {
this.options.callback($node);
}
if ($parent) {
$parent.append($node);
}
return $node;
};
return Renderer;
}());
var renderer = {
create: function (markup, callback) {
return function () {
var options = typeof arguments[1] === 'object' ? arguments[1] : arguments[0];
var children = $$1.isArray(arguments[0]) ? arguments[0] : [];
if (options && options.children) {
children = options.children;
}
return new Renderer(markup, children, options, callback);
};
}
};
var editor = renderer.create('<div class="note-editor note-frame panel"/>');
var toolbar = renderer.create('<div class="note-toolbar-wrapper panel-default"><div class="note-toolbar panel-heading"></div></div>');
var editingArea = renderer.create('<div class="note-editing-area"/>');
var codable = renderer.create('<textarea class="note-codable"/>');
var editable = renderer.create('<div class="note-editable" contentEditable="true"/>');
var statusbar = renderer.create([
'<div class="note-statusbar">',
'  <div class="note-resizebar">',
'    <div class="note-icon-bar"/>',
'    <div class="note-icon-bar"/>',
'    <div class="note-icon-bar"/>',
'  </div>',
'</div>'
].join(''));
var airEditor = renderer.create('<div class="note-editor"/>');
var airEditable = renderer.create('<div class="note-editable" contentEditable="true"/>');
var buttonGroup = renderer.create('<div class="note-btn-group btn-group">');
var dropdown = renderer.create('<div class="dropdown-menu">', function ($node, options) {
var markup = $$1.isArray(options.items) ? options.items.map(function (item) {
var value = (typeof item === 'string') ? item : (item.value || '');
var content = options.template ? options.template(item) : item;
var option = (typeof item === 'object') ? item.option : undefined;
var dataValue = 'data-value="' + value + '"';
var dataOption = (option !== undefined) ? ' data-option="' + option + '"' : '';
return '<li><a href="#" ' + (dataValue + dataOption) + '>' + content + '</a></li>';
}).join('') : options.items;
$node.html(markup);
});
var dropdownButtonContents = function (contents, options) {
return contents + ' ' + icon(options.icons.caret, 'span');
};
var dropdownCheck = renderer.create('<div class="dropdown-menu note-check">', function ($node, options) {
var markup = $$1.isArray(options.items) ? options.items.map(function (item) {
var value = (typeof item === 'string') ? item : (item.value || '');
var content = options.template ? options.template(item) : item;
return '<li><a href="#" data-value="' + value + '">' + icon(options.checkClassName) + ' ' + content + '</a></li>';
}).join('') : options.items;
$node.html(markup);
});
var palette = renderer.create('<div class="note-color-palette"/>', function ($node, options) {
var contents = [];
for (var row = 0, rowSize = options.colors.length; row < rowSize; row++) {
var eventName = options.eventName;
var colors = options.colors[row];
var buttons = [];
for (var col = 0, colSize = colors.length; col < colSize; col++) {
var color = colors[col];
buttons.push([
'<button type="button" class="note-color-btn"',
'style="background-color:', color, '" ',
'data-event="', eventName, '" ',
'data-value="', color, '" ',
'title="', color, '" ',
'data-toggle="button" tabindex="-1"></button>'
].join(''));
}
contents.push('<div class="note-color-row">' + buttons.join('') + '</div>');
}
$node.html(contents.join(''));
if (options.tooltip) {
$node.find('.note-color-btn').tooltip({
container: options.container,
trigger: 'hover',
placement: 'bottom'
});
}
});
var dialog = renderer.create('<div class="modal" aria-hidden="false" tabindex="-1"/>', function ($node, options) {
if (options.fade) {
$node.addClass('fade');
}
$node.html([
'<div class="modal-dialog">',
'  <div class="modal-content">',
(options.title
? '    <div class="modal-header">' +
'      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>' +
'      <h4 class="modal-title">' + options.title + '</h4>' +
'    </div>' : ''),
'    <div class="modal-body">' + options.body + '</div>',
(options.footer
? '    <div class="modal-footer">' + options.footer + '</div>' : ''),
'  </div>',
'</div>'
].join(''));
});
var popover = renderer.create([
'<div class="note-popover popover in">',
'  <div class="arrow"/>',
'  <div class="popover-content note-children-container"/>',
'</div>'
].join(''), function ($node, options) {
var direction = typeof options.direction !== 'undefined' ? options.direction : 'bottom';
$node.addClass(direction);
if (options.hideArrow) {
$node.find('.arrow').hide();
}
});
var checkbox = renderer.create('<div class="checkbox"></div>', function ($node, options) {
$node.html([
' <label' + (options.id ? ' for="' + options.id + '"' : '') + '>',
' <input type="checkbox"' + (options.id ? ' id="' + options.id + '"' : ''),
(options.checked ? ' checked' : '') + '/>',
(options.text ? options.text : ''),
'</label>'
].join(''));
});
var icon = function (iconClassName, tagName) {
tagName = tagName || 'i';
return '<' + tagName + ' class="' + iconClassName + '"/>';
};
var ui = {
editor: editor,
toolbar: toolbar,
editingArea: editingArea,
codable: codable,
editable: editable,
statusbar: statusbar,
airEditor: airEditor,
airEditable: airEditable,
buttonGroup: buttonGroup,
dropdown: dropdown,
dropdownButtonContents: dropdownButtonContents,
dropdownCheck: dropdownCheck,
palette: palette,
dialog: dialog,
popover: popover,
checkbox: checkbox,
icon: icon,
options: {},
button: function ($node, options) {
return renderer.create('<button type="button" class="note-btn btn btn-default btn-sm" tabindex="-1">', function ($node, options) {
if (options && options.tooltip) {
$node.attr({
title: options.tooltip
}).tooltip({
container: options.container,
trigger: 'hover',
placement: 'bottom'
});
}
})($node, options);
},
toggleBtn: function ($btn, isEnable) {
$btn.toggleClass('disabled', !isEnable);
$btn.attr('disabled', !isEnable);
},
toggleBtnActive: function ($btn, isActive) {
$btn.toggleClass('active', isActive);
},
onDialogShown: function ($dialog, handler) {
$dialog.one('shown.bs.modal', handler);
},
onDialogHidden: function ($dialog, handler) {
$dialog.one('hidden.bs.modal', handler);
},
showDialog: function ($dialog) {
$dialog.modal('show');
},
hideDialog: function ($dialog) {
$dialog.modal('hide');
},
createLayout: function ($note, options) {
var $editor = (options.airMode ? ui.airEditor([
ui.editingArea([
ui.airEditable()
])
]) : ui.editor([
ui.toolbar(),
ui.editingArea([
ui.codable(),
ui.editable()
]),
ui.statusbar()
])).render();
$editor.insertAfter($note);
return {
note: $note,
editor: $editor,
toolbar: $editor.find('.note-toolbar'),
editingArea: $editor.find('.note-editing-area'),
editable: $editor.find('.note-editable'),
codable: $editor.find('.note-codable'),
statusbar: $editor.find('.note-statusbar')
};
},
removeLayout: function ($note, layoutInfo) {
$note.html(layoutInfo.editable.html());
layoutInfo.editor.remove();
$note.show();
}
};
function eq(itemA) {
return function (itemB) {
return itemA === itemB;
};
}
function eq2(itemA, itemB) {
return itemA === itemB;
}
function peq2(propName) {
return function (itemA, itemB) {
return itemA[propName] === itemB[propName];
};
}
function ok() {
return true;
}
function fail() {
return false;
}
function not(f) {
return function () {
return !f.apply(f, arguments);
};
}
function and(fA, fB) {
return function (item) {
return fA(item) && fB(item);
};
}
function self(a) {
return a;
}
function invoke(obj, method) {
return function () {
return obj[method].apply(obj, arguments);
};
}
var idCounter = 0;
function uniqueId(prefix) {
var id = ++idCounter + '';
return prefix ? prefix + id : id;
}
function rect2bnd(rect) {
var $document = $(document);
return {
top: rect.top + $document.scrollTop(),
left: rect.left + $document.scrollLeft(),
width: rect.right - rect.left,
height: rect.bottom - rect.top
};
}
function invertObject(obj) {
var inverted = {};
for (var key in obj) {
if (obj.hasOwnProperty(key)) {
inverted[obj[key]] = key;
}
}
return inverted;
}
function namespaceToCamel(namespace, prefix) {
prefix = prefix || '';
return prefix + namespace.split('.').map(function (name) {
return name.substring(0, 1).toUpperCase() + name.substring(1);
}).join('');
}
function debounce(func, wait, immediate) {
var _this = this;
var timeout;
return function () {
var context = _this;
var args = arguments;
var later = function () {
timeout = null;
if (!immediate) {
func.apply(context, args);
}
};
var callNow = immediate && !timeout;
clearTimeout(timeout);
timeout = setTimeout(later, wait);
if (callNow) {
func.apply(context, args);
}
};
}
var func = {
eq: eq,
eq2: eq2,
peq2: peq2,
ok: ok,
fail: fail,
self: self,
not: not,
and: and,
invoke: invoke,
uniqueId: uniqueId,
rect2bnd: rect2bnd,
invertObject: invertObject,
namespaceToCamel: namespaceToCamel,
debounce: debounce
};
function head(array) {
return array[0];
}
function last(array) {
return array[array.length - 1];
}
function initial(array) {
return array.slice(0, array.length - 1);
}
function tail(array) {
return array.slice(1);
}
function find(array, pred) {
for (var idx = 0, len = array.length; idx < len; idx++) {
var item = array[idx];
if (pred(item)) {
return item;
}
}
}
function all(array, pred) {
for (var idx = 0, len = array.length; idx < len; idx++) {
if (!pred(array[idx])) {
return false;
}
}
return true;
}
function indexOf(array, item) {
return $$1.inArray(item, array);
}
function contains(array, item) {
return indexOf(array, item) !== -1;
}
function sum(array, fn) {
fn = fn || func.self;
return array.reduce(function (memo, v) {
return memo + fn(v);
}, 0);
}
function from(collection) {
var result = [];
var length = collection.length;
var idx = -1;
while (++idx < length) {
result[idx] = collection[idx];
}
return result;
}
function isEmpty$1(array) {
return !array || !array.length;
}
function clusterBy(array, fn) {
if (!array.length) {
return [];
}
var aTail = tail(array);
return aTail.reduce(function (memo, v) {
var aLast = last(memo);
if (fn(last(aLast), v)) {
aLast[aLast.length] = v;
}
else {
memo[memo.length] = [v];
}
return memo;
}, [[head(array)]]);
}
function compact(array) {
var aResult = [];
for (var idx = 0, len = array.length; idx < len; idx++) {
if (array[idx]) {
aResult.push(array[idx]);
}
}
return aResult;
}
function unique(array) {
var results = [];
for (var idx = 0, len = array.length; idx < len; idx++) {
if (!contains(results, array[idx])) {
results.push(array[idx]);
}
}
return results;
}
function next(array, item) {
var idx = indexOf(array, item);
if (idx === -1) {
return null;
}
return array[idx + 1];
}
function prev(array, item) {
var idx = indexOf(array, item);
if (idx === -1) {
return null;
}
return array[idx - 1];
}
var lists = {
head: head,
last: last,
initial: initial,
tail: tail,
prev: prev,
next: next,
find: find,
contains: contains,
all: all,
sum: sum,
from: from,
isEmpty: isEmpty$1,
clusterBy: clusterBy,
compact: compact,
unique: unique
};
var isSupportAmd = typeof define === 'function' && define.amd; // eslint-disable-line
function isFontInstalled(fontName) {
var testFontName = fontName === 'Comic Sans MS' ? 'Courier New' : 'Comic Sans MS';
var $tester = $$1('<div>').css({
position: 'absolute',
left: '-9999px',
top: '-9999px',
fontSize: '200px'
}).text('mmmmmmmmmwwwwwww').appendTo(document.body);
var originalWidth = $tester.css('fontFamily', testFontName).width();
var width = $tester.css('fontFamily', fontName + ',' + testFontName).width();
$tester.remove();
return originalWidth !== width;
}
var userAgent = navigator.userAgent;
var isMSIE = /MSIE|Trident/i.test(userAgent);
var browserVersion;
if (isMSIE) {
var matches = /MSIE (\d+[.]\d+)/.exec(userAgent);
if (matches) {
browserVersion = parseFloat(matches[1]);
}
matches = /Trident\/.*rv:([0-9]{1,}[.0-9]{0,})/.exec(userAgent);
if (matches) {
browserVersion = parseFloat(matches[1]);
}
}
var isEdge = /Edge\/\d+/.test(userAgent);
var hasCodeMirror = !!window.CodeMirror;
if (!hasCodeMirror && isSupportAmd) {
if (typeof __webpack_require__ === 'function') {
try {
require.resolve('codemirror');
hasCodeMirror = true;
}
catch (e) {
}
}
else if (typeof require !== 'undefined') {
if (typeof require.resolve !== 'undefined') {
try {
require.resolve('codemirror');
hasCodeMirror = true;
}
catch (e) {
}
}
else if (typeof require.specified !== 'undefined') {
hasCodeMirror = require.specified('codemirror');
}
}
}
var isSupportTouch = (('ontouchstart' in window) ||
(navigator.MaxTouchPoints > 0) ||
(navigator.msMaxTouchPoints > 0));
var inputEventName = (isMSIE || isEdge) ? 'DOMCharacterDataModified DOMSubtreeModified DOMNodeInserted' : 'input';
var env = {
isMac: navigator.appVersion.indexOf('Mac') > -1,
isMSIE: isMSIE,
isEdge: isEdge,
isFF: !isEdge && /firefox/i.test(userAgent),
isPhantom: /PhantomJS/i.test(userAgent),
isWebkit: !isEdge && /webkit/i.test(userAgent),
isChrome: !isEdge && /chrome/i.test(userAgent),
isSafari: !isEdge && /safari/i.test(userAgent),
browserVersion: browserVersion,
jqueryVersion: parseFloat($$1.fn.jquery),
isSupportAmd: isSupportAmd,
isSupportTouch: isSupportTouch,
hasCodeMirror: hasCodeMirror,
isFontInstalled: isFontInstalled,
isW3CRangeSupport: !!document.createRange,
inputEventName: inputEventName
};
var NBSP_CHAR = String.fromCharCode(160);
var ZERO_WIDTH_NBSP_CHAR = '\ufeff';
function isEditable(node) {
return node && $$1(node).hasClass('note-editable');
}
function isControlSizing(node) {
return node && $$1(node).hasClass('note-control-sizing');
}
function makePredByNodeName(nodeName) {
nodeName = nodeName.toUpperCase();
return function (node) {
return node && node.nodeName.toUpperCase() === nodeName;
};
}
function isText(node) {
return node && node.nodeType === 3;
}
function isElement(node) {
return node && node.nodeType === 1;
}
function isVoid(node) {
return node && /^BR|^IMG|^HR|^IFRAME|^BUTTON|^INPUT/.test(node.nodeName.toUpperCase());
}
function isPara(node) {
if (isEditable(node)) {
return false;
}
return node && /^DIV|^P|^LI|^H[1-7]/.test(node.nodeName.toUpperCase());
}
function isHeading(node) {
return node && /^H[1-7]/.test(node.nodeName.toUpperCase());
}
var isPre = makePredByNodeName('PRE');
var isLi = makePredByNodeName('LI');
function isPurePara(node) {
return isPara(node) && !isLi(node);
}
var isTable = makePredByNodeName('TABLE');
var isData = makePredByNodeName('DATA');
function isInline(node) {
return !isBodyContainer(node) &&
!isList(node) &&
!isHr(node) &&
!isPara(node) &&
!isTable(node) &&
!isBlockquote(node) &&
!isData(node);
}
function isList(node) {
return node && /^UL|^OL/.test(node.nodeName.toUpperCase());
}
var isHr = makePredByNodeName('HR');
function isCell(node) {
return node && /^TD|^TH/.test(node.nodeName.toUpperCase());
}
var isBlockquote = makePredByNodeName('BLOCKQUOTE');
function isBodyContainer(node) {
return isCell(node) || isBlockquote(node) || isEditable(node);
}
var isAnchor = makePredByNodeName('A');
function isParaInline(node) {
return isInline(node) && !!ancestor(node, isPara);
}
function isBodyInline(node) {
return isInline(node) && !ancestor(node, isPara);
}
var isBody = makePredByNodeName('BODY');
function isClosestSibling(nodeA, nodeB) {
return nodeA.nextSibling === nodeB ||
nodeA.previousSibling === nodeB;
}
function withClosestSiblings(node, pred) {
pred = pred || func.ok;
var siblings = [];
if (node.previousSibling && pred(node.previousSibling)) {
siblings.push(node.previousSibling);
}
siblings.push(node);
if (node.nextSibling && pred(node.nextSibling)) {
siblings.push(node.nextSibling);
}
return siblings;
}
var blankHTML = env.isMSIE && env.browserVersion < 11 ? '&nbsp;' : '<br>';
function nodeLength(node) {
if (isText(node)) {
return node.nodeValue.length;
}
if (node) {
return node.childNodes.length;
}
return 0;
}
function isEmpty(node) {
var len = nodeLength(node);
if (len === 0) {
return true;
}
else if (!isText(node) && len === 1 && node.innerHTML === blankHTML) {
return true;
}
else if (lists.all(node.childNodes, isText) && node.innerHTML === '') {
return true;
}
return false;
}
function paddingBlankHTML(node) {
if (!isVoid(node) && !nodeLength(node)) {
node.innerHTML = blankHTML;
}
}
function ancestor(node, pred) {
while (node) {
if (pred(node)) {
return node;
}
if (isEditable(node)) {
break;
}
node = node.parentNode;
}
return null;
}
function singleChildAncestor(node, pred) {
node = node.parentNode;
while (node) {
if (nodeLength(node) !== 1) {
break;
}
if (pred(node)) {
return node;
}
if (isEditable(node)) {
break;
}
node = node.parentNode;
}
return null;
}
function listAncestor(node, pred) {
pred = pred || func.fail;
var ancestors = [];
ancestor(node, function (el) {
if (!isEditable(el)) {
ancestors.push(el);
}
return pred(el);
});
return ancestors;
}
function lastAncestor(node, pred) {
var ancestors = listAncestor(node);
return lists.last(ancestors.filter(pred));
}
function commonAncestor(nodeA, nodeB) {
var ancestors = listAncestor(nodeA);
for (var n = nodeB; n; n = n.parentNode) {
if ($$1.inArray(n, ancestors) > -1) {
return n;
}
}
return null; // difference document area
}
function listPrev(node, pred) {
pred = pred || func.fail;
var nodes = [];
while (node) {
if (pred(node)) {
break;
}
nodes.push(node);
node = node.previousSibling;
}
return nodes;
}
function listNext(node, pred) {
pred = pred || func.fail;
var nodes = [];
while (node) {
if (pred(node)) {
break;
}
nodes.push(node);
node = node.nextSibling;
}
return nodes;
}
function listDescendant(node, pred) {
var descendants = [];
pred = pred || func.ok;
(function fnWalk(current) {
if (node !== current && pred(current)) {
descendants.push(current);
}
for (var idx = 0, len = current.childNodes.length; idx < len; idx++) {
fnWalk(current.childNodes[idx]);
}
})(node);
return descendants;
}
function wrap(node, wrapperName) {
var parent = node.parentNode;
var wrapper = $$1('<' + wrapperName + '>')[0];
parent.insertBefore(wrapper, node);
wrapper.appendChild(node);
return wrapper;
}
function insertAfter(node, preceding) {
var next = preceding.nextSibling;
var parent = preceding.parentNode;
if (next) {
parent.insertBefore(node, next);
}
else {
parent.appendChild(node);
}
return node;
}
function appendChildNodes(node, aChild) {
$$1.each(aChild, function (idx, child) {
node.appendChild(child);
});
return node;
}
function isLeftEdgePoint(point) {
return point.offset === 0;
}
function isRightEdgePoint(point) {
return point.offset === nodeLength(point.node);
}
function isEdgePoint(point) {
return isLeftEdgePoint(point) || isRightEdgePoint(point);
}
function isLeftEdgeOf(node, ancestor) {
while (node && node !== ancestor) {
if (position(node) !== 0) {
return false;
}
node = node.parentNode;
}
return true;
}
function isRightEdgeOf(node, ancestor) {
if (!ancestor) {
return false;
}
while (node && node !== ancestor) {
if (position(node) !== nodeLength(node.parentNode) - 1) {
return false;
}
node = node.parentNode;
}
return true;
}
function isLeftEdgePointOf(point, ancestor) {
return isLeftEdgePoint(point) && isLeftEdgeOf(point.node, ancestor);
}
function isRightEdgePointOf(point, ancestor) {
return isRightEdgePoint(point) && isRightEdgeOf(point.node, ancestor);
}
function position(node) {
var offset = 0;
while ((node = node.previousSibling)) {
offset += 1;
}
return offset;
}
function hasChildren(node) {
return !!(node && node.childNodes && node.childNodes.length);
}
function prevPoint(point, isSkipInnerOffset) {
var node;
var offset;
if (point.offset === 0) {
if (isEditable(point.node)) {
return null;
}
node = point.node.parentNode;
offset = position(point.node);
}
else if (hasChildren(point.node)) {
node = point.node.childNodes[point.offset - 1];
offset = nodeLength(node);
}
else {
node = point.node;
offset = isSkipInnerOffset ? 0 : point.offset - 1;
}
return {
node: node,
offset: offset
};
}
function nextPoint(point, isSkipInnerOffset) {
var node, offset;
if (nodeLength(point.node) === point.offset) {
if (isEditable(point.node)) {
return null;
}
node = point.node.parentNode;
offset = position(point.node) + 1;
}
else if (hasChildren(point.node)) {
node = point.node.childNodes[point.offset];
offset = 0;
}
else {
node = point.node;
offset = isSkipInnerOffset ? nodeLength(point.node) : point.offset + 1;
}
return {
node: node,
offset: offset
};
}
function isSamePoint(pointA, pointB) {
return pointA.node === pointB.node && pointA.offset === pointB.offset;
}
function isVisiblePoint(point) {
if (isText(point.node) || !hasChildren(point.node) || isEmpty(point.node)) {
return true;
}
var leftNode = point.node.childNodes[point.offset - 1];
var rightNode = point.node.childNodes[point.offset];
if ((!leftNode || isVoid(leftNode)) && (!rightNode || isVoid(rightNode))) {
return true;
}
return false;
}
function prevPointUntil(point, pred) {
while (point) {
if (pred(point)) {
return point;
}
point = prevPoint(point);
}
return null;
}
function nextPointUntil(point, pred) {
while (point) {
if (pred(point)) {
return point;
}
point = nextPoint(point);
}
return null;
}
function isCharPoint(point) {
if (!isText(point.node)) {
return false;
}
var ch = point.node.nodeValue.charAt(point.offset - 1);
return ch && (ch !== ' ' && ch !== NBSP_CHAR);
}
function walkPoint(startPoint, endPoint, handler, isSkipInnerOffset) {
var point = startPoint;
while (point) {
handler(point);
if (isSamePoint(point, endPoint)) {
break;
}
var isSkipOffset = isSkipInnerOffset &&
startPoint.node !== point.node &&
endPoint.node !== point.node;
point = nextPoint(point, isSkipOffset);
}
}
function makeOffsetPath(ancestor, node) {
var ancestors = listAncestor(node, func.eq(ancestor));
return ancestors.map(position).reverse();
}
function fromOffsetPath(ancestor, offsets) {
var current = ancestor;
for (var i = 0, len = offsets.length; i < len; i++) {
if (current.childNodes.length <= offsets[i]) {
current = current.childNodes[current.childNodes.length - 1];
}
else {
current = current.childNodes[offsets[i]];
}
}
return current;
}
function splitNode(point, options) {
var isSkipPaddingBlankHTML = options && options.isSkipPaddingBlankHTML;
var isNotSplitEdgePoint = options && options.isNotSplitEdgePoint;
if (isEdgePoint(point) && (isText(point.node) || isNotSplitEdgePoint)) {
if (isLeftEdgePoint(point)) {
return point.node;
}
else if (isRightEdgePoint(point)) {
return point.node.nextSibling;
}
}
if (isText(point.node)) {
return point.node.splitText(point.offset);
}
else {
var childNode = point.node.childNodes[point.offset];
var clone = insertAfter(point.node.cloneNode(false), point.node);
appendChildNodes(clone, listNext(childNode));
if (!isSkipPaddingBlankHTML) {
paddingBlankHTML(point.node);
paddingBlankHTML(clone);
}
return clone;
}
}
function splitTree(root, point, options) {
var ancestors = listAncestor(point.node, func.eq(root));
if (!ancestors.length) {
return null;
}
else if (ancestors.length === 1) {
return splitNode(point, options);
}
return ancestors.reduce(function (node, parent) {
if (node === point.node) {
node = splitNode(point, options);
}
return splitNode({
node: parent,
offset: node ? position(node) : nodeLength(parent)
}, options);
});
}
function splitPoint(point, isInline) {
var pred = isInline ? isPara : isBodyContainer;
var ancestors = listAncestor(point.node, pred);
var topAncestor = lists.last(ancestors) || point.node;
var splitRoot, container;
if (pred(topAncestor)) {
splitRoot = ancestors[ancestors.length - 2];
container = topAncestor;
}
else {
splitRoot = topAncestor;
container = splitRoot.parentNode;
}
var pivot = splitRoot && splitTree(splitRoot, point, {
isSkipPaddingBlankHTML: isInline,
isNotSplitEdgePoint: isInline
});
if (!pivot && container === point.node) {
pivot = point.node.childNodes[point.offset];
}
return {
rightNode: pivot,
container: container
};
}
function create(nodeName) {
return document.createElement(nodeName);
}
function createText(text) {
return document.createTextNode(text);
}
function remove(node, isRemoveChild) {
if (!node || !node.parentNode) {
return;
}
if (node.removeNode) {
return node.removeNode(isRemoveChild);
}
var parent = node.parentNode;
if (!isRemoveChild) {
var nodes = [];
for (var i = 0, len = node.childNodes.length; i < len; i++) {
nodes.push(node.childNodes[i]);
}
for (var i = 0, len = nodes.length; i < len; i++) {
parent.insertBefore(nodes[i], node);
}
}
parent.removeChild(node);
}
function removeWhile(node, pred) {
while (node) {
if (isEditable(node) || !pred(node)) {
break;
}
var parent = node.parentNode;
remove(node);
node = parent;
}
}
function replace(node, nodeName) {
if (node.nodeName.toUpperCase() === nodeName.toUpperCase()) {
return node;
}
var newNode = create(nodeName);
if (node.style.cssText) {
newNode.style.cssText = node.style.cssText;
}
appendChildNodes(newNode, lists.from(node.childNodes));
insertAfter(newNode, node);
remove(node);
return newNode;
}
var isTextarea = makePredByNodeName('TEXTAREA');
function value($node, stripLinebreaks) {
var val = isTextarea($node[0]) ? $node.val() : $node.html();
if (stripLinebreaks) {
return val.replace(/[\n\r]/g, '');
}
return val;
}
function html($node, isNewlineOnBlock) {
var markup = value($node);
if (isNewlineOnBlock) {
var regexTag = /<(\/?)(\b(?!!)[^>\s]*)(.*?)(\s*\/?>)/g;
markup = markup.replace(regexTag, function (match, endSlash, name) {
name = name.toUpperCase();
var isEndOfInlineContainer = /^DIV|^TD|^TH|^P|^LI|^H[1-7]/.test(name) &&
!!endSlash;
var isBlockNode = /^BLOCKQUOTE|^TABLE|^TBODY|^TR|^HR|^UL|^OL/.test(name);
return match + ((isEndOfInlineContainer || isBlockNode) ? '\n' : '');
});
markup = $$1.trim(markup);
}
return markup;
}
function posFromPlaceholder(placeholder) {
var $placeholder = $$1(placeholder);
var pos = $placeholder.offset();
var height = $placeholder.outerHeight(true); // include margin
return {
left: pos.left,
top: pos.top + height
};
}
function attachEvents($node, events) {
Object.keys(events).forEach(function (key) {
$node.on(key, events[key]);
});
}
function detachEvents($node, events) {
Object.keys(events).forEach(function (key) {
$node.off(key, events[key]);
});
}
function isCustomStyleTag(node) {
return node && !isText(node) && lists.contains(node.classList, 'note-styletag');
}
var dom = {
NBSP_CHAR: NBSP_CHAR,
ZERO_WIDTH_NBSP_CHAR: ZERO_WIDTH_NBSP_CHAR,
blank: blankHTML,
emptyPara: "<p>" + blankHTML + "</p>",
makePredByNodeName: makePredByNodeName,
isEditable: isEditable,
isControlSizing: isControlSizing,
isText: isText,
isElement: isElement,
isVoid: isVoid,
isPara: isPara,
isPurePara: isPurePara,
isHeading: isHeading,
isInline: isInline,
isBlock: func.not(isInline),
isBodyInline: isBodyInline,
isBody: isBody,
isParaInline: isParaInline,
isPre: isPre,
isList: isList,
isTable: isTable,
isData: isData,
isCell: isCell,
isBlockquote: isBlockquote,
isBodyContainer: isBodyContainer,
isAnchor: isAnchor,
isDiv: makePredByNodeName('DIV'),
isLi: isLi,
isBR: makePredByNodeName('BR'),
isSpan: makePredByNodeName('SPAN'),
isB: makePredByNodeName('B'),
isU: makePredByNodeName('U'),
isS: makePredByNodeName('S'),
isI: makePredByNodeName('I'),
isImg: makePredByNodeName('IMG'),
isTextarea: isTextarea,
isEmpty: isEmpty,
isEmptyAnchor: func.and(isAnchor, isEmpty),
isClosestSibling: isClosestSibling,
withClosestSiblings: withClosestSiblings,
nodeLength: nodeLength,
isLeftEdgePoint: isLeftEdgePoint,
isRightEdgePoint: isRightEdgePoint,
isEdgePoint: isEdgePoint,
isLeftEdgeOf: isLeftEdgeOf,
isRightEdgeOf: isRightEdgeOf,
isLeftEdgePointOf: isLeftEdgePointOf,
isRightEdgePointOf: isRightEdgePointOf,
prevPoint: prevPoint,
nextPoint: nextPoint,
isSamePoint: isSamePoint,
isVisiblePoint: isVisiblePoint,
prevPointUntil: prevPointUntil,
nextPointUntil: nextPointUntil,
isCharPoint: isCharPoint,
walkPoint: walkPoint,
ancestor: ancestor,
singleChildAncestor: singleChildAncestor,
listAncestor: listAncestor,
lastAncestor: lastAncestor,
listNext: listNext,
listPrev: listPrev,
listDescendant: listDescendant,
commonAncestor: commonAncestor,
wrap: wrap,
insertAfter: insertAfter,
appendChildNodes: appendChildNodes,
position: position,
hasChildren: hasChildren,
makeOffsetPath: makeOffsetPath,
fromOffsetPath: fromOffsetPath,
splitTree: splitTree,
splitPoint: splitPoint,
create: create,
createText: createText,
remove: remove,
removeWhile: removeWhile,
replace: replace,
html: html,
value: value,
posFromPlaceholder: posFromPlaceholder,
attachEvents: attachEvents,
detachEvents: detachEvents,
isCustomStyleTag: isCustomStyleTag
};
$$1.summernote = $$1.summernote || {
lang: {}
};
$$1.extend($$1.summernote.lang, {
'en-US': {
font: {
bold: 'Bold',
italic: 'Italic',
underline: 'Underline',
clear: 'Remove Font Style',
height: 'Line Height',
name: 'Font Family',
strikethrough: 'Strikethrough',
subscript: 'Subscript',
superscript: 'Superscript',
size: 'Font Size'
},
image: {
image: 'Picture',
insert: 'Insert Image',
resizeFull: 'Resize Full',
resizeHalf: 'Resize Half',
resizeQuarter: 'Resize Quarter',
floatLeft: 'Float Left',
floatRight: 'Float Right',
floatNone: 'Float None',
shapeRounded: 'Shape: Rounded',
shapeCircle: 'Shape: Circle',
shapeThumbnail: 'Shape: Thumbnail',
shapeNone: 'Shape: None',
dragImageHere: 'Drag image or text here',
dropImage: 'Drop image or Text',
selectFromFiles: 'Select from files',
maximumFileSize: 'Maximum file size',
maximumFileSizeError: 'Maximum file size exceeded.',
url: 'Image URL',
remove: 'Remove Image',
original: 'Original'
},
video: {
video: 'Video',
videoLink: 'Video Link',
insert: 'Insert Video',
url: 'Video URL',
providers: '(YouTube, Vimeo, Vine, Instagram, DailyMotion or Youku)'
},
link: {
link: 'Link',
insert: 'Insert Link',
unlink: 'Unlink',
edit: 'Edit',
textToDisplay: 'Text to display',
url: 'To what URL should this link go?',
openInNewWindow: 'Open in new window'
},
table: {
table: 'Table',
addRowAbove: 'Add row above',
addRowBelow: 'Add row below',
addColLeft: 'Add column left',
addColRight: 'Add column right',
delRow: 'Delete row',
delCol: 'Delete column',
delTable: 'Delete table'
},
hr: {
insert: 'Insert Horizontal Rule'
},
style: {
style: 'Style',
p: 'Normal',
blockquote: 'Quote',
pre: 'Code',
h1: 'Header 1',
h2: 'Header 2',
h3: 'Header 3',
h4: 'Header 4',
h5: 'Header 5',
h6: 'Header 6'
},
lists: {
unordered: 'Unordered list',
ordered: 'Ordered list'
},
options: {
help: 'Help',
fullscreen: 'Full Screen',
codeview: 'Code View'
},
paragraph: {
paragraph: 'Paragraph',
outdent: 'Outdent',
indent: 'Indent',
left: 'Align left',
center: 'Align center',
right: 'Align right',
justify: 'Justify full'
},
color: {
recent: 'Recent Color',
more: 'More Color',
background: 'Background Color',
foreground: 'Foreground Color',
transparent: 'Transparent',
setTransparent: 'Set transparent',
reset: 'Reset',
resetToDefault: 'Reset to default'
},
shortcut: {
shortcuts: 'Keyboard shortcuts',
close: 'Close',
textFormatting: 'Text formatting',
action: 'Action',
paragraphFormatting: 'Paragraph formatting',
documentStyle: 'Document Style',
extraKeys: 'Extra keys'
},
help: {
'insertParagraph': 'Insert Paragraph',
'undo': 'Undoes the last command',
'redo': 'Redoes the last command',
'tab': 'Tab',
'untab': 'Untab',
'bold': 'Set a bold style',
'italic': 'Set a italic style',
'underline': 'Set a underline style',
'strikethrough': 'Set a strikethrough style',
'removeFormat': 'Clean a style',
'justifyLeft': 'Set left align',
'justifyCenter': 'Set center align',
'justifyRight': 'Set right align',
'justifyFull': 'Set full align',
'insertUnorderedList': 'Toggle unordered list',
'insertOrderedList': 'Toggle ordered list',
'outdent': 'Outdent on current paragraph',
'indent': 'Indent on current paragraph',
'formatPara': 'Change current block\'s format as a paragraph(P tag)',
'formatH1': 'Change current block\'s format as H1',
'formatH2': 'Change current block\'s format as H2',
'formatH3': 'Change current block\'s format as H3',
'formatH4': 'Change current block\'s format as H4',
'formatH5': 'Change current block\'s format as H5',
'formatH6': 'Change current block\'s format as H6',
'insertHorizontalRule': 'Insert horizontal rule',
'linkDialog.show': 'Show Link Dialog'
},
history: {
undo: 'Undo',
redo: 'Redo'
},
specialChar: {
specialChar: 'SPECIAL CHARACTERS',
select: 'Select Special characters'
}
}
});
var KEY_MAP = {
'BACKSPACE': 8,
'TAB': 9,
'ENTER': 13,
'SPACE': 32,
'DELETE': 46,
'LEFT': 37,
'UP': 38,
'RIGHT': 39,
'DOWN': 40,
'NUM0': 48,
'NUM1': 49,
'NUM2': 50,
'NUM3': 51,
'NUM4': 52,
'NUM5': 53,
'NUM6': 54,
'NUM7': 55,
'NUM8': 56,
'B': 66,
'E': 69,
'I': 73,
'J': 74,
'K': 75,
'L': 76,
'R': 82,
'S': 83,
'U': 85,
'V': 86,
'Y': 89,
'Z': 90,
'SLASH': 191,
'LEFTBRACKET': 219,
'BACKSLASH': 220,
'RIGHTBRACKET': 221
};
var key = {
isEdit: function (keyCode) {
return lists.contains([
KEY_MAP.BACKSPACE,
KEY_MAP.TAB,
KEY_MAP.ENTER,
KEY_MAP.SPACE,
KEY_MAP.DELETE
], keyCode);
},
isMove: function (keyCode) {
return lists.contains([
KEY_MAP.LEFT,
KEY_MAP.UP,
KEY_MAP.RIGHT,
KEY_MAP.DOWN
], keyCode);
},
nameFromCode: func.invertObject(KEY_MAP),
code: KEY_MAP
};
function textRangeToPoint(textRange, isStart) {
var container = textRange.parentElement();
var offset;
var tester = document.body.createTextRange();
var prevContainer;
var childNodes = lists.from(container.childNodes);
for (offset = 0; offset < childNodes.length; offset++) {
if (dom.isText(childNodes[offset])) {
continue;
}
tester.moveToElementText(childNodes[offset]);
if (tester.compareEndPoints('StartToStart', textRange) >= 0) {
break;
}
prevContainer = childNodes[offset];
}
if (offset !== 0 && dom.isText(childNodes[offset - 1])) {
var textRangeStart = document.body.createTextRange();
var curTextNode = null;
textRangeStart.moveToElementText(prevContainer || container);
textRangeStart.collapse(!prevContainer);
curTextNode = prevContainer ? prevContainer.nextSibling : container.firstChild;
var pointTester = textRange.duplicate();
pointTester.setEndPoint('StartToStart', textRangeStart);
var textCount = pointTester.text.replace(/[\r\n]/g, '').length;
while (textCount > curTextNode.nodeValue.length && curTextNode.nextSibling) {
textCount -= curTextNode.nodeValue.length;
curTextNode = curTextNode.nextSibling;
}
var dummy = curTextNode.nodeValue; // eslint-disable-line
if (isStart && curTextNode.nextSibling && dom.isText(curTextNode.nextSibling) &&
textCount === curTextNode.nodeValue.length) {
textCount -= curTextNode.nodeValue.length;
curTextNode = curTextNode.nextSibling;
}
container = curTextNode;
offset = textCount;
}
return {
cont: container,
offset: offset
};
}
function pointToTextRange(point) {
var textRangeInfo = function (container, offset) {
var node, isCollapseToStart;
if (dom.isText(container)) {
var prevTextNodes = dom.listPrev(container, func.not(dom.isText));
var prevContainer = lists.last(prevTextNodes).previousSibling;
node = prevContainer || container.parentNode;
offset += lists.sum(lists.tail(prevTextNodes), dom.nodeLength);
isCollapseToStart = !prevContainer;
}
else {
node = container.childNodes[offset] || container;
if (dom.isText(node)) {
return textRangeInfo(node, 0);
}
offset = 0;
isCollapseToStart = false;
}
return {
node: node,
collapseToStart: isCollapseToStart,
offset: offset
};
};
var textRange = document.body.createTextRange();
var info = textRangeInfo(point.node, point.offset);
textRange.moveToElementText(info.node);
textRange.collapse(info.collapseToStart);
textRange.moveStart('character', info.offset);
return textRange;
}
var WrappedRange = (function () {
function WrappedRange(sc, so, ec, eo) {
this.sc = sc;
this.so = so;
this.ec = ec;
this.eo = eo;
this.isOnEditable = this.makeIsOn(dom.isEditable);
this.isOnList = this.makeIsOn(dom.isList);
this.isOnAnchor = this.makeIsOn(dom.isAnchor);
this.isOnCell = this.makeIsOn(dom.isCell);
this.isOnData = this.makeIsOn(dom.isData);
}
WrappedRange.prototype.nativeRange = function () {
if (env.isW3CRangeSupport) {
var w3cRange = document.createRange();
w3cRange.setStart(this.sc, this.so);
w3cRange.setEnd(this.ec, this.eo);
return w3cRange;
}
else {
var textRange = pointToTextRange({
node: this.sc,
offset: this.so
});
textRange.setEndPoint('EndToEnd', pointToTextRange({
node: this.ec,
offset: this.eo
}));
return textRange;
}
};
WrappedRange.prototype.getPoints = function () {
return {
sc: this.sc,
so: this.so,
ec: this.ec,
eo: this.eo
};
};
WrappedRange.prototype.getStartPoint = function () {
return {
node: this.sc,
offset: this.so
};
};
WrappedRange.prototype.getEndPoint = function () {
return {
node: this.ec,
offset: this.eo
};
};
WrappedRange.prototype.select = function () {
var nativeRng = this.nativeRange();
if (env.isW3CRangeSupport) {
var selection = document.getSelection();
if (selection.rangeCount > 0) {
selection.removeAllRanges();
}
selection.addRange(nativeRng);
}
else {
nativeRng.select();
}
return this;
};
WrappedRange.prototype.scrollIntoView = function (container) {
var height = $$1(container).height();
if (container.scrollTop + height < this.sc.offsetTop) {
container.scrollTop += Math.abs(container.scrollTop + height - this.sc.offsetTop);
}
return this;
};
WrappedRange.prototype.normalize = function () {
var getVisiblePoint = function (point, isLeftToRight) {
if ((dom.isVisiblePoint(point) && !dom.isEdgePoint(point)) ||
(dom.isVisiblePoint(point) && dom.isRightEdgePoint(point) && !isLeftToRight) ||
(dom.isVisiblePoint(point) && dom.isLeftEdgePoint(point) && isLeftToRight) ||
(dom.isVisiblePoint(point) && dom.isBlock(point.node) && dom.isEmpty(point.node))) {
return point;
}
var block = dom.ancestor(point.node, dom.isBlock);
if (((dom.isLeftEdgePointOf(point, block) || dom.isVoid(dom.prevPoint(point).node)) && !isLeftToRight) ||
((dom.isRightEdgePointOf(point, block) || dom.isVoid(dom.nextPoint(point).node)) && isLeftToRight)) {
if (dom.isVisiblePoint(point)) {
return point;
}
isLeftToRight = !isLeftToRight;
}
var nextPoint = isLeftToRight ? dom.nextPointUntil(dom.nextPoint(point), dom.isVisiblePoint)
: dom.prevPointUntil(dom.prevPoint(point), dom.isVisiblePoint);
return nextPoint || point;
};
var endPoint = getVisiblePoint(this.getEndPoint(), false);
var startPoint = this.isCollapsed() ? endPoint : getVisiblePoint(this.getStartPoint(), true);
return new WrappedRange(startPoint.node, startPoint.offset, endPoint.node, endPoint.offset);
};
WrappedRange.prototype.nodes = function (pred, options) {
pred = pred || func.ok;
var includeAncestor = options && options.includeAncestor;
var fullyContains = options && options.fullyContains;
var startPoint = this.getStartPoint();
var endPoint = this.getEndPoint();
var nodes = [];
var leftEdgeNodes = [];
dom.walkPoint(startPoint, endPoint, function (point) {
if (dom.isEditable(point.node)) {
return;
}
var node;
if (fullyContains) {
if (dom.isLeftEdgePoint(point)) {
leftEdgeNodes.push(point.node);
}
if (dom.isRightEdgePoint(point) && lists.contains(leftEdgeNodes, point.node)) {
node = point.node;
}
}
else if (includeAncestor) {
node = dom.ancestor(point.node, pred);
}
else {
node = point.node;
}
if (node && pred(node)) {
nodes.push(node);
}
}, true);
return lists.unique(nodes);
};
WrappedRange.prototype.commonAncestor = function () {
return dom.commonAncestor(this.sc, this.ec);
};
WrappedRange.prototype.expand = function (pred) {
var startAncestor = dom.ancestor(this.sc, pred);
var endAncestor = dom.ancestor(this.ec, pred);
if (!startAncestor && !endAncestor) {
return new WrappedRange(this.sc, this.so, this.ec, this.eo);
}
var boundaryPoints = this.getPoints();
if (startAncestor) {
boundaryPoints.sc = startAncestor;
boundaryPoints.so = 0;
}
if (endAncestor) {
boundaryPoints.ec = endAncestor;
boundaryPoints.eo = dom.nodeLength(endAncestor);
}
return new WrappedRange(boundaryPoints.sc, boundaryPoints.so, boundaryPoints.ec, boundaryPoints.eo);
};
WrappedRange.prototype.collapse = function (isCollapseToStart) {
if (isCollapseToStart) {
return new WrappedRange(this.sc, this.so, this.sc, this.so);
}
else {
return new WrappedRange(this.ec, this.eo, this.ec, this.eo);
}
};
WrappedRange.prototype.splitText = function () {
var isSameContainer = this.sc === this.ec;
var boundaryPoints = this.getPoints();
if (dom.isText(this.ec) && !dom.isEdgePoint(this.getEndPoint())) {
this.ec.splitText(this.eo);
}
if (dom.isText(this.sc) && !dom.isEdgePoint(this.getStartPoint())) {
boundaryPoints.sc = this.sc.splitText(this.so);
boundaryPoints.so = 0;
if (isSameContainer) {
boundaryPoints.ec = boundaryPoints.sc;
boundaryPoints.eo = this.eo - this.so;
}
}
return new WrappedRange(boundaryPoints.sc, boundaryPoints.so, boundaryPoints.ec, boundaryPoints.eo);
};
WrappedRange.prototype.deleteContents = function () {
if (this.isCollapsed()) {
return this;
}
var rng = this.splitText();
var nodes = rng.nodes(null, {
fullyContains: true
});
var point = dom.prevPointUntil(rng.getStartPoint(), function (point) {
return !lists.contains(nodes, point.node);
});
var emptyParents = [];
$$1.each(nodes, function (idx, node) {
var parent = node.parentNode;
if (point.node !== parent && dom.nodeLength(parent) === 1) {
emptyParents.push(parent);
}
dom.remove(node, false);
});
$$1.each(emptyParents, function (idx, node) {
dom.remove(node, false);
});
return new WrappedRange(point.node, point.offset, point.node, point.offset).normalize();
};
WrappedRange.prototype.makeIsOn = function (pred) {
return function () {
var ancestor = dom.ancestor(this.sc, pred);
return !!ancestor && (ancestor === dom.ancestor(this.ec, pred));
};
};
WrappedRange.prototype.isLeftEdgeOf = function (pred) {
if (!dom.isLeftEdgePoint(this.getStartPoint())) {
return false;
}
var node = dom.ancestor(this.sc, pred);
return node && dom.isLeftEdgeOf(this.sc, node);
};
WrappedRange.prototype.isCollapsed = function () {
return this.sc === this.ec && this.so === this.eo;
};
WrappedRange.prototype.wrapBodyInlineWithPara = function () {
if (dom.isBodyContainer(this.sc) && dom.isEmpty(this.sc)) {
this.sc.innerHTML = dom.emptyPara;
return new WrappedRange(this.sc.firstChild, 0, this.sc.firstChild, 0);
}
var rng = this.normalize();
if (dom.isParaInline(this.sc) || dom.isPara(this.sc)) {
return rng;
}
var topAncestor;
if (dom.isInline(rng.sc)) {
var ancestors = dom.listAncestor(rng.sc, func.not(dom.isInline));
topAncestor = lists.last(ancestors);
if (!dom.isInline(topAncestor)) {
topAncestor = ancestors[ancestors.length - 2] || rng.sc.childNodes[rng.so];
}
}
else {
topAncestor = rng.sc.childNodes[rng.so > 0 ? rng.so - 1 : 0];
}
var inlineSiblings = dom.listPrev(topAncestor, dom.isParaInline).reverse();
inlineSiblings = inlineSiblings.concat(dom.listNext(topAncestor.nextSibling, dom.isParaInline));
if (inlineSiblings.length) {
var para = dom.wrap(lists.head(inlineSiblings), 'p');
dom.appendChildNodes(para, lists.tail(inlineSiblings));
}
return this.normalize();
};
WrappedRange.prototype.insertNode = function (node) {
var rng = this.wrapBodyInlineWithPara().deleteContents();
var info = dom.splitPoint(rng.getStartPoint(), dom.isInline(node));
if (info.rightNode) {
info.rightNode.parentNode.insertBefore(node, info.rightNode);
}
else {
info.container.appendChild(node);
}
return node;
};
WrappedRange.prototype.pasteHTML = function (markup) {
var contentsContainer = $$1('<div></div>').html(markup)[0];
var childNodes = lists.from(contentsContainer.childNodes);
var rng = this.wrapBodyInlineWithPara().deleteContents();
return childNodes.reverse().map(function (childNode) {
return rng.insertNode(childNode);
}).reverse();
};
WrappedRange.prototype.toString = function () {
var nativeRng = this.nativeRange();
return env.isW3CRangeSupport ? nativeRng.toString() : nativeRng.text;
};
WrappedRange.prototype.getWordRange = function (findAfter) {
var endPoint = this.getEndPoint();
if (!dom.isCharPoint(endPoint)) {
return this;
}
var startPoint = dom.prevPointUntil(endPoint, function (point) {
return !dom.isCharPoint(point);
});
if (findAfter) {
endPoint = dom.nextPointUntil(endPoint, function (point) {
return !dom.isCharPoint(point);
});
}
return new WrappedRange(startPoint.node, startPoint.offset, endPoint.node, endPoint.offset);
};
WrappedRange.prototype.bookmark = function (editable) {
return {
s: {
path: dom.makeOffsetPath(editable, this.sc),
offset: this.so
},
e: {
path: dom.makeOffsetPath(editable, this.ec),
offset: this.eo
}
};
};
WrappedRange.prototype.paraBookmark = function (paras) {
return {
s: {
path: lists.tail(dom.makeOffsetPath(lists.head(paras), this.sc)),
offset: this.so
},
e: {
path: lists.tail(dom.makeOffsetPath(lists.last(paras), this.ec)),
offset: this.eo
}
};
};
WrappedRange.prototype.getClientRects = function () {
var nativeRng = this.nativeRange();
return nativeRng.getClientRects();
};
return WrappedRange;
}());
var range = {
create: function (sc, so, ec, eo) {
if (arguments.length === 4) {
return new WrappedRange(sc, so, ec, eo);
}
else if (arguments.length === 2) {
ec = sc;
eo = so;
return new WrappedRange(sc, so, ec, eo);
}
else {
var wrappedRange = this.createFromSelection();
if (!wrappedRange && arguments.length === 1) {
wrappedRange = this.createFromNode(arguments[0]);
return wrappedRange.collapse(dom.emptyPara === arguments[0].innerHTML);
}
return wrappedRange;
}
},
createFromSelection: function () {
var sc, so, ec, eo;
if (env.isW3CRangeSupport) {
var selection = document.getSelection();
if (!selection || selection.rangeCount === 0) {
return null;
}
else if (dom.isBody(selection.anchorNode)) {
return null;
}
var nativeRng = selection.getRangeAt(0);
sc = nativeRng.startContainer;
so = nativeRng.startOffset;
ec = nativeRng.endContainer;
eo = nativeRng.endOffset;
}
else {
var textRange = document.selection.createRange();
var textRangeEnd = textRange.duplicate();
textRangeEnd.collapse(false);
var textRangeStart = textRange;
textRangeStart.collapse(true);
var startPoint = textRangeToPoint(textRangeStart, true);
var endPoint = textRangeToPoint(textRangeEnd, false);
if (dom.isText(startPoint.node) && dom.isLeftEdgePoint(startPoint) &&
dom.isTextNode(endPoint.node) && dom.isRightEdgePoint(endPoint) &&
endPoint.node.nextSibling === startPoint.node) {
startPoint = endPoint;
}
sc = startPoint.cont;
so = startPoint.offset;
ec = endPoint.cont;
eo = endPoint.offset;
}
return new WrappedRange(sc, so, ec, eo);
},
createFromNode: function (node) {
var sc = node;
var so = 0;
var ec = node;
var eo = dom.nodeLength(ec);
if (dom.isVoid(sc)) {
so = dom.listPrev(sc).length - 1;
sc = sc.parentNode;
}
if (dom.isBR(ec)) {
eo = dom.listPrev(ec).length - 1;
ec = ec.parentNode;
}
else if (dom.isVoid(ec)) {
eo = dom.listPrev(ec).length;
ec = ec.parentNode;
}
return this.create(sc, so, ec, eo);
},
createFromNodeBefore: function (node) {
return this.createFromNode(node).collapse(true);
},
createFromNodeAfter: function (node) {
return this.createFromNode(node).collapse();
},
createFromBookmark: function (editable, bookmark) {
var sc = dom.fromOffsetPath(editable, bookmark.s.path);
var so = bookmark.s.offset;
var ec = dom.fromOffsetPath(editable, bookmark.e.path);
var eo = bookmark.e.offset;
return new WrappedRange(sc, so, ec, eo);
},
createFromParaBookmark: function (bookmark, paras) {
var so = bookmark.s.offset;
var eo = bookmark.e.offset;
var sc = dom.fromOffsetPath(lists.head(paras), bookmark.s.path);
var ec = dom.fromOffsetPath(lists.last(paras), bookmark.e.path);
return new WrappedRange(sc, so, ec, eo);
}
};
function readFileAsDataURL(file) {
return $$1.Deferred(function (deferred) {
$$1.extend(new FileReader(), {
onload: function (e) {
var dataURL = e.target.result;
deferred.resolve(dataURL);
},
onerror: function (err) {
deferred.reject(err);
}
}).readAsDataURL(file);
}).promise();
}
function createImage(url) {
return $$1.Deferred(function (deferred) {
var $img = $$1('<img>');
$img.one('load', function () {
$img.off('error abort');
deferred.resolve($img);
}).one('error abort', function () {
$img.off('load').detach();
deferred.reject($img);
}).css({
display: 'none'
}).appendTo(document.body).attr('src', url);
}).promise();
}
var History = (function () {
function History($editable) {
this.stack = [];
this.stackOffset = -1;
this.$editable = $editable;
this.editable = $editable[0];
}
History.prototype.makeSnapshot = function () {
var rng = range.create(this.editable);
var emptyBookmark = { s: { path: [], offset: 0 }, e: { path: [], offset: 0 } };
return {
contents: this.$editable.html(),
bookmark: (rng ? rng.bookmark(this.editable) : emptyBookmark)
};
};
History.prototype.applySnapshot = function (snapshot) {
if (snapshot.contents !== null) {
this.$editable.html(snapshot.contents);
}
if (snapshot.bookmark !== null) {
range.createFromBookmark(this.editable, snapshot.bookmark).select();
}
};
History.prototype.rewind = function () {
if (this.$editable.html() !== this.stack[this.stackOffset].contents) {
this.recordUndo();
}
this.stackOffset = 0;
this.applySnapshot(this.stack[this.stackOffset]);
};
History.prototype.reset = function () {
this.stack = [];
this.stackOffset = -1;
this.$editable.html('');
this.recordUndo();
};
History.prototype.undo = function () {
if (this.$editable.html() !== this.stack[this.stackOffset].contents) {
this.recordUndo();
}
if (this.stackOffset > 0) {
this.stackOffset--;
this.applySnapshot(this.stack[this.stackOffset]);
}
};
History.prototype.redo = function () {
if (this.stack.length - 1 > this.stackOffset) {
this.stackOffset++;
this.applySnapshot(this.stack[this.stackOffset]);
}
};
History.prototype.recordUndo = function () {
this.stackOffset++;
if (this.stack.length > this.stackOffset) {
this.stack = this.stack.slice(0, this.stackOffset);
}
this.stack.push(this.makeSnapshot());
};
return History;
}());
var Style = (function () {
function Style() {
}
Style.prototype.jQueryCSS = function ($obj, propertyNames) {
if (env.jqueryVersion < 1.9) {
var result_1 = {};
$$1.each(propertyNames, function (idx, propertyName) {
result_1[propertyName] = $obj.css(propertyName);
});
return result_1;
}
return $obj.css(propertyNames);
};
Style.prototype.fromNode = function ($node) {
var properties = ['font-family', 'font-size', 'text-align', 'list-style-type', 'line-height'];
var styleInfo = this.jQueryCSS($node, properties) || {};
styleInfo['font-size'] = parseInt(styleInfo['font-size'], 10);
return styleInfo;
};
Style.prototype.stylePara = function (rng, styleInfo) {
$$1.each(rng.nodes(dom.isPara, {
includeAncestor: true
}), function (idx, para) {
$$1(para).css(styleInfo);
});
};
Style.prototype.styleNodes = function (rng, options) {
rng = rng.splitText();
var nodeName = (options && options.nodeName) || 'SPAN';
var expandClosestSibling = !!(options && options.expandClosestSibling);
var onlyPartialContains = !!(options && options.onlyPartialContains);
if (rng.isCollapsed()) {
return [rng.insertNode(dom.create(nodeName))];
}
var pred = dom.makePredByNodeName(nodeName);
var nodes = rng.nodes(dom.isText, {
fullyContains: true
}).map(function (text) {
return dom.singleChildAncestor(text, pred) || dom.wrap(text, nodeName);
});
if (expandClosestSibling) {
if (onlyPartialContains) {
var nodesInRange_1 = rng.nodes();
pred = func.and(pred, function (node) {
return lists.contains(nodesInRange_1, node);
});
}
return nodes.map(function (node) {
var siblings = dom.withClosestSiblings(node, pred);
var head = lists.head(siblings);
var tails = lists.tail(siblings);
$$1.each(tails, function (idx, elem) {
dom.appendChildNodes(head, elem.childNodes);
dom.remove(elem);
});
return lists.head(siblings);
});
}
else {
return nodes;
}
};
Style.prototype.current = function (rng) {
var $cont = $$1(!dom.isElement(rng.sc) ? rng.sc.parentNode : rng.sc);
var styleInfo = this.fromNode($cont);
try {
styleInfo = $$1.extend(styleInfo, {
'font-bold': document.queryCommandState('bold') ? 'bold' : 'normal',
'font-italic': document.queryCommandState('italic') ? 'italic' : 'normal',
'font-underline': document.queryCommandState('underline') ? 'underline' : 'normal',
'font-subscript': document.queryCommandState('subscript') ? 'subscript' : 'normal',
'font-superscript': document.queryCommandState('superscript') ? 'superscript' : 'normal',
'font-strikethrough': document.queryCommandState('strikethrough') ? 'strikethrough' : 'normal',
'font-family': document.queryCommandValue('fontname') || styleInfo['font-family']
});
}
catch (e) { }
if (!rng.isOnList()) {
styleInfo['list-style'] = 'none';
}
else {
var orderedTypes = ['circle', 'disc', 'disc-leading-zero', 'square'];
var isUnordered = $$1.inArray(styleInfo['list-style-type'], orderedTypes) > -1;
styleInfo['list-style'] = isUnordered ? 'unordered' : 'ordered';
}
var para = dom.ancestor(rng.sc, dom.isPara);
if (para && para.style['line-height']) {
styleInfo['line-height'] = para.style.lineHeight;
}
else {
var lineHeight = parseInt(styleInfo['line-height'], 10) / parseInt(styleInfo['font-size'], 10);
styleInfo['line-height'] = lineHeight.toFixed(1);
}
styleInfo.anchor = rng.isOnAnchor() && dom.ancestor(rng.sc, dom.isAnchor);
styleInfo.ancestors = dom.listAncestor(rng.sc, dom.isEditable);
styleInfo.range = rng;
return styleInfo;
};
return Style;
}());
var Bullet = (function () {
function Bullet() {
}
Bullet.prototype.insertOrderedList = function (editable) {
this.toggleList('OL', editable);
};
Bullet.prototype.insertUnorderedList = function (editable) {
this.toggleList('UL', editable);
};
Bullet.prototype.indent = function (editable) {
var _this = this;
var rng = range.create(editable).wrapBodyInlineWithPara();
var paras = rng.nodes(dom.isPara, { includeAncestor: true });
var clustereds = lists.clusterBy(paras, func.peq2('parentNode'));
$$1.each(clustereds, function (idx, paras) {
var head = lists.head(paras);
if (dom.isLi(head)) {
_this.wrapList(paras, head.parentNode.nodeName);
}
else {
$$1.each(paras, function (idx, para) {
$$1(para).css('marginLeft', function (idx, val) {
return (parseInt(val, 10) || 0) + 25;
});
});
}
});
rng.select();
};
Bullet.prototype.outdent = function (editable) {
var _this = this;
var rng = range.create(editable).wrapBodyInlineWithPara();
var paras = rng.nodes(dom.isPara, { includeAncestor: true });
var clustereds = lists.clusterBy(paras, func.peq2('parentNode'));
$$1.each(clustereds, function (idx, paras) {
var head = lists.head(paras);
if (dom.isLi(head)) {
_this.releaseList([paras]);
}
else {
$$1.each(paras, function (idx, para) {
$$1(para).css('marginLeft', function (idx, val) {
val = (parseInt(val, 10) || 0);
return val > 25 ? val - 25 : '';
});
});
}
});
rng.select();
};
Bullet.prototype.toggleList = function (listName, editable) {
var _this = this;
var rng = range.create(editable).wrapBodyInlineWithPara();
var paras = rng.nodes(dom.isPara, { includeAncestor: true });
var bookmark = rng.paraBookmark(paras);
var clustereds = lists.clusterBy(paras, func.peq2('parentNode'));
if (lists.find(paras, dom.isPurePara)) {
var wrappedParas_1 = [];
$$1.each(clustereds, function (idx, paras) {
wrappedParas_1 = wrappedParas_1.concat(_this.wrapList(paras, listName));
});
paras = wrappedParas_1;
}
else {
var diffLists = rng.nodes(dom.isList, {
includeAncestor: true
}).filter(function (listNode) {
return !$$1.nodeName(listNode, listName);
});
if (diffLists.length) {
$$1.each(diffLists, function (idx, listNode) {
dom.replace(listNode, listName);
});
}
else {
paras = this.releaseList(clustereds, true);
}
}
range.createFromParaBookmark(bookmark, paras).select();
};
Bullet.prototype.wrapList = function (paras, listName) {
var head = lists.head(paras);
var last = lists.last(paras);
var prevList = dom.isList(head.previousSibling) && head.previousSibling;
var nextList = dom.isList(last.nextSibling) && last.nextSibling;
var listNode = prevList || dom.insertAfter(dom.create(listName || 'UL'), last);
paras = paras.map(function (para) {
return dom.isPurePara(para) ? dom.replace(para, 'LI') : para;
});
dom.appendChildNodes(listNode, paras);
if (nextList) {
dom.appendChildNodes(listNode, lists.from(nextList.childNodes));
dom.remove(nextList);
}
return paras;
};
Bullet.prototype.releaseList = function (clustereds, isEscapseToBody) {
var releasedParas = [];
$$1.each(clustereds, function (idx, paras) {
var head = lists.head(paras);
var last = lists.last(paras);
var headList = isEscapseToBody ? dom.lastAncestor(head, dom.isList) : head.parentNode;
var lastList = headList.childNodes.length > 1 ? dom.splitTree(headList, {
node: last.parentNode,
offset: dom.position(last) + 1
}, {
isSkipPaddingBlankHTML: true
}) : null;
var middleList = dom.splitTree(headList, {
node: head.parentNode,
offset: dom.position(head)
}, {
isSkipPaddingBlankHTML: true
});
paras = isEscapseToBody ? dom.listDescendant(middleList, dom.isLi)
: lists.from(middleList.childNodes).filter(dom.isLi);
if (isEscapseToBody || !dom.isList(headList.parentNode)) {
paras = paras.map(function (para) {
return dom.replace(para, 'P');
});
}
$$1.each(lists.from(paras).reverse(), function (idx, para) {
dom.insertAfter(para, headList);
});
var rootLists = lists.compact([headList, middleList, lastList]);
$$1.each(rootLists, function (idx, rootList) {
var listNodes = [rootList].concat(dom.listDescendant(rootList, dom.isList));
$$1.each(listNodes.reverse(), function (idx, listNode) {
if (!dom.nodeLength(listNode)) {
dom.remove(listNode, true);
}
});
});
releasedParas = releasedParas.concat(paras);
});
return releasedParas;
};
return Bullet;
}());
var Typing = (function () {
function Typing() {
this.bullet = new Bullet();
}
Typing.prototype.insertTab = function (rng, tabsize) {
var tab = dom.createText(new Array(tabsize + 1).join(dom.NBSP_CHAR));
rng = rng.deleteContents();
rng.insertNode(tab, true);
rng = range.create(tab, tabsize);
rng.select();
};
Typing.prototype.insertParagraph = function (editable) {
var rng = range.create(editable);
rng = rng.deleteContents();
rng = rng.wrapBodyInlineWithPara();
var splitRoot = dom.ancestor(rng.sc, dom.isPara);
var nextPara;
if (splitRoot) {
if (dom.isEmpty(splitRoot) && dom.isLi(splitRoot)) {
this.bullet.toggleList(splitRoot.parentNode.nodeName);
return;
}
else if (dom.isEmpty(splitRoot) && dom.isPara(splitRoot) && dom.isBlockquote(splitRoot.parentNode)) {
dom.insertAfter(splitRoot, splitRoot.parentNode);
nextPara = splitRoot;
}
else {
nextPara = dom.splitTree(splitRoot, rng.getStartPoint());
var emptyAnchors = dom.listDescendant(splitRoot, dom.isEmptyAnchor);
emptyAnchors = emptyAnchors.concat(dom.listDescendant(nextPara, dom.isEmptyAnchor));
$$1.each(emptyAnchors, function (idx, anchor) {
dom.remove(anchor);
});
if ((dom.isHeading(nextPara) || dom.isPre(nextPara) || dom.isCustomStyleTag(nextPara)) && dom.isEmpty(nextPara)) {
nextPara = dom.replace(nextPara, 'p');
}
}
}
else {
var next = rng.sc.childNodes[rng.so];
nextPara = $$1(dom.emptyPara)[0];
if (next) {
rng.sc.insertBefore(nextPara, next);
}
else {
rng.sc.appendChild(nextPara);
}
}
range.create(nextPara, 0).normalize().select().scrollIntoView(editable);
};
return Typing;
}());
var TableResultAction = function (startPoint, where, action, domTable) {
var _startPoint = { 'colPos': 0, 'rowPos': 0 };
var _virtualTable = [];
var _actionCellList = [];
function setStartPoint() {
if (!startPoint || !startPoint.tagName || (startPoint.tagName.toLowerCase() !== 'td' && startPoint.tagName.toLowerCase() !== 'th')) {
console.error('Impossible to identify start Cell point.', startPoint);
return;
}
_startPoint.colPos = startPoint.cellIndex;
if (!startPoint.parentElement || !startPoint.parentElement.tagName || startPoint.parentElement.tagName.toLowerCase() !== 'tr') {
console.error('Impossible to identify start Row point.', startPoint);
return;
}
_startPoint.rowPos = startPoint.parentElement.rowIndex;
}
function setVirtualTablePosition(rowIndex, cellIndex, baseRow, baseCell, isRowSpan, isColSpan, isVirtualCell) {
var objPosition = {
'baseRow': baseRow,
'baseCell': baseCell,
'isRowSpan': isRowSpan,
'isColSpan': isColSpan,
'isVirtual': isVirtualCell
};
if (!_virtualTable[rowIndex]) {
_virtualTable[rowIndex] = [];
}
_virtualTable[rowIndex][cellIndex] = objPosition;
}
function getActionCell(virtualTableCellObj, resultAction, virtualRowPosition, virtualColPosition) {
return {
'baseCell': virtualTableCellObj.baseCell,
'action': resultAction,
'virtualTable': {
'rowIndex': virtualRowPosition,
'cellIndex': virtualColPosition
}
};
}
function recoverCellIndex(rowIndex, cellIndex) {
if (!_virtualTable[rowIndex]) {
return cellIndex;
}
if (!_virtualTable[rowIndex][cellIndex]) {
return cellIndex;
}
var newCellIndex = cellIndex;
while (_virtualTable[rowIndex][newCellIndex]) {
newCellIndex++;
if (!_virtualTable[rowIndex][newCellIndex]) {
return newCellIndex;
}
}
}
function addCellInfoToVirtual(row, cell) {
var cellIndex = recoverCellIndex(row.rowIndex, cell.cellIndex);
var cellHasColspan = (cell.colSpan > 1);
var cellHasRowspan = (cell.rowSpan > 1);
var isThisSelectedCell = (row.rowIndex === _startPoint.rowPos && cell.cellIndex === _startPoint.colPos);
setVirtualTablePosition(row.rowIndex, cellIndex, row, cell, cellHasRowspan, cellHasColspan, false);
var rowspanNumber = cell.attributes.rowSpan ? parseInt(cell.attributes.rowSpan.value, 10) : 0;
if (rowspanNumber > 1) {
for (var rp = 1; rp < rowspanNumber; rp++) {
var rowspanIndex = row.rowIndex + rp;
adjustStartPoint(rowspanIndex, cellIndex, cell, isThisSelectedCell);
setVirtualTablePosition(rowspanIndex, cellIndex, row, cell, true, cellHasColspan, true);
}
}
var colspanNumber = cell.attributes.colSpan ? parseInt(cell.attributes.colSpan.value, 10) : 0;
if (colspanNumber > 1) {
for (var cp = 1; cp < colspanNumber; cp++) {
var cellspanIndex = recoverCellIndex(row.rowIndex, (cellIndex + cp));
adjustStartPoint(row.rowIndex, cellspanIndex, cell, isThisSelectedCell);
setVirtualTablePosition(row.rowIndex, cellspanIndex, row, cell, cellHasRowspan, true, true);
}
}
}
function adjustStartPoint(rowIndex, cellIndex, cell, isSelectedCell) {
if (rowIndex === _startPoint.rowPos && _startPoint.colPos >= cell.cellIndex && cell.cellIndex <= cellIndex && !isSelectedCell) {
_startPoint.colPos++;
}
}
function createVirtualTable() {
var rows = domTable.rows;
for (var rowIndex = 0; rowIndex < rows.length; rowIndex++) {
var cells = rows[rowIndex].cells;
for (var cellIndex = 0; cellIndex < cells.length; cellIndex++) {
addCellInfoToVirtual(rows[rowIndex], cells[cellIndex]);
}
}
}
function getDeleteResultActionToCell(cell) {
switch (where) {
case TableResultAction.where.Column:
if (cell.isColSpan) {
return TableResultAction.resultAction.SubtractSpanCount;
}
break;
case TableResultAction.where.Row:
if (!cell.isVirtual && cell.isRowSpan) {
return TableResultAction.resultAction.AddCell;
}
else if (cell.isRowSpan) {
return TableResultAction.resultAction.SubtractSpanCount;
}
break;
}
return TableResultAction.resultAction.RemoveCell;
}
function getAddResultActionToCell(cell) {
switch (where) {
case TableResultAction.where.Column:
if (cell.isColSpan) {
return TableResultAction.resultAction.SumSpanCount;
}
else if (cell.isRowSpan && cell.isVirtual) {
return TableResultAction.resultAction.Ignore;
}
break;
case TableResultAction.where.Row:
if (cell.isRowSpan) {
return TableResultAction.resultAction.SumSpanCount;
}
else if (cell.isColSpan && cell.isVirtual) {
return TableResultAction.resultAction.Ignore;
}
break;
}
return TableResultAction.resultAction.AddCell;
}
function init() {
setStartPoint();
createVirtualTable();
}
this.getActionList = function () {
var fixedRow = (where === TableResultAction.where.Row) ? _startPoint.rowPos : -1;
var fixedCol = (where === TableResultAction.where.Column) ? _startPoint.colPos : -1;
var actualPosition = 0;
var canContinue = true;
while (canContinue) {
var rowPosition = (fixedRow >= 0) ? fixedRow : actualPosition;
var colPosition = (fixedCol >= 0) ? fixedCol : actualPosition;
var row = _virtualTable[rowPosition];
if (!row) {
canContinue = false;
return _actionCellList;
}
var cell = row[colPosition];
if (!cell) {
canContinue = false;
return _actionCellList;
}
var resultAction = TableResultAction.resultAction.Ignore;
switch (action) {
case TableResultAction.requestAction.Add:
resultAction = getAddResultActionToCell(cell);
break;
case TableResultAction.requestAction.Delete:
resultAction = getDeleteResultActionToCell(cell);
break;
}
_actionCellList.push(getActionCell(cell, resultAction, rowPosition, colPosition));
actualPosition++;
}
return _actionCellList;
};
init();
};
TableResultAction.where = { 'Row': 0, 'Column': 1 };
TableResultAction.requestAction = { 'Add': 0, 'Delete': 1 };
TableResultAction.resultAction = { 'Ignore': 0, 'SubtractSpanCount': 1, 'RemoveCell': 2, 'AddCell': 3, 'SumSpanCount': 4 };
var Table = (function () {
function Table() {
}
Table.prototype.tab = function (rng, isShift) {
var cell = dom.ancestor(rng.commonAncestor(), dom.isCell);
var table = dom.ancestor(cell, dom.isTable);
var cells = dom.listDescendant(table, dom.isCell);
var nextCell = lists[isShift ? 'prev' : 'next'](cells, cell);
if (nextCell) {
range.create(nextCell, 0).select();
}
};
Table.prototype.addRow = function (rng, position) {
var cell = dom.ancestor(rng.commonAncestor(), dom.isCell);
var currentTr = $$1(cell).closest('tr');
var trAttributes = this.recoverAttributes(currentTr);
var html = $$1('<tr' + trAttributes + '></tr>');
var vTable = new TableResultAction(cell, TableResultAction.where.Row, TableResultAction.requestAction.Add, $$1(currentTr).closest('table')[0]);
var actions = vTable.getActionList();
for (var idCell = 0; idCell < actions.length; idCell++) {
var currentCell = actions[idCell];
var tdAttributes = this.recoverAttributes(currentCell.baseCell);
switch (currentCell.action) {
case TableResultAction.resultAction.AddCell:
html.append('<td' + tdAttributes + '>' + dom.blank + '</td>');
break;
case TableResultAction.resultAction.SumSpanCount:
if (position === 'top') {
var baseCellTr = currentCell.baseCell.parent;
var isTopFromRowSpan = (!baseCellTr ? 0 : currentCell.baseCell.closest('tr').rowIndex) <= currentTr[0].rowIndex;
if (isTopFromRowSpan) {
var newTd = $$1('<div></div>').append($$1('<td' + tdAttributes + '>' + dom.blank + '</td>').removeAttr('rowspan')).html();
html.append(newTd);
break;
}
}
var rowspanNumber = parseInt(currentCell.baseCell.rowSpan, 10);
rowspanNumber++;
currentCell.baseCell.setAttribute('rowSpan', rowspanNumber);
break;
}
}
if (position === 'top') {
currentTr.before(html);
}
else {
var cellHasRowspan = (cell.rowSpan > 1);
if (cellHasRowspan) {
var lastTrIndex = currentTr[0].rowIndex + (cell.rowSpan - 2);
$$1($$1(currentTr).parent().find('tr')[lastTrIndex]).after($$1(html));
return;
}
currentTr.after(html);
}
};
Table.prototype.addCol = function (rng, position) {
var cell = dom.ancestor(rng.commonAncestor(), dom.isCell);
var row = $$1(cell).closest('tr');
var rowsGroup = $$1(row).siblings();
rowsGroup.push(row);
var vTable = new TableResultAction(cell, TableResultAction.where.Column, TableResultAction.requestAction.Add, $$1(row).closest('table')[0]);
var actions = vTable.getActionList();
for (var actionIndex = 0; actionIndex < actions.length; actionIndex++) {
var currentCell = actions[actionIndex];
var tdAttributes = this.recoverAttributes(currentCell.baseCell);
switch (currentCell.action) {
case TableResultAction.resultAction.AddCell:
if (position === 'right') {
$$1(currentCell.baseCell).after('<td' + tdAttributes + '>' + dom.blank + '</td>');
}
else {
$$1(currentCell.baseCell).before('<td' + tdAttributes + '>' + dom.blank + '</td>');
}
break;
case TableResultAction.resultAction.SumSpanCount:
if (position === 'right') {
var colspanNumber = parseInt(currentCell.baseCell.colSpan, 10);
colspanNumber++;
currentCell.baseCell.setAttribute('colSpan', colspanNumber);
}
else {
$$1(currentCell.baseCell).before('<td' + tdAttributes + '>' + dom.blank + '</td>');
}
break;
}
}
};
Table.prototype.recoverAttributes = function (el) {
var resultStr = '';
if (!el) {
return resultStr;
}
var attrList = el.attributes || [];
for (var i = 0; i < attrList.length; i++) {
if (attrList[i].name.toLowerCase() === 'id') {
continue;
}
if (attrList[i].specified) {
resultStr += ' ' + attrList[i].name + '=\'' + attrList[i].value + '\'';
}
}
return resultStr;
};
Table.prototype.deleteRow = function (rng) {
var cell = dom.ancestor(rng.commonAncestor(), dom.isCell);
var row = $$1(cell).closest('tr');
var cellPos = row.children('td, th').index($$1(cell));
var rowPos = row[0].rowIndex;
var vTable = new TableResultAction(cell, TableResultAction.where.Row, TableResultAction.requestAction.Delete, $$1(row).closest('table')[0]);
var actions = vTable.getActionList();
for (var actionIndex = 0; actionIndex < actions.length; actionIndex++) {
if (!actions[actionIndex]) {
continue;
}
var baseCell = actions[actionIndex].baseCell;
var virtualPosition = actions[actionIndex].virtualTable;
var hasRowspan = (baseCell.rowSpan && baseCell.rowSpan > 1);
var rowspanNumber = (hasRowspan) ? parseInt(baseCell.rowSpan, 10) : 0;
switch (actions[actionIndex].action) {
case TableResultAction.resultAction.Ignore:
continue;
case TableResultAction.resultAction.AddCell:
var nextRow = row.next('tr')[0];
if (!nextRow) {
continue;
}
var cloneRow = row[0].cells[cellPos];
if (hasRowspan) {
if (rowspanNumber > 2) {
rowspanNumber--;
nextRow.insertBefore(cloneRow, nextRow.cells[cellPos]);
nextRow.cells[cellPos].setAttribute('rowSpan', rowspanNumber);
nextRow.cells[cellPos].innerHTML = '';
}
else if (rowspanNumber === 2) {
nextRow.insertBefore(cloneRow, nextRow.cells[cellPos]);
nextRow.cells[cellPos].removeAttribute('rowSpan');
nextRow.cells[cellPos].innerHTML = '';
}
}
continue;
case TableResultAction.resultAction.SubtractSpanCount:
if (hasRowspan) {
if (rowspanNumber > 2) {
rowspanNumber--;
baseCell.setAttribute('rowSpan', rowspanNumber);
if (virtualPosition.rowIndex !== rowPos && baseCell.cellIndex === cellPos) {
baseCell.innerHTML = '';
}
}
else if (rowspanNumber === 2) {
baseCell.removeAttribute('rowSpan');
if (virtualPosition.rowIndex !== rowPos && baseCell.cellIndex === cellPos) {
baseCell.innerHTML = '';
}
}
}
continue;
case TableResultAction.resultAction.RemoveCell:
continue;
}
}
row.remove();
};
Table.prototype.deleteCol = function (rng) {
var cell = dom.ancestor(rng.commonAncestor(), dom.isCell);
var row = $$1(cell).closest('tr');
var cellPos = row.children('td, th').index($$1(cell));
var vTable = new TableResultAction(cell, TableResultAction.where.Column, TableResultAction.requestAction.Delete, $$1(row).closest('table')[0]);
var actions = vTable.getActionList();
for (var actionIndex = 0; actionIndex < actions.length; actionIndex++) {
if (!actions[actionIndex]) {
continue;
}
switch (actions[actionIndex].action) {
case TableResultAction.resultAction.Ignore:
continue;
case TableResultAction.resultAction.SubtractSpanCount:
var baseCell = actions[actionIndex].baseCell;
var hasColspan = (baseCell.colSpan && baseCell.colSpan > 1);
if (hasColspan) {
var colspanNumber = (baseCell.colSpan) ? parseInt(baseCell.colSpan, 10) : 0;
if (colspanNumber > 2) {
colspanNumber--;
baseCell.setAttribute('colSpan', colspanNumber);
if (baseCell.cellIndex === cellPos) {
baseCell.innerHTML = '';
}
}
else if (colspanNumber === 2) {
baseCell.removeAttribute('colSpan');
if (baseCell.cellIndex === cellPos) {
baseCell.innerHTML = '';
}
}
}
continue;
case TableResultAction.resultAction.RemoveCell:
dom.remove(actions[actionIndex].baseCell, true);
continue;
}
}
};
Table.prototype.createTable = function (colCount, rowCount, options) {
var tds = [];
var tdHTML;
for (var idxCol = 0; idxCol < colCount; idxCol++) {
tds.push('<td>' + dom.blank + '</td>');
}
tdHTML = tds.join('');
var trs = [];
var trHTML;
for (var idxRow = 0; idxRow < rowCount; idxRow++) {
trs.push('<tr>' + tdHTML + '</tr>');
}
trHTML = trs.join('');
var $table = $$1('<table>' + trHTML + '</table>');
if (options && options.tableClassName) {
$table.addClass(options.tableClassName);
}
return $table[0];
};
Table.prototype.deleteTable = function (rng) {
var cell = dom.ancestor(rng.commonAncestor(), dom.isCell);
$$1(cell).closest('table').remove();
};
return Table;
}());
var KEY_BOGUS = 'bogus';
var Editor = (function () {
function Editor(context) {
var _this = this;
this.context = context;
this.$note = context.layoutInfo.note;
this.$editor = context.layoutInfo.editor;
this.$editable = context.layoutInfo.editable;
this.options = context.options;
this.lang = this.options.langInfo;
this.editable = this.$editable[0];
this.lastRange = null;
this.style = new Style();
this.table = new Table();
this.typing = new Typing();
this.bullet = new Bullet();
this.history = new History(this.$editable);
this.context.memo('help.undo', this.lang.help.undo);
this.context.memo('help.redo', this.lang.help.redo);
this.context.memo('help.tab', this.lang.help.tab);
this.context.memo('help.untab', this.lang.help.untab);
this.context.memo('help.insertParagraph', this.lang.help.insertParagraph);
this.context.memo('help.insertOrderedList', this.lang.help.insertOrderedList);
this.context.memo('help.insertUnorderedList', this.lang.help.insertUnorderedList);
this.context.memo('help.indent', this.lang.help.indent);
this.context.memo('help.outdent', this.lang.help.outdent);
this.context.memo('help.formatPara', this.lang.help.formatPara);
this.context.memo('help.insertHorizontalRule', this.lang.help.insertHorizontalRule);
this.context.memo('help.fontName', this.lang.help.fontName);
var commands = [
'bold', 'italic', 'underline', 'strikethrough', 'superscript', 'subscript',
'justifyLeft', 'justifyCenter', 'justifyRight', 'justifyFull',
'formatBlock', 'removeFormat', 'backColor'
];
for (var idx = 0, len = commands.length; idx < len; idx++) {
this[commands[idx]] = (function (sCmd) {
return function (value) {
_this.beforeCommand();
document.execCommand(sCmd, false, value);
_this.afterCommand(true);
};
})(commands[idx]);
this.context.memo('help.' + commands[idx], this.lang.help[commands[idx]]);
}
this.fontName = this.wrapCommand(function (value) {
return _this.fontStyling('font-family', "\'" + value + "\'");
});
this.fontSize = this.wrapCommand(function (value) {
return _this.fontStyling('font-size', value + 'px');
});
for (var idx = 1; idx <= 6; idx++) {
this['formatH' + idx] = (function (idx) {
return function () {
_this.formatBlock('H' + idx);
};
})(idx);
this.context.memo('help.formatH' + idx, this.lang.help['formatH' + idx]);
}
this.insertParagraph = this.wrapCommand(function () {
_this.typing.insertParagraph(_this.editable);
});
this.insertOrderedList = this.wrapCommand(function () {
_this.bullet.insertOrderedList(_this.editable);
});
this.insertUnorderedList = this.wrapCommand(function () {
_this.bullet.insertUnorderedList(_this.editable);
});
this.indent = this.wrapCommand(function () {
_this.bullet.indent(_this.editable);
});
this.outdent = this.wrapCommand(function () {
_this.bullet.outdent(_this.editable);
});
this.insertNode = this.wrapCommand(function (node) {
if (_this.isLimited($$1(node).text().length)) {
return;
}
var rng = _this.createRange();
rng.insertNode(node);
range.createFromNodeAfter(node).select();
});
this.insertText = this.wrapCommand(function (text) {
if (_this.isLimited(text.length)) {
return;
}
var rng = _this.createRange();
var textNode = rng.insertNode(dom.createText(text));
range.create(textNode, dom.nodeLength(textNode)).select();
});
this.pasteHTML = this.wrapCommand(function (markup) {
if (_this.isLimited(markup.length)) {
return;
}
var contents = _this.createRange().pasteHTML(markup);
range.createFromNodeAfter(lists.last(contents)).select();
});
this.formatBlock = this.wrapCommand(function (tagName, $target) {
var onApplyCustomStyle = _this.options.callbacks.onApplyCustomStyle;
if (onApplyCustomStyle) {
onApplyCustomStyle.call(_this, $target, _this.context, _this.onFormatBlock);
}
else {
_this.onFormatBlock(tagName, $target);
}
});
this.insertHorizontalRule = this.wrapCommand(function () {
var hrNode = _this.createRange().insertNode(dom.create('HR'));
if (hrNode.nextSibling) {
range.create(hrNode.nextSibling, 0).normalize().select();
}
});
this.lineHeight = this.wrapCommand(function (value) {
_this.style.stylePara(_this.createRange(), {
lineHeight: value
});
});
this.createLink = this.wrapCommand(function (linkInfo) {
var linkUrl = linkInfo.url;
var linkText = linkInfo.text;
var isNewWindow = linkInfo.isNewWindow;
var rng = linkInfo.range || _this.createRange();
var isTextChanged = rng.toString() !== linkText;
if (typeof linkUrl === 'string') {
linkUrl = linkUrl.trim();
}
if (_this.options.onCreateLink) {
linkUrl = _this.options.onCreateLink(linkUrl);
}
else {
linkUrl = /^[A-Za-z][A-Za-z0-9+-.]*\:[\/\/]?/.test(linkUrl)
? linkUrl : 'http://' + linkUrl;
}
var anchors = [];
if (isTextChanged) {
rng = rng.deleteContents();
var anchor = rng.insertNode($$1('<A>' + linkText + '</A>')[0]);
anchors.push(anchor);
}
else {
anchors = _this.style.styleNodes(rng, {
nodeName: 'A',
expandClosestSibling: true,
onlyPartialContains: true
});
}
$$1.each(anchors, function (idx, anchor) {
$$1(anchor).attr('href', linkUrl);
if (isNewWindow) {
$$1(anchor).attr('target', '_blank');
}
else {
$$1(anchor).removeAttr('target');
}
});
var startRange = range.createFromNodeBefore(lists.head(anchors));
var startPoint = startRange.getStartPoint();
var endRange = range.createFromNodeAfter(lists.last(anchors));
var endPoint = endRange.getEndPoint();
range.create(startPoint.node, startPoint.offset, endPoint.node, endPoint.offset).select();
});
this.color = this.wrapCommand(function (colorInfo) {
var foreColor = colorInfo.foreColor;
var backColor = colorInfo.backColor;
if (foreColor) {
document.execCommand('foreColor', false, foreColor);
}
if (backColor) {
document.execCommand('backColor', false, backColor);
}
});
this.foreColor = this.wrapCommand(function (colorInfo) {
document.execCommand('styleWithCSS', false, true);
document.execCommand('foreColor', false, colorInfo);
});
this.insertTable = this.wrapCommand(function (dim) {
var dimension = dim.split('x');
var rng = _this.createRange().deleteContents();
rng.insertNode(_this.table.createTable(dimension[0], dimension[1], _this.options));
});
this.removeMedia = this.wrapCommand(function () {
var $target = $$1(_this.restoreTarget()).parent();
if ($target.parent('figure').length) {
$target.parent('figure').remove();
}
else {
$target = $$1(_this.restoreTarget()).detach();
}
_this.context.triggerEvent('media.delete', $target, _this.$editable);
});
this.floatMe = this.wrapCommand(function (value) {
var $target = $$1(_this.restoreTarget());
$target.toggleClass('note-float-left', value === 'left');
$target.toggleClass('note-float-right', value === 'right');
$target.css('float', value);
});
this.resize = this.wrapCommand(function (value) {
var $target = $$1(_this.restoreTarget());
$target.css({
width: value * 100 + '%',
height: ''
});
});
}
Editor.prototype.initialize = function () {
var _this = this;
this.$editable.on('keydown', function (event) {
if (event.keyCode === key.code.ENTER) {
_this.context.triggerEvent('enter', event);
}
_this.context.triggerEvent('keydown', event);
if (!event.isDefaultPrevented()) {
if (_this.options.shortcuts) {
_this.handleKeyMap(event);
}
else {
_this.preventDefaultEditableShortCuts(event);
}
}
if (_this.isLimited(1, event)) {
return false;
}
}).on('keyup', function (event) {
_this.context.triggerEvent('keyup', event);
}).on('focus', function (event) {
_this.context.triggerEvent('focus', event);
}).on('blur', function (event) {
_this.context.triggerEvent('blur', event);
}).on('mousedown', function (event) {
_this.context.triggerEvent('mousedown', event);
}).on('mouseup', function (event) {
_this.context.triggerEvent('mouseup', event);
}).on('scroll', function (event) {
_this.context.triggerEvent('scroll', event);
}).on('paste', function (event) {
_this.context.triggerEvent('paste', event);
});
this.$editable.html(dom.html(this.$note) || dom.emptyPara);
this.$editable.on(env.inputEventName, func.debounce(function () {
_this.context.triggerEvent('change', _this.$editable.html());
}, 100));
this.$editor.on('focusin', function (event) {
_this.context.triggerEvent('focusin', event);
}).on('focusout', function (event) {
_this.context.triggerEvent('focusout', event);
});
if (!this.options.airMode) {
if (this.options.width) {
this.$editor.outerWidth(this.options.width);
}
if (this.options.height) {
this.$editable.outerHeight(this.options.height);
}
if (this.options.maxHeight) {
this.$editable.css('max-height', this.options.maxHeight);
}
if (this.options.minHeight) {
this.$editable.css('min-height', this.options.minHeight);
}
}
this.history.recordUndo();
};
Editor.prototype.destroy = function () {
this.$editable.off();
};
Editor.prototype.handleKeyMap = function (event) {
var keyMap = this.options.keyMap[env.isMac ? 'mac' : 'pc'];
var keys = [];
if (event.metaKey) {
keys.push('CMD');
}
if (event.ctrlKey && !event.altKey) {
keys.push('CTRL');
}
if (event.shiftKey) {
keys.push('SHIFT');
}
var keyName = key.nameFromCode[event.keyCode];
if (keyName) {
keys.push(keyName);
}
var eventName = keyMap[keys.join('+')];
if (eventName) {
if (this.context.invoke(eventName) !== false) {
event.preventDefault();
}
}
else if (key.isEdit(event.keyCode)) {
this.afterCommand();
}
};
Editor.prototype.preventDefaultEditableShortCuts = function (event) {
if ((event.ctrlKey || event.metaKey) &&
lists.contains([66, 73, 85], event.keyCode)) {
event.preventDefault();
}
};
Editor.prototype.isLimited = function (pad, event) {
pad = pad || 0;
if (typeof event !== 'undefined') {
if (key.isMove(event.keyCode) ||
(event.ctrlKey || event.metaKey) ||
lists.contains([key.code.BACKSPACE, key.code.DELETE], event.keyCode)) {
return false;
}
}
if (this.options.maxTextLength > 0) {
if ((this.$editable.text().length + pad) >= this.options.maxTextLength) {
return true;
}
}
return false;
};
Editor.prototype.createRange = function () {
this.focus();
return range.create(this.editable);
};
Editor.prototype.saveRange = function (thenCollapse) {
this.lastRange = this.createRange();
if (thenCollapse) {
this.lastRange.collapse().select();
}
};
Editor.prototype.restoreRange = function () {
if (this.lastRange) {
this.lastRange.select();
this.focus();
}
};
Editor.prototype.saveTarget = function (node) {
this.$editable.data('target', node);
};
Editor.prototype.clearTarget = function () {
this.$editable.removeData('target');
};
Editor.prototype.restoreTarget = function () {
return this.$editable.data('target');
};
Editor.prototype.currentStyle = function () {
var rng = range.create();
if (rng) {
rng = rng.normalize();
}
return rng ? this.style.current(rng) : this.style.fromNode(this.$editable);
};
Editor.prototype.styleFromNode = function ($node) {
return this.style.fromNode($node);
};
Editor.prototype.undo = function () {
this.context.triggerEvent('before.command', this.$editable.html());
this.history.undo();
this.context.triggerEvent('change', this.$editable.html());
};
Editor.prototype.redo = function () {
this.context.triggerEvent('before.command', this.$editable.html());
this.history.redo();
this.context.triggerEvent('change', this.$editable.html());
};
Editor.prototype.beforeCommand = function () {
this.context.triggerEvent('before.command', this.$editable.html());
this.focus();
};
Editor.prototype.afterCommand = function (isPreventTrigger) {
this.history.recordUndo();
if (!isPreventTrigger) {
this.context.triggerEvent('change', this.$editable.html());
}
};
Editor.prototype.tab = function () {
var rng = this.createRange();
if (rng.isCollapsed() && rng.isOnCell()) {
this.table.tab(rng);
}
else {
if (this.options.tabSize === 0) {
return false;
}
if (!this.isLimited(this.options.tabSize)) {
this.beforeCommand();
this.typing.insertTab(rng, this.options.tabSize);
this.afterCommand();
}
}
};
Editor.prototype.untab = function () {
var rng = this.createRange();
if (rng.isCollapsed() && rng.isOnCell()) {
this.table.tab(rng, true);
}
else {
if (this.options.tabSize === 0) {
return false;
}
}
};
Editor.prototype.wrapCommand = function (fn) {
var _this = this;
return function () {
_this.beforeCommand();
fn.apply(_this, arguments);
_this.afterCommand();
};
};
Editor.prototype.insertImage = function (src, param) {
var _this = this;
return createImage(src, param).then(function ($image) {
_this.beforeCommand();
if (typeof param === 'function') {
param($image);
}
else {
if (typeof param === 'string') {
$image.attr('data-filename', param);
}
$image.css('width', Math.min(_this.$editable.width(), $image.width()));
}
$image.show();
range.create(_this.editable).insertNode($image[0]);
range.createFromNodeAfter($image[0]).select();
_this.afterCommand();
}).fail(function (e) {
_this.context.triggerEvent('image.upload.error', e);
});
};
Editor.prototype.insertImages = function (files) {
var _this = this;
$$1.each(files, function (idx, file) {
var filename = file.name;
if (_this.options.maximumImageFileSize && _this.options.maximumImageFileSize < file.size) {
_this.context.triggerEvent('image.upload.error', _this.lang.image.maximumFileSizeError);
}
else {
readFileAsDataURL(file).then(function (dataURL) {
return _this.insertImage(dataURL, filename);
}).fail(function () {
_this.context.triggerEvent('image.upload.error');
});
}
});
};
Editor.prototype.insertImagesOrCallback = function (files) {
var callbacks = this.options.callbacks;
if (callbacks.onImageUpload) {
this.context.triggerEvent('image.upload', files);
}
else {
this.insertImages(files);
}
};
Editor.prototype.getSelectedText = function () {
var rng = this.createRange();
if (rng.isOnAnchor()) {
rng = range.createFromNode(dom.ancestor(rng.sc, dom.isAnchor));
}
return rng.toString();
};
Editor.prototype.onFormatBlock = function (tagName, $target) {
tagName = env.isMSIE ? '<' + tagName + '>' : tagName;
document.execCommand('FormatBlock', false, tagName);
if ($target && $target.length) {
var className = $target[0].className || '';
if (className) {
var currentRange = this.createRange();
var $parent = $$1([currentRange.sc, currentRange.ec]).closest(tagName);
$parent.addClass(className);
}
}
};
Editor.prototype.formatPara = function () {
this.formatBlock('P');
};
Editor.prototype.fontStyling = function (target, value) {
var rng = this.createRange();
if (rng) {
var spans = this.style.styleNodes(rng);
$$1(spans).css(target, value);
if (rng.isCollapsed()) {
var firstSpan = lists.head(spans);
if (firstSpan && !dom.nodeLength(firstSpan)) {
firstSpan.innerHTML = dom.ZERO_WIDTH_NBSP_CHAR;
range.createFromNodeAfter(firstSpan.firstChild).select();
this.$editable.data(KEY_BOGUS, firstSpan);
}
}
}
};
Editor.prototype.unlink = function () {
var rng = this.createRange();
if (rng.isOnAnchor()) {
var anchor = dom.ancestor(rng.sc, dom.isAnchor);
rng = range.createFromNode(anchor);
rng.select();
this.beforeCommand();
document.execCommand('unlink');
this.afterCommand();
}
};
Editor.prototype.getLinkInfo = function () {
var rng = this.createRange().expand(dom.isAnchor);
var $anchor = $$1(lists.head(rng.nodes(dom.isAnchor)));
var linkInfo = {
range: rng,
text: rng.toString(),
url: $anchor.length ? $anchor.attr('href') : ''
};
if ($anchor.length) {
linkInfo.isNewWindow = $anchor.attr('target') === '_blank';
}
return linkInfo;
};
Editor.prototype.addRow = function (position) {
var rng = this.createRange(this.$editable);
if (rng.isCollapsed() && rng.isOnCell()) {
this.beforeCommand();
this.table.addRow(rng, position);
this.afterCommand();
}
};
Editor.prototype.addCol = function (position) {
var rng = this.createRange(this.$editable);
if (rng.isCollapsed() && rng.isOnCell()) {
this.beforeCommand();
this.table.addCol(rng, position);
this.afterCommand();
}
};
Editor.prototype.deleteRow = function () {
var rng = this.createRange(this.$editable);
if (rng.isCollapsed() && rng.isOnCell()) {
this.beforeCommand();
this.table.deleteRow(rng);
this.afterCommand();
}
};
Editor.prototype.deleteCol = function () {
var rng = this.createRange(this.$editable);
if (rng.isCollapsed() && rng.isOnCell()) {
this.beforeCommand();
this.table.deleteCol(rng);
this.afterCommand();
}
};
Editor.prototype.deleteTable = function () {
var rng = this.createRange(this.$editable);
if (rng.isCollapsed() && rng.isOnCell()) {
this.beforeCommand();
this.table.deleteTable(rng);
this.afterCommand();
}
};
Editor.prototype.resizeTo = function (pos, $target, bKeepRatio) {
var imageSize;
if (bKeepRatio) {
var newRatio = pos.y / pos.x;
var ratio = $target.data('ratio');
imageSize = {
width: ratio > newRatio ? pos.x : pos.y / ratio,
height: ratio > newRatio ? pos.x * ratio : pos.y
};
}
else {
imageSize = {
width: pos.x,
height: pos.y
};
}
$target.css(imageSize);
};
Editor.prototype.hasFocus = function () {
return this.$editable.is(':focus');
};
Editor.prototype.focus = function () {
if (!this.hasFocus()) {
this.$editable.focus();
}
};
Editor.prototype.isEmpty = function () {
return dom.isEmpty(this.$editable[0]) || dom.emptyPara === this.$editable.html();
};
Editor.prototype.empty = function () {
this.context.invoke('code', dom.emptyPara);
};
return Editor;
}());
var Clipboard = (function () {
function Clipboard(context) {
this.context = context;
this.$editable = context.layoutInfo.editable;
}
Clipboard.prototype.initialize = function () {
this.$editable.on('paste', this.pasteByEvent.bind(this));
};
Clipboard.prototype.pasteByEvent = function (event) {
var clipboardData = event.originalEvent.clipboardData;
if (clipboardData && clipboardData.items && clipboardData.items.length) {
var item = lists.head(clipboardData.items);
if (item.kind === 'file' && item.type.indexOf('image/') !== -1) {
this.context.invoke('editor.insertImagesOrCallback', [item.getAsFile()]);
}
this.context.invoke('editor.afterCommand');
}
};
return Clipboard;
}());
var Dropzone = (function () {
function Dropzone(context) {
this.context = context;
this.$eventListener = $$1(document);
this.$editor = context.layoutInfo.editor;
this.$editable = context.layoutInfo.editable;
this.options = context.options;
this.lang = this.options.langInfo;
this.documentEventHandlers = {};
this.$dropzone = $$1([
'<div class="note-dropzone">',
'  <div class="note-dropzone-message"/>',
'</div>'
].join('')).prependTo(this.$editor);
}
Dropzone.prototype.initialize = function () {
if (this.options.disableDragAndDrop) {
this.documentEventHandlers.onDrop = function (e) {
e.preventDefault();
};
this.$eventListener = this.$dropzone;
this.$eventListener.on('drop', this.documentEventHandlers.onDrop);
}
else {
this.attachDragAndDropEvent();
}
};
Dropzone.prototype.attachDragAndDropEvent = function () {
var _this = this;
var collection = $$1();
var $dropzoneMessage = this.$dropzone.find('.note-dropzone-message');
this.documentEventHandlers.onDragenter = function (e) {
var isCodeview = _this.context.invoke('codeview.isActivated');
var hasEditorSize = _this.$editor.width() > 0 && _this.$editor.height() > 0;
if (!isCodeview && !collection.length && hasEditorSize) {
_this.$editor.addClass('dragover');
_this.$dropzone.width(_this.$editor.width());
_this.$dropzone.height(_this.$editor.height());
$dropzoneMessage.text(_this.lang.image.dragImageHere);
}
collection = collection.add(e.target);
};
this.documentEventHandlers.onDragleave = function (e) {
collection = collection.not(e.target);
if (!collection.length) {
_this.$editor.removeClass('dragover');
}
};
this.documentEventHandlers.onDrop = function () {
collection = $$1();
_this.$editor.removeClass('dragover');
};
this.$eventListener.on('dragenter', this.documentEventHandlers.onDragenter)
.on('dragleave', this.documentEventHandlers.onDragleave)
.on('drop', this.documentEventHandlers.onDrop);
this.$dropzone.on('dragenter', function () {
_this.$dropzone.addClass('hover');
$dropzoneMessage.text(_this.lang.image.dropImage);
}).on('dragleave', function () {
_this.$dropzone.removeClass('hover');
$dropzoneMessage.text(_this.lang.image.dragImageHere);
});
this.$dropzone.on('drop', function (event) {
var dataTransfer = event.originalEvent.dataTransfer;
event.preventDefault();
if (dataTransfer && dataTransfer.files && dataTransfer.files.length) {
_this.$editable.focus();
_this.context.invoke('editor.insertImagesOrCallback', dataTransfer.files);
}
else {
$$1.each(dataTransfer.types, function (idx, type) {
var content = dataTransfer.getData(type);
if (type.toLowerCase().indexOf('text') > -1) {
_this.context.invoke('editor.pasteHTML', content);
}
else {
$$1(content).each(function (idx, item) {
_this.context.invoke('editor.insertNode', item);
});
}
});
}
}).on('dragover', false); // prevent default dragover event
};
Dropzone.prototype.destroy = function () {
var _this = this;
Object.keys(this.documentEventHandlers).forEach(function (key) {
_this.$eventListener.off(key.substr(2).toLowerCase(), _this.documentEventHandlers[key]);
});
this.documentEventHandlers = {};
};
return Dropzone;
}());
var CodeMirror;
if (env.hasCodeMirror) {
if (env.isSupportAmd) {
require(['codemirror'], function (cm) {
CodeMirror = cm;
});
}
else {
CodeMirror = window.CodeMirror;
}
}
var CodeView = (function () {
function CodeView(context) {
this.context = context;
this.$editor = context.layoutInfo.editor;
this.$editable = context.layoutInfo.editable;
this.$codable = context.layoutInfo.codable;
this.options = context.options;
}
CodeView.prototype.sync = function () {
var isCodeview = this.isActivated();
if (isCodeview && env.hasCodeMirror) {
this.$codable.data('cmEditor').save();
}
};
CodeView.prototype.isActivated = function () {
return this.$editor.hasClass('codeview');
};
CodeView.prototype.toggle = function () {
if (this.isActivated()) {
this.deactivate();
}
else {
this.activate();
}
this.context.triggerEvent('codeview.toggled');
};
CodeView.prototype.activate = function () {
var _this = this;
this.$codable.val(dom.html(this.$editable, this.options.prettifyHtml));
this.$codable.height(this.$editable.height());
this.context.invoke('toolbar.updateCodeview', true);
this.$editor.addClass('codeview');
this.$codable.focus();
if (env.hasCodeMirror) {
var cmEditor_1 = CodeMirror.fromTextArea(this.$codable[0], this.options.codemirror);
if (this.options.codemirror.tern) {
var server_1 = new CodeMirror.TernServer(this.options.codemirror.tern);
cmEditor_1.ternServer = server_1;
cmEditor_1.on('cursorActivity', function (cm) {
server_1.updateArgHints(cm);
});
}
cmEditor_1.on('blur', function (event) {
_this.context.triggerEvent('blur.codeview', cmEditor_1.getValue(), event);
});
cmEditor_1.setSize(null, this.$editable.outerHeight());
this.$codable.data('cmEditor', cmEditor_1);
}
else {
this.$codable.on('blur', function (event) {
_this.context.triggerEvent('blur.codeview', _this.$codable.val(), event);
});
}
};
CodeView.prototype.deactivate = function () {
if (env.hasCodeMirror) {
var cmEditor = this.$codable.data('cmEditor');
this.$codable.val(cmEditor.getValue());
cmEditor.toTextArea();
}
var value = dom.value(this.$codable, this.options.prettifyHtml) || dom.emptyPara;
var isChange = this.$editable.html() !== value;
this.$editable.html(value);
this.$editable.height(this.options.height ? this.$codable.height() : 'auto');
this.$editor.removeClass('codeview');
if (isChange) {
this.context.triggerEvent('change', this.$editable.html(), this.$editable);
}
this.$editable.focus();
this.context.invoke('toolbar.updateCodeview', false);
};
CodeView.prototype.destroy = function () {
if (this.isActivated()) {
this.deactivate();
}
};
return CodeView;
}());
var EDITABLE_PADDING = 24;
var Statusbar = (function () {
function Statusbar(context) {
this.$document = $$1(document);
this.$statusbar = context.layoutInfo.statusbar;
this.$editable = context.layoutInfo.editable;
this.options = context.options;
}
Statusbar.prototype.initialize = function () {
var _this = this;
if (this.options.airMode || this.options.disableResizeEditor) {
this.destroy();
return;
}
this.$statusbar.on('mousedown', function (event) {
event.preventDefault();
event.stopPropagation();
var editableTop = _this.$editable.offset().top - _this.$document.scrollTop();
var onMouseMove = function (event) {
var height = event.clientY - (editableTop + EDITABLE_PADDING);
height = (_this.options.minheight > 0) ? Math.max(height, _this.options.minheight) : height;
height = (_this.options.maxHeight > 0) ? Math.min(height, _this.options.maxHeight) : height;
_this.$editable.height(height);
};
_this.$document.on('mousemove', onMouseMove).one('mouseup', function () {
_this.$document.off('mousemove', onMouseMove);
});
});
};
Statusbar.prototype.destroy = function () {
this.$statusbar.off();
};
return Statusbar;
}());
var Fullscreen = (function () {
function Fullscreen(context) {
var _this = this;
this.context = context;
this.$editor = context.layoutInfo.editor;
this.$toolbar = context.layoutInfo.toolbar;
this.$editable = context.layoutInfo.editable;
this.$codable = context.layoutInfo.codable;
this.$window = $$1(window);
this.$scrollbar = $$1('html, body');
this.onResize = function () {
_this.resizeTo({
h: _this.$window.height() - _this.$toolbar.outerHeight()
});
};
}
Fullscreen.prototype.resizeTo = function (size) {
this.$editable.css('height', size.h);
this.$codable.css('height', size.h);
if (this.$codable.data('cmeditor')) {
this.$codable.data('cmeditor').setsize(null, size.h);
}
};
Fullscreen.prototype.toggle = function () {
this.$editor.toggleClass('fullscreen');
if (this.isFullscreen()) {
this.$editable.data('orgHeight', this.$editable.css('height'));
this.$window.on('resize', this.onResize).trigger('resize');
this.$scrollbar.css('overflow', 'hidden');
}
else {
this.$window.off('resize', this.onResize);
this.resizeTo({ h: this.$editable.data('orgHeight') });
this.$scrollbar.css('overflow', 'visible');
}
this.context.invoke('toolbar.updateFullscreen', this.isFullscreen());
};
Fullscreen.prototype.isFullscreen = function () {
return this.$editor.hasClass('fullscreen');
};
return Fullscreen;
}());
var Handle = (function () {
function Handle(context) {
var _this = this;
this.context = context;
this.$document = $$1(document);
this.$editingArea = context.layoutInfo.editingArea;
this.options = context.options;
this.lang = this.options.langInfo;
this.events = {
'summernote.mousedown': function (we, e) {
if (_this.update(e.target)) {
e.preventDefault();
}
},
'summernote.keyup summernote.scroll summernote.change summernote.dialog.shown': function () {
_this.update();
},
'summernote.disable': function () {
_this.hide();
},
'summernote.codeview.toggled': function () {
_this.update();
}
};
}
Handle.prototype.initialize = function () {
var _this = this;
this.$handle = $$1([
'<div class="note-handle">',
'<div class="note-control-selection">',
'<div class="note-control-selection-bg"></div>',
'<div class="note-control-holder note-control-nw"></div>',
'<div class="note-control-holder note-control-ne"></div>',
'<div class="note-control-holder note-control-sw"></div>',
'<div class="',
(this.options.disableResizeImage ? 'note-control-holder' : 'note-control-sizing'),
' note-control-se"></div>',
(this.options.disableResizeImage ? '' : '<div class="note-control-selection-info"></div>'),
'</div>',
'</div>'
].join('')).prependTo(this.$editingArea);
this.$handle.on('mousedown', function (event) {
if (dom.isControlSizing(event.target)) {
event.preventDefault();
event.stopPropagation();
var $target_1 = _this.$handle.find('.note-control-selection').data('target');
var posStart_1 = $target_1.offset();
var scrollTop_1 = _this.$document.scrollTop();
var onMouseMove_1 = function (event) {
_this.context.invoke('editor.resizeTo', {
x: event.clientX - posStart_1.left,
y: event.clientY - (posStart_1.top - scrollTop_1)
}, $target_1, !event.shiftKey);
_this.update($target_1[0]);
};
_this.$document
.on('mousemove', onMouseMove_1)
.one('mouseup', function (e) {
e.preventDefault();
_this.$document.off('mousemove', onMouseMove_1);
_this.context.invoke('editor.afterCommand');
});
if (!$target_1.data('ratio')) {
$target_1.data('ratio', $target_1.height() / $target_1.width());
}
}
});
this.$handle.on('wheel', function (e) {
e.preventDefault();
_this.update();
});
};
Handle.prototype.destroy = function () {
this.$handle.remove();
};
Handle.prototype.update = function (target) {
if (this.context.isDisabled()) {
return false;
}
var isImage = dom.isImg(target);
var $selection = this.$handle.find('.note-control-selection');
this.context.invoke('imagePopover.update', target);
if (isImage) {
var $image = $$1(target);
var position = $image.position();
var pos = {
left: position.left + parseInt($image.css('marginLeft'), 10),
top: position.top + parseInt($image.css('marginTop'), 10)
};
var imageSize = {
w: $image.outerWidth(false),
h: $image.outerHeight(false)
};
$selection.css({
display: 'block',
left: pos.left,
top: pos.top,
width: imageSize.w,
height: imageSize.h
}).data('target', $image); // save current image element.
var origImageObj = new Image();
origImageObj.src = $image.attr('src');
var sizingText = imageSize.w + 'x' + imageSize.h + ' (' + this.lang.image.original + ': ' + origImageObj.width + 'x' + origImageObj.height + ')';
$selection.find('.note-control-selection-info').text(sizingText);
this.context.invoke('editor.saveTarget', target);
}
else {
this.hide();
}
return isImage;
};
Handle.prototype.hide = function () {
this.context.invoke('editor.clearTarget');
this.$handle.children().hide();
};
return Handle;
}());
var defaultScheme = 'http://';
var linkPattern = /^([A-Za-z][A-Za-z0-9+-.]*\:[\/\/]?|mailto:[A-Z0-9._%+-]+@)?(www\.)?(.+)$/i;
var AutoLink = (function () {
function AutoLink(context) {
var _this = this;
this.context = context;
this.events = {
'summernote.keyup': function (we, e) {
if (!e.isDefaultPrevented()) {
_this.handleKeyup(e);
}
},
'summernote.keydown': function (we, e) {
_this.handleKeydown(e);
}
};
}
AutoLink.prototype.initialize = function () {
this.lastWordRange = null;
};
AutoLink.prototype.destroy = function () {
this.lastWordRange = null;
};
AutoLink.prototype.replace = function () {
if (!this.lastWordRange) {
return;
}
var keyword = this.lastWordRange.toString();
var match = keyword.match(linkPattern);
if (match && (match[1] || match[2])) {
var link = match[1] ? keyword : defaultScheme + keyword;
var node = $$1('<a />').html(keyword).attr('href', link)[0];
this.lastWordRange.insertNode(node);
this.lastWordRange = null;
this.context.invoke('editor.focus');
}
};
AutoLink.prototype.handleKeydown = function (e) {
if (lists.contains([key.code.ENTER, key.code.SPACE], e.keyCode)) {
var wordRange = this.context.invoke('editor.createRange').getWordRange();
this.lastWordRange = wordRange;
}
};
AutoLink.prototype.handleKeyup = function (e) {
if (lists.contains([key.code.ENTER, key.code.SPACE], e.keyCode)) {
this.replace();
}
};
return AutoLink;
}());
var AutoSync = (function () {
function AutoSync(context) {
var _this = this;
this.$note = context.layoutInfo.note;
this.events = {
'summernote.change': function () {
_this.$note.val(context.invoke('code'));
}
};
}
AutoSync.prototype.shouldInitialize = function () {
return dom.isTextarea(this.$note[0]);
};
return AutoSync;
}());
var Placeholder = (function () {
function Placeholder(context) {
var _this = this;
this.context = context;
this.$editingArea = context.layoutInfo.editingArea;
this.options = context.options;
this.events = {
'summernote.init summernote.change': function () {
_this.update();
},
'summernote.codeview.toggled': function () {
_this.update();
}
};
}
Placeholder.prototype.shouldInitialize = function () {
return !!this.options.placeholder;
};
Placeholder.prototype.initialize = function () {
var _this = this;
this.$placeholder = $$1('<div class="note-placeholder">');
this.$placeholder.on('click', function () {
_this.context.invoke('focus');
}).text(this.options.placeholder).prependTo(this.$editingArea);
this.update();
};
Placeholder.prototype.destroy = function () {
this.$placeholder.remove();
};
Placeholder.prototype.update = function () {
var isShow = !this.context.invoke('codeview.isActivated') && this.context.invoke('editor.isEmpty');
this.$placeholder.toggle(isShow);
};
return Placeholder;
}());
var Buttons = (function () {
function Buttons(context) {
this.ui = $$1.summernote.ui;
this.context = context;
this.$toolbar = context.layoutInfo.toolbar;
this.options = context.options;
this.lang = this.options.langInfo;
this.invertedKeyMap = func.invertObject(this.options.keyMap[env.isMac ? 'mac' : 'pc']);
}
Buttons.prototype.representShortcut = function (editorMethod) {
var shortcut = this.invertedKeyMap[editorMethod];
if (!this.options.shortcuts || !shortcut) {
return '';
}
if (env.isMac) {
shortcut = shortcut.replace('CMD', '').replace('SHIFT', '');
}
shortcut = shortcut.replace('BACKSLASH', '\\')
.replace('SLASH', '/')
.replace('LEFTBRACKET', '[')
.replace('RIGHTBRACKET', ']');
return ' (' + shortcut + ')';
};
Buttons.prototype.button = function (o) {
if (!this.options.tooltip && o.tooltip) {
delete o.tooltip;
}
o.container = this.options.container;
return this.ui.button(o);
};
Buttons.prototype.initialize = function () {
this.addToolbarButtons();
this.addImagePopoverButtons();
this.addLinkPopoverButtons();
this.addTablePopoverButtons();
this.fontInstalledMap = {};
};
Buttons.prototype.destroy = function () {
delete this.fontInstalledMap;
};
Buttons.prototype.isFontInstalled = function (name) {
if (!this.fontInstalledMap.hasOwnProperty(name)) {
this.fontInstalledMap[name] = env.isFontInstalled(name) ||
lists.contains(this.options.fontNamesIgnoreCheck, name);
}
return this.fontInstalledMap[name];
};
Buttons.prototype.isFontDeservedToAdd = function (name) {
var genericFamilies = ['sans-serif', 'serif', 'monospace', 'cursive', 'fantasy'];
name = name.toLowerCase();
return ((name !== '') && this.isFontInstalled(name) && ($$1.inArray(name, genericFamilies) === -1));
};
Buttons.prototype.addToolbarButtons = function () {
var _this = this;
this.context.memo('button.style', function () {
return _this.ui.buttonGroup([
_this.button({
className: 'dropdown-toggle',
contents: _this.ui.dropdownButtonContents(_this.ui.icon(_this.options.icons.magic), _this.options),
tooltip: _this.lang.style.style,
data: {
toggle: 'dropdown'
}
}),
_this.ui.dropdown({
className: 'dropdown-style',
items: _this.options.styleTags,
template: function (item) {
if (typeof item === 'string') {
item = { tag: item, title: (_this.lang.style.hasOwnProperty(item) ? _this.lang.style[item] : item) };
}
var tag = item.tag;
var title = item.title;
var style = item.style ? ' style="' + item.style + '" ' : '';
var className = item.className ? ' class="' + item.className + '"' : '';
return '<' + tag + style + className + '>' + title + '</' + tag + '>';
},
click: _this.context.createInvokeHandler('editor.formatBlock')
})
]).render();
});
var _loop_1 = function (styleIdx, styleLen) {
var item = this_1.options.styleTags[styleIdx];
this_1.context.memo('button.style.' + item, function () {
return _this.button({
className: 'note-btn-style-' + item,
contents: '<div data-value="' + item + '">' + item.toUpperCase() + '</div>',
tooltip: item.toUpperCase(),
click: _this.context.createInvokeHandler('editor.formatBlock')
}).render();
});
};
var this_1 = this;
for (var styleIdx = 0, styleLen = this.options.styleTags.length; styleIdx < styleLen; styleIdx++) {
_loop_1(styleIdx, styleLen);
}
this.context.memo('button.bold', function () {
return _this.button({
className: 'note-btn-bold',
contents: _this.ui.icon(_this.options.icons.bold),
tooltip: _this.lang.font.bold + _this.representShortcut('bold'),
click: _this.context.createInvokeHandlerAndUpdateState('editor.bold')
}).render();
});
this.context.memo('button.italic', function () {
return _this.button({
className: 'note-btn-italic',
contents: _this.ui.icon(_this.options.icons.italic),
tooltip: _this.lang.font.italic + _this.representShortcut('italic'),
click: _this.context.createInvokeHandlerAndUpdateState('editor.italic')
}).render();
});
this.context.memo('button.underline', function () {
return _this.button({
className: 'note-btn-underline',
contents: _this.ui.icon(_this.options.icons.underline),
tooltip: _this.lang.font.underline + _this.representShortcut('underline'),
click: _this.context.createInvokeHandlerAndUpdateState('editor.underline')
}).render();
});
this.context.memo('button.clear', function () {
return _this.button({
contents: _this.ui.icon(_this.options.icons.eraser),
tooltip: _this.lang.font.clear + _this.representShortcut('removeFormat'),
click: _this.context.createInvokeHandler('editor.removeFormat')
}).render();
});
this.context.memo('button.strikethrough', function () {
return _this.button({
className: 'note-btn-strikethrough',
contents: _this.ui.icon(_this.options.icons.strikethrough),
tooltip: _this.lang.font.strikethrough + _this.representShortcut('strikethrough'),
click: _this.context.createInvokeHandlerAndUpdateState('editor.strikethrough')
}).render();
});
this.context.memo('button.superscript', function () {
return _this.button({
className: 'note-btn-superscript',
contents: _this.ui.icon(_this.options.icons.superscript),
tooltip: _this.lang.font.superscript,
click: _this.context.createInvokeHandlerAndUpdateState('editor.superscript')
}).render();
});
this.context.memo('button.subscript', function () {
return _this.button({
className: 'note-btn-subscript',
contents: _this.ui.icon(_this.options.icons.subscript),
tooltip: _this.lang.font.subscript,
click: _this.context.createInvokeHandlerAndUpdateState('editor.subscript')
}).render();
});
this.context.memo('button.fontname', function () {
var styleInfo = _this.context.invoke('editor.currentStyle');
$$1.each(styleInfo['font-family'].split(','), function (idx, fontname) {
fontname = fontname.trim().replace(/['"]+/g, '');
if (_this.isFontDeservedToAdd(fontname)) {
if ($$1.inArray(fontname, _this.options.fontNames) === -1) {
_this.options.fontNames.push(fontname);
}
}
});
return _this.ui.buttonGroup([
_this.button({
className: 'dropdown-toggle',
contents: _this.ui.dropdownButtonContents('<span class="note-current-fontname"/>', _this.options),
tooltip: _this.lang.font.name,
data: {
toggle: 'dropdown'
}
}),
_this.ui.dropdownCheck({
className: 'dropdown-fontname',
checkClassName: _this.options.icons.menuCheck,
items: _this.options.fontNames.filter(_this.isFontInstalled.bind(_this)),
template: function (item) {
return '<span style="font-family: \'' + item + '\'">' + item + '</span>';
},
click: _this.context.createInvokeHandlerAndUpdateState('editor.fontName')
})
]).render();
});
this.context.memo('button.fontsize', function () {
return _this.ui.buttonGroup([
_this.button({
className: 'dropdown-toggle',
contents: _this.ui.dropdownButtonContents('<span class="note-current-fontsize"/>', _this.options),
tooltip: _this.lang.font.size,
data: {
toggle: 'dropdown'
}
}),
_this.ui.dropdownCheck({
className: 'dropdown-fontsize',
checkClassName: _this.options.icons.menuCheck,
items: _this.options.fontSizes,
click: _this.context.createInvokeHandlerAndUpdateState('editor.fontSize')
})
]).render();
});
this.context.memo('button.color', function () {
return _this.ui.buttonGroup({
className: 'note-color',
children: [
_this.button({
className: 'note-current-color-button',
contents: _this.ui.icon(_this.options.icons.font + ' note-recent-color'),
tooltip: _this.lang.color.recent,
click: function (e) {
var $button = $$1(e.currentTarget);
_this.context.invoke('editor.color', {
backColor: $button.attr('data-backColor'),
foreColor: $button.attr('data-foreColor')
});
},
callback: function ($button) {
var $recentColor = $button.find('.note-recent-color');
$recentColor.css('background-color', '#FFFF00');
$button.attr('data-backColor', '#FFFF00');
}
}),
_this.button({
className: 'dropdown-toggle',
contents: _this.ui.dropdownButtonContents('', _this.options),
tooltip: _this.lang.color.more,
data: {
toggle: 'dropdown'
}
}),
_this.ui.dropdown({
items: [
'<div class="note-palette">',
'  <div class="note-palette-title">' + _this.lang.color.background + '</div>',
'  <div>',
'    <button type="button" class="note-color-reset btn btn-light" data-event="backColor" data-value="inherit">',
_this.lang.color.transparent,
'    </button>',
'  </div>',
'  <div class="note-holder" data-event="backColor"/>',
'</div>',
'<div class="note-palette">',
'  <div class="note-palette-title">' + _this.lang.color.foreground + '</div>',
'  <div>',
'    <button type="button" class="note-color-reset btn btn-light" data-event="removeFormat" data-value="foreColor">',
_this.lang.color.resetToDefault,
'    </button>',
'  </div>',
'  <div class="note-holder" data-event="foreColor"/>',
'</div>'
].join(''),
callback: function ($dropdown) {
$dropdown.find('.note-holder').each(function (idx, item) {
var $holder = $$1(item);
$holder.append(_this.ui.palette({
colors: _this.options.colors,
eventName: $holder.data('event'),
container: _this.options.container,
tooltip: _this.options.tooltip
}).render());
});
},
click: function (event) {
var $button = $$1(event.target);
var eventName = $button.data('event');
var value = $button.data('value');
if (eventName && value) {
var key = eventName === 'backColor' ? 'background-color' : 'color';
var $color = $button.closest('.note-color').find('.note-recent-color');
var $currentButton = $button.closest('.note-color').find('.note-current-color-button');
$color.css(key, value);
$currentButton.attr('data-' + eventName, value);
_this.context.invoke('editor.' + eventName, value);
}
}
})
]
}).render();
});
this.context.memo('button.ul', function () {
return _this.button({
contents: _this.ui.icon(_this.options.icons.unorderedlist),
tooltip: _this.lang.lists.unordered + _this.representShortcut('insertUnorderedList'),
click: _this.context.createInvokeHandler('editor.insertUnorderedList')
}).render();
});
this.context.memo('button.ol', function () {
return _this.button({
contents: _this.ui.icon(_this.options.icons.orderedlist),
tooltip: _this.lang.lists.ordered + _this.representShortcut('insertOrderedList'),
click: _this.context.createInvokeHandler('editor.insertOrderedList')
}).render();
});
var justifyLeft = this.button({
contents: this.ui.icon(this.options.icons.alignLeft),
tooltip: this.lang.paragraph.left + this.representShortcut('justifyLeft'),
click: this.context.createInvokeHandler('editor.justifyLeft')
});
var justifyCenter = this.button({
contents: this.ui.icon(this.options.icons.alignCenter),
tooltip: this.lang.paragraph.center + this.representShortcut('justifyCenter'),
click: this.context.createInvokeHandler('editor.justifyCenter')
});
var justifyRight = this.button({
contents: this.ui.icon(this.options.icons.alignRight),
tooltip: this.lang.paragraph.right + this.representShortcut('justifyRight'),
click: this.context.createInvokeHandler('editor.justifyRight')
});
var justifyFull = this.button({
contents: this.ui.icon(this.options.icons.alignJustify),
tooltip: this.lang.paragraph.justify + this.representShortcut('justifyFull'),
click: this.context.createInvokeHandler('editor.justifyFull')
});
var outdent = this.button({
contents: this.ui.icon(this.options.icons.outdent),
tooltip: this.lang.paragraph.outdent + this.representShortcut('outdent'),
click: this.context.createInvokeHandler('editor.outdent')
});
var indent = this.button({
contents: this.ui.icon(this.options.icons.indent),
tooltip: this.lang.paragraph.indent + this.representShortcut('indent'),
click: this.context.createInvokeHandler('editor.indent')
});
this.context.memo('button.justifyLeft', func.invoke(justifyLeft, 'render'));
this.context.memo('button.justifyCenter', func.invoke(justifyCenter, 'render'));
this.context.memo('button.justifyRight', func.invoke(justifyRight, 'render'));
this.context.memo('button.justifyFull', func.invoke(justifyFull, 'render'));
this.context.memo('button.outdent', func.invoke(outdent, 'render'));
this.context.memo('button.indent', func.invoke(indent, 'render'));
this.context.memo('button.paragraph', function () {
return _this.ui.buttonGroup([
_this.button({
className: 'dropdown-toggle',
contents: _this.ui.dropdownButtonContents(_this.ui.icon(_this.options.icons.alignLeft), _this.options),
tooltip: _this.lang.paragraph.paragraph,
data: {
toggle: 'dropdown'
}
}),
_this.ui.dropdown([
_this.ui.buttonGroup({
className: 'note-align',
children: [justifyLeft, justifyCenter, justifyRight, justifyFull]
}),
_this.ui.buttonGroup({
className: 'note-list',
children: [outdent, indent]
})
])
]).render();
});
this.context.memo('button.height', function () {
return _this.ui.buttonGroup([
_this.button({
className: 'dropdown-toggle',
contents: _this.ui.dropdownButtonContents(_this.ui.icon(_this.options.icons.textHeight), _this.options),
tooltip: _this.lang.font.height,
data: {
toggle: 'dropdown'
}
}),
_this.ui.dropdownCheck({
items: _this.options.lineHeights,
checkClassName: _this.options.icons.menuCheck,
className: 'dropdown-line-height',
click: _this.context.createInvokeHandler('editor.lineHeight')
})
]).render();
});
this.context.memo('button.table', function () {
return _this.ui.buttonGroup([
_this.button({
className: 'dropdown-toggle',
contents: _this.ui.dropdownButtonContents(_this.ui.icon(_this.options.icons.table), _this.options),
tooltip: _this.lang.table.table,
data: {
toggle: 'dropdown'
}
}),
_this.ui.dropdown({
className: 'note-table',
items: [
'<div class="note-dimension-picker">',
'  <div class="note-dimension-picker-mousecatcher" data-event="insertTable" data-value="1x1"/>',
'  <div class="note-dimension-picker-highlighted"/>',
'  <div class="note-dimension-picker-unhighlighted"/>',
'</div>',
'<div class="note-dimension-display">1 x 1</div>'
].join('')
})
], {
callback: function ($node) {
var $catcher = $node.find('.note-dimension-picker-mousecatcher');
$catcher.css({
width: _this.options.insertTableMaxSize.col + 'em',
height: _this.options.insertTableMaxSize.row + 'em'
}).mousedown(_this.context.createInvokeHandler('editor.insertTable'))
.on('mousemove', _this.tableMoveHandler.bind(_this));
}
}).render();
});
this.context.memo('button.link', function () {
return _this.button({
contents: _this.ui.icon(_this.options.icons.link),
tooltip: _this.lang.link.link + _this.representShortcut('linkDialog.show'),
click: _this.context.createInvokeHandler('linkDialog.show')
}).render();
});
this.context.memo('button.picture', function () {
return _this.button({
contents: _this.ui.icon(_this.options.icons.picture),
tooltip: _this.lang.image.image,
click: _this.context.createInvokeHandler('imageDialog.show')
}).render();
});
this.context.memo('button.video', function () {
return _this.button({
contents: _this.ui.icon(_this.options.icons.video),
tooltip: _this.lang.video.video,
click: _this.context.createInvokeHandler('videoDialog.show')
}).render();
});
this.context.memo('button.hr', function () {
return _this.button({
contents: _this.ui.icon(_this.options.icons.minus),
tooltip: _this.lang.hr.insert + _this.representShortcut('insertHorizontalRule'),
click: _this.context.createInvokeHandler('editor.insertHorizontalRule')
}).render();
});
this.context.memo('button.fullscreen', function () {
return _this.button({
className: 'btn-fullscreen',
contents: _this.ui.icon(_this.options.icons.arrowsAlt),
tooltip: _this.options.fullscreen,
click: _this.context.createInvokeHandler('fullscreen.toggle')
}).render();
});
this.context.memo('button.codeview', function () {
return _this.button({
className: 'btn-codeview',
contents: _this.ui.icon(_this.options.icons.code),
tooltip: _this.options.codeview,
click: _this.context.createInvokeHandler('codeview.toggle')
}).render();
});
this.context.memo('button.redo', function () {
return _this.button({
contents: _this.ui.icon(_this.options.icons.redo),
tooltip: _this.lang.history.redo + _this.representShortcut('redo'),
click: _this.context.createInvokeHandler('editor.redo')
}).render();
});
this.context.memo('button.undo', function () {
return _this.button({
contents: _this.ui.icon(_this.options.icons.undo),
tooltip: _this.lang.history.undo + _this.representShortcut('undo'),
click: _this.context.createInvokeHandler('editor.undo')
}).render();
});
this.context.memo('button.help', function () {
return _this.button({
contents: _this.ui.icon(_this.options.icons.question),
tooltip: _this.options.help,
click: _this.context.createInvokeHandler('helpDialog.show')
}).render();
});
};
Buttons.prototype.addImagePopoverButtons = function () {
var _this = this;
this.context.memo('button.imageSize100', function () {
return _this.button({
contents: '<span class="note-fontsize-10">100%</span>',
tooltip: _this.lang.image.resizeFull,
click: _this.context.createInvokeHandler('editor.resize', '1')
}).render();
});
this.context.memo('button.imageSize50', function () {
return _this.button({
contents: '<span class="note-fontsize-10">50%</span>',
tooltip: _this.lang.image.resizeHalf,
click: _this.context.createInvokeHandler('editor.resize', '0.5')
}).render();
});
this.context.memo('button.imageSize25', function () {
return _this.button({
contents: '<span class="note-fontsize-10">25%</span>',
tooltip: _this.lang.image.resizeQuarter,
click: _this.context.createInvokeHandler('editor.resize', '0.25')
}).render();
});
this.context.memo('button.floatLeft', function () {
return _this.button({
contents: _this.ui.icon(_this.options.icons.alignLeft),
tooltip: _this.lang.image.floatLeft,
click: _this.context.createInvokeHandler('editor.floatMe', 'left')
}).render();
});
this.context.memo('button.floatRight', function () {
return _this.button({
contents: _this.ui.icon(_this.options.icons.alignRight),
tooltip: _this.lang.image.floatRight,
click: _this.context.createInvokeHandler('editor.floatMe', 'right')
}).render();
});
this.context.memo('button.floatNone', function () {
return _this.button({
contents: _this.ui.icon(_this.options.icons.alignJustify),
tooltip: _this.lang.image.floatNone,
click: _this.context.createInvokeHandler('editor.floatMe', 'none')
}).render();
});
this.context.memo('button.removeMedia', function () {
return _this.button({
contents: _this.ui.icon(_this.options.icons.trash),
tooltip: _this.lang.image.remove,
click: _this.context.createInvokeHandler('editor.removeMedia')
}).render();
});
};
Buttons.prototype.addLinkPopoverButtons = function () {
var _this = this;
this.context.memo('button.linkDialogShow', function () {
return _this.button({
contents: _this.ui.icon(_this.options.icons.link),
tooltip: _this.lang.link.edit,
click: _this.context.createInvokeHandler('linkDialog.show')
}).render();
});
this.context.memo('button.unlink', function () {
return _this.button({
contents: _this.ui.icon(_this.options.icons.unlink),
tooltip: _this.lang.link.unlink,
click: _this.context.createInvokeHandler('editor.unlink')
}).render();
});
};
Buttons.prototype.addTablePopoverButtons = function () {
var _this = this;
this.context.memo('button.addRowUp', function () {
return _this.button({
className: 'btn-md',
contents: _this.ui.icon(_this.options.icons.rowAbove),
tooltip: _this.lang.table.addRowAbove,
click: _this.context.createInvokeHandler('editor.addRow', 'top')
}).render();
});
this.context.memo('button.addRowDown', function () {
return _this.button({
className: 'btn-md',
contents: _this.ui.icon(_this.options.icons.rowBelow),
tooltip: _this.lang.table.addRowBelow,
click: _this.context.createInvokeHandler('editor.addRow', 'bottom')
}).render();
});
this.context.memo('button.addColLeft', function () {
return _this.button({
className: 'btn-md',
contents: _this.ui.icon(_this.options.icons.colBefore),
tooltip: _this.lang.table.addColLeft,
click: _this.context.createInvokeHandler('editor.addCol', 'left')
}).render();
});
this.context.memo('button.addColRight', function () {
return _this.button({
className: 'btn-md',
contents: _this.ui.icon(_this.options.icons.colAfter),
tooltip: _this.lang.table.addColRight,
click: _this.context.createInvokeHandler('editor.addCol', 'right')
}).render();
});
this.context.memo('button.deleteRow', function () {
return _this.button({
className: 'btn-md',
contents: _this.ui.icon(_this.options.icons.rowRemove),
tooltip: _this.lang.table.delRow,
click: _this.context.createInvokeHandler('editor.deleteRow')
}).render();
});
this.context.memo('button.deleteCol', function () {
return _this.button({
className: 'btn-md',
contents: _this.ui.icon(_this.options.icons.colRemove),
tooltip: _this.lang.table.delCol,
click: _this.context.createInvokeHandler('editor.deleteCol')
}).render();
});
this.context.memo('button.deleteTable', function () {
return _this.button({
className: 'btn-md',
contents: _this.ui.icon(_this.options.icons.trash),
tooltip: _this.lang.table.delTable,
click: _this.context.createInvokeHandler('editor.deleteTable')
}).render();
});
};
Buttons.prototype.build = function ($container, groups) {
for (var groupIdx = 0, groupLen = groups.length; groupIdx < groupLen; groupIdx++) {
var group = groups[groupIdx];
var groupName = $$1.isArray(group) ? group[0] : group;
var buttons = $$1.isArray(group) ? ((group.length === 1) ? [group[0]] : group[1]) : [group];
var $group = this.ui.buttonGroup({
className: 'note-' + groupName
}).render();
for (var idx = 0, len = buttons.length; idx < len; idx++) {
var btn = this.context.memo('button.' + buttons[idx]);
if (btn) {
$group.append(typeof btn === 'function' ? btn(this.context) : btn);
}
}
$group.appendTo($container);
}
};
Buttons.prototype.updateCurrentStyle = function ($container) {
var _this = this;
var $cont = $container || this.$toolbar;
var styleInfo = this.context.invoke('editor.currentStyle');
this.updateBtnStates($cont, {
'.note-btn-bold': function () {
return styleInfo['font-bold'] === 'bold';
},
'.note-btn-italic': function () {
return styleInfo['font-italic'] === 'italic';
},
'.note-btn-underline': function () {
return styleInfo['font-underline'] === 'underline';
},
'.note-btn-subscript': function () {
return styleInfo['font-subscript'] === 'subscript';
},
'.note-btn-superscript': function () {
return styleInfo['font-superscript'] === 'superscript';
},
'.note-btn-strikethrough': function () {
return styleInfo['font-strikethrough'] === 'strikethrough';
}
});
if (styleInfo['font-family']) {
var fontNames = styleInfo['font-family'].split(',').map(function (name) {
return name.replace(/[\'\"]/g, '')
.replace(/\s+$/, '')
.replace(/^\s+/, '');
});
var fontName_1 = lists.find(fontNames, this.isFontInstalled.bind(this));
$cont.find('.dropdown-fontname a').each(function (idx, item) {
var $item = $$1(item);
var isChecked = ($item.data('value') + '') === (fontName_1 + '');
$item.toggleClass('checked', isChecked);
});
$cont.find('.note-current-fontname').text(fontName_1).css('font-family', fontName_1);
}
if (styleInfo['font-size']) {
var fontSize_1 = styleInfo['font-size'];
$cont.find('.dropdown-fontsize a').each(function (idx, item) {
var $item = $$1(item);
var isChecked = ($item.data('value') + '') === (fontSize_1 + '');
$item.toggleClass('checked', isChecked);
});
$cont.find('.note-current-fontsize').text(fontSize_1);
}
if (styleInfo['line-height']) {
var lineHeight_1 = styleInfo['line-height'];
$cont.find('.dropdown-line-height li a').each(function (idx, item) {
var isChecked = ($$1(item).data('value') + '') === (lineHeight_1 + '');
_this.className = isChecked ? 'checked' : '';
});
}
};
Buttons.prototype.updateBtnStates = function ($container, infos) {
var _this = this;
$$1.each(infos, function (selector, pred) {
_this.ui.toggleBtnActive($container.find(selector), pred());
});
};
Buttons.prototype.tableMoveHandler = function (event) {
var PX_PER_EM = 18;
var $picker = $$1(event.target.parentNode); // target is mousecatcher
var $dimensionDisplay = $picker.next();
var $catcher = $picker.find('.note-dimension-picker-mousecatcher');
var $highlighted = $picker.find('.note-dimension-picker-highlighted');
var $unhighlighted = $picker.find('.note-dimension-picker-unhighlighted');
var posOffset;
if (event.offsetX === undefined) {
var posCatcher = $$1(event.target).offset();
posOffset = {
x: event.pageX - posCatcher.left,
y: event.pageY - posCatcher.top
};
}
else {
posOffset = {
x: event.offsetX,
y: event.offsetY
};
}
var dim = {
c: Math.ceil(posOffset.x / PX_PER_EM) || 1,
r: Math.ceil(posOffset.y / PX_PER_EM) || 1
};
$highlighted.css({ width: dim.c + 'em', height: dim.r + 'em' });
$catcher.data('value', dim.c + 'x' + dim.r);
if (dim.c > 3 && dim.c < this.options.insertTableMaxSize.col) {
$unhighlighted.css({ width: dim.c + 1 + 'em' });
}
if (dim.r > 3 && dim.r < this.options.insertTableMaxSize.row) {
$unhighlighted.css({ height: dim.r + 1 + 'em' });
}
$dimensionDisplay.html(dim.c + ' x ' + dim.r);
};
return Buttons;
}());
var Toolbar = (function () {
function Toolbar(context) {
this.context = context;
this.$window = $$1(window);
this.$document = $$1(document);
this.ui = $$1.summernote.ui;
this.$note = context.layoutInfo.note;
this.$editor = context.layoutInfo.editor;
this.$toolbar = context.layoutInfo.toolbar;
this.options = context.options;
this.followScroll = this.followScroll.bind(this);
}
Toolbar.prototype.shouldInitialize = function () {
return !this.options.airMode;
};
Toolbar.prototype.initialize = function () {
var _this = this;
this.options.toolbar = this.options.toolbar || [];
if (!this.options.toolbar.length) {
this.$toolbar.hide();
}
else {
this.context.invoke('buttons.build', this.$toolbar, this.options.toolbar);
}
if (this.options.toolbarContainer) {
this.$toolbar.appendTo(this.options.toolbarContainer);
}
this.changeContainer(false);
this.$note.on('summernote.keyup summernote.mouseup summernote.change', function () {
_this.context.invoke('buttons.updateCurrentStyle');
});
this.context.invoke('buttons.updateCurrentStyle');
if (this.options.followingToolbar) {
this.$window.on('scroll resize', this.followScroll);
}
};
Toolbar.prototype.destroy = function () {
this.$toolbar.children().remove();
if (this.options.followingToolbar) {
this.$window.off('scroll resize', this.followScroll);
}
};
Toolbar.prototype.followScroll = function () {
if (this.$editor.hasClass('fullscreen')) {
return false;
}
var $toolbarWrapper = this.$toolbar.parent('.note-toolbar-wrapper');
var editorHeight = this.$editor.outerHeight();
var editorWidth = this.$editor.width();
var toolbarHeight = this.$toolbar.height();
$toolbarWrapper.css({
height: toolbarHeight
});
var otherBarHeight = 0;
if (this.options.otherStaticBar) {
otherBarHeight = $$1(this.options.otherStaticBar).outerHeight();
}
var currentOffset = this.$document.scrollTop();
var editorOffsetTop = this.$editor.offset().top;
var editorOffsetBottom = editorOffsetTop + editorHeight;
var activateOffset = editorOffsetTop - otherBarHeight;
var deactivateOffsetBottom = editorOffsetBottom - otherBarHeight - toolbarHeight;
if ((currentOffset > activateOffset) && (currentOffset < deactivateOffsetBottom)) {
this.$toolbar.css({
position: 'fixed',
top: otherBarHeight,
width: editorWidth
});
}
else {
this.$toolbar.css({
position: 'relative',
top: 0,
width: '100%'
});
}
};
Toolbar.prototype.changeContainer = function (isFullscreen) {
if (isFullscreen) {
this.$toolbar.prependTo(this.$editor);
}
else {
if (this.options.toolbarContainer) {
this.$toolbar.appendTo(this.options.toolbarContainer);
}
}
};
Toolbar.prototype.updateFullscreen = function (isFullscreen) {
this.ui.toggleBtnActive(this.$toolbar.find('.btn-fullscreen'), isFullscreen);
this.changeContainer(isFullscreen);
};
Toolbar.prototype.updateCodeview = function (isCodeview) {
this.ui.toggleBtnActive(this.$toolbar.find('.btn-codeview'), isCodeview);
if (isCodeview) {
this.deactivate();
}
else {
this.activate();
}
};
Toolbar.prototype.activate = function (isIncludeCodeview) {
var $btn = this.$toolbar.find('button');
if (!isIncludeCodeview) {
$btn = $btn.not('.btn-codeview');
}
this.ui.toggleBtn($btn, true);
};
Toolbar.prototype.deactivate = function (isIncludeCodeview) {
var $btn = this.$toolbar.find('button');
if (!isIncludeCodeview) {
$btn = $btn.not('.btn-codeview');
}
this.ui.toggleBtn($btn, false);
};
return Toolbar;
}());
var LinkDialog = (function () {
function LinkDialog(context) {
this.context = context;
this.ui = $$1.summernote.ui;
this.$body = $$1(document.body);
this.$editor = context.layoutInfo.editor;
this.options = context.options;
this.lang = this.options.langInfo;
context.memo('help.linkDialog.show', this.options.langInfo.help['linkDialog.show']);
}
LinkDialog.prototype.initialize = function () {
var $container = this.options.dialogsInBody ? this.$body : this.$editor;
var body = [
'<div class="form-group note-form-group">',
"<label class=\"note-form-label\">" + this.lang.link.textToDisplay + "</label>",
'<input class="note-link-text form-control note-form-control  note-input" type="text" />',
'</div>',
'<div class="form-group note-form-group">',
"<label class=\"note-form-label\">" + this.lang.link.url + "</label>",
'<input class="note-link-url form-control note-form-control note-input" type="text" value="http://" />',
'</div>',
!this.options.disableLinkTarget
? $$1('<div/>').append(this.ui.checkbox({
id: 'sn-checkbox-open-in-new-window',
text: this.lang.link.openInNewWindow,
checked: true
}).render()).html()
: ''
].join('');
var buttonClass = 'btn btn-primary note-btn note-btn-primary note-link-btn';
var footer = "<button type=\"submit\" href=\"#\" class=\"" + buttonClass + "\" disabled>" + this.lang.link.insert + "</button>";
this.$dialog = this.ui.dialog({
className: 'link-dialog',
title: this.lang.link.insert,
fade: this.options.dialogsFade,
body: body,
footer: footer
}).render().appendTo($container);
};
LinkDialog.prototype.destroy = function () {
this.ui.hideDialog(this.$dialog);
this.$dialog.remove();
};
LinkDialog.prototype.bindEnterKey = function ($input, $btn) {
$input.on('keypress', function (event) {
if (event.keyCode === key.code.ENTER) {
event.preventDefault();
$btn.trigger('click');
}
});
};
LinkDialog.prototype.toggleLinkBtn = function ($linkBtn, $linkText, $linkUrl) {
this.ui.toggleBtn($linkBtn, $linkText.val() && $linkUrl.val());
};
LinkDialog.prototype.showLinkDialog = function (linkInfo) {
var _this = this;
return $$1.Deferred(function (deferred) {
var $linkText = _this.$dialog.find('.note-link-text');
var $linkUrl = _this.$dialog.find('.note-link-url');
var $linkBtn = _this.$dialog.find('.note-link-btn');
var $openInNewWindow = _this.$dialog.find('input[type=checkbox]');
_this.ui.onDialogShown(_this.$dialog, function () {
_this.context.triggerEvent('dialog.shown');
if (!linkInfo.url) {
linkInfo.url = linkInfo.text;
}
$linkText.val(linkInfo.text);
var handleLinkTextUpdate = function () {
_this.toggleLinkBtn($linkBtn, $linkText, $linkUrl);
linkInfo.text = $linkText.val();
};
$linkText.on('input', handleLinkTextUpdate).on('paste', function () {
setTimeout(handleLinkTextUpdate, 0);
});
var handleLinkUrlUpdate = function () {
_this.toggleLinkBtn($linkBtn, $linkText, $linkUrl);
if (!linkInfo.text) {
$linkText.val($linkUrl.val());
}
};
$linkUrl.on('input', handleLinkUrlUpdate).on('paste', function () {
setTimeout(handleLinkUrlUpdate, 0);
}).val(linkInfo.url);
if (!env.isSupportTouch) {
$linkUrl.trigger('focus');
}
_this.toggleLinkBtn($linkBtn, $linkText, $linkUrl);
_this.bindEnterKey($linkUrl, $linkBtn);
_this.bindEnterKey($linkText, $linkBtn);
var isChecked = linkInfo.isNewWindow !== undefined
? linkInfo.isNewWindow : _this.context.options.linkTargetBlank;
$openInNewWindow.prop('checked', isChecked);
$linkBtn.one('click', function (event) {
event.preventDefault();
deferred.resolve({
range: linkInfo.range,
url: $linkUrl.val(),
text: $linkText.val(),
isNewWindow: $openInNewWindow.is(':checked')
});
_this.ui.hideDialog(_this.$dialog);
});
});
_this.ui.onDialogHidden(_this.$dialog, function () {
$linkText.off('input paste keypress');
$linkUrl.off('input paste keypress');
$linkBtn.off('click');
if (deferred.state() === 'pending') {
deferred.reject();
}
});
_this.ui.showDialog(_this.$dialog);
}).promise();
};
LinkDialog.prototype.show = function () {
var _this = this;
var linkInfo = this.context.invoke('editor.getLinkInfo');
this.context.invoke('editor.saveRange');
this.showLinkDialog(linkInfo).then(function (linkInfo) {
_this.context.invoke('editor.restoreRange');
_this.context.invoke('editor.createLink', linkInfo);
}).fail(function () {
_this.context.invoke('editor.restoreRange');
});
};
return LinkDialog;
}());
var LinkPopover = (function () {
function LinkPopover(context) {
var _this = this;
this.context = context;
this.ui = $$1.summernote.ui;
this.options = context.options;
this.events = {
'summernote.keyup summernote.mouseup summernote.change summernote.scroll': function () {
_this.update();
},
'summernote.disable summernote.dialog.shown': function () {
_this.hide();
}
};
}
LinkPopover.prototype.shouldInitialize = function () {
return !lists.isEmpty(this.options.popover.link);
};
LinkPopover.prototype.initialize = function () {
this.$popover = this.ui.popover({
className: 'note-link-popover',
callback: function ($node) {
var $content = $node.find('.popover-content,.note-popover-content');
$content.prepend('<span><a target="_blank"></a>&nbsp;</span>');
}
}).render().appendTo(this.options.container);
var $content = this.$popover.find('.popover-content,.note-popover-content');
this.context.invoke('buttons.build', $content, this.options.popover.link);
};
LinkPopover.prototype.destroy = function () {
this.$popover.remove();
};
LinkPopover.prototype.update = function () {
if (!this.context.invoke('editor.hasFocus')) {
this.hide();
return;
}
var rng = this.context.invoke('editor.createRange');
if (rng.isCollapsed() && rng.isOnAnchor()) {
var anchor = dom.ancestor(rng.sc, dom.isAnchor);
var href = $$1(anchor).attr('href');
this.$popover.find('a').attr('href', href).html(href);
var pos = dom.posFromPlaceholder(anchor);
this.$popover.css({
display: 'block',
left: pos.left,
top: pos.top
});
}
else {
this.hide();
}
};
LinkPopover.prototype.hide = function () {
this.$popover.hide();
};
return LinkPopover;
}());
var ImageDialog = (function () {
function ImageDialog(context) {
this.context = context;
this.ui = $$1.summernote.ui;
this.$body = $$1(document.body);
this.$editor = context.layoutInfo.editor;
this.options = context.options;
this.lang = this.options.langInfo;
}
ImageDialog.prototype.initialize = function () {
var $container = this.options.dialogsInBody ? this.$body : this.$editor;
var imageLimitation = '';
if (this.options.maximumImageFileSize) {
var unit = Math.floor(Math.log(this.options.maximumImageFileSize) / Math.log(1024));
var readableSize = (this.options.maximumImageFileSize / Math.pow(1024, unit)).toFixed(2) * 1 +
' ' + ' KMGTP'[unit] + 'B';
imageLimitation = "<small>" + (this.lang.image.maximumFileSize + ' : ' + readableSize) + "</small>";
}
var body = [
'<div class="form-group note-form-group note-group-select-from-files">',
'<label class="note-form-label">' + this.lang.image.selectFromFiles + '</label>',
'<input class="note-image-input note-form-control note-input" ',
' type="file" name="files" accept="image/*" multiple="multiple" />',
imageLimitation,
'</div>',
'<div class="form-group note-group-image-url" style="overflow:auto;">',
'<label class="note-form-label">' + this.lang.image.url + '</label>',
'<input class="note-image-url form-control note-form-control note-input ',
' col-md-12" type="text" />',
'</div>'
].join('');
var buttonClass = 'btn btn-primary note-btn note-btn-primary note-image-btn';
var footer = "<button type=\"submit\" href=\"#\" class=\"" + buttonClass + "\" disabled>" + this.lang.image.insert + "</button>";
this.$dialog = this.ui.dialog({
title: this.lang.image.insert,
fade: this.options.dialogsFade,
body: body,
footer: footer
}).render().appendTo($container);
};
ImageDialog.prototype.destroy = function () {
this.ui.hideDialog(this.$dialog);
this.$dialog.remove();
};
ImageDialog.prototype.bindEnterKey = function ($input, $btn) {
$input.on('keypress', function (event) {
if (event.keyCode === key.code.ENTER) {
event.preventDefault();
$btn.trigger('click');
}
});
};
ImageDialog.prototype.show = function () {
var _this = this;
this.context.invoke('editor.saveRange');
this.showImageDialog().then(function (data) {
_this.ui.hideDialog(_this.$dialog);
_this.context.invoke('editor.restoreRange');
if (typeof data === 'string') {
_this.context.invoke('editor.insertImage', data);
}
else {
_this.context.invoke('editor.insertImagesOrCallback', data);
}
}).fail(function () {
_this.context.invoke('editor.restoreRange');
});
};
ImageDialog.prototype.showImageDialog = function () {
var _this = this;
return $$1.Deferred(function (deferred) {
var $imageInput = _this.$dialog.find('.note-image-input');
var $imageUrl = _this.$dialog.find('.note-image-url');
var $imageBtn = _this.$dialog.find('.note-image-btn');
_this.ui.onDialogShown(_this.$dialog, function () {
_this.context.triggerEvent('dialog.shown');
$imageInput.replaceWith($imageInput.clone().on('change', function (event) {
deferred.resolve(event.target.files || event.target.value);
}).val(''));
$imageBtn.click(function (event) {
event.preventDefault();
deferred.resolve($imageUrl.val());
});
$imageUrl.on('keyup paste', function () {
var url = $imageUrl.val();
_this.ui.toggleBtn($imageBtn, url);
}).val('');
if (!env.isSupportTouch) {
$imageUrl.trigger('focus');
}
_this.bindEnterKey($imageUrl, $imageBtn);
});
_this.ui.onDialogHidden(_this.$dialog, function () {
$imageInput.off('change');
$imageUrl.off('keyup paste keypress');
$imageBtn.off('click');
if (deferred.state() === 'pending') {
deferred.reject();
}
});
_this.ui.showDialog(_this.$dialog);
});
};
return ImageDialog;
}());
var ImagePopover = (function () {
function ImagePopover(context) {
var _this = this;
this.context = context;
this.ui = $$1.summernote.ui;
this.editable = context.layoutInfo.editable[0];
this.options = context.options;
this.events = {
'summernote.disable': function () {
_this.hide();
}
};
}
ImagePopover.prototype.shouldInitialize = function () {
return !lists.isEmpty(this.options.popover.image);
};
ImagePopover.prototype.initialize = function () {
this.$popover = this.ui.popover({
className: 'note-image-popover'
}).render().appendTo(this.options.container);
var $content = this.$popover.find('.popover-content,.note-popover-content');
this.context.invoke('buttons.build', $content, this.options.popover.image);
};
ImagePopover.prototype.destroy = function () {
this.$popover.remove();
};
ImagePopover.prototype.update = function (target) {
if (dom.isImg(target)) {
var pos = dom.posFromPlaceholder(target);
var posEditor = dom.posFromPlaceholder(this.editable);
this.$popover.css({
display: 'block',
left: this.options.popatmouse ? event.pageX - 20 : pos.left,
top: this.options.popatmouse ? event.pageY : Math.min(pos.top, posEditor.top)
});
}
else {
this.hide();
}
};
ImagePopover.prototype.hide = function () {
this.$popover.hide();
};
return ImagePopover;
}());
var TablePopover = (function () {
function TablePopover(context) {
var _this = this;
this.context = context;
this.ui = $$1.summernote.ui;
this.options = context.options;
this.events = {
'summernote.mousedown': function (we, e) {
_this.update(e.target);
},
'summernote.keyup summernote.scroll summernote.change': function () {
_this.update();
},
'summernote.disable': function () {
_this.hide();
}
};
}
TablePopover.prototype.shouldInitialize = function () {
return !lists.isEmpty(this.options.popover.table);
};
TablePopover.prototype.initialize = function () {
this.$popover = this.ui.popover({
className: 'note-table-popover'
}).render().appendTo(this.options.container);
var $content = this.$popover.find('.popover-content,.note-popover-content');
this.context.invoke('buttons.build', $content, this.options.popover.table);
if (env.isFF) {
document.execCommand('enableInlineTableEditing', false, false);
}
};
TablePopover.prototype.destroy = function () {
this.$popover.remove();
};
TablePopover.prototype.update = function (target) {
if (this.context.isDisabled()) {
return false;
}
var isCell = dom.isCell(target);
if (isCell) {
var pos = dom.posFromPlaceholder(target);
this.$popover.css({
display: 'block',
left: pos.left,
top: pos.top
});
}
else {
this.hide();
}
return isCell;
};
TablePopover.prototype.hide = function () {
this.$popover.hide();
};
return TablePopover;
}());
var VideoDialog = (function () {
function VideoDialog(context) {
this.context = context;
this.ui = $$1.summernote.ui;
this.$body = $$1(document.body);
this.$editor = context.layoutInfo.editor;
this.options = context.options;
this.lang = this.options.langInfo;
}
VideoDialog.prototype.initialize = function () {
var $container = this.options.dialogsInBody ? this.$body : this.$editor;
var body = [
'<div class="form-group note-form-group row-fluid">',
"<label class=\"note-form-label\">" + this.lang.video.url + " <small class=\"text-muted\">" + this.lang.video.providers + "</small></label>",
'<input class="note-video-url form-control note-form-control note-input" type="text" />',
'</div>'
].join('');
var buttonClass = 'btn btn-primary note-btn note-btn-primary note-video-btn';
var footer = "<button type=\"submit\" href=\"#\" class=\"" + buttonClass + "\" disabled>" + this.lang.video.insert + "</button>";
this.$dialog = this.ui.dialog({
title: this.lang.video.insert,
fade: this.options.dialogsFade,
body: body,
footer: footer
}).render().appendTo($container);
};
VideoDialog.prototype.destroy = function () {
this.ui.hideDialog(this.$dialog);
this.$dialog.remove();
};
VideoDialog.prototype.bindEnterKey = function ($input, $btn) {
$input.on('keypress', function (event) {
if (event.keyCode === key.code.ENTER) {
event.preventDefault();
$btn.trigger('click');
}
});
};
VideoDialog.prototype.createVideoNode = function (url) {
var ytRegExp = /^(?:https?:\/\/)?(?:www\.)?(?:youtu\.be\/|youtube\.com\/(?:embed\/|v\/|watch\?v=|watch\?.+&v=))((\w|-){11})(?:\S+)?$/;
var ytMatch = url.match(ytRegExp);
var igRegExp = /(?:www\.|\/\/)instagram\.com\/p\/(.[a-zA-Z0-9_-]*)/;
var igMatch = url.match(igRegExp);
var vRegExp = /\/\/vine\.co\/v\/([a-zA-Z0-9]+)/;
var vMatch = url.match(vRegExp);
var vimRegExp = /\/\/(player\.)?vimeo\.com\/([a-z]*\/)*(\d+)[?]?.*/;
var vimMatch = url.match(vimRegExp);
var dmRegExp = /.+dailymotion.com\/(video|hub)\/([^_]+)[^#]*(#video=([^_&]+))?/;
var dmMatch = url.match(dmRegExp);
var youkuRegExp = /\/\/v\.youku\.com\/v_show\/id_(\w+)=*\.html/;
var youkuMatch = url.match(youkuRegExp);
var qqRegExp = /\/\/v\.qq\.com.*?vid=(.+)/;
var qqMatch = url.match(qqRegExp);
var qqRegExp2 = /\/\/v\.qq\.com\/x?\/?(page|cover).*?\/([^\/]+)\.html\??.*/;
var qqMatch2 = url.match(qqRegExp2);
var mp4RegExp = /^.+.(mp4|m4v)$/;
var mp4Match = url.match(mp4RegExp);
var oggRegExp = /^.+.(ogg|ogv)$/;
var oggMatch = url.match(oggRegExp);
var webmRegExp = /^.+.(webm)$/;
var webmMatch = url.match(webmRegExp);
var $video;
if (ytMatch && ytMatch[1].length === 11) {
var youtubeId = ytMatch[1];
$video = $$1('<iframe>')
.attr('frameborder', 0)
.attr('src', '//www.youtube.com/embed/' + youtubeId)
.attr('width', '640').attr('height', '360');
}
else if (igMatch && igMatch[0].length) {
$video = $$1('<iframe>')
.attr('frameborder', 0)
.attr('src', 'https://instagram.com/p/' + igMatch[1] + '/embed/')
.attr('width', '612').attr('height', '710')
.attr('scrolling', 'no')
.attr('allowtransparency', 'true');
}
else if (vMatch && vMatch[0].length) {
$video = $$1('<iframe>')
.attr('frameborder', 0)
.attr('src', vMatch[0] + '/embed/simple')
.attr('width', '600').attr('height', '600')
.attr('class', 'vine-embed');
}
else if (vimMatch && vimMatch[3].length) {
$video = $$1('<iframe webkitallowfullscreen mozallowfullscreen allowfullscreen>')
.attr('frameborder', 0)
.attr('src', '//player.vimeo.com/video/' + vimMatch[3])
.attr('width', '640').attr('height', '360');
}
else if (dmMatch && dmMatch[2].length) {
$video = $$1('<iframe>')
.attr('frameborder', 0)
.attr('src', '//www.dailymotion.com/embed/video/' + dmMatch[2])
.attr('width', '640').attr('height', '360');
}
else if (youkuMatch && youkuMatch[1].length) {
$video = $$1('<iframe webkitallowfullscreen mozallowfullscreen allowfullscreen>')
.attr('frameborder', 0)
.attr('height', '498')
.attr('width', '510')
.attr('src', '//player.youku.com/embed/' + youkuMatch[1]);
}
else if ((qqMatch && qqMatch[1].length) || (qqMatch2 && qqMatch2[2].length)) {
var vid = ((qqMatch && qqMatch[1].length) ? qqMatch[1] : qqMatch2[2]);
$video = $$1('<iframe webkitallowfullscreen mozallowfullscreen allowfullscreen>')
.attr('frameborder', 0)
.attr('height', '310')
.attr('width', '500')
.attr('src', 'http://v.qq.com/iframe/player.html?vid=' + vid + '&amp;auto=0');
}
else if (mp4Match || oggMatch || webmMatch) {
$video = $$1('<video controls>')
.attr('src', url)
.attr('width', '640').attr('height', '360');
}
else {
return false;
}
$video.addClass('note-video-clip');
return $video[0];
};
VideoDialog.prototype.show = function () {
var _this = this;
var text = this.context.invoke('editor.getSelectedText');
this.context.invoke('editor.saveRange');
this.showVideoDialog(text).then(function (url) {
_this.ui.hideDialog(_this.$dialog);
_this.context.invoke('editor.restoreRange');
var $node = _this.createVideoNode(url);
if ($node) {
_this.context.invoke('editor.insertNode', $node);
}
}).fail(function () {
_this.context.invoke('editor.restoreRange');
});
};
VideoDialog.prototype.showVideoDialog = function (text) {
var _this = this;
return $$1.Deferred(function (deferred) {
var $videoUrl = _this.$dialog.find('.note-video-url');
var $videoBtn = _this.$dialog.find('.note-video-btn');
_this.ui.onDialogShown(_this.$dialog, function () {
_this.context.triggerEvent('dialog.shown');
$videoUrl.val(text).on('input', function () {
_this.ui.toggleBtn($videoBtn, $videoUrl.val());
});
if (!env.isSupportTouch) {
$videoUrl.trigger('focus');
}
$videoBtn.click(function (event) {
event.preventDefault();
deferred.resolve($videoUrl.val());
});
_this.bindEnterKey($videoUrl, $videoBtn);
});
_this.ui.onDialogHidden(_this.$dialog, function () {
$videoUrl.off('input');
$videoBtn.off('click');
if (deferred.state() === 'pending') {
deferred.reject();
}
});
_this.ui.showDialog(_this.$dialog);
});
};
return VideoDialog;
}());
var HelpDialog = (function () {
function HelpDialog(context) {
this.context = context;
this.ui = $$1.summernote.ui;
this.$body = $$1(document.body);
this.$editor = context.layoutInfo.editor;
this.options = context.options;
this.lang = this.options.langInfo;
}
HelpDialog.prototype.initialize = function () {
var $container = this.options.dialogsInBody ? this.$body : this.$editor;
var body = [
'<p class="text-center">',
'<a href="http://summernote.org/" target="_blank">Summernote 0.8.9</a>  ',
'<a href="https://github.com/summernote/summernote" target="_blank">Project</a>  ',
'<a href="https://github.com/summernote/summernote/issues" target="_blank">Issues</a>',
'</p>'
].join('');
this.$dialog = this.ui.dialog({
title: this.lang.options.help,
fade: this.options.dialogsFade,
body: this.createShortcutList(),
footer: body,
callback: function ($node) {
$node.find('.modal-body,.note-modal-body').css({
'max-height': 300,
'overflow': 'scroll'
});
}
}).render().appendTo($container);
};
HelpDialog.prototype.destroy = function () {
this.ui.hideDialog(this.$dialog);
this.$dialog.remove();
};
HelpDialog.prototype.createShortcutList = function () {
var _this = this;
var keyMap = this.options.keyMap[env.isMac ? 'mac' : 'pc'];
return Object.keys(keyMap).map(function (key) {
var command = keyMap[key];
var $row = $$1('<div><div class="help-list-item"/></div>');
$row.append($$1('<label><kbd>' + key + '</kdb></label>').css({
'width': 180,
'margin-right': 10
})).append($$1('<span/>').html(_this.context.memo('help.' + command) || command));
return $row.html();
}).join('');
};
HelpDialog.prototype.showHelpDialog = function () {
var _this = this;
return $$1.Deferred(function (deferred) {
_this.ui.onDialogShown(_this.$dialog, function () {
_this.context.triggerEvent('dialog.shown');
deferred.resolve();
});
_this.ui.showDialog(_this.$dialog);
}).promise();
};
HelpDialog.prototype.show = function () {
var _this = this;
this.context.invoke('editor.saveRange');
this.showHelpDialog().then(function () {
_this.context.invoke('editor.restoreRange');
});
};
return HelpDialog;
}());
var AIR_MODE_POPOVER_X_OFFSET = 20;
var AirPopover = (function () {
function AirPopover(context) {
var _this = this;
this.context = context;
this.ui = $$1.summernote.ui;
this.options = context.options;
this.events = {
'summernote.keyup summernote.mouseup summernote.scroll': function () {
_this.update();
},
'summernote.disable summernote.change summernote.dialog.shown': function () {
_this.hide();
},
'summernote.focusout': function (we, e) {
if (env.isFF) {
return;
}
if (!e.relatedTarget || !dom.ancestor(e.relatedTarget, func.eq(_this.$popover[0]))) {
_this.hide();
}
}
};
}
AirPopover.prototype.shouldInitialize = function () {
return this.options.airMode && !lists.isEmpty(this.options.popover.air);
};
AirPopover.prototype.initialize = function () {
this.$popover = this.ui.popover({
className: 'note-air-popover'
}).render().appendTo(this.options.container);
var $content = this.$popover.find('.popover-content');
this.context.invoke('buttons.build', $content, this.options.popover.air);
};
AirPopover.prototype.destroy = function () {
this.$popover.remove();
};
AirPopover.prototype.update = function () {
var styleInfo = this.context.invoke('editor.currentStyle');
if (styleInfo.range && !styleInfo.range.isCollapsed()) {
var rect = lists.last(styleInfo.range.getClientRects());
if (rect) {
var bnd = func.rect2bnd(rect);
this.$popover.css({
display: 'block',
left: Math.max(bnd.left + bnd.width / 2, 0) - AIR_MODE_POPOVER_X_OFFSET,
top: bnd.top + bnd.height
});
this.context.invoke('buttons.updateCurrentStyle', this.$popover);
}
}
else {
this.hide();
}
};
AirPopover.prototype.hide = function () {
this.$popover.hide();
};
return AirPopover;
}());
var POPOVER_DIST = 5;
var HintPopover = (function () {
function HintPopover(context) {
var _this = this;
this.context = context;
this.ui = $$1.summernote.ui;
this.$editable = context.layoutInfo.editable;
this.options = context.options;
this.hint = this.options.hint || [];
this.direction = this.options.hintDirection || 'bottom';
this.hints = $$1.isArray(this.hint) ? this.hint : [this.hint];
this.events = {
'summernote.keyup': function (we, e) {
if (!e.isDefaultPrevented()) {
_this.handleKeyup(e);
}
},
'summernote.keydown': function (we, e) {
_this.handleKeydown(e);
},
'summernote.disable summernote.dialog.shown': function () {
_this.hide();
}
};
}
HintPopover.prototype.shouldInitialize = function () {
return this.hints.length > 0;
};
HintPopover.prototype.initialize = function () {
var _this = this;
this.lastWordRange = null;
this.$popover = this.ui.popover({
className: 'note-hint-popover',
hideArrow: true,
direction: ''
}).render().appendTo(this.options.container);
this.$popover.hide();
this.$content = this.$popover.find('.popover-content,.note-popover-content');
this.$content.on('click', '.note-hint-item', function () {
_this.$content.find('.active').removeClass('active');
$$1(_this).addClass('active');
_this.replace();
});
};
HintPopover.prototype.destroy = function () {
this.$popover.remove();
};
HintPopover.prototype.selectItem = function ($item) {
this.$content.find('.active').removeClass('active');
$item.addClass('active');
this.$content[0].scrollTop = $item[0].offsetTop - (this.$content.innerHeight() / 2);
};
HintPopover.prototype.moveDown = function () {
var $current = this.$content.find('.note-hint-item.active');
var $next = $current.next();
if ($next.length) {
this.selectItem($next);
}
else {
var $nextGroup = $current.parent().next();
if (!$nextGroup.length) {
$nextGroup = this.$content.find('.note-hint-group').first();
}
this.selectItem($nextGroup.find('.note-hint-item').first());
}
};
HintPopover.prototype.moveUp = function () {
var $current = this.$content.find('.note-hint-item.active');
var $prev = $current.prev();
if ($prev.length) {
this.selectItem($prev);
}
else {
var $prevGroup = $current.parent().prev();
if (!$prevGroup.length) {
$prevGroup = this.$content.find('.note-hint-group').last();
}
this.selectItem($prevGroup.find('.note-hint-item').last());
}
};
HintPopover.prototype.replace = function () {
var $item = this.$content.find('.note-hint-item.active');
if ($item.length) {
var node = this.nodeFromItem($item);
this.lastWordRange.insertNode(node);
range.createFromNode(node).collapse().select();
this.lastWordRange = null;
this.hide();
this.context.triggerEvent('change', this.$editable.html(), this.$editable[0]);
this.context.invoke('editor.focus');
}
};
HintPopover.prototype.nodeFromItem = function ($item) {
var hint = this.hints[$item.data('index')];
var item = $item.data('item');
var node = hint.content ? hint.content(item) : item;
if (typeof node === 'string') {
node = dom.createText(node);
}
return node;
};
HintPopover.prototype.createItemTemplates = function (hintIdx, items) {
var hint = this.hints[hintIdx];
return items.map(function (item, idx) {
var $item = $$1('<div class="note-hint-item"/>');
$item.append(hint.template ? hint.template(item) : item + '');
$item.data({
'index': hintIdx,
'item': item
});
return $item;
});
};
HintPopover.prototype.handleKeydown = function (e) {
if (!this.$popover.is(':visible')) {
return;
}
if (e.keyCode === key.code.ENTER) {
e.preventDefault();
this.replace();
}
else if (e.keyCode === key.code.UP) {
e.preventDefault();
this.moveUp();
}
else if (e.keyCode === key.code.DOWN) {
e.preventDefault();
this.moveDown();
}
};
HintPopover.prototype.searchKeyword = function (index, keyword, callback) {
var hint = this.hints[index];
if (hint && hint.match.test(keyword) && hint.search) {
var matches = hint.match.exec(keyword);
hint.search(matches[1], callback);
}
else {
callback();
}
};
HintPopover.prototype.createGroup = function (idx, keyword) {
var _this = this;
var $group = $$1('<div class="note-hint-group note-hint-group-' + idx + '"/>');
this.searchKeyword(idx, keyword, function (items) {
items = items || [];
if (items.length) {
$group.html(_this.createItemTemplates(idx, items));
_this.show();
}
});
return $group;
};
HintPopover.prototype.handleKeyup = function (e) {
var _this = this;
if (!lists.contains([key.code.ENTER, key.code.UP, key.code.DOWN], e.keyCode)) {
var wordRange = this.context.invoke('editor.createRange').getWordRange();
var keyword_1 = wordRange.toString();
if (this.hints.length && keyword_1) {
this.$content.empty();
var bnd = func.rect2bnd(lists.last(wordRange.getClientRects()));
if (bnd) {
this.$popover.hide();
this.lastWordRange = wordRange;
this.hints.forEach(function (hint, idx) {
if (hint.match.test(keyword_1)) {
_this.createGroup(idx, keyword_1).appendTo(_this.$content);
}
});
this.$content.find('.note-hint-item:first').addClass('active');
if (this.direction === 'top') {
this.$popover.css({
left: bnd.left,
top: bnd.top - this.$popover.outerHeight() - POPOVER_DIST
});
}
else {
this.$popover.css({
left: bnd.left,
top: bnd.top + bnd.height + POPOVER_DIST
});
}
}
}
else {
this.hide();
}
}
};
HintPopover.prototype.show = function () {
this.$popover.show();
};
HintPopover.prototype.hide = function () {
this.$popover.hide();
};
return HintPopover;
}());
var Context = (function () {
function Context($note, options) {
this.ui = $$1.summernote.ui;
this.$note = $note;
this.memos = {};
this.modules = {};
this.layoutInfo = {};
this.options = options;
this.initialize();
}
Context.prototype.initialize = function () {
this.layoutInfo = this.ui.createLayout(this.$note, this.options);
this._initialize();
this.$note.hide();
return this;
};
Context.prototype.destroy = function () {
this._destroy();
this.$note.removeData('summernote');
this.ui.removeLayout(this.$note, this.layoutInfo);
};
Context.prototype.reset = function () {
var disabled = this.isDisabled();
this.code(dom.emptyPara);
this._destroy();
this._initialize();
if (disabled) {
this.disable();
}
};
Context.prototype._initialize = function () {
var _this = this;
var buttons = $$1.extend({}, this.options.buttons);
Object.keys(buttons).forEach(function (key) {
_this.memo('button.' + key, buttons[key]);
});
var modules = $$1.extend({}, this.options.modules, $$1.summernote.plugins || {});
Object.keys(modules).forEach(function (key) {
_this.module(key, modules[key], true);
});
Object.keys(this.modules).forEach(function (key) {
_this.initializeModule(key);
});
};
Context.prototype._destroy = function () {
var _this = this;
Object.keys(this.modules).reverse().forEach(function (key) {
_this.removeModule(key);
});
Object.keys(this.memos).forEach(function (key) {
_this.removeMemo(key);
});
this.triggerEvent('destroy', this);
};
Context.prototype.code = function (html) {
var isActivated = this.invoke('codeview.isActivated');
if (html === undefined) {
this.invoke('codeview.sync');
return isActivated ? this.layoutInfo.codable.val() : this.layoutInfo.editable.html();
}
else {
if (isActivated) {
this.layoutInfo.codable.val(html);
}
else {
this.layoutInfo.editable.html(html);
}
this.$note.val(html);
this.triggerEvent('change', html);
}
};
Context.prototype.isDisabled = function () {
return this.layoutInfo.editable.attr('contenteditable') === 'false';
};
Context.prototype.enable = function () {
this.layoutInfo.editable.attr('contenteditable', true);
this.invoke('toolbar.activate', true);
this.triggerEvent('disable', false);
};
Context.prototype.disable = function () {
if (this.invoke('codeview.isActivated')) {
this.invoke('codeview.deactivate');
}
this.layoutInfo.editable.attr('contenteditable', false);
this.invoke('toolbar.deactivate', true);
this.triggerEvent('disable', true);
};
Context.prototype.triggerEvent = function () {
var namespace = lists.head(arguments);
var args = lists.tail(lists.from(arguments));
var callback = this.options.callbacks[func.namespaceToCamel(namespace, 'on')];
if (callback) {
callback.apply(this.$note[0], args);
}
this.$note.trigger('summernote.' + namespace, args);
};
Context.prototype.initializeModule = function (key) {
var module = this.modules[key];
module.shouldInitialize = module.shouldInitialize || func.ok;
if (!module.shouldInitialize()) {
return;
}
if (module.initialize) {
module.initialize();
}
if (module.events) {
dom.attachEvents(this.$note, module.events);
}
};
Context.prototype.module = function (key, ModuleClass, withoutIntialize) {
if (arguments.length === 1) {
return this.modules[key];
}
this.modules[key] = new ModuleClass(this);
if (!withoutIntialize) {
this.initializeModule(key);
}
};
Context.prototype.removeModule = function (key) {
var module = this.modules[key];
if (module.shouldInitialize()) {
if (module.events) {
dom.detachEvents(this.$note, module.events);
}
if (module.destroy) {
module.destroy();
}
}
delete this.modules[key];
};
Context.prototype.memo = function (key, obj) {
if (arguments.length === 1) {
return this.memos[key];
}
this.memos[key] = obj;
};
Context.prototype.removeMemo = function (key) {
if (this.memos[key] && this.memos[key].destroy) {
this.memos[key].destroy();
}
delete this.memos[key];
};
Context.prototype.createInvokeHandlerAndUpdateState = function (namespace, value) {
var _this = this;
return function (event) {
_this.createInvokeHandler(namespace, value)(event);
_this.invoke('buttons.updateCurrentStyle');
};
};
Context.prototype.createInvokeHandler = function (namespace, value) {
var _this = this;
return function (event) {
event.preventDefault();
var $target = $$1(event.target);
_this.invoke(namespace, value || $target.closest('[data-value]').data('value'), $target);
};
};
Context.prototype.invoke = function () {
var namespace = lists.head(arguments);
var args = lists.tail(lists.from(arguments));
var splits = namespace.split('.');
var hasSeparator = splits.length > 1;
var moduleName = hasSeparator && lists.head(splits);
var methodName = hasSeparator ? lists.last(splits) : lists.head(splits);
var module = this.modules[moduleName || 'editor'];
if (!moduleName && this[methodName]) {
return this[methodName].apply(this, args);
}
else if (module && module[methodName] && module.shouldInitialize()) {
return module[methodName].apply(module, args);
}
};
return Context;
}());
$$1.fn.extend({
summernote: function () {
var type = $$1.type(lists.head(arguments));
var isExternalAPICalled = type === 'string';
var hasInitOptions = type === 'object';
var options = $$1.extend({}, $$1.summernote.options, hasInitOptions ? lists.head(arguments) : {});
options.langInfo = $$1.extend(true, {}, $$1.summernote.lang['en-US'], $$1.summernote.lang[options.lang]);
options.icons = $$1.extend(true, {}, $$1.summernote.options.icons, options.icons);
options.tooltip = options.tooltip === 'auto' ? !env.isSupportTouch : options.tooltip;
this.each(function (idx, note) {
var $note = $$1(note);
if (!$note.data('summernote')) {
var context = new Context($note, options);
$note.data('summernote', context);
$note.data('summernote').triggerEvent('init', context.layoutInfo);
}
});
var $note = this.first();
if ($note.length) {
var context = $note.data('summernote');
if (isExternalAPICalled) {
return context.invoke.apply(context, lists.from(arguments));
}
else if (options.focus) {
context.invoke('editor.focus');
}
}
return this;
}
});
$$1.summernote = $$1.extend($$1.summernote, {
version: '0.8.9',
ui: ui,
dom: dom,
plugins: {},
options: {
modules: {
'editor': Editor,
'clipboard': Clipboard,
'dropzone': Dropzone,
'codeview': CodeView,
'statusbar': Statusbar,
'fullscreen': Fullscreen,
'handle': Handle,
'hintPopover': HintPopover,
'autoLink': AutoLink,
'autoSync': AutoSync,
'placeholder': Placeholder,
'buttons': Buttons,
'toolbar': Toolbar,
'linkDialog': LinkDialog,
'linkPopover': LinkPopover,
'imageDialog': ImageDialog,
'imagePopover': ImagePopover,
'tablePopover': TablePopover,
'videoDialog': VideoDialog,
'helpDialog': HelpDialog,
'airPopover': AirPopover
},
buttons: {},
lang: 'en-US',
followingToolbar: true,
otherStaticBar: '',
toolbar: [
['style', ['style']],
['font', ['bold', 'underline', 'clear']],
['fontname', ['fontname']],
['color', ['color']],
['para', ['ul', 'ol', 'paragraph']],
['table', ['table']],
['insert', ['link', 'picture', 'video']],
['view', ['fullscreen', 'codeview', 'help']]
],
popatmouse: true,
popover: {
image: [
['imagesize', ['imageSize100', 'imageSize50', 'imageSize25']],
['float', ['floatLeft', 'floatRight', 'floatNone']],
['remove', ['removeMedia']]
],
link: [
['link', ['linkDialogShow', 'unlink']]
],
table: [
['add', ['addRowDown', 'addRowUp', 'addColLeft', 'addColRight']],
['delete', ['deleteRow', 'deleteCol', 'deleteTable']]
],
air: [
['color', ['color']],
['font', ['bold', 'underline', 'clear']],
['para', ['ul', 'paragraph']],
['table', ['table']],
['insert', ['link', 'picture']]
]
},
airMode: false,
width: null,
height: null,
linkTargetBlank: true,
focus: false,
tabSize: 4,
styleWithSpan: true,
shortcuts: true,
textareaAutoSync: true,
hintDirection: 'bottom',
tooltip: 'auto',
container: 'body',
maxTextLength: 0,
styleTags: ['p', 'blockquote', 'pre', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6'],
fontNames: [
'Arial', 'Arial Black', 'Comic Sans MS', 'Courier New',
'Helvetica Neue', 'Helvetica', 'Impact', 'Lucida Grande',
'Tahoma', 'Times New Roman', 'Verdana'
],
fontSizes: ['8', '9', '10', '11', '12', '14', '18', '24', '36'],
colors: [
['#000000', '#424242', '#636363', '#9C9C94', '#CEC6CE', '#EFEFEF', '#F7F7F7', '#FFFFFF'],
['#FF0000', '#FF9C00', '#FFFF00', '#00FF00', '#00FFFF', '#0000FF', '#9C00FF', '#FF00FF'],
['#F7C6CE', '#FFE7CE', '#FFEFC6', '#D6EFD6', '#CEDEE7', '#CEE7F7', '#D6D6E7', '#E7D6DE'],
['#E79C9C', '#FFC69C', '#FFE79C', '#B5D6A5', '#A5C6CE', '#9CC6EF', '#B5A5D6', '#D6A5BD'],
['#E76363', '#F7AD6B', '#FFD663', '#94BD7B', '#73A5AD', '#6BADDE', '#8C7BC6', '#C67BA5'],
['#CE0000', '#E79439', '#EFC631', '#6BA54A', '#4A7B8C', '#3984C6', '#634AA5', '#A54A7B'],
['#9C0000', '#B56308', '#BD9400', '#397B21', '#104A5A', '#085294', '#311873', '#731842'],
['#630000', '#7B3900', '#846300', '#295218', '#083139', '#003163', '#21104A', '#4A1031']
],
lineHeights: ['1.0', '1.2', '1.4', '1.5', '1.6', '1.8', '2.0', '3.0'],
tableClassName: 'table table-bordered',
insertTableMaxSize: {
col: 10,
row: 10
},
dialogsInBody: false,
dialogsFade: false,
maximumImageFileSize: null,
callbacks: {
onInit: null,
onFocus: null,
onBlur: null,
onBlurCodeview: null,
onEnter: null,
onKeyup: null,
onKeydown: null,
onImageUpload: null,
onImageUploadError: null
},
codemirror: {
mode: 'text/html',
htmlMode: true,
lineNumbers: true
},
keyMap: {
pc: {
'ENTER': 'insertParagraph',
'CTRL+Z': 'undo',
'CTRL+Y': 'redo',
'TAB': 'tab',
'SHIFT+TAB': 'untab',
'CTRL+B': 'bold',
'CTRL+I': 'italic',
'CTRL+U': 'underline',
'CTRL+SHIFT+S': 'strikethrough',
'CTRL+BACKSLASH': 'removeFormat',
'CTRL+SHIFT+L': 'justifyLeft',
'CTRL+SHIFT+E': 'justifyCenter',
'CTRL+SHIFT+R': 'justifyRight',
'CTRL+SHIFT+J': 'justifyFull',
'CTRL+SHIFT+NUM7': 'insertUnorderedList',
'CTRL+SHIFT+NUM8': 'insertOrderedList',
'CTRL+LEFTBRACKET': 'outdent',
'CTRL+RIGHTBRACKET': 'indent',
'CTRL+NUM0': 'formatPara',
'CTRL+NUM1': 'formatH1',
'CTRL+NUM2': 'formatH2',
'CTRL+NUM3': 'formatH3',
'CTRL+NUM4': 'formatH4',
'CTRL+NUM5': 'formatH5',
'CTRL+NUM6': 'formatH6',
'CTRL+ENTER': 'insertHorizontalRule',
'CTRL+K': 'linkDialog.show'
},
mac: {
'ENTER': 'insertParagraph',
'CMD+Z': 'undo',
'CMD+SHIFT+Z': 'redo',
'TAB': 'tab',
'SHIFT+TAB': 'untab',
'CMD+B': 'bold',
'CMD+I': 'italic',
'CMD+U': 'underline',
'CMD+SHIFT+S': 'strikethrough',
'CMD+BACKSLASH': 'removeFormat',
'CMD+SHIFT+L': 'justifyLeft',
'CMD+SHIFT+E': 'justifyCenter',
'CMD+SHIFT+R': 'justifyRight',
'CMD+SHIFT+J': 'justifyFull',
'CMD+SHIFT+NUM7': 'insertUnorderedList',
'CMD+SHIFT+NUM8': 'insertOrderedList',
'CMD+LEFTBRACKET': 'outdent',
'CMD+RIGHTBRACKET': 'indent',
'CMD+NUM0': 'formatPara',
'CMD+NUM1': 'formatH1',
'CMD+NUM2': 'formatH2',
'CMD+NUM3': 'formatH3',
'CMD+NUM4': 'formatH4',
'CMD+NUM5': 'formatH5',
'CMD+NUM6': 'formatH6',
'CMD+ENTER': 'insertHorizontalRule',
'CMD+K': 'linkDialog.show'
}
},
icons: {
'align': 'note-icon-align',
'alignCenter': 'note-icon-align-center',
'alignJustify': 'note-icon-align-justify',
'alignLeft': 'note-icon-align-left',
'alignRight': 'note-icon-align-right',
'rowBelow': 'note-icon-row-below',
'colBefore': 'note-icon-col-before',
'colAfter': 'note-icon-col-after',
'rowAbove': 'note-icon-row-above',
'rowRemove': 'note-icon-row-remove',
'colRemove': 'note-icon-col-remove',
'indent': 'note-icon-align-indent',
'outdent': 'note-icon-align-outdent',
'arrowsAlt': 'note-icon-arrows-alt',
'bold': 'note-icon-bold',
'caret': 'note-icon-caret',
'circle': 'note-icon-circle',
'close': 'note-icon-close',
'code': 'note-icon-code',
'eraser': 'note-icon-eraser',
'font': 'note-icon-font',
'frame': 'note-icon-frame',
'italic': 'note-icon-italic',
'link': 'note-icon-link',
'unlink': 'note-icon-chain-broken',
'magic': 'note-icon-magic',
'menuCheck': 'note-icon-menu-check',
'minus': 'note-icon-minus',
'orderedlist': 'note-icon-orderedlist',
'pencil': 'note-icon-pencil',
'picture': 'note-icon-picture',
'question': 'note-icon-question',
'redo': 'note-icon-redo',
'square': 'note-icon-square',
'strikethrough': 'note-icon-strikethrough',
'subscript': 'note-icon-subscript',
'superscript': 'note-icon-superscript',
'table': 'note-icon-table',
'textHeight': 'note-icon-text-height',
'trash': 'note-icon-trash',
'underline': 'note-icon-underline',
'undo': 'note-icon-undo',
'unorderedlist': 'note-icon-unorderedlist',
'video': 'note-icon-video'
}
}
});
})));
(function( expose ) {
var Markdown = expose.Markdown = function(dialect) {
switch (typeof dialect) {
case "undefined":
this.dialect = Markdown.dialects.Gruber;
break;
case "object":
this.dialect = dialect;
break;
default:
if ( dialect in Markdown.dialects ) {
this.dialect = Markdown.dialects[dialect];
}
else {
throw new Error("Unknown Markdown dialect '" + String(dialect) + "'");
}
break;
}
this.em_state = [];
this.strong_state = [];
this.debug_indent = "";
};
expose.parse = function( source, dialect ) {
var md = new Markdown( dialect );
return md.toTree( source );
};
expose.toHTML = function toHTML( source , dialect , options ) {
var input = expose.toHTMLTree( source , dialect , options );
return expose.renderJsonML( input );
};
expose.toHTMLTree = function toHTMLTree( input, dialect , options ) {
if ( typeof input ==="string" ) input = this.parse( input, dialect );
var attrs = extract_attr( input ),
refs = {};
if ( attrs && attrs.references ) {
refs = attrs.references;
}
var html = convert_tree_to_html( input, refs , options );
merge_text_nodes( html );
return html;
};
function mk_block_toSource() {
return "Markdown.mk_block( " +
uneval(this.toString()) +
", " +
uneval(this.trailing) +
", " +
uneval(this.lineNumber) +
" )";
}
function mk_block_inspect() {
var util = require("util");
return "Markdown.mk_block( " +
util.inspect(this.toString()) +
", " +
util.inspect(this.trailing) +
", " +
util.inspect(this.lineNumber) +
" )";
}
var mk_block = Markdown.mk_block = function(block, trail, line) {
if ( arguments.length == 1 ) trail = "\n\n";
var s = new String(block);
s.trailing = trail;
s.inspect = mk_block_inspect;
s.toSource = mk_block_toSource;
if ( line != undefined )
s.lineNumber = line;
return s;
};
function count_lines( str ) {
var n = 0, i = -1;
while ( ( i = str.indexOf("\n", i + 1) ) !== -1 ) n++;
return n;
}
Markdown.prototype.split_blocks = function splitBlocks( input, startLine ) {
input = input.replace(/(\r\n|\n|\r)/g, "\n");
var re = /([\s\S]+?)($|\n#|\n(?:\s*\n|$)+)/g,
blocks = [],
m;
var line_no = 1;
if ( ( m = /^(\s*\n)/.exec(input) ) != null ) {
line_no += count_lines( m[0] );
re.lastIndex = m[0].length;
}
while ( ( m = re.exec(input) ) !== null ) {
if (m[2] == "\n#") {
m[2] = "\n";
re.lastIndex--;
}
blocks.push( mk_block( m[1], m[2], line_no ) );
line_no += count_lines( m[0] );
}
return blocks;
};
Markdown.prototype.processBlock = function processBlock( block, next ) {
var cbs = this.dialect.block,
ord = cbs.__order__;
if ( "__call__" in cbs ) {
return cbs.__call__.call(this, block, next);
}
for ( var i = 0; i < ord.length; i++ ) {
var res = cbs[ ord[i] ].call( this, block, next );
if ( res ) {
if ( !isArray(res) || ( res.length > 0 && !( isArray(res[0]) ) ) )
this.debug(ord[i], "didn't return a proper array");
return res;
}
}
return [];
};
Markdown.prototype.processInline = function processInline( block ) {
return this.dialect.inline.__call__.call( this, String( block ) );
};
Markdown.prototype.toTree = function toTree( source, custom_root ) {
var blocks = source instanceof Array ? source : this.split_blocks( source );
var old_tree = this.tree;
try {
this.tree = custom_root || this.tree || [ "markdown" ];
blocks:
while ( blocks.length ) {
var b = this.processBlock( blocks.shift(), blocks );
if ( !b.length ) continue blocks;
this.tree.push.apply( this.tree, b );
}
return this.tree;
}
finally {
if ( custom_root ) {
this.tree = old_tree;
}
}
};
Markdown.prototype.debug = function () {
var args = Array.prototype.slice.call( arguments);
args.unshift(this.debug_indent);
if ( typeof print !== "undefined" )
print.apply( print, args );
if ( typeof console !== "undefined" && typeof console.log !== "undefined" )
console.log.apply( null, args );
}
Markdown.prototype.loop_re_over_block = function( re, block, cb ) {
var m,
b = block.valueOf();
while ( b.length && (m = re.exec(b) ) != null ) {
b = b.substr( m[0].length );
cb.call(this, m);
}
return b;
};
Markdown.dialects = {};
Markdown.dialects.Gruber = {
block: {
atxHeader: function atxHeader( block, next ) {
var m = block.match( /^(#{1,6})\s*(.*?)\s*#*\s*(?:\n|$)/ );
if ( !m ) return undefined;
var header = [ "header", { level: m[ 1 ].length } ];
Array.prototype.push.apply(header, this.processInline(m[ 2 ]));
if ( m[0].length < block.length )
next.unshift( mk_block( block.substr( m[0].length ), block.trailing, block.lineNumber + 2 ) );
return [ header ];
},
setextHeader: function setextHeader( block, next ) {
var m = block.match( /^(.*)\n([-=])\2\2+(?:\n|$)/ );
if ( !m ) return undefined;
var level = ( m[ 2 ] === "=" ) ? 1 : 2;
var header = [ "header", { level : level }, m[ 1 ] ];
if ( m[0].length < block.length )
next.unshift( mk_block( block.substr( m[0].length ), block.trailing, block.lineNumber + 2 ) );
return [ header ];
},
code: function code( block, next ) {
var ret = [],
re = /^(?: {0,3}\t| {4})(.*)\n?/,
lines;
if ( !block.match( re ) ) return undefined;
block_search:
do {
var b = this.loop_re_over_block(
re, block.valueOf(), function( m ) { ret.push( m[1] ); } );
if ( b.length ) {
next.unshift( mk_block(b, block.trailing) );
break block_search;
}
else if ( next.length ) {
if ( !next[0].match( re ) ) break block_search;
ret.push ( block.trailing.replace(/[^\n]/g, "").substring(2) );
block = next.shift();
}
else {
break block_search;
}
} while ( true );
return [ [ "code_block", ret.join("\n") ] ];
},
horizRule: function horizRule( block, next ) {
var m = block.match( /^(?:([\s\S]*?)\n)?[ \t]*([-_*])(?:[ \t]*\2){2,}[ \t]*(?:\n([\s\S]*))?$/ );
if ( !m ) {
return undefined;
}
var jsonml = [ [ "hr" ] ];
if ( m[ 1 ] ) {
jsonml.unshift.apply( jsonml, this.processBlock( m[ 1 ], [] ) );
}
if ( m[ 3 ] ) {
next.unshift( mk_block( m[ 3 ] ) );
}
return jsonml;
},
lists: (function( ) {
var any_list = "[*+-]|\\d+\\.",
bullet_list = /[*+-]/,
number_list = /\d+\./,
is_list_re = new RegExp( "^( {0,3})(" + any_list + ")[ \t]+" ),
indent_re = "(?: {0,3}\\t| {4})";
function regex_for_depth( depth ) {
return new RegExp(
"(?:^(" + indent_re + "{0," + depth + "} {0,3})(" + any_list + ")\\s+)|" +
"(^" + indent_re + "{0," + (depth-1) + "}[ ]{0,4})"
);
}
function expand_tab( input ) {
return input.replace( / {0,3}\t/g, "    " );
}
function add(li, loose, inline, nl) {
if ( loose ) {
li.push( [ "para" ].concat(inline) );
return;
}
var add_to = li[li.length -1] instanceof Array && li[li.length - 1][0] == "para"
? li[li.length -1]
: li;
if ( nl && li.length > 1 ) inline.unshift(nl);
for ( var i = 0; i < inline.length; i++ ) {
var what = inline[i],
is_str = typeof what == "string";
if ( is_str && add_to.length > 1 && typeof add_to[add_to.length-1] == "string" ) {
add_to[ add_to.length-1 ] += what;
}
else {
add_to.push( what );
}
}
}
function get_contained_blocks( depth, blocks ) {
var re = new RegExp( "^(" + indent_re + "{" + depth + "}.*?\\n?)*$" ),
replace = new RegExp("^" + indent_re + "{" + depth + "}", "gm"),
ret = [];
while ( blocks.length > 0 ) {
if ( re.exec( blocks[0] ) ) {
var b = blocks.shift(),
x = b.replace( replace, "");
ret.push( mk_block( x, b.trailing, b.lineNumber ) );
}
else {
break;
}
}
return ret;
}
function paragraphify(s, i, stack) {
var list = s.list;
var last_li = list[list.length-1];
if ( last_li[1] instanceof Array && last_li[1][0] == "para" ) {
return;
}
if ( i + 1 == stack.length ) {
last_li.push( ["para"].concat( last_li.splice(1, last_li.length - 1) ) );
}
else {
var sublist = last_li.pop();
last_li.push( ["para"].concat( last_li.splice(1, last_li.length - 1) ), sublist );
}
}
return function( block, next ) {
var m = block.match( is_list_re );
if ( !m ) return undefined;
function make_list( m ) {
var list = bullet_list.exec( m[2] )
? ["bulletlist"]
: ["numberlist"];
stack.push( { list: list, indent: m[1] } );
return list;
}
var stack = [], // Stack of lists for nesting.
list = make_list( m ),
last_li,
loose = false,
ret = [ stack[0].list ],
i;
loose_search:
while ( true ) {
var lines = block.split( /(?=\n)/ );
var li_accumulate = "";
tight_search:
for ( var line_no = 0; line_no < lines.length; line_no++ ) {
var nl = "",
l = lines[line_no].replace(/^\n/, function(n) { nl = n; return ""; });
var line_re = regex_for_depth( stack.length );
m = l.match( line_re );
if ( m[1] !== undefined ) {
if ( li_accumulate.length ) {
add( last_li, loose, this.processInline( li_accumulate ), nl );
loose = false;
li_accumulate = "";
}
m[1] = expand_tab( m[1] );
var wanted_depth = Math.floor(m[1].length/4)+1;
if ( wanted_depth > stack.length ) {
list = make_list( m );
last_li.push( list );
last_li = list[1] = [ "listitem" ];
}
else {
var found = false;
for ( i = 0; i < stack.length; i++ ) {
if ( stack[ i ].indent != m[1] ) continue;
list = stack[ i ].list;
stack.splice( i+1, stack.length - (i+1) );
found = true;
break;
}
if (!found) {
wanted_depth++;
if ( wanted_depth <= stack.length ) {
stack.splice(wanted_depth, stack.length - wanted_depth);
list = stack[wanted_depth-1].list;
}
else {
list = make_list(m);
last_li.push(list);
}
}
last_li = [ "listitem" ];
list.push(last_li);
} // end depth of shenegains
nl = "";
}
if ( l.length > m[0].length ) {
li_accumulate += nl + l.substr( m[0].length );
}
} // tight_search
if ( li_accumulate.length ) {
add( last_li, loose, this.processInline( li_accumulate ), nl );
loose = false;
li_accumulate = "";
}
var contained = get_contained_blocks( stack.length, next );
if ( contained.length > 0 ) {
forEach( stack, paragraphify, this);
last_li.push.apply( last_li, this.toTree( contained, [] ) );
}
var next_block = next[0] && next[0].valueOf() || "";
if ( next_block.match(is_list_re) || next_block.match( /^ / ) ) {
block = next.shift();
var hr = this.dialect.block.horizRule( block, next );
if ( hr ) {
ret.push.apply(ret, hr);
break;
}
forEach( stack, paragraphify, this);
loose = true;
continue loose_search;
}
break;
} // loose_search
return ret;
};
})(),
blockquote: function blockquote( block, next ) {
if ( !block.match( /^>/m ) )
return undefined;
var jsonml = [];
if ( block[ 0 ] != ">" ) {
var lines = block.split( /\n/ ),
prev = [],
line_no = block.lineNumber;
while ( lines.length && lines[ 0 ][ 0 ] != ">" ) {
prev.push( lines.shift() );
line_no++;
}
var abutting = mk_block( prev.join( "\n" ), "\n", block.lineNumber );
jsonml.push.apply( jsonml, this.processBlock( abutting, [] ) );
block = mk_block( lines.join( "\n" ), block.trailing, line_no );
}
while ( next.length && next[ 0 ][ 0 ] == ">" ) {
var b = next.shift();
block = mk_block( block + block.trailing + b, b.trailing, block.lineNumber );
}
var input = block.replace( /^> ?/gm, "" ),
old_tree = this.tree,
processedBlock = this.toTree( input, [ "blockquote" ] ),
attr = extract_attr( processedBlock );
if ( attr && attr.references ) {
delete attr.references;
if ( isEmpty( attr ) ) {
processedBlock.splice( 1, 1 );
}
}
jsonml.push( processedBlock );
return jsonml;
},
referenceDefn: function referenceDefn( block, next) {
var re = /^\s*\[(.*?)\]:\s*(\S+)(?:\s+(?:(['"])(.*?)\3|\((.*?)\)))?\n?/;
if ( !block.match(re) )
return undefined;
if ( !extract_attr( this.tree ) ) {
this.tree.splice( 1, 0, {} );
}
var attrs = extract_attr( this.tree );
if ( attrs.references === undefined ) {
attrs.references = {};
}
var b = this.loop_re_over_block(re, block, function( m ) {
if ( m[2] && m[2][0] == "<" && m[2][m[2].length-1] == ">" )
m[2] = m[2].substring( 1, m[2].length - 1 );
var ref = attrs.references[ m[1].toLowerCase() ] = {
href: m[2]
};
if ( m[4] !== undefined )
ref.title = m[4];
else if ( m[5] !== undefined )
ref.title = m[5];
} );
if ( b.length )
next.unshift( mk_block( b, block.trailing ) );
return [];
},
para: function para( block, next ) {
return [ ["para"].concat( this.processInline( block ) ) ];
}
}
};
Markdown.dialects.Gruber.inline = {
__oneElement__: function oneElement( text, patterns_or_re, previous_nodes ) {
var m,
res,
lastIndex = 0;
patterns_or_re = patterns_or_re || this.dialect.inline.__patterns__;
var re = new RegExp( "([\\s\\S]*?)(" + (patterns_or_re.source || patterns_or_re) + ")" );
m = re.exec( text );
if (!m) {
return [ text.length, text ];
}
else if ( m[1] ) {
return [ m[1].length, m[1] ];
}
var res;
if ( m[2] in this.dialect.inline ) {
res = this.dialect.inline[ m[2] ].call(
this,
text.substr( m.index ), m, previous_nodes || [] );
}
res = res || [ m[2].length, m[2] ];
return res;
},
__call__: function inline( text, patterns ) {
var out = [],
res;
function add(x) {
if ( typeof x == "string" && typeof out[out.length-1] == "string" )
out[ out.length-1 ] += x;
else
out.push(x);
}
while ( text.length > 0 ) {
res = this.dialect.inline.__oneElement__.call(this, text, patterns, out );
text = text.substr( res.shift() );
forEach(res, add )
}
return out;
},
"]": function () {},
"}": function () {},
__escape__ : /^\\[\\`\*_{}\[\]()#\+.!\-]/,
"\\": function escaped( text ) {
if ( this.dialect.inline.__escape__.exec( text ) )
return [ 2, text.charAt( 1 ) ];
else
return [ 1, "\\" ];
},
"![": function image( text ) {
var m = text.match( /^!\[(.*?)\][ \t]*\([ \t]*([^")]*?)(?:[ \t]+(["'])(.*?)\3)?[ \t]*\)/ );
if ( m ) {
if ( m[2] && m[2][0] == "<" && m[2][m[2].length-1] == ">" )
m[2] = m[2].substring( 1, m[2].length - 1 );
m[2] = this.dialect.inline.__call__.call( this, m[2], /\\/ )[0];
var attrs = { alt: m[1], href: m[2] || "" };
if ( m[4] !== undefined)
attrs.title = m[4];
return [ m[0].length, [ "img", attrs ] ];
}
m = text.match( /^!\[(.*?)\][ \t]*\[(.*?)\]/ );
if ( m ) {
return [ m[0].length, [ "img_ref", { alt: m[1], ref: m[2].toLowerCase(), original: m[0] } ] ];
}
return [ 2, "![" ];
},
"[": function link( text ) {
var orig = String(text);
var res = Markdown.DialectHelpers.inline_until_char.call( this, text.substr(1), "]" );
if ( !res ) return [ 1, "[" ];
var consumed = 1 + res[ 0 ],
children = res[ 1 ],
link,
attrs;
text = text.substr( consumed );
var m = text.match( /^\s*\([ \t]*([^"']*)(?:[ \t]+(["'])(.*?)\2)?[ \t]*\)/ );
if ( m ) {
var url = m[1];
consumed += m[0].length;
if ( url && url[0] == "<" && url[url.length-1] == ">" )
url = url.substring( 1, url.length - 1 );
if ( !m[3] ) {
var open_parens = 1; // One open that isn't in the capture
for ( var len = 0; len < url.length; len++ ) {
switch ( url[len] ) {
case "(":
open_parens++;
break;
case ")":
if ( --open_parens == 0) {
consumed -= url.length - len;
url = url.substring(0, len);
}
break;
}
}
}
url = this.dialect.inline.__call__.call( this, url, /\\/ )[0];
attrs = { href: url || "" };
if ( m[3] !== undefined)
attrs.title = m[3];
link = [ "link", attrs ].concat( children );
return [ consumed, link ];
}
m = text.match( /^\s*\[(.*?)\]/ );
if ( m ) {
consumed += m[ 0 ].length;
attrs = { ref: ( m[ 1 ] || String(children) ).toLowerCase(),  original: orig.substr( 0, consumed ) };
link = [ "link_ref", attrs ].concat( children );
return [ consumed, link ];
}
if ( children.length == 1 && typeof children[0] == "string" ) {
attrs = { ref: children[0].toLowerCase(),  original: orig.substr( 0, consumed ) };
link = [ "link_ref", attrs, children[0] ];
return [ consumed, link ];
}
return [ 1, "[" ];
},
"<": function autoLink( text ) {
var m;
if ( ( m = text.match( /^<(?:((https?|ftp|mailto):[^>]+)|(.*?@.*?\.[a-zA-Z]+))>/ ) ) != null ) {
if ( m[3] ) {
return [ m[0].length, [ "link", { href: "mailto:" + m[3] }, m[3] ] ];
}
else if ( m[2] == "mailto" ) {
return [ m[0].length, [ "link", { href: m[1] }, m[1].substr("mailto:".length ) ] ];
}
else
return [ m[0].length, [ "link", { href: m[1] }, m[1] ] ];
}
return [ 1, "<" ];
},
"`": function inlineCode( text ) {
var m = text.match( /(`+)(([\s\S]*?)\1)/ );
if ( m && m[2] )
return [ m[1].length + m[2].length, [ "inlinecode", m[3] ] ];
else {
return [ 1, "`" ];
}
},
"  \n": function lineBreak( text ) {
return [ 3, [ "linebreak" ] ];
}
};
function strong_em( tag, md ) {
var state_slot = tag + "_state",
other_slot = tag == "strong" ? "em_state" : "strong_state";
function CloseTag(len) {
this.len_after = len;
this.name = "close_" + md;
}
return function ( text, orig_match ) {
if ( this[state_slot][0] == md ) {
this[state_slot].shift();
return[ text.length, new CloseTag(text.length-md.length) ];
}
else {
var other = this[other_slot].slice(),
state = this[state_slot].slice();
this[state_slot].unshift(md);
var res = this.processInline( text.substr( md.length ) );
var last = res[res.length - 1];
var check = this[state_slot].shift();
if ( last instanceof CloseTag ) {
res.pop();
var consumed = text.length - last.len_after;
return [ consumed, [ tag ].concat(res) ];
}
else {
this[other_slot] = other;
this[state_slot] = state;
return [ md.length, md ];
}
}
}; // End returned function
}
Markdown.dialects.Gruber.inline["**"] = strong_em("strong", "**");
Markdown.dialects.Gruber.inline["__"] = strong_em("strong", "__");
Markdown.dialects.Gruber.inline["*"]  = strong_em("em", "*");
Markdown.dialects.Gruber.inline["_"]  = strong_em("em", "_");
Markdown.buildBlockOrder = function(d) {
var ord = [];
for ( var i in d ) {
if ( i == "__order__" || i == "__call__" ) continue;
ord.push( i );
}
d.__order__ = ord;
};
Markdown.buildInlinePatterns = function(d) {
var patterns = [];
for ( var i in d ) {
if ( i.match( /^__.*__$/) ) continue;
var l = i.replace( /([\\.*+?|()\[\]{}])/g, "\\$1" )
.replace( /\n/, "\\n" );
patterns.push( i.length == 1 ? l : "(?:" + l + ")" );
}
patterns = patterns.join("|");
d.__patterns__ = patterns;
var fn = d.__call__;
d.__call__ = function(text, pattern) {
if ( pattern != undefined ) {
return fn.call(this, text, pattern);
}
else
{
return fn.call(this, text, patterns);
}
};
};
Markdown.DialectHelpers = {};
Markdown.DialectHelpers.inline_until_char = function( text, want ) {
var consumed = 0,
nodes = [];
while ( true ) {
if ( text.charAt( consumed ) == want ) {
consumed++;
return [ consumed, nodes ];
}
if ( consumed >= text.length ) {
return null;
}
var res = this.dialect.inline.__oneElement__.call(this, text.substr( consumed ) );
consumed += res[ 0 ];
nodes.push.apply( nodes, res.slice( 1 ) );
}
}
Markdown.subclassDialect = function( d ) {
function Block() {}
Block.prototype = d.block;
function Inline() {}
Inline.prototype = d.inline;
return { block: new Block(), inline: new Inline() };
};
Markdown.buildBlockOrder ( Markdown.dialects.Gruber.block );
Markdown.buildInlinePatterns( Markdown.dialects.Gruber.inline );
Markdown.dialects.Maruku = Markdown.subclassDialect( Markdown.dialects.Gruber );
Markdown.dialects.Maruku.processMetaHash = function processMetaHash( meta_string ) {
var meta = split_meta_hash( meta_string ),
attr = {};
for ( var i = 0; i < meta.length; ++i ) {
if ( /^#/.test( meta[ i ] ) ) {
attr.id = meta[ i ].substring( 1 );
}
else if ( /^\./.test( meta[ i ] ) ) {
if ( attr["class"] ) {
attr["class"] = attr["class"] + meta[ i ].replace( /./, " " );
}
else {
attr["class"] = meta[ i ].substring( 1 );
}
}
else if ( /\=/.test( meta[ i ] ) ) {
var s = meta[ i ].split( /\=/ );
attr[ s[ 0 ] ] = s[ 1 ];
}
}
return attr;
}
function split_meta_hash( meta_string ) {
var meta = meta_string.split( "" ),
parts = [ "" ],
in_quotes = false;
while ( meta.length ) {
var letter = meta.shift();
switch ( letter ) {
case " " :
if ( in_quotes ) {
parts[ parts.length - 1 ] += letter;
}
else {
parts.push( "" );
}
break;
case "'" :
case '"' :
in_quotes = !in_quotes;
break;
case "\\" :
letter = meta.shift();
default :
parts[ parts.length - 1 ] += letter;
break;
}
}
return parts;
}
Markdown.dialects.Maruku.block.document_meta = function document_meta( block, next ) {
if ( block.lineNumber > 1 ) return undefined;
if ( ! block.match( /^(?:\w+:.*\n)*\w+:.*$/ ) ) return undefined;
if ( !extract_attr( this.tree ) ) {
this.tree.splice( 1, 0, {} );
}
var pairs = block.split( /\n/ );
for ( p in pairs ) {
var m = pairs[ p ].match( /(\w+):\s*(.*)$/ ),
key = m[ 1 ].toLowerCase(),
value = m[ 2 ];
this.tree[ 1 ][ key ] = value;
}
return [];
};
Markdown.dialects.Maruku.block.block_meta = function block_meta( block, next ) {
var m = block.match( /(^|\n) {0,3}\{:\s*((?:\\\}|[^\}])*)\s*\}$/ );
if ( !m ) return undefined;
var attr = this.dialect.processMetaHash( m[ 2 ] );
var hash;
if ( m[ 1 ] === "" ) {
var node = this.tree[ this.tree.length - 1 ];
hash = extract_attr( node );
if ( typeof node === "string" ) return undefined;
if ( !hash ) {
hash = {};
node.splice( 1, 0, hash );
}
for ( a in attr ) {
hash[ a ] = attr[ a ];
}
return [];
}
var b = block.replace( /\n.*$/, "" ),
result = this.processBlock( b, [] );
hash = extract_attr( result[ 0 ] );
if ( !hash ) {
hash = {};
result[ 0 ].splice( 1, 0, hash );
}
for ( a in attr ) {
hash[ a ] = attr[ a ];
}
return result;
};
Markdown.dialects.Maruku.block.definition_list = function definition_list( block, next ) {
var tight = /^((?:[^\s:].*\n)+):\s+([\s\S]+)$/,
list = [ "dl" ],
i, m;
if ( ( m = block.match( tight ) ) ) {
var blocks = [ block ];
while ( next.length && tight.exec( next[ 0 ] ) ) {
blocks.push( next.shift() );
}
for ( var b = 0; b < blocks.length; ++b ) {
var m = blocks[ b ].match( tight ),
terms = m[ 1 ].replace( /\n$/, "" ).split( /\n/ ),
defns = m[ 2 ].split( /\n:\s+/ );
for ( i = 0; i < terms.length; ++i ) {
list.push( [ "dt", terms[ i ] ] );
}
for ( i = 0; i < defns.length; ++i ) {
list.push( [ "dd" ].concat( this.processInline( defns[ i ].replace( /(\n)\s+/, "$1" ) ) ) );
}
}
}
else {
return undefined;
}
return [ list ];
};
Markdown.dialects.Maruku.block.table = function table (block, next) {
var _split_on_unescaped = function(s, ch) {
ch = ch || '\\s';
if (ch.match(/^[\\|\[\]{}?*.+^$]$/)) { ch = '\\' + ch; }
var res = [ ],
r = new RegExp('^((?:\\\\.|[^\\\\' + ch + '])*)' + ch + '(.*)'),
m;
while(m = s.match(r)) {
res.push(m[1]);
s = m[2];
}
res.push(s);
return res;
}
var leading_pipe = /^ {0,3}\|(.+)\n {0,3}\|\s*([\-:]+[\-| :]*)\n((?:\s*\|.*(?:\n|$))*)(?=\n|$)/,
no_leading_pipe = /^ {0,3}(\S(?:\\.|[^\\|])*\|.*)\n {0,3}([\-:]+\s*\|[\-| :]*)\n((?:(?:\\.|[^\\|])*\|.*(?:\n|$))*)(?=\n|$)/,
i, m;
if (m = block.match(leading_pipe)) {
m[3] = m[3].replace(/^\s*\|/gm, '');
} else if (! ( m = block.match(no_leading_pipe))) {
return undefined;
}
var table = [ "table", [ "thead", [ "tr" ] ], [ "tbody" ] ];
m[2] = m[2].replace(/\|\s*$/, '').split('|');
var html_attrs = [ ];
forEach (m[2], function (s) {
if (s.match(/^\s*-+:\s*$/))       html_attrs.push({align: "right"});
else if (s.match(/^\s*:-+\s*$/))  html_attrs.push({align: "left"});
else if (s.match(/^\s*:-+:\s*$/)) html_attrs.push({align: "center"});
else                              html_attrs.push({});
});
m[1] = _split_on_unescaped(m[1].replace(/\|\s*$/, ''), '|');
for (i = 0; i < m[1].length; i++) {
table[1][1].push(['th', html_attrs[i] || {}].concat(
this.processInline(m[1][i].trim())));
}
forEach (m[3].replace(/\|\s*$/mg, '').split('\n'), function (row) {
var html_row = ['tr'];
row = _split_on_unescaped(row, '|');
for (i = 0; i < row.length; i++) {
html_row.push(['td', html_attrs[i] || {}].concat(this.processInline(row[i].trim())));
}
table[2].push(html_row);
}, this);
return [table];
}
Markdown.dialects.Maruku.inline[ "{:" ] = function inline_meta( text, matches, out ) {
if ( !out.length ) {
return [ 2, "{:" ];
}
var before = out[ out.length - 1 ];
if ( typeof before === "string" ) {
return [ 2, "{:" ];
}
var m = text.match( /^\{:\s*((?:\\\}|[^\}])*)\s*\}/ );
if ( !m ) {
return [ 2, "{:" ];
}
var meta = this.dialect.processMetaHash( m[ 1 ] ),
attr = extract_attr( before );
if ( !attr ) {
attr = {};
before.splice( 1, 0, attr );
}
for ( var k in meta ) {
attr[ k ] = meta[ k ];
}
return [ m[ 0 ].length, "" ];
};
Markdown.dialects.Maruku.inline.__escape__ = /^\\[\\`\*_{}\[\]()#\+.!\-|:]/;
Markdown.buildBlockOrder ( Markdown.dialects.Maruku.block );
Markdown.buildInlinePatterns( Markdown.dialects.Maruku.inline );
var isArray = Array.isArray || function(obj) {
return Object.prototype.toString.call(obj) == "[object Array]";
};
var forEach;
if ( Array.prototype.forEach ) {
forEach = function( arr, cb, thisp ) {
return arr.forEach( cb, thisp );
};
}
else {
forEach = function(arr, cb, thisp) {
for (var i = 0; i < arr.length; i++) {
cb.call(thisp || arr, arr[i], i, arr);
}
}
}
var isEmpty = function( obj ) {
for ( var key in obj ) {
if ( hasOwnProperty.call( obj, key ) ) {
return false;
}
}
return true;
}
function extract_attr( jsonml ) {
return isArray(jsonml)
&& jsonml.length > 1
&& typeof jsonml[ 1 ] === "object"
&& !( isArray(jsonml[ 1 ]) )
? jsonml[ 1 ]
: undefined;
}
expose.renderJsonML = function( jsonml, options ) {
options = options || {};
options.root = options.root || false;
var content = [];
if ( options.root ) {
content.push( render_tree( jsonml ) );
}
else {
jsonml.shift(); // get rid of the tag
if ( jsonml.length && typeof jsonml[ 0 ] === "object" && !( jsonml[ 0 ] instanceof Array ) ) {
jsonml.shift(); // get rid of the attributes
}
while ( jsonml.length ) {
content.push( render_tree( jsonml.shift() ) );
}
}
return content.join( "\n\n" );
};
function escapeHTML( text ) {
return text.replace( /&/g, "&amp;" )
.replace( /</g, "&lt;" )
.replace( />/g, "&gt;" )
.replace( /"/g, "&quot;" )
.replace( /'/g, "&#39;" );
}
function render_tree( jsonml ) {
if ( typeof jsonml === "string" ) {
return escapeHTML( jsonml );
}
var tag = jsonml.shift(),
attributes = {},
content = [];
if ( jsonml.length && typeof jsonml[ 0 ] === "object" && !( jsonml[ 0 ] instanceof Array ) ) {
attributes = jsonml.shift();
}
while ( jsonml.length ) {
content.push( render_tree( jsonml.shift() ) );
}
var tag_attrs = "";
for ( var a in attributes ) {
tag_attrs += " " + a + '="' + escapeHTML( attributes[ a ] ) + '"';
}
if ( tag == "img" || tag == "br" || tag == "hr" ) {
return "<"+ tag + tag_attrs + "/>";
}
else {
return "<"+ tag + tag_attrs + ">" + content.join( "" ) + "</" + tag + ">";
}
}
function convert_tree_to_html( tree, references, options ) {
var i;
options = options || {};
var jsonml = tree.slice( 0 );
if ( typeof options.preprocessTreeNode === "function" ) {
jsonml = options.preprocessTreeNode(jsonml, references);
}
var attrs = extract_attr( jsonml );
if ( attrs ) {
jsonml[ 1 ] = {};
for ( i in attrs ) {
jsonml[ 1 ][ i ] = attrs[ i ];
}
attrs = jsonml[ 1 ];
}
if ( typeof jsonml === "string" ) {
return jsonml;
}
switch ( jsonml[ 0 ] ) {
case "header":
jsonml[ 0 ] = "h" + jsonml[ 1 ].level;
delete jsonml[ 1 ].level;
break;
case "bulletlist":
jsonml[ 0 ] = "ul";
break;
case "numberlist":
jsonml[ 0 ] = "ol";
break;
case "listitem":
jsonml[ 0 ] = "li";
break;
case "para":
jsonml[ 0 ] = "p";
break;
case "markdown":
jsonml[ 0 ] = "html";
if ( attrs ) delete attrs.references;
break;
case "code_block":
jsonml[ 0 ] = "pre";
i = attrs ? 2 : 1;
var code = [ "code" ];
code.push.apply( code, jsonml.splice( i, jsonml.length - i ) );
jsonml[ i ] = code;
break;
case "inlinecode":
jsonml[ 0 ] = "code";
break;
case "img":
jsonml[ 1 ].src = jsonml[ 1 ].href;
delete jsonml[ 1 ].href;
break;
case "linebreak":
jsonml[ 0 ] = "br";
break;
case "link":
jsonml[ 0 ] = "a";
break;
case "link_ref":
jsonml[ 0 ] = "a";
var ref = references[ attrs.ref ];
if ( ref ) {
delete attrs.ref;
attrs.href = ref.href;
if ( ref.title ) {
attrs.title = ref.title;
}
delete attrs.original;
}
else {
return attrs.original;
}
break;
case "img_ref":
jsonml[ 0 ] = "img";
var ref = references[ attrs.ref ];
if ( ref ) {
delete attrs.ref;
attrs.src = ref.href;
if ( ref.title ) {
attrs.title = ref.title;
}
delete attrs.original;
}
else {
return attrs.original;
}
break;
}
i = 1;
if ( attrs ) {
for ( var key in jsonml[ 1 ] ) {
i = 2;
break;
}
if ( i === 1 ) {
jsonml.splice( i, 1 );
}
}
for ( ; i < jsonml.length; ++i ) {
jsonml[ i ] = convert_tree_to_html( jsonml[ i ], references, options );
}
return jsonml;
}
function merge_text_nodes( jsonml ) {
var i = extract_attr( jsonml ) ? 2 : 1;
while ( i < jsonml.length ) {
if ( typeof jsonml[ i ] === "string" ) {
if ( i + 1 < jsonml.length && typeof jsonml[ i + 1 ] === "string" ) {
jsonml[ i ] += jsonml.splice( i + 1, 1 )[ 0 ];
}
else {
++i;
}
}
else {
merge_text_nodes( jsonml[ i ] );
++i;
}
}
}
} )( (function() {
if ( typeof exports === "undefined" ) {
window.markdown = {};
return window.markdown;
}
else {
return exports;
}
} )() );
(function(factory){
if (typeof define === "function" && define.amd) {
define(["jquery"], factory);
} else if (typeof exports === 'object') {
factory(require('jquery'));
} else {
factory(jQuery);
}
}(function($){
"use strict"; // jshint ;_;
var Markdown = function (element, options) {
var opts = ['autofocus', 'savable', 'hideable', 'width',
'height', 'resize', 'iconlibrary', 'language',
'footer', 'fullscreen', 'hiddenButtons', 'disabledButtons'];
$.each(opts,function(_, opt){
if (typeof $(element).data(opt) !== 'undefined') {
options = typeof options == 'object' ? options : {}
options[opt] = $(element).data(opt)
}
});
this.$ns           = 'bootstrap-markdown';
this.$element      = $(element);
this.$editable     = {el:null, type:null,attrKeys:[], attrValues:[], content:null};
this.$options      = $.extend(true, {}, $.fn.markdown.defaults, options, this.$element.data('options'));
this.$oldContent   = null;
this.$isPreview    = false;
this.$isFullscreen = false;
this.$editor       = null;
this.$textarea     = null;
this.$handler      = [];
this.$callback     = [];
this.$nextTab      = [];
this.showEditor();
};
Markdown.prototype = {
constructor: Markdown
, __alterButtons: function(name,alter) {
var handler = this.$handler, isAll = (name == 'all'),that = this;
$.each(handler,function(k,v) {
var halt = true;
if (isAll) {
halt = false;
} else {
halt = v.indexOf(name) < 0;
}
if (halt === false) {
alter(that.$editor.find('button[data-handler="'+v+'"]'));
}
});
}
, __buildButtons: function(buttonsArray, container) {
var i,
ns = this.$ns,
handler = this.$handler,
callback = this.$callback;
for (i=0;i<buttonsArray.length;i++) {
var y, btnGroups = buttonsArray[i];
for (y=0;y<btnGroups.length;y++) {
var z,
buttons = btnGroups[y].data,
btnGroupContainer = $('<div/>', {
'class': 'btn-group'
});
for (z=0;z<buttons.length;z++) {
var button = buttons[z],
buttonContainer, buttonIconContainer,
buttonHandler = ns+'-'+button.name,
buttonIcon = this.__getIcon(button.icon),
btnText = button.btnText ? button.btnText : '',
btnClass = button.btnClass ? button.btnClass : 'btn',
tabIndex = button.tabIndex ? button.tabIndex : '-1',
hotkey = typeof button.hotkey !== 'undefined' ? button.hotkey : '',
hotkeyCaption = typeof jQuery.hotkeys !== 'undefined' && hotkey !== '' ? ' ('+hotkey+')' : '';
buttonContainer = $('<button></button>');
buttonContainer.text(' ' + this.__localize(btnText)).addClass('btn-default btn-sm').addClass(btnClass);
if(btnClass.match(/btn\-(primary|success|info|warning|danger|link)/)){
buttonContainer.removeClass('btn-default');
}
buttonContainer.attr({
'type': 'button',
'title': this.__localize(button.title) + hotkeyCaption,
'tabindex': tabIndex,
'data-provider': ns,
'data-handler': buttonHandler,
'data-hotkey': hotkey
});
if (button.toggle === true){
buttonContainer.attr('data-toggle', 'button');
}
buttonIconContainer = $('<span/>');
buttonIconContainer.addClass(buttonIcon);
buttonIconContainer.prependTo(buttonContainer);
btnGroupContainer.append(buttonContainer);
handler.push(buttonHandler);
callback.push(button.callback);
}
container.append(btnGroupContainer);
}
}
return container;
}
, __setListener: function() {
var hasRows = typeof this.$textarea.attr('rows') !== 'undefined',
maxRows = this.$textarea.val().split("\n").length > 5 ? this.$textarea.val().split("\n").length : '5',
rowsVal = hasRows ? this.$textarea.attr('rows') : maxRows;
this.$textarea.attr('rows',rowsVal);
if (this.$options.resize) {
this.$textarea.css('resize',this.$options.resize);
}
this.$textarea.on({
'focus' : $.proxy(this.focus, this),
'keyup' : $.proxy(this.keyup, this),
'change' : $.proxy(this.change, this),
'select' : $.proxy(this.select, this)
});
if (this.eventSupported('keydown')) {
this.$textarea.on('keydown', $.proxy(this.keydown, this));
}
if (this.eventSupported('keypress')) {
this.$textarea.on('keypress', $.proxy(this.keypress, this))
}
this.$textarea.data('markdown',this);
}
, __handle: function(e) {
var target = $(e.currentTarget),
handler = this.$handler,
callback = this.$callback,
handlerName = target.attr('data-handler'),
callbackIndex = handler.indexOf(handlerName),
callbackHandler = callback[callbackIndex];
$(e.currentTarget).focus();
callbackHandler(this);
this.change(this);
if (handlerName.indexOf('cmdSave') < 0) {
this.$textarea.focus();
}
e.preventDefault();
}
, __localize: function(string) {
var messages = $.fn.markdown.messages,
language = this.$options.language;
if (
typeof messages !== 'undefined' &&
typeof messages[language] !== 'undefined' &&
typeof messages[language][string] !== 'undefined'
) {
return messages[language][string];
}
return string;
}
, __getIcon: function(src) {
return typeof src == 'object' ? src[this.$options.iconlibrary] : src;
}
, setFullscreen: function(mode) {
var $editor = this.$editor,
$textarea = this.$textarea;
if (mode === true) {
$editor.addClass('md-fullscreen-mode');
$('body').addClass('md-nooverflow');
this.$options.onFullscreen(this);
} else {
$editor.removeClass('md-fullscreen-mode');
$('body').removeClass('md-nooverflow');
if (this.$isPreview == true) this.hidePreview().showPreview()
}
this.$isFullscreen = mode;
$textarea.focus();
}
, showEditor: function() {
var instance = this,
textarea,
ns = this.$ns,
container = this.$element,
originalHeigth = container.css('height'),
originalWidth = container.css('width'),
editable = this.$editable,
handler = this.$handler,
callback = this.$callback,
options = this.$options,
editor = $( '<div/>', {
'class': 'md-editor',
click: function() {
instance.focus();
}
});
if (this.$editor === null) {
var editorHeader = $('<div/>', {
'class': 'md-header btn-toolbar'
});
var allBtnGroups = [];
if (options.buttons.length > 0) allBtnGroups = allBtnGroups.concat(options.buttons[0]);
if (options.additionalButtons.length > 0) {
$.each(options.additionalButtons[0], function(idx, buttonGroup){
var matchingGroups = $.grep(allBtnGroups, function(allButtonGroup, allIdx){
return allButtonGroup.name === buttonGroup.name;
});
if(matchingGroups.length > 0) {
matchingGroups[0].data = matchingGroups[0].data.concat(buttonGroup.data);
} else {
allBtnGroups.push(options.additionalButtons[0][idx]);
}
});
}
if (options.reorderButtonGroups.length > 0) {
allBtnGroups = allBtnGroups
.filter(function(btnGroup) {
return options.reorderButtonGroups.indexOf(btnGroup.name) > -1;
})
.sort(function(a, b) {
if (options.reorderButtonGroups.indexOf(a.name) < options.reorderButtonGroups.indexOf(b.name)) return -1;
if (options.reorderButtonGroups.indexOf(a.name) > options.reorderButtonGroups.indexOf(b.name)) return 1;
return 0;
});
}
if (allBtnGroups.length > 0) {
editorHeader = this.__buildButtons([allBtnGroups], editorHeader);
}
if (options.fullscreen.enable) {
editorHeader.append('<div class="md-controls"><a class="md-control md-control-fullscreen" href="#"><span class="'+this.__getIcon(options.fullscreen.icons.fullscreenOn)+'"></span></a></div>').on('click', '.md-control-fullscreen', function(e) {
e.preventDefault();
instance.setFullscreen(true);
});
}
editor.append(editorHeader);
if (container.is('textarea')) {
container.before(editor);
textarea = container;
textarea.addClass('md-input');
editor.append(textarea);
} else {
var rawContent = (typeof toMarkdown == 'function') ? toMarkdown(container.html()) : container.html(),
currentContent = $.trim(rawContent);
textarea = $('<textarea/>', {
'class': 'md-input',
'val' : currentContent
});
editor.append(textarea);
editable.el = container;
editable.type = container.prop('tagName').toLowerCase();
editable.content = container.html();
$(container[0].attributes).each(function(){
editable.attrKeys.push(this.nodeName);
editable.attrValues.push(this.nodeValue);
});
container.replaceWith(editor);
}
var editorFooter = $('<div/>', {
'class': 'md-footer'
}),
createFooter = false,
footer = '';
if (options.savable) {
createFooter = true;
var saveHandler = 'cmdSave';
handler.push(saveHandler);
callback.push(options.onSave);
editorFooter.append('<button class="btn btn-success" data-provider="'
+ ns
+ '" data-handler="'
+ saveHandler
+ '"><i class="icon icon-white icon-ok"></i> '
+ this.__localize('Save')
+ '</button>');
}
footer = typeof options.footer === 'function' ? options.footer(this) : options.footer;
if ($.trim(footer) !== '') {
createFooter = true;
editorFooter.append(footer);
}
if (createFooter) editor.append(editorFooter);
if (options.width && options.width !== 'inherit') {
if (jQuery.isNumeric(options.width)) {
editor.css('display', 'table');
textarea.css('width', options.width + 'px');
} else {
editor.addClass(options.width);
}
}
if (options.height && options.height !== 'inherit') {
if (jQuery.isNumeric(options.height)) {
var height = options.height;
if (editorHeader) height = Math.max(0, height - editorHeader.outerHeight());
if (editorFooter) height = Math.max(0, height - editorFooter.outerHeight());
textarea.css('height', height + 'px');
} else {
editor.addClass(options.height);
}
}
this.$editor     = editor;
this.$textarea   = textarea;
this.$editable   = editable;
this.$oldContent = this.getContent();
this.__setListener();
this.$editor.attr('id',(new Date()).getTime());
this.$editor.on('click', '[data-provider="bootstrap-markdown"]', $.proxy(this.__handle, this));
if (this.$element.is(':disabled') || this.$element.is('[readonly]')) {
this.$editor.addClass('md-editor-disabled');
this.disableButtons('all');
}
if (this.eventSupported('keydown') && typeof jQuery.hotkeys === 'object') {
editorHeader.find('[data-provider="bootstrap-markdown"]').each(function() {
var $button = $(this),
hotkey = $button.attr('data-hotkey');
if (hotkey.toLowerCase() !== '') {
textarea.bind('keydown', hotkey, function() {
$button.trigger('click');
return false;
});
}
});
}
if (options.initialstate === 'preview') {
this.showPreview();
} else if (options.initialstate === 'fullscreen' && options.fullscreen.enable) {
this.setFullscreen(true);
}
} else {
this.$editor.show();
}
if (options.autofocus) {
this.$textarea.focus();
this.$editor.addClass('active');
}
if (options.fullscreen.enable && options.fullscreen !== false) {
this.$editor.append('<div class="md-fullscreen-controls">'
+ '<a href="#" class="exit-fullscreen" title="Exit fullscreen"><span class="' + this.__getIcon(options.fullscreen.icons.fullscreenOff) + '">'
+ '</span></a>'
+ '</div>');
this.$editor.on('click', '.exit-fullscreen', function(e) {
e.preventDefault();
instance.setFullscreen(false);
});
}
this.hideButtons(options.hiddenButtons);
this.disableButtons(options.disabledButtons);
options.onShow(this);
return this;
}
, parseContent: function(val) {
var content;
var val = val || this.$textarea.val();
if (this.$options.parser) {
content = this.$options.parser(val);
} else if (typeof markdown == 'object') {
content = markdown.toHTML(val);
} else if (typeof marked == 'function') {
content = marked(val);
} else {
content = val;
}
return content;
}
, showPreview: function() {
var options = this.$options,
container = this.$textarea,
afterContainer = container.next(),
replacementContainer = $('<div/>',{'class':'md-preview','data-provider':'markdown-preview'}),
content,
callbackContent;
if (this.$isPreview == true) {
return this;
}
this.$isPreview = true;
this.disableButtons('all').enableButtons('cmdPreview');
callbackContent = options.onPreview(this);
content = typeof callbackContent == 'string' ? callbackContent : this.parseContent();
replacementContainer.html(content);
if (afterContainer && afterContainer.attr('class') == 'md-footer') {
replacementContainer.insertBefore(afterContainer);
} else {
container.parent().append(replacementContainer);
}
replacementContainer.css({
width: container.outerWidth() + 'px',
height: container.outerHeight() + 'px'
});
if (this.$options.resize) {
replacementContainer.css('resize',this.$options.resize);
}
container.hide();
replacementContainer.data('markdown',this);
if (this.$element.is(':disabled') || this.$element.is('[readonly]')) {
this.$editor.addClass('md-editor-disabled');
this.disableButtons('all');
}
return this;
}
, hidePreview: function() {
this.$isPreview = false;
var container = this.$editor.find('div[data-provider="markdown-preview"]');
container.remove();
this.enableButtons('all');
this.disableButtons(this.$options.disabledButtons);
this.$textarea.show();
this.__setListener();
return this;
}
, isDirty: function() {
return this.$oldContent != this.getContent();
}
, getContent: function() {
return this.$textarea.val();
}
, setContent: function(content) {
this.$textarea.val(content);
return this;
}
, findSelection: function(chunk) {
var content = this.getContent(), startChunkPosition;
if (startChunkPosition = content.indexOf(chunk), startChunkPosition >= 0 && chunk.length > 0) {
var oldSelection = this.getSelection(), selection;
this.setSelection(startChunkPosition,startChunkPosition+chunk.length);
selection = this.getSelection();
this.setSelection(oldSelection.start,oldSelection.end);
return selection;
} else {
return null;
}
}
, getSelection: function() {
var e = this.$textarea[0];
return (
('selectionStart' in e && function() {
var l = e.selectionEnd - e.selectionStart;
return { start: e.selectionStart, end: e.selectionEnd, length: l, text: e.value.substr(e.selectionStart, l) };
}) ||
function() {
return null;
}
)();
}
, setSelection: function(start,end) {
var e = this.$textarea[0];
return (
('selectionStart' in e && function() {
e.selectionStart = start;
e.selectionEnd = end;
return;
}) ||
function() {
return null;
}
)();
}
, replaceSelection: function(text) {
var e = this.$textarea[0];
return (
('selectionStart' in e && function() {
e.value = e.value.substr(0, e.selectionStart) + text + e.value.substr(e.selectionEnd, e.value.length);
e.selectionStart = e.value.length;
return this;
}) ||
function() {
e.value += text;
return jQuery(e);
}
)();
}
, getNextTab: function() {
if (this.$nextTab.length === 0) {
return null;
} else {
var nextTab, tab = this.$nextTab.shift();
if (typeof tab == 'function') {
nextTab = tab();
} else if (typeof tab == 'object' && tab.length > 0) {
nextTab = tab;
}
return nextTab;
}
}
, setNextTab: function(start,end) {
if (typeof start == 'string') {
var that = this;
this.$nextTab.push(function(){
return that.findSelection(start);
});
} else if (typeof start == 'number' && typeof end == 'number') {
var oldSelection = this.getSelection();
this.setSelection(start,end);
this.$nextTab.push(this.getSelection());
this.setSelection(oldSelection.start,oldSelection.end);
}
return;
}
, __parseButtonNameParam: function (names) {
return typeof names == 'string' ?
names.split(' ') :
names;
}
, enableButtons: function(name) {
var buttons = this.__parseButtonNameParam(name),
that = this;
$.each(buttons, function(i, v) {
that.__alterButtons(buttons[i], function (el) {
el.removeAttr('disabled');
});
});
return this;
}
, disableButtons: function(name) {
var buttons = this.__parseButtonNameParam(name),
that = this;
$.each(buttons, function(i, v) {
that.__alterButtons(buttons[i], function (el) {
el.attr('disabled','disabled');
});
});
return this;
}
, hideButtons: function(name) {
var buttons = this.__parseButtonNameParam(name),
that = this;
$.each(buttons, function(i, v) {
that.__alterButtons(buttons[i], function (el) {
el.addClass('hidden');
});
});
return this;
}
, showButtons: function(name) {
var buttons = this.__parseButtonNameParam(name),
that = this;
$.each(buttons, function(i, v) {
that.__alterButtons(buttons[i], function (el) {
el.removeClass('hidden');
});
});
return this;
}
, eventSupported: function(eventName) {
var isSupported = eventName in this.$element;
if (!isSupported) {
this.$element.setAttribute(eventName, 'return;');
isSupported = typeof this.$element[eventName] === 'function';
}
return isSupported;
}
, keyup: function (e) {
var blocked = false;
switch(e.keyCode) {
case 40: // down arrow
case 38: // up arrow
case 16: // shift
case 17: // ctrl
case 18: // alt
break;
case 9: // tab
var nextTab;
if (nextTab = this.getNextTab(),nextTab !== null) {
var that = this;
setTimeout(function(){
that.setSelection(nextTab.start,nextTab.end);
},500);
blocked = true;
} else {
var cursor = this.getSelection();
if (cursor.start == cursor.end && cursor.end == this.getContent().length) {
blocked = false;
} else {
this.setSelection(this.getContent().length,this.getContent().length);
blocked = true;
}
}
break;
case 13: // enter
blocked = false;
break;
case 27: // escape
if (this.$isFullscreen) this.setFullscreen(false);
blocked = false;
break;
default:
blocked = false;
}
if (blocked) {
e.stopPropagation();
e.preventDefault();
}
this.$options.onChange(this);
}
, change: function(e) {
this.$options.onChange(this);
return this;
}
, select: function (e) {
this.$options.onSelect(this);
return this;
}
, focus: function (e) {
var options = this.$options,
isHideable = options.hideable,
editor = this.$editor;
editor.addClass('active');
$(document).find('.md-editor').each(function(){
if ($(this).attr('id') !== editor.attr('id')) {
var attachedMarkdown;
if (attachedMarkdown = $(this).find('textarea').data('markdown'),
attachedMarkdown === null) {
attachedMarkdown = $(this).find('div[data-provider="markdown-preview"]').data('markdown');
}
if (attachedMarkdown) {
attachedMarkdown.blur();
}
}
});
options.onFocus(this);
return this;
}
, blur: function (e) {
var options = this.$options,
isHideable = options.hideable,
editor = this.$editor,
editable = this.$editable;
if (editor.hasClass('active') || this.$element.parent().length === 0) {
editor.removeClass('active');
if (isHideable) {
if (editable.el !== null) {
var oldElement = $('<'+editable.type+'/>'),
content = this.getContent(),
currentContent = this.parseContent(content);
$(editable.attrKeys).each(function(k,v) {
oldElement.attr(editable.attrKeys[k],editable.attrValues[k]);
});
oldElement.html(currentContent);
editor.replaceWith(oldElement);
} else {
editor.hide();
}
}
options.onBlur(this);
}
return this;
}
};
var old = $.fn.markdown;
$.fn.markdown = function (option) {
return this.each(function () {
var $this = $(this)
, data = $this.data('markdown')
, options = typeof option == 'object' && option;
if (!data) $this.data('markdown', (data = new Markdown(this, options)))
})
};
$.fn.markdown.messages = {};
$.fn.markdown.defaults = {
autofocus: false,
hideable: false,
savable: false,
width: 'inherit',
height: 'inherit',
resize: 'none',
iconlibrary: 'glyph',
language: 'en',
initialstate: 'editor',
parser: null,
buttons: [
[{
name: 'groupFont',
data: [{
name: 'cmdBold',
hotkey: 'Ctrl+B',
title: 'Bold',
icon: { glyph: 'glyphicon glyphicon-bold', fa: 'fa fa-bold', 'fa-3': 'icon-bold' },
callback: function(e){
var chunk, cursor, selected = e.getSelection(), content = e.getContent();
if (selected.length === 0) {
chunk = e.__localize('strong text');
} else {
chunk = selected.text;
}
if (content.substr(selected.start-2,2) === '**'
&& content.substr(selected.end,2) === '**' ) {
e.setSelection(selected.start-2,selected.end+2);
e.replaceSelection(chunk);
cursor = selected.start-2;
} else {
e.replaceSelection('**'+chunk+'**');
cursor = selected.start+2;
}
e.setSelection(cursor,cursor+chunk.length);
}
},{
name: 'cmdItalic',
title: 'Italic',
hotkey: 'Ctrl+I',
icon: { glyph: 'glyphicon glyphicon-italic', fa: 'fa fa-italic', 'fa-3': 'icon-italic' },
callback: function(e){
var chunk, cursor, selected = e.getSelection(), content = e.getContent();
if (selected.length === 0) {
chunk = e.__localize('emphasized text');
} else {
chunk = selected.text;
}
if (content.substr(selected.start-1,1) === '_'
&& content.substr(selected.end,1) === '_' ) {
e.setSelection(selected.start-1,selected.end+1);
e.replaceSelection(chunk);
cursor = selected.start-1;
} else {
e.replaceSelection('_'+chunk+'_');
cursor = selected.start+1;
}
e.setSelection(cursor,cursor+chunk.length);
}
},{
name: 'cmdHeading',
title: 'Heading',
hotkey: 'Ctrl+H',
icon: { glyph: 'glyphicon glyphicon-header', fa: 'fa fa-header', 'fa-3': 'icon-font' },
callback: function(e){
var chunk, cursor, selected = e.getSelection(), content = e.getContent(), pointer, prevChar;
if (selected.length === 0) {
chunk = e.__localize('heading text');
} else {
chunk = selected.text + '\n';
}
if ((pointer = 4, content.substr(selected.start-pointer,pointer) === '### ')
|| (pointer = 3, content.substr(selected.start-pointer,pointer) === '###')) {
e.setSelection(selected.start-pointer,selected.end);
e.replaceSelection(chunk);
cursor = selected.start-pointer;
} else if (selected.start > 0 && (prevChar = content.substr(selected.start-1,1), !!prevChar && prevChar != '\n')) {
e.replaceSelection('\n\n### '+chunk);
cursor = selected.start+6;
} else {
e.replaceSelection('### '+chunk);
cursor = selected.start+4;
}
e.setSelection(cursor,cursor+chunk.length);
}
}]
},{
name: 'groupLink',
data: [{
name: 'cmdUrl',
title: 'URL/Link',
hotkey: 'Ctrl+L',
icon: { glyph: 'glyphicon glyphicon-link', fa: 'fa fa-link', 'fa-3': 'icon-link' },
callback: function(e){
var chunk, cursor, selected = e.getSelection(), content = e.getContent(), link;
if (selected.length === 0) {
chunk = e.__localize('enter link description here');
} else {
chunk = selected.text;
}
link = prompt(e.__localize('Insert Hyperlink'),'http://');
var urlRegex = new RegExp('^((http|https)://|(mailto:)|(//))[a-z0-9]', 'i');
if (link !== null && link !== '' && link !== 'http://' && urlRegex.test(link)) {
var sanitizedLink = $('<div>'+link+'</div>').text();
e.replaceSelection('['+chunk+']('+sanitizedLink+')');
cursor = selected.start+1;
e.setSelection(cursor,cursor+chunk.length);
}
}
},{
name: 'cmdImage',
title: 'Image',
hotkey: 'Ctrl+G',
icon: { glyph: 'glyphicon glyphicon-picture', fa: 'fa fa-picture-o', 'fa-3': 'icon-picture' },
callback: function(e){
var chunk, cursor, selected = e.getSelection(), content = e.getContent(), link;
if (selected.length === 0) {
chunk = e.__localize('enter image description here');
} else {
chunk = selected.text;
}
link = prompt(e.__localize('Insert Image Hyperlink'),'http://');
var urlRegex = new RegExp('^((http|https)://|(//))[a-z0-9]', 'i');
if (link !== null && link !== '' && link !== 'http://' && urlRegex.test(link)) {
var sanitizedLink = $('<div>'+link+'</div>').text();
e.replaceSelection('!['+chunk+']('+sanitizedLink+' "'+e.__localize('enter image title here')+'")');
cursor = selected.start+2;
e.setNextTab(e.__localize('enter image title here'));
e.setSelection(cursor,cursor+chunk.length);
}
}
}]
},{
name: 'groupMisc',
data: [{
name: 'cmdList',
hotkey: 'Ctrl+U',
title: 'Unordered List',
icon: { glyph: 'glyphicon glyphicon-list', fa: 'fa fa-list', 'fa-3': 'icon-list-ul' },
callback: function(e){
var chunk, cursor, selected = e.getSelection(), content = e.getContent();
if (selected.length === 0) {
chunk = e.__localize('list text here');
e.replaceSelection('- '+chunk);
cursor = selected.start+2;
} else {
if (selected.text.indexOf('\n') < 0) {
chunk = selected.text;
e.replaceSelection('- '+chunk);
cursor = selected.start+2;
} else {
var list = [];
list = selected.text.split('\n');
chunk = list[0];
$.each(list,function(k,v) {
list[k] = '- '+v;
});
e.replaceSelection('\n\n'+list.join('\n'));
cursor = selected.start+4;
}
}
e.setSelection(cursor,cursor+chunk.length);
}
},
{
name: 'cmdListO',
hotkey: 'Ctrl+O',
title: 'Ordered List',
icon: { glyph: 'glyphicon glyphicon-th-list', fa: 'fa fa-list-ol', 'fa-3': 'icon-list-ol' },
callback: function(e) {
var chunk, cursor, selected = e.getSelection(), content = e.getContent();
if (selected.length === 0) {
chunk = e.__localize('list text here');
e.replaceSelection('1. '+chunk);
cursor = selected.start+3;
} else {
if (selected.text.indexOf('\n') < 0) {
chunk = selected.text;
e.replaceSelection('1. '+chunk);
cursor = selected.start+3;
} else {
var list = [];
list = selected.text.split('\n');
chunk = list[0];
$.each(list,function(k,v) {
list[k] = '1. '+v;
});
e.replaceSelection('\n\n'+list.join('\n'));
cursor = selected.start+5;
}
}
e.setSelection(cursor,cursor+chunk.length);
}
},
{
name: 'cmdCode',
hotkey: 'Ctrl+K',
title: 'Code',
icon: { glyph: 'glyphicon glyphicon-asterisk', fa: 'fa fa-code', 'fa-3': 'icon-code' },
callback: function(e) {
var chunk, cursor, selected = e.getSelection(), content = e.getContent();
if (selected.length === 0) {
chunk = e.__localize('code text here');
} else {
chunk = selected.text;
}
if (content.substr(selected.start-4,4) === '```\n'
&& content.substr(selected.end,4) === '\n```') {
e.setSelection(selected.start-4, selected.end+4);
e.replaceSelection(chunk);
cursor = selected.start-4;
} else if (content.substr(selected.start-1,1) === '`'
&& content.substr(selected.end,1) === '`') {
e.setSelection(selected.start-1,selected.end+1);
e.replaceSelection(chunk);
cursor = selected.start-1;
} else if (content.indexOf('\n') > -1) {
e.replaceSelection('```\n'+chunk+'\n```');
cursor = selected.start+4;
} else {
e.replaceSelection('`'+chunk+'`');
cursor = selected.start+1;
}
e.setSelection(cursor,cursor+chunk.length);
}
},
{
name: 'cmdQuote',
hotkey: 'Ctrl+Q',
title: 'Quote',
icon: { glyph: 'glyphicon glyphicon-comment', fa: 'fa fa-quote-left', 'fa-3': 'icon-quote-left' },
callback: function(e) {
var chunk, cursor, selected = e.getSelection(), content = e.getContent();
if (selected.length === 0) {
chunk = e.__localize('quote here');
e.replaceSelection('> '+chunk);
cursor = selected.start+2;
} else {
if (selected.text.indexOf('\n') < 0) {
chunk = selected.text;
e.replaceSelection('> '+chunk);
cursor = selected.start+2;
} else {
var list = [];
list = selected.text.split('\n');
chunk = list[0];
$.each(list,function(k,v) {
list[k] = '> '+v;
});
e.replaceSelection('\n\n'+list.join('\n'));
cursor = selected.start+4;
}
}
e.setSelection(cursor,cursor+chunk.length);
}
}]
},{
name: 'groupUtil',
data: [{
name: 'cmdPreview',
toggle: true,
hotkey: 'Ctrl+P',
title: 'Preview',
btnText: 'Preview',
btnClass: 'btn btn-primary btn-sm',
icon: { glyph: 'glyphicon glyphicon-search', fa: 'fa fa-search', 'fa-3': 'icon-search' },
callback: function(e){
var isPreview = e.$isPreview,content;
if (isPreview === false) {
e.showPreview();
} else {
e.hidePreview();
}
}
}]
}]
],
additionalButtons:[], // Place to hook more buttons by code
reorderButtonGroups:[],
hiddenButtons:[], // Default hidden buttons
disabledButtons:[], // Default disabled buttons
footer: '',
fullscreen: {
enable: true,
icons: {
fullscreenOn: {
fa: 'fa fa-expand',
glyph: 'glyphicon glyphicon-fullscreen',
'fa-3': 'icon-resize-full'
},
fullscreenOff: {
fa: 'fa fa-compress',
glyph: 'glyphicon glyphicon-fullscreen',
'fa-3': 'icon-resize-small'
}
}
},
onShow: function (e) {},
onPreview: function (e) {},
onSave: function (e) {},
onBlur: function (e) {},
onFocus: function (e) {},
onChange: function(e) {},
onFullscreen: function(e) {},
onSelect: function (e) {}
};
$.fn.markdown.Constructor = Markdown;
$.fn.markdown.noConflict = function () {
$.fn.markdown = old;
return this;
};
var initMarkdown = function(el) {
var $this = el;
if ($this.data('markdown')) {
$this.data('markdown').showEditor();
return;
}
$this.markdown()
};
var blurNonFocused = function(e) {
var $activeElement = $(document.activeElement);
$(document).find('.md-editor').each(function(){
var $this            = $(this),
focused          = $activeElement.closest('.md-editor')[0] === this,
attachedMarkdown = $this.find('textarea').data('markdown') ||
$this.find('div[data-provider="markdown-preview"]').data('markdown');
if (attachedMarkdown && !focused) {
attachedMarkdown.blur();
}
})
};
$(document)
.on('click.markdown.data-api', '[data-provide="markdown-editable"]', function (e) {
initMarkdown($(this));
e.preventDefault();
})
.on('click focusin', function (e) {
blurNonFocused(e);
})
.ready(function(){
$('textarea[data-provide="markdown"]').each(function(){
initMarkdown($(this));
})
});
}));
$.fn.markdown.defaults.iconlibrary = 'fa';
(function( factory ) {
if ( typeof define === "function" && define.amd ) {
define( ["jquery"], factory );
} else if (typeof module === "object" && module.exports) {
module.exports = factory( require( "jquery" ) );
} else {
factory( jQuery );
}
}(function( $ ) {
$.extend( $.fn, {
validate: function( options ) {
if ( !this.length ) {
if ( options && options.debug && window.console ) {
console.warn( "Nothing selected, can't validate, returning nothing." );
}
return;
}
var validator = $.data( this[ 0 ], "validator" );
if ( validator ) {
return validator;
}
this.attr( "novalidate", "novalidate" );
validator = new $.validator( options, this[ 0 ] );
$.data( this[ 0 ], "validator", validator );
if ( validator.settings.onsubmit ) {
this.on( "click.validate", ":submit", function( event ) {
validator.submitButton = event.currentTarget;
if ( $( this ).hasClass( "cancel" ) ) {
validator.cancelSubmit = true;
}
if ( $( this ).attr( "formnovalidate" ) !== undefined ) {
validator.cancelSubmit = true;
}
} );
this.on( "submit.validate", function( event ) {
if ( validator.settings.debug ) {
event.preventDefault();
}
function handle() {
var hidden, result;
if ( validator.submitButton && ( validator.settings.submitHandler || validator.formSubmitted ) ) {
hidden = $( "<input type='hidden'/>" )
.attr( "name", validator.submitButton.name )
.val( $( validator.submitButton ).val() )
.appendTo( validator.currentForm );
}
if ( validator.settings.submitHandler ) {
result = validator.settings.submitHandler.call( validator, validator.currentForm, event );
if ( hidden ) {
hidden.remove();
}
if ( result !== undefined ) {
return result;
}
return false;
}
return true;
}
if ( validator.cancelSubmit ) {
validator.cancelSubmit = false;
return handle();
}
if ( validator.form() ) {
if ( validator.pendingRequest ) {
validator.formSubmitted = true;
return false;
}
return handle();
} else {
validator.focusInvalid();
return false;
}
} );
}
return validator;
},
valid: function() {
var valid, validator, errorList;
if ( $( this[ 0 ] ).is( "form" ) ) {
valid = this.validate().form();
} else {
errorList = [];
valid = true;
validator = $( this[ 0 ].form ).validate();
this.each( function() {
valid = validator.element( this ) && valid;
if ( !valid ) {
errorList = errorList.concat( validator.errorList );
}
} );
validator.errorList = errorList;
}
return valid;
},
rules: function( command, argument ) {
var element = this[ 0 ],
settings, staticRules, existingRules, data, param, filtered;
if ( element == null ) {
return;
}
if ( !element.form && element.hasAttribute( "contenteditable" ) ) {
element.form = this.closest( "form" )[ 0 ];
element.name = this.attr( "name" );
}
if ( element.form == null ) {
return;
}
if ( command ) {
settings = $.data( element.form, "validator" ).settings;
staticRules = settings.rules;
existingRules = $.validator.staticRules( element );
switch ( command ) {
case "add":
$.extend( existingRules, $.validator.normalizeRule( argument ) );
delete existingRules.messages;
staticRules[ element.name ] = existingRules;
if ( argument.messages ) {
settings.messages[ element.name ] = $.extend( settings.messages[ element.name ], argument.messages );
}
break;
case "remove":
if ( !argument ) {
delete staticRules[ element.name ];
return existingRules;
}
filtered = {};
$.each( argument.split( /\s/ ), function( index, method ) {
filtered[ method ] = existingRules[ method ];
delete existingRules[ method ];
} );
return filtered;
}
}
data = $.validator.normalizeRules(
$.extend(
{},
$.validator.classRules( element ),
$.validator.attributeRules( element ),
$.validator.dataRules( element ),
$.validator.staticRules( element )
), element );
if ( data.required ) {
param = data.required;
delete data.required;
data = $.extend( { required: param }, data );
}
if ( data.remote ) {
param = data.remote;
delete data.remote;
data = $.extend( data, { remote: param } );
}
return data;
}
} );
$.extend( $.expr.pseudos || $.expr[ ":" ], {		// '|| $.expr[ ":" ]' here enables backwards compatibility to jQuery 1.7. Can be removed when dropping jQ 1.7.x support
blank: function( a ) {
return !$.trim( "" + $( a ).val() );
},
filled: function( a ) {
var val = $( a ).val();
return val !== null && !!$.trim( "" + val );
},
unchecked: function( a ) {
return !$( a ).prop( "checked" );
}
} );
$.validator = function( options, form ) {
this.settings = $.extend( true, {}, $.validator.defaults, options );
this.currentForm = form;
this.init();
};
$.validator.format = function( source, params ) {
if ( arguments.length === 1 ) {
return function() {
var args = $.makeArray( arguments );
args.unshift( source );
return $.validator.format.apply( this, args );
};
}
if ( params === undefined ) {
return source;
}
if ( arguments.length > 2 && params.constructor !== Array  ) {
params = $.makeArray( arguments ).slice( 1 );
}
if ( params.constructor !== Array ) {
params = [ params ];
}
$.each( params, function( i, n ) {
source = source.replace( new RegExp( "\\{" + i + "\\}", "g" ), function() {
return n;
} );
} );
return source;
};
$.extend( $.validator, {
defaults: {
messages: {},
groups: {},
rules: {},
errorClass: "error",
pendingClass: "pending",
validClass: "valid",
errorElement: "label",
focusCleanup: false,
focusInvalid: true,
errorContainer: $( [] ),
errorLabelContainer: $( [] ),
onsubmit: true,
ignore: ":hidden",
ignoreTitle: false,
onfocusin: function( element ) {
this.lastActive = element;
if ( this.settings.focusCleanup ) {
if ( this.settings.unhighlight ) {
this.settings.unhighlight.call( this, element, this.settings.errorClass, this.settings.validClass );
}
this.hideThese( this.errorsFor( element ) );
}
},
onfocusout: function( element ) {
if ( !this.checkable( element ) && ( element.name in this.submitted || !this.optional( element ) ) ) {
this.element( element );
}
},
onkeyup: function( element, event ) {
var excludedKeys = [
16, 17, 18, 20, 35, 36, 37,
38, 39, 40, 45, 144, 225
];
if ( event.which === 9 && this.elementValue( element ) === "" || $.inArray( event.keyCode, excludedKeys ) !== -1 ) {
return;
} else if ( element.name in this.submitted || element.name in this.invalid ) {
this.element( element );
}
},
onclick: function( element ) {
if ( element.name in this.submitted ) {
this.element( element );
} else if ( element.parentNode.name in this.submitted ) {
this.element( element.parentNode );
}
},
highlight: function( element, errorClass, validClass ) {
if ( element.type === "radio" ) {
this.findByName( element.name ).addClass( errorClass ).removeClass( validClass );
} else {
$( element ).addClass( errorClass ).removeClass( validClass );
}
},
unhighlight: function( element, errorClass, validClass ) {
if ( element.type === "radio" ) {
this.findByName( element.name ).removeClass( errorClass ).addClass( validClass );
} else {
$( element ).removeClass( errorClass ).addClass( validClass );
}
}
},
setDefaults: function( settings ) {
$.extend( $.validator.defaults, settings );
},
messages: {
required: "This field is required.",
remote: "Please fix this field.",
email: "Please enter a valid email address.",
url: "Please enter a valid URL.",
date: "Please enter a valid date.",
dateISO: "Please enter a valid date (ISO).",
number: "Please enter a valid number.",
digits: "Please enter only digits.",
equalTo: "Please enter the same value again.",
maxlength: $.validator.format( "Please enter no more than {0} characters." ),
minlength: $.validator.format( "Please enter at least {0} characters." ),
rangelength: $.validator.format( "Please enter a value between {0} and {1} characters long." ),
range: $.validator.format( "Please enter a value between {0} and {1}." ),
max: $.validator.format( "Please enter a value less than or equal to {0}." ),
min: $.validator.format( "Please enter a value greater than or equal to {0}." ),
step: $.validator.format( "Please enter a multiple of {0}." )
},
autoCreateRanges: false,
prototype: {
init: function() {
this.labelContainer = $( this.settings.errorLabelContainer );
this.errorContext = this.labelContainer.length && this.labelContainer || $( this.currentForm );
this.containers = $( this.settings.errorContainer ).add( this.settings.errorLabelContainer );
this.submitted = {};
this.valueCache = {};
this.pendingRequest = 0;
this.pending = {};
this.invalid = {};
this.reset();
var groups = ( this.groups = {} ),
rules;
$.each( this.settings.groups, function( key, value ) {
if ( typeof value === "string" ) {
value = value.split( /\s/ );
}
$.each( value, function( index, name ) {
groups[ name ] = key;
} );
} );
rules = this.settings.rules;
$.each( rules, function( key, value ) {
rules[ key ] = $.validator.normalizeRule( value );
} );
function delegate( event ) {
if ( !this.form && this.hasAttribute( "contenteditable" ) ) {
this.form = $( this ).closest( "form" )[ 0 ];
this.name = $( this ).attr( "name" );
}
var validator = $.data( this.form, "validator" ),
eventType = "on" + event.type.replace( /^validate/, "" ),
settings = validator.settings;
if ( settings[ eventType ] && !$( this ).is( settings.ignore ) ) {
settings[ eventType ].call( validator, this, event );
}
}
$( this.currentForm )
.on( "focusin.validate focusout.validate keyup.validate",
":text, [type='password'], [type='file'], select, textarea, [type='number'], [type='search'], " +
"[type='tel'], [type='url'], [type='email'], [type='datetime'], [type='date'], [type='month'], " +
"[type='week'], [type='time'], [type='datetime-local'], [type='range'], [type='color'], " +
"[type='radio'], [type='checkbox'], [contenteditable], [type='button']", delegate )
.on( "click.validate", "select, option, [type='radio'], [type='checkbox']", delegate );
if ( this.settings.invalidHandler ) {
$( this.currentForm ).on( "invalid-form.validate", this.settings.invalidHandler );
}
},
form: function() {
this.checkForm();
$.extend( this.submitted, this.errorMap );
this.invalid = $.extend( {}, this.errorMap );
if ( !this.valid() ) {
$( this.currentForm ).triggerHandler( "invalid-form", [ this ] );
}
this.showErrors();
return this.valid();
},
checkForm: function() {
this.prepareForm();
for ( var i = 0, elements = ( this.currentElements = this.elements() ); elements[ i ]; i++ ) {
this.check( elements[ i ] );
}
return this.valid();
},
element: function( element ) {
var cleanElement = this.clean( element ),
checkElement = this.validationTargetFor( cleanElement ),
v = this,
result = true,
rs, group;
if ( checkElement === undefined ) {
delete this.invalid[ cleanElement.name ];
} else {
this.prepareElement( checkElement );
this.currentElements = $( checkElement );
group = this.groups[ checkElement.name ];
if ( group ) {
$.each( this.groups, function( name, testgroup ) {
if ( testgroup === group && name !== checkElement.name ) {
cleanElement = v.validationTargetFor( v.clean( v.findByName( name ) ) );
if ( cleanElement && cleanElement.name in v.invalid ) {
v.currentElements.push( cleanElement );
result = v.check( cleanElement ) && result;
}
}
} );
}
rs = this.check( checkElement ) !== false;
result = result && rs;
if ( rs ) {
this.invalid[ checkElement.name ] = false;
} else {
this.invalid[ checkElement.name ] = true;
}
if ( !this.numberOfInvalids() ) {
this.toHide = this.toHide.add( this.containers );
}
this.showErrors();
$( element ).attr( "aria-invalid", !rs );
}
return result;
},
showErrors: function( errors ) {
if ( errors ) {
var validator = this;
$.extend( this.errorMap, errors );
this.errorList = $.map( this.errorMap, function( message, name ) {
return {
message: message,
element: validator.findByName( name )[ 0 ]
};
} );
this.successList = $.grep( this.successList, function( element ) {
return !( element.name in errors );
} );
}
if ( this.settings.showErrors ) {
this.settings.showErrors.call( this, this.errorMap, this.errorList );
} else {
this.defaultShowErrors();
}
},
resetForm: function() {
if ( $.fn.resetForm ) {
$( this.currentForm ).resetForm();
}
this.invalid = {};
this.submitted = {};
this.prepareForm();
this.hideErrors();
var elements = this.elements()
.removeData( "previousValue" )
.removeAttr( "aria-invalid" );
this.resetElements( elements );
},
resetElements: function( elements ) {
var i;
if ( this.settings.unhighlight ) {
for ( i = 0; elements[ i ]; i++ ) {
this.settings.unhighlight.call( this, elements[ i ],
this.settings.errorClass, "" );
this.findByName( elements[ i ].name ).removeClass( this.settings.validClass );
}
} else {
elements
.removeClass( this.settings.errorClass )
.removeClass( this.settings.validClass );
}
},
numberOfInvalids: function() {
return this.objectLength( this.invalid );
},
objectLength: function( obj ) {
var count = 0,
i;
for ( i in obj ) {
if ( obj[ i ] !== undefined && obj[ i ] !== null && obj[ i ] !== false ) {
count++;
}
}
return count;
},
hideErrors: function() {
this.hideThese( this.toHide );
},
hideThese: function( errors ) {
errors.not( this.containers ).text( "" );
this.addWrapper( errors ).hide();
},
valid: function() {
return this.size() === 0;
},
size: function() {
return this.errorList.length;
},
focusInvalid: function() {
if ( this.settings.focusInvalid ) {
try {
$( this.findLastActive() || this.errorList.length && this.errorList[ 0 ].element || [] )
.filter( ":visible" )
.focus()
.trigger( "focusin" );
} catch ( e ) {
}
}
},
findLastActive: function() {
var lastActive = this.lastActive;
return lastActive && $.grep( this.errorList, function( n ) {
return n.element.name === lastActive.name;
} ).length === 1 && lastActive;
},
elements: function() {
var validator = this,
rulesCache = {};
return $( this.currentForm )
.find( "input, select, textarea, [contenteditable]" )
.not( ":submit, :reset, :image, :disabled" )
.not( this.settings.ignore )
.filter( function() {
var name = this.name || $( this ).attr( "name" ); // For contenteditable
if ( !name && validator.settings.debug && window.console ) {
console.error( "%o has no name assigned", this );
}
if ( this.hasAttribute( "contenteditable" ) ) {
this.form = $( this ).closest( "form" )[ 0 ];
this.name = name;
}
if ( name in rulesCache || !validator.objectLength( $( this ).rules() ) ) {
return false;
}
rulesCache[ name ] = true;
return true;
} );
},
clean: function( selector ) {
return $( selector )[ 0 ];
},
errors: function() {
var errorClass = this.settings.errorClass.split( " " ).join( "." );
return $( this.settings.errorElement + "." + errorClass, this.errorContext );
},
resetInternals: function() {
this.successList = [];
this.errorList = [];
this.errorMap = {};
this.toShow = $( [] );
this.toHide = $( [] );
},
reset: function() {
this.resetInternals();
this.currentElements = $( [] );
},
prepareForm: function() {
this.reset();
this.toHide = this.errors().add( this.containers );
},
prepareElement: function( element ) {
this.reset();
this.toHide = this.errorsFor( element );
},
elementValue: function( element ) {
var $element = $( element ),
type = element.type,
val, idx;
if ( type === "radio" || type === "checkbox" ) {
return this.findByName( element.name ).filter( ":checked" ).val();
} else if ( type === "number" && typeof element.validity !== "undefined" ) {
return element.validity.badInput ? "NaN" : $element.val();
}
if ( element.hasAttribute( "contenteditable" ) ) {
val = $element.text();
} else {
val = $element.val();
}
if ( type === "file" ) {
if ( val.substr( 0, 12 ) === "C:\\fakepath\\" ) {
return val.substr( 12 );
}
idx = val.lastIndexOf( "/" );
if ( idx >= 0 ) {
return val.substr( idx + 1 );
}
idx = val.lastIndexOf( "\\" );
if ( idx >= 0 ) {
return val.substr( idx + 1 );
}
return val;
}
if ( typeof val === "string" ) {
return val.replace( /\r/g, "" );
}
return val;
},
check: function( element ) {
element = this.validationTargetFor( this.clean( element ) );
var rules = $( element ).rules(),
rulesCount = $.map( rules, function( n, i ) {
return i;
} ).length,
dependencyMismatch = false,
val = this.elementValue( element ),
result, method, rule, normalizer;
if ( typeof rules.normalizer === "function" ) {
normalizer = rules.normalizer;
} else if (	typeof this.settings.normalizer === "function" ) {
normalizer = this.settings.normalizer;
}
if ( normalizer ) {
val = normalizer.call( element, val );
if ( typeof val !== "string" ) {
throw new TypeError( "The normalizer should return a string value." );
}
delete rules.normalizer;
}
for ( method in rules ) {
rule = { method: method, parameters: rules[ method ] };
try {
result = $.validator.methods[ method ].call( this, val, element, rule.parameters );
if ( result === "dependency-mismatch" && rulesCount === 1 ) {
dependencyMismatch = true;
continue;
}
dependencyMismatch = false;
if ( result === "pending" ) {
this.toHide = this.toHide.not( this.errorsFor( element ) );
return;
}
if ( !result ) {
this.formatAndAdd( element, rule );
return false;
}
} catch ( e ) {
if ( this.settings.debug && window.console ) {
console.log( "Exception occurred when checking element " + element.id + ", check the '" + rule.method + "' method.", e );
}
if ( e instanceof TypeError ) {
e.message += ".  Exception occurred when checking element " + element.id + ", check the '" + rule.method + "' method.";
}
throw e;
}
}
if ( dependencyMismatch ) {
return;
}
if ( this.objectLength( rules ) ) {
this.successList.push( element );
}
return true;
},
customDataMessage: function( element, method ) {
return $( element ).data( "msg" + method.charAt( 0 ).toUpperCase() +
method.substring( 1 ).toLowerCase() ) || $( element ).data( "msg" );
},
customMessage: function( name, method ) {
var m = this.settings.messages[ name ];
return m && ( m.constructor === String ? m : m[ method ] );
},
findDefined: function() {
for ( var i = 0; i < arguments.length; i++ ) {
if ( arguments[ i ] !== undefined ) {
return arguments[ i ];
}
}
return undefined;
},
defaultMessage: function( element, rule ) {
if ( typeof rule === "string" ) {
rule = { method: rule };
}
var message = this.findDefined(
this.customMessage( element.name, rule.method ),
this.customDataMessage( element, rule.method ),
!this.settings.ignoreTitle && element.title || undefined,
$.validator.messages[ rule.method ],
"<strong>Warning: No message defined for " + element.name + "</strong>"
),
theregex = /\$?\{(\d+)\}/g;
if ( typeof message === "function" ) {
message = message.call( this, rule.parameters, element );
} else if ( theregex.test( message ) ) {
message = $.validator.format( message.replace( theregex, "{$1}" ), rule.parameters );
}
return message;
},
formatAndAdd: function( element, rule ) {
var message = this.defaultMessage( element, rule );
this.errorList.push( {
message: message,
element: element,
method: rule.method
} );
this.errorMap[ element.name ] = message;
this.submitted[ element.name ] = message;
},
addWrapper: function( toToggle ) {
if ( this.settings.wrapper ) {
toToggle = toToggle.add( toToggle.parent( this.settings.wrapper ) );
}
return toToggle;
},
defaultShowErrors: function() {
var i, elements, error;
for ( i = 0; this.errorList[ i ]; i++ ) {
error = this.errorList[ i ];
if ( this.settings.highlight ) {
this.settings.highlight.call( this, error.element, this.settings.errorClass, this.settings.validClass );
}
this.showLabel( error.element, error.message );
}
if ( this.errorList.length ) {
this.toShow = this.toShow.add( this.containers );
}
if ( this.settings.success ) {
for ( i = 0; this.successList[ i ]; i++ ) {
this.showLabel( this.successList[ i ] );
}
}
if ( this.settings.unhighlight ) {
for ( i = 0, elements = this.validElements(); elements[ i ]; i++ ) {
this.settings.unhighlight.call( this, elements[ i ], this.settings.errorClass, this.settings.validClass );
}
}
this.toHide = this.toHide.not( this.toShow );
this.hideErrors();
this.addWrapper( this.toShow ).show();
},
validElements: function() {
return this.currentElements.not( this.invalidElements() );
},
invalidElements: function() {
return $( this.errorList ).map( function() {
return this.element;
} );
},
showLabel: function( element, message ) {
var place, group, errorID, v,
error = this.errorsFor( element ),
elementID = this.idOrName( element ),
describedBy = $( element ).attr( "aria-describedby" );
if ( error.length ) {
error.removeClass( this.settings.validClass ).addClass( this.settings.errorClass );
error.html( message );
} else {
error = $( "<" + this.settings.errorElement + ">" )
.attr( "id", elementID + "-error" )
.addClass( this.settings.errorClass )
.html( message || "" );
place = error;
if ( this.settings.wrapper ) {
place = error.hide().show().wrap( "<" + this.settings.wrapper + "/>" ).parent();
}
if ( this.labelContainer.length ) {
this.labelContainer.append( place );
} else if ( this.settings.errorPlacement ) {
this.settings.errorPlacement.call( this, place, $( element ) );
} else {
place.insertAfter( element );
}
if ( error.is( "label" ) ) {
error.attr( "for", elementID );
} else if ( error.parents( "label[for='" + this.escapeCssMeta( elementID ) + "']" ).length === 0 ) {
errorID = error.attr( "id" );
if ( !describedBy ) {
describedBy = errorID;
} else if ( !describedBy.match( new RegExp( "\\b" + this.escapeCssMeta( errorID ) + "\\b" ) ) ) {
describedBy += " " + errorID;
}
$( element ).attr( "aria-describedby", describedBy );
group = this.groups[ element.name ];
if ( group ) {
v = this;
$.each( v.groups, function( name, testgroup ) {
if ( testgroup === group ) {
$( "[name='" + v.escapeCssMeta( name ) + "']", v.currentForm )
.attr( "aria-describedby", error.attr( "id" ) );
}
} );
}
}
}
if ( !message && this.settings.success ) {
error.text( "" );
if ( typeof this.settings.success === "string" ) {
error.addClass( this.settings.success );
} else {
this.settings.success( error, element );
}
}
this.toShow = this.toShow.add( error );
},
errorsFor: function( element ) {
var name = this.escapeCssMeta( this.idOrName( element ) ),
describer = $( element ).attr( "aria-describedby" ),
selector = "label[for='" + name + "'], label[for='" + name + "'] *";
if ( describer ) {
selector = selector + ", #" + this.escapeCssMeta( describer )
.replace( /\s+/g, ", #" );
}
return this
.errors()
.filter( selector );
},
escapeCssMeta: function( string ) {
return string.replace( /([\\!"#$%&'()*+,./:;<=>?@\[\]^`{|}~])/g, "\\$1" );
},
idOrName: function( element ) {
return this.groups[ element.name ] || ( this.checkable( element ) ? element.name : element.id || element.name );
},
validationTargetFor: function( element ) {
if ( this.checkable( element ) ) {
element = this.findByName( element.name );
}
return $( element ).not( this.settings.ignore )[ 0 ];
},
checkable: function( element ) {
return ( /radio|checkbox/i ).test( element.type );
},
findByName: function( name ) {
return $( this.currentForm ).find( "[name='" + this.escapeCssMeta( name ) + "']" );
},
getLength: function( value, element ) {
switch ( element.nodeName.toLowerCase() ) {
case "select":
return $( "option:selected", element ).length;
case "input":
if ( this.checkable( element ) ) {
return this.findByName( element.name ).filter( ":checked" ).length;
}
}
return value.length;
},
depend: function( param, element ) {
return this.dependTypes[ typeof param ] ? this.dependTypes[ typeof param ]( param, element ) : true;
},
dependTypes: {
"boolean": function( param ) {
return param;
},
"string": function( param, element ) {
return !!$( param, element.form ).length;
},
"function": function( param, element ) {
return param( element );
}
},
optional: function( element ) {
var val = this.elementValue( element );
return !$.validator.methods.required.call( this, val, element ) && "dependency-mismatch";
},
startRequest: function( element ) {
if ( !this.pending[ element.name ] ) {
this.pendingRequest++;
$( element ).addClass( this.settings.pendingClass );
this.pending[ element.name ] = true;
}
},
stopRequest: function( element, valid ) {
this.pendingRequest--;
if ( this.pendingRequest < 0 ) {
this.pendingRequest = 0;
}
delete this.pending[ element.name ];
$( element ).removeClass( this.settings.pendingClass );
if ( valid && this.pendingRequest === 0 && this.formSubmitted && this.form() ) {
$( this.currentForm ).submit();
if ( this.submitButton ) {
$( "input:hidden[name='" + this.submitButton.name + "']", this.currentForm ).remove();
}
this.formSubmitted = false;
} else if ( !valid && this.pendingRequest === 0 && this.formSubmitted ) {
$( this.currentForm ).triggerHandler( "invalid-form", [ this ] );
this.formSubmitted = false;
}
},
previousValue: function( element, method ) {
method = typeof method === "string" && method || "remote";
return $.data( element, "previousValue" ) || $.data( element, "previousValue", {
old: null,
valid: true,
message: this.defaultMessage( element, { method: method } )
} );
},
destroy: function() {
this.resetForm();
$( this.currentForm )
.off( ".validate" )
.removeData( "validator" )
.find( ".validate-equalTo-blur" )
.off( ".validate-equalTo" )
.removeClass( "validate-equalTo-blur" );
}
},
classRuleSettings: {
required: { required: true },
email: { email: true },
url: { url: true },
date: { date: true },
dateISO: { dateISO: true },
number: { number: true },
digits: { digits: true },
creditcard: { creditcard: true }
},
addClassRules: function( className, rules ) {
if ( className.constructor === String ) {
this.classRuleSettings[ className ] = rules;
} else {
$.extend( this.classRuleSettings, className );
}
},
classRules: function( element ) {
var rules = {},
classes = $( element ).attr( "class" );
if ( classes ) {
$.each( classes.split( " " ), function() {
if ( this in $.validator.classRuleSettings ) {
$.extend( rules, $.validator.classRuleSettings[ this ] );
}
} );
}
return rules;
},
normalizeAttributeRule: function( rules, type, method, value ) {
if ( /min|max|step/.test( method ) && ( type === null || /number|range|text/.test( type ) ) ) {
value = Number( value );
if ( isNaN( value ) ) {
value = undefined;
}
}
if ( value || value === 0 ) {
rules[ method ] = value;
} else if ( type === method && type !== "range" ) {
rules[ method ] = true;
}
},
attributeRules: function( element ) {
var rules = {},
$element = $( element ),
type = element.getAttribute( "type" ),
method, value;
for ( method in $.validator.methods ) {
if ( method === "required" ) {
value = element.getAttribute( method );
if ( value === "" ) {
value = true;
}
value = !!value;
} else {
value = $element.attr( method );
}
this.normalizeAttributeRule( rules, type, method, value );
}
if ( rules.maxlength && /-1|2147483647|524288/.test( rules.maxlength ) ) {
delete rules.maxlength;
}
return rules;
},
dataRules: function( element ) {
var rules = {},
$element = $( element ),
type = element.getAttribute( "type" ),
method, value;
for ( method in $.validator.methods ) {
value = $element.data( "rule" + method.charAt( 0 ).toUpperCase() + method.substring( 1 ).toLowerCase() );
this.normalizeAttributeRule( rules, type, method, value );
}
return rules;
},
staticRules: function( element ) {
var rules = {},
validator = $.data( element.form, "validator" );
if ( validator.settings.rules ) {
rules = $.validator.normalizeRule( validator.settings.rules[ element.name ] ) || {};
}
return rules;
},
normalizeRules: function( rules, element ) {
$.each( rules, function( prop, val ) {
if ( val === false ) {
delete rules[ prop ];
return;
}
if ( val.param || val.depends ) {
var keepRule = true;
switch ( typeof val.depends ) {
case "string":
keepRule = !!$( val.depends, element.form ).length;
break;
case "function":
keepRule = val.depends.call( element, element );
break;
}
if ( keepRule ) {
rules[ prop ] = val.param !== undefined ? val.param : true;
} else {
$.data( element.form, "validator" ).resetElements( $( element ) );
delete rules[ prop ];
}
}
} );
$.each( rules, function( rule, parameter ) {
rules[ rule ] = $.isFunction( parameter ) && rule !== "normalizer" ? parameter( element ) : parameter;
} );
$.each( [ "minlength", "maxlength" ], function() {
if ( rules[ this ] ) {
rules[ this ] = Number( rules[ this ] );
}
} );
$.each( [ "rangelength", "range" ], function() {
var parts;
if ( rules[ this ] ) {
if ( $.isArray( rules[ this ] ) ) {
rules[ this ] = [ Number( rules[ this ][ 0 ] ), Number( rules[ this ][ 1 ] ) ];
} else if ( typeof rules[ this ] === "string" ) {
parts = rules[ this ].replace( /[\[\]]/g, "" ).split( /[\s,]+/ );
rules[ this ] = [ Number( parts[ 0 ] ), Number( parts[ 1 ] ) ];
}
}
} );
if ( $.validator.autoCreateRanges ) {
if ( rules.min != null && rules.max != null ) {
rules.range = [ rules.min, rules.max ];
delete rules.min;
delete rules.max;
}
if ( rules.minlength != null && rules.maxlength != null ) {
rules.rangelength = [ rules.minlength, rules.maxlength ];
delete rules.minlength;
delete rules.maxlength;
}
}
return rules;
},
normalizeRule: function( data ) {
if ( typeof data === "string" ) {
var transformed = {};
$.each( data.split( /\s/ ), function() {
transformed[ this ] = true;
} );
data = transformed;
}
return data;
},
addMethod: function( name, method, message ) {
$.validator.methods[ name ] = method;
$.validator.messages[ name ] = message !== undefined ? message : $.validator.messages[ name ];
if ( method.length < 3 ) {
$.validator.addClassRules( name, $.validator.normalizeRule( name ) );
}
},
methods: {
required: function( value, element, param ) {
if ( !this.depend( param, element ) ) {
return "dependency-mismatch";
}
if ( element.nodeName.toLowerCase() === "select" ) {
var val = $( element ).val();
return val && val.length > 0;
}
if ( this.checkable( element ) ) {
return this.getLength( value, element ) > 0;
}
return value.length > 0;
},
email: function( value, element ) {
return this.optional( element ) || /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/.test( value );
},
url: function( value, element ) {
return this.optional( element ) || /^(?:(?:(?:https?|ftp):)?\/\/)(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)(?:\.(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)*(?:\.(?:[a-z\u00a1-\uffff]{2,})).?)(?::\d{2,5})?(?:[/?#]\S*)?$/i.test( value );
},
date: function( value, element ) {
return this.optional( element ) || !/Invalid|NaN/.test( new Date( value ).toString() );
},
dateISO: function( value, element ) {
return this.optional( element ) || /^\d{4}[\/\-](0?[1-9]|1[012])[\/\-](0?[1-9]|[12][0-9]|3[01])$/.test( value );
},
number: function( value, element ) {
return this.optional( element ) || /^(?:-?\d+|-?\d{1,3}(?:,\d{3})+)?(?:\.\d+)?$/.test( value );
},
digits: function( value, element ) {
return this.optional( element ) || /^\d+$/.test( value );
},
minlength: function( value, element, param ) {
var length = $.isArray( value ) ? value.length : this.getLength( value, element );
return this.optional( element ) || length >= param;
},
maxlength: function( value, element, param ) {
var length = $.isArray( value ) ? value.length : this.getLength( value, element );
return this.optional( element ) || length <= param;
},
rangelength: function( value, element, param ) {
var length = $.isArray( value ) ? value.length : this.getLength( value, element );
return this.optional( element ) || ( length >= param[ 0 ] && length <= param[ 1 ] );
},
min: function( value, element, param ) {
return this.optional( element ) || value >= param;
},
max: function( value, element, param ) {
return this.optional( element ) || value <= param;
},
range: function( value, element, param ) {
return this.optional( element ) || ( value >= param[ 0 ] && value <= param[ 1 ] );
},
step: function( value, element, param ) {
var type = $( element ).attr( "type" ),
errorMessage = "Step attribute on input type " + type + " is not supported.",
supportedTypes = [ "text", "number", "range" ],
re = new RegExp( "\\b" + type + "\\b" ),
notSupported = type && !re.test( supportedTypes.join() ),
decimalPlaces = function( num ) {
var match = ( "" + num ).match( /(?:\.(\d+))?$/ );
if ( !match ) {
return 0;
}
return match[ 1 ] ? match[ 1 ].length : 0;
},
toInt = function( num ) {
return Math.round( num * Math.pow( 10, decimals ) );
},
valid = true,
decimals;
if ( notSupported ) {
throw new Error( errorMessage );
}
decimals = decimalPlaces( param );
if ( decimalPlaces( value ) > decimals || toInt( value ) % toInt( param ) !== 0 ) {
valid = false;
}
return this.optional( element ) || valid;
},
equalTo: function( value, element, param ) {
var target = $( param );
if ( this.settings.onfocusout && target.not( ".validate-equalTo-blur" ).length ) {
target.addClass( "validate-equalTo-blur" ).on( "blur.validate-equalTo", function() {
$( element ).valid();
} );
}
return value === target.val();
},
remote: function( value, element, param, method ) {
if ( this.optional( element ) ) {
return "dependency-mismatch";
}
method = typeof method === "string" && method || "remote";
var previous = this.previousValue( element, method ),
validator, data, optionDataString;
if ( !this.settings.messages[ element.name ] ) {
this.settings.messages[ element.name ] = {};
}
previous.originalMessage = previous.originalMessage || this.settings.messages[ element.name ][ method ];
this.settings.messages[ element.name ][ method ] = previous.message;
param = typeof param === "string" && { url: param } || param;
optionDataString = $.param( $.extend( { data: value }, param.data ) );
if ( previous.old === optionDataString ) {
return previous.valid;
}
previous.old = optionDataString;
validator = this;
this.startRequest( element );
data = {};
data[ element.name ] = value;
$.ajax( $.extend( true, {
mode: "abort",
port: "validate" + element.name,
dataType: "json",
data: data,
context: validator.currentForm,
success: function( response ) {
var valid = response === true || response === "true",
errors, message, submitted;
validator.settings.messages[ element.name ][ method ] = previous.originalMessage;
if ( valid ) {
submitted = validator.formSubmitted;
validator.resetInternals();
validator.toHide = validator.errorsFor( element );
validator.formSubmitted = submitted;
validator.successList.push( element );
validator.invalid[ element.name ] = false;
validator.showErrors();
} else {
errors = {};
message = response || validator.defaultMessage( element, { method: method, parameters: value } );
errors[ element.name ] = previous.message = message;
validator.invalid[ element.name ] = true;
validator.showErrors( errors );
}
previous.valid = valid;
validator.stopRequest( element, valid );
}
}, param ) );
return "pending";
}
}
} );
var pendingRequests = {},
ajax;
if ( $.ajaxPrefilter ) {
$.ajaxPrefilter( function( settings, _, xhr ) {
var port = settings.port;
if ( settings.mode === "abort" ) {
if ( pendingRequests[ port ] ) {
pendingRequests[ port ].abort();
}
pendingRequests[ port ] = xhr;
}
} );
} else {
ajax = $.ajax;
$.ajax = function( settings ) {
var mode = ( "mode" in settings ? settings : $.ajaxSettings ).mode,
port = ( "port" in settings ? settings : $.ajaxSettings ).port;
if ( mode === "abort" ) {
if ( pendingRequests[ port ] ) {
pendingRequests[ port ].abort();
}
pendingRequests[ port ] = ajax.apply( this, arguments );
return pendingRequests[ port ];
}
return ajax.apply( this, arguments );
};
}
return $;
}));
(function( factory ) {
if ( typeof define === "function" && define.amd ) {
define( ["jquery", "./jquery.validate"], factory );
} else if (typeof module === "object" && module.exports) {
module.exports = factory( require( "jquery" ) );
} else {
factory( jQuery );
}
}(function( $ ) {
( function() {
function stripHtml( value ) {
return value.replace( /<.[^<>]*?>/g, " " ).replace( /&nbsp;|&#160;/gi, " " )
.replace( /[.(),;:!?%#$'\"_+=\/\-]*/g, "" );
}
$.validator.addMethod( "maxWords", function( value, element, params ) {
return this.optional( element ) || stripHtml( value ).match( /\b\w+\b/g ).length <= params;
}, $.validator.format( "Please enter {0} words or less." ) );
$.validator.addMethod( "minWords", function( value, element, params ) {
return this.optional( element ) || stripHtml( value ).match( /\b\w+\b/g ).length >= params;
}, $.validator.format( "Please enter at least {0} words." ) );
$.validator.addMethod( "rangeWords", function( value, element, params ) {
var valueStripped = stripHtml( value ),
regex = /\b\w+\b/g;
return this.optional( element ) || valueStripped.match( regex ).length >= params[ 0 ] && valueStripped.match( regex ).length <= params[ 1 ];
}, $.validator.format( "Please enter between {0} and {1} words." ) );
}() );
$.validator.addMethod( "accept", function( value, element, param ) {
var typeParam = typeof param === "string" ? param.replace( /\s/g, "" ) : "image/*",
optionalValue = this.optional( element ),
i, file, regex;
if ( optionalValue ) {
return optionalValue;
}
if ( $( element ).attr( "type" ) === "file" ) {
typeParam = typeParam
.replace( /[\-\[\]\/\{\}\(\)\+\?\.\\\^\$\|]/g, "\\$&" )
.replace( /,/g, "|" )
.replace( /\/\*/g, "/.*" );
if ( element.files && element.files.length ) {
regex = new RegExp( ".?(" + typeParam + ")$", "i" );
for ( i = 0; i < element.files.length; i++ ) {
file = element.files[ i ];
if ( !file.type.match( regex ) ) {
return false;
}
}
}
}
return true;
}, $.validator.format( "Please enter a value with a valid mimetype." ) );
$.validator.addMethod( "alphanumeric", function( value, element ) {
return this.optional( element ) || /^\w+$/i.test( value );
}, "Letters, numbers, and underscores only please" );
$.validator.addMethod( "bankaccountNL", function( value, element ) {
if ( this.optional( element ) ) {
return true;
}
if ( !( /^[0-9]{9}|([0-9]{2} ){3}[0-9]{3}$/.test( value ) ) ) {
return false;
}
var account = value.replace( / /g, "" ), // Remove spaces
sum = 0,
len = account.length,
pos, factor, digit;
for ( pos = 0; pos < len; pos++ ) {
factor = len - pos;
digit = account.substring( pos, pos + 1 );
sum = sum + factor * digit;
}
return sum % 11 === 0;
}, "Please specify a valid bank account number" );
$.validator.addMethod( "bankorgiroaccountNL", function( value, element ) {
return this.optional( element ) ||
( $.validator.methods.bankaccountNL.call( this, value, element ) ) ||
( $.validator.methods.giroaccountNL.call( this, value, element ) );
}, "Please specify a valid bank or giro account number" );
$.validator.addMethod( "bic", function( value, element ) {
return this.optional( element ) || /^([A-Z]{6}[A-Z2-9][A-NP-Z1-9])(X{3}|[A-WY-Z0-9][A-Z0-9]{2})?$/.test( value.toUpperCase() );
}, "Please specify a valid BIC code" );
$.validator.addMethod( "cifES", function( value, element ) {
"use strict";
if ( this.optional( element ) ) {
return true;
}
var cifRegEx = new RegExp( /^([ABCDEFGHJKLMNPQRSUVW])(\d{7})([0-9A-J])$/gi );
var letter  = value.substring( 0, 1 ), // [ T ]
number  = value.substring( 1, 8 ), // [ P ][ P ][ N ][ N ][ N ][ N ][ N ]
control = value.substring( 8, 9 ), // [ C ]
all_sum = 0,
even_sum = 0,
odd_sum = 0,
i, n,
control_digit,
control_letter;
function isOdd( n ) {
return n % 2 === 0;
}
if ( value.length !== 9 || !cifRegEx.test( value ) ) {
return false;
}
for ( i = 0; i < number.length; i++ ) {
n = parseInt( number[ i ], 10 );
if ( isOdd( i ) ) {
n *= 2;
odd_sum += n < 10 ? n : n - 9;
} else {
even_sum += n;
}
}
all_sum = even_sum + odd_sum;
control_digit = ( 10 - ( all_sum ).toString().substr( -1 ) ).toString();
control_digit = parseInt( control_digit, 10 ) > 9 ? "0" : control_digit;
control_letter = "JABCDEFGHI".substr( control_digit, 1 ).toString();
if ( letter.match( /[ABEH]/ ) ) {
return control === control_digit;
} else if ( letter.match( /[KPQS]/ ) ) {
return control === control_letter;
}
return control === control_digit || control === control_letter;
}, "Please specify a valid CIF number." );
$.validator.addMethod( "cpfBR", function( value ) {
value = value.replace( /([~!@#$%^&*()_+=`{}\[\]\-|\\:;'<>,.\/? ])+/g, "" );
if ( value.length !== 11 ) {
return false;
}
var sum = 0,
firstCN, secondCN, checkResult, i;
firstCN = parseInt( value.substring( 9, 10 ), 10 );
secondCN = parseInt( value.substring( 10, 11 ), 10 );
checkResult = function( sum, cn ) {
var result = ( sum * 10 ) % 11;
if ( ( result === 10 ) || ( result === 11 ) ) {
result = 0;
}
return ( result === cn );
};
if ( value === "" ||
value === "00000000000" ||
value === "11111111111" ||
value === "22222222222" ||
value === "33333333333" ||
value === "44444444444" ||
value === "55555555555" ||
value === "66666666666" ||
value === "77777777777" ||
value === "88888888888" ||
value === "99999999999"
) {
return false;
}
for ( i = 1; i <= 9; i++ ) {
sum = sum + parseInt( value.substring( i - 1, i ), 10 ) * ( 11 - i );
}
if ( checkResult( sum, firstCN ) ) {
sum = 0;
for ( i = 1; i <= 10; i++ ) {
sum = sum + parseInt( value.substring( i - 1, i ), 10 ) * ( 12 - i );
}
return checkResult( sum, secondCN );
}
return false;
}, "Please specify a valid CPF number" );
$.validator.addMethod( "creditcard", function( value, element ) {
if ( this.optional( element ) ) {
return "dependency-mismatch";
}
if ( /[^0-9 \-]+/.test( value ) ) {
return false;
}
var nCheck = 0,
nDigit = 0,
bEven = false,
n, cDigit;
value = value.replace( /\D/g, "" );
if ( value.length < 13 || value.length > 19 ) {
return false;
}
for ( n = value.length - 1; n >= 0; n-- ) {
cDigit = value.charAt( n );
nDigit = parseInt( cDigit, 10 );
if ( bEven ) {
if ( ( nDigit *= 2 ) > 9 ) {
nDigit -= 9;
}
}
nCheck += nDigit;
bEven = !bEven;
}
return ( nCheck % 10 ) === 0;
}, "Please enter a valid credit card number." );
$.validator.addMethod( "creditcardtypes", function( value, element, param ) {
if ( /[^0-9\-]+/.test( value ) ) {
return false;
}
value = value.replace( /\D/g, "" );
var validTypes = 0x0000;
if ( param.mastercard ) {
validTypes |= 0x0001;
}
if ( param.visa ) {
validTypes |= 0x0002;
}
if ( param.amex ) {
validTypes |= 0x0004;
}
if ( param.dinersclub ) {
validTypes |= 0x0008;
}
if ( param.enroute ) {
validTypes |= 0x0010;
}
if ( param.discover ) {
validTypes |= 0x0020;
}
if ( param.jcb ) {
validTypes |= 0x0040;
}
if ( param.unknown ) {
validTypes |= 0x0080;
}
if ( param.all ) {
validTypes = 0x0001 | 0x0002 | 0x0004 | 0x0008 | 0x0010 | 0x0020 | 0x0040 | 0x0080;
}
if ( validTypes & 0x0001 && /^(5[12345])/.test( value ) ) { // Mastercard
return value.length === 16;
}
if ( validTypes & 0x0002 && /^(4)/.test( value ) ) { // Visa
return value.length === 16;
}
if ( validTypes & 0x0004 && /^(3[47])/.test( value ) ) { // Amex
return value.length === 15;
}
if ( validTypes & 0x0008 && /^(3(0[012345]|[68]))/.test( value ) ) { // Dinersclub
return value.length === 14;
}
if ( validTypes & 0x0010 && /^(2(014|149))/.test( value ) ) { // Enroute
return value.length === 15;
}
if ( validTypes & 0x0020 && /^(6011)/.test( value ) ) { // Discover
return value.length === 16;
}
if ( validTypes & 0x0040 && /^(3)/.test( value ) ) { // Jcb
return value.length === 16;
}
if ( validTypes & 0x0040 && /^(2131|1800)/.test( value ) ) { // Jcb
return value.length === 15;
}
if ( validTypes & 0x0080 ) { // Unknown
return true;
}
return false;
}, "Please enter a valid credit card number." );
$.validator.addMethod( "currency", function( value, element, param ) {
var isParamString = typeof param === "string",
symbol = isParamString ? param : param[ 0 ],
soft = isParamString ? true : param[ 1 ],
regex;
symbol = symbol.replace( /,/g, "" );
symbol = soft ? symbol + "]" : symbol + "]?";
regex = "^[" + symbol + "([1-9]{1}[0-9]{0,2}(\\,[0-9]{3})*(\\.[0-9]{0,2})?|[1-9]{1}[0-9]{0,}(\\.[0-9]{0,2})?|0(\\.[0-9]{0,2})?|(\\.[0-9]{1,2})?)$";
regex = new RegExp( regex );
return this.optional( element ) || regex.test( value );
}, "Please specify a valid currency" );
$.validator.addMethod( "dateFA", function( value, element ) {
return this.optional( element ) || /^[1-4]\d{3}\/((0?[1-6]\/((3[0-1])|([1-2][0-9])|(0?[1-9])))|((1[0-2]|(0?[7-9]))\/(30|([1-2][0-9])|(0?[1-9]))))$/.test( value );
}, $.validator.messages.date );
$.validator.addMethod( "dateITA", function( value, element ) {
var check = false,
re = /^\d{1,2}\/\d{1,2}\/\d{4}$/,
adata, gg, mm, aaaa, xdata;
if ( re.test( value ) ) {
adata = value.split( "/" );
gg = parseInt( adata[ 0 ], 10 );
mm = parseInt( adata[ 1 ], 10 );
aaaa = parseInt( adata[ 2 ], 10 );
xdata = new Date( Date.UTC( aaaa, mm - 1, gg, 12, 0, 0, 0 ) );
if ( ( xdata.getUTCFullYear() === aaaa ) && ( xdata.getUTCMonth() === mm - 1 ) && ( xdata.getUTCDate() === gg ) ) {
check = true;
} else {
check = false;
}
} else {
check = false;
}
return this.optional( element ) || check;
}, $.validator.messages.date );
$.validator.addMethod( "dateNL", function( value, element ) {
return this.optional( element ) || /^(0?[1-9]|[12]\d|3[01])[\.\/\-](0?[1-9]|1[012])[\.\/\-]([12]\d)?(\d\d)$/.test( value );
}, $.validator.messages.date );
$.validator.addMethod( "extension", function( value, element, param ) {
param = typeof param === "string" ? param.replace( /,/g, "|" ) : "png|jpe?g|gif";
return this.optional( element ) || value.match( new RegExp( "\\.(" + param + ")$", "i" ) );
}, $.validator.format( "Please enter a value with a valid extension." ) );
$.validator.addMethod( "giroaccountNL", function( value, element ) {
return this.optional( element ) || /^[0-9]{1,7}$/.test( value );
}, "Please specify a valid giro account number" );
$.validator.addMethod( "iban", function( value, element ) {
if ( this.optional( element ) ) {
return true;
}
var iban = value.replace( / /g, "" ).toUpperCase(),
ibancheckdigits = "",
leadingZeroes = true,
cRest = "",
cOperator = "",
countrycode, ibancheck, charAt, cChar, bbanpattern, bbancountrypatterns, ibanregexp, i, p;
var minimalIBANlength = 5;
if ( iban.length < minimalIBANlength ) {
return false;
}
countrycode = iban.substring( 0, 2 );
bbancountrypatterns = {
"AL": "\\d{8}[\\dA-Z]{16}",
"AD": "\\d{8}[\\dA-Z]{12}",
"AT": "\\d{16}",
"AZ": "[\\dA-Z]{4}\\d{20}",
"BE": "\\d{12}",
"BH": "[A-Z]{4}[\\dA-Z]{14}",
"BA": "\\d{16}",
"BR": "\\d{23}[A-Z][\\dA-Z]",
"BG": "[A-Z]{4}\\d{6}[\\dA-Z]{8}",
"CR": "\\d{17}",
"HR": "\\d{17}",
"CY": "\\d{8}[\\dA-Z]{16}",
"CZ": "\\d{20}",
"DK": "\\d{14}",
"DO": "[A-Z]{4}\\d{20}",
"EE": "\\d{16}",
"FO": "\\d{14}",
"FI": "\\d{14}",
"FR": "\\d{10}[\\dA-Z]{11}\\d{2}",
"GE": "[\\dA-Z]{2}\\d{16}",
"DE": "\\d{18}",
"GI": "[A-Z]{4}[\\dA-Z]{15}",
"GR": "\\d{7}[\\dA-Z]{16}",
"GL": "\\d{14}",
"GT": "[\\dA-Z]{4}[\\dA-Z]{20}",
"HU": "\\d{24}",
"IS": "\\d{22}",
"IE": "[\\dA-Z]{4}\\d{14}",
"IL": "\\d{19}",
"IT": "[A-Z]\\d{10}[\\dA-Z]{12}",
"KZ": "\\d{3}[\\dA-Z]{13}",
"KW": "[A-Z]{4}[\\dA-Z]{22}",
"LV": "[A-Z]{4}[\\dA-Z]{13}",
"LB": "\\d{4}[\\dA-Z]{20}",
"LI": "\\d{5}[\\dA-Z]{12}",
"LT": "\\d{16}",
"LU": "\\d{3}[\\dA-Z]{13}",
"MK": "\\d{3}[\\dA-Z]{10}\\d{2}",
"MT": "[A-Z]{4}\\d{5}[\\dA-Z]{18}",
"MR": "\\d{23}",
"MU": "[A-Z]{4}\\d{19}[A-Z]{3}",
"MC": "\\d{10}[\\dA-Z]{11}\\d{2}",
"MD": "[\\dA-Z]{2}\\d{18}",
"ME": "\\d{18}",
"NL": "[A-Z]{4}\\d{10}",
"NO": "\\d{11}",
"PK": "[\\dA-Z]{4}\\d{16}",
"PS": "[\\dA-Z]{4}\\d{21}",
"PL": "\\d{24}",
"PT": "\\d{21}",
"RO": "[A-Z]{4}[\\dA-Z]{16}",
"SM": "[A-Z]\\d{10}[\\dA-Z]{12}",
"SA": "\\d{2}[\\dA-Z]{18}",
"RS": "\\d{18}",
"SK": "\\d{20}",
"SI": "\\d{15}",
"ES": "\\d{20}",
"SE": "\\d{20}",
"CH": "\\d{5}[\\dA-Z]{12}",
"TN": "\\d{20}",
"TR": "\\d{5}[\\dA-Z]{17}",
"AE": "\\d{3}\\d{16}",
"GB": "[A-Z]{4}\\d{14}",
"VG": "[\\dA-Z]{4}\\d{16}"
};
bbanpattern = bbancountrypatterns[ countrycode ];
if ( typeof bbanpattern !== "undefined" ) {
ibanregexp = new RegExp( "^[A-Z]{2}\\d{2}" + bbanpattern + "$", "" );
if ( !( ibanregexp.test( iban ) ) ) {
return false; // Invalid country specific format
}
}
ibancheck = iban.substring( 4, iban.length ) + iban.substring( 0, 4 );
for ( i = 0; i < ibancheck.length; i++ ) {
charAt = ibancheck.charAt( i );
if ( charAt !== "0" ) {
leadingZeroes = false;
}
if ( !leadingZeroes ) {
ibancheckdigits += "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ".indexOf( charAt );
}
}
for ( p = 0; p < ibancheckdigits.length; p++ ) {
cChar = ibancheckdigits.charAt( p );
cOperator = "" + cRest + "" + cChar;
cRest = cOperator % 97;
}
return cRest === 1;
}, "Please specify a valid IBAN" );
$.validator.addMethod( "integer", function( value, element ) {
return this.optional( element ) || /^-?\d+$/.test( value );
}, "A positive or negative non-decimal number please" );
$.validator.addMethod( "ipv4", function( value, element ) {
return this.optional( element ) || /^(25[0-5]|2[0-4]\d|[01]?\d\d?)\.(25[0-5]|2[0-4]\d|[01]?\d\d?)\.(25[0-5]|2[0-4]\d|[01]?\d\d?)\.(25[0-5]|2[0-4]\d|[01]?\d\d?)$/i.test( value );
}, "Please enter a valid IP v4 address." );
$.validator.addMethod( "ipv6", function( value, element ) {
return this.optional( element ) || /^((([0-9A-Fa-f]{1,4}:){7}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){6}:[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){5}:([0-9A-Fa-f]{1,4}:)?[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){4}:([0-9A-Fa-f]{1,4}:){0,2}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){3}:([0-9A-Fa-f]{1,4}:){0,3}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){2}:([0-9A-Fa-f]{1,4}:){0,4}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){6}((\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b)\.){3}(\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b))|(([0-9A-Fa-f]{1,4}:){0,5}:((\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b)\.){3}(\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b))|(::([0-9A-Fa-f]{1,4}:){0,5}((\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b)\.){3}(\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b))|([0-9A-Fa-f]{1,4}::([0-9A-Fa-f]{1,4}:){0,5}[0-9A-Fa-f]{1,4})|(::([0-9A-Fa-f]{1,4}:){0,6}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){1,7}:))$/i.test( value );
}, "Please enter a valid IP v6 address." );
$.validator.addMethod( "lettersonly", function( value, element ) {
return this.optional( element ) || /^[a-z]+$/i.test( value );
}, "Letters only please" );
$.validator.addMethod( "letterswithbasicpunc", function( value, element ) {
return this.optional( element ) || /^[a-z\-.,()'"\s]+$/i.test( value );
}, "Letters or punctuation only please" );
$.validator.addMethod( "mobileNL", function( value, element ) {
return this.optional( element ) || /^((\+|00(\s|\s?\-\s?)?)31(\s|\s?\-\s?)?(\(0\)[\-\s]?)?|0)6((\s|\s?\-\s?)?[0-9]){8}$/.test( value );
}, "Please specify a valid mobile number" );
$.validator.addMethod( "mobileUK", function( phone_number, element ) {
phone_number = phone_number.replace( /\(|\)|\s+|-/g, "" );
return this.optional( element ) || phone_number.length > 9 &&
phone_number.match( /^(?:(?:(?:00\s?|\+)44\s?|0)7(?:[1345789]\d{2}|624)\s?\d{3}\s?\d{3})$/ );
}, "Please specify a valid mobile number" );
$.validator.addMethod( "netmask", function( value, element ) {
return this.optional( element ) || /^(254|252|248|240|224|192|128)\.0\.0\.0|255\.(254|252|248|240|224|192|128|0)\.0\.0|255\.255\.(254|252|248|240|224|192|128|0)\.0|255\.255\.255\.(254|252|248|240|224|192|128|0)/i.test( value );
}, "Please enter a valid netmask." );
$.validator.addMethod( "nieES", function( value, element ) {
"use strict";
if ( this.optional( element ) ) {
return true;
}
var nieRegEx = new RegExp( /^[MXYZ]{1}[0-9]{7,8}[TRWAGMYFPDXBNJZSQVHLCKET]{1}$/gi );
var validChars = "TRWAGMYFPDXBNJZSQVHLCKET",
letter = value.substr( value.length - 1 ).toUpperCase(),
number;
value = value.toString().toUpperCase();
if ( value.length > 10 || value.length < 9 || !nieRegEx.test( value ) ) {
return false;
}
value = value.replace( /^[X]/, "0" )
.replace( /^[Y]/, "1" )
.replace( /^[Z]/, "2" );
number = value.length === 9 ? value.substr( 0, 8 ) : value.substr( 0, 9 );
return validChars.charAt( parseInt( number, 10 ) % 23 ) === letter;
}, "Please specify a valid NIE number." );
$.validator.addMethod( "nifES", function( value, element ) {
"use strict";
if ( this.optional( element ) ) {
return true;
}
value = value.toUpperCase();
if ( !value.match( "((^[A-Z]{1}[0-9]{7}[A-Z0-9]{1}$|^[T]{1}[A-Z0-9]{8}$)|^[0-9]{8}[A-Z]{1}$)" ) ) {
return false;
}
if ( /^[0-9]{8}[A-Z]{1}$/.test( value ) ) {
return ( "TRWAGMYFPDXBNJZSQVHLCKE".charAt( value.substring( 8, 0 ) % 23 ) === value.charAt( 8 ) );
}
if ( /^[KLM]{1}/.test( value ) ) {
return ( value[ 8 ] === "TRWAGMYFPDXBNJZSQVHLCKE".charAt( value.substring( 8, 1 ) % 23 ) );
}
return false;
}, "Please specify a valid NIF number." );
$.validator.addMethod( "nipPL", function( value ) {
"use strict";
value = value.replace( /[^0-9]/g, "" );
if ( value.length !== 10 ) {
return false;
}
var arrSteps = [ 6, 5, 7, 2, 3, 4, 5, 6, 7 ];
var intSum = 0;
for ( var i = 0; i < 9; i++ ) {
intSum += arrSteps[ i ] * value[ i ];
}
var int2 = intSum % 11;
var intControlNr = ( int2 === 10 ) ? 0 : int2;
return ( intControlNr === parseInt( value[ 9 ], 10 ) );
}, "Please specify a valid NIP number." );
$.validator.addMethod( "notEqualTo", function( value, element, param ) {
return this.optional( element ) || !$.validator.methods.equalTo.call( this, value, element, param );
}, "Please enter a different value, values must not be the same." );
$.validator.addMethod( "nowhitespace", function( value, element ) {
return this.optional( element ) || /^\S+$/i.test( value );
}, "No white space please" );
$.validator.addMethod( "pattern", function( value, element, param ) {
if ( this.optional( element ) ) {
return true;
}
if ( typeof param === "string" ) {
param = new RegExp( "^(?:" + param + ")$" );
}
return param.test( value );
}, "Invalid format." );
$.validator.addMethod( "phoneNL", function( value, element ) {
return this.optional( element ) || /^((\+|00(\s|\s?\-\s?)?)31(\s|\s?\-\s?)?(\(0\)[\-\s]?)?|0)[1-9]((\s|\s?\-\s?)?[0-9]){8}$/.test( value );
}, "Please specify a valid phone number." );
$.validator.addMethod( "phonesUK", function( phone_number, element ) {
phone_number = phone_number.replace( /\(|\)|\s+|-/g, "" );
return this.optional( element ) || phone_number.length > 9 &&
phone_number.match( /^(?:(?:(?:00\s?|\+)44\s?|0)(?:1\d{8,9}|[23]\d{9}|7(?:[1345789]\d{8}|624\d{6})))$/ );
}, "Please specify a valid uk phone number" );
$.validator.addMethod( "phoneUK", function( phone_number, element ) {
phone_number = phone_number.replace( /\(|\)|\s+|-/g, "" );
return this.optional( element ) || phone_number.length > 9 &&
phone_number.match( /^(?:(?:(?:00\s?|\+)44\s?)|(?:\(?0))(?:\d{2}\)?\s?\d{4}\s?\d{4}|\d{3}\)?\s?\d{3}\s?\d{3,4}|\d{4}\)?\s?(?:\d{5}|\d{3}\s?\d{3})|\d{5}\)?\s?\d{4,5})$/ );
}, "Please specify a valid phone number" );
$.validator.addMethod( "phoneUS", function( phone_number, element ) {
phone_number = phone_number.replace( /\s+/g, "" );
return this.optional( element ) || phone_number.length > 9 &&
phone_number.match( /^(\+?1-?)?(\([2-9]([02-9]\d|1[02-9])\)|[2-9]([02-9]\d|1[02-9]))-?[2-9]([02-9]\d|1[02-9])-?\d{4}$/ );
}, "Please specify a valid phone number" );
$.validator.addMethod( "postalcodeBR", function( cep_value, element ) {
return this.optional( element ) || /^\d{2}.\d{3}-\d{3}?$|^\d{5}-?\d{3}?$/.test( cep_value );
}, "Informe um CEP vlido." );
$.validator.addMethod( "postalCodeCA", function( value, element ) {
return this.optional( element ) || /^[ABCEGHJKLMNPRSTVXY]\d[ABCEGHJKLMNPRSTVWXYZ] *\d[ABCEGHJKLMNPRSTVWXYZ]\d$/i.test( value );
}, "Please specify a valid postal code" );
$.validator.addMethod( "postalcodeIT", function( value, element ) {
return this.optional( element ) || /^\d{5}$/.test( value );
}, "Please specify a valid postal code" );
$.validator.addMethod( "postalcodeNL", function( value, element ) {
return this.optional( element ) || /^[1-9][0-9]{3}\s?[a-zA-Z]{2}$/.test( value );
}, "Please specify a valid postal code" );
$.validator.addMethod( "postcodeUK", function( value, element ) {
return this.optional( element ) || /^((([A-PR-UWYZ][0-9])|([A-PR-UWYZ][0-9][0-9])|([A-PR-UWYZ][A-HK-Y][0-9])|([A-PR-UWYZ][A-HK-Y][0-9][0-9])|([A-PR-UWYZ][0-9][A-HJKSTUW])|([A-PR-UWYZ][A-HK-Y][0-9][ABEHMNPRVWXY]))\s?([0-9][ABD-HJLNP-UW-Z]{2})|(GIR)\s?(0AA))$/i.test( value );
}, "Please specify a valid UK postcode" );
$.validator.addMethod( "require_from_group", function( value, element, options ) {
var $fields = $( options[ 1 ], element.form ),
$fieldsFirst = $fields.eq( 0 ),
validator = $fieldsFirst.data( "valid_req_grp" ) ? $fieldsFirst.data( "valid_req_grp" ) : $.extend( {}, this ),
isValid = $fields.filter( function() {
return validator.elementValue( this );
} ).length >= options[ 0 ];
$fieldsFirst.data( "valid_req_grp", validator );
if ( !$( element ).data( "being_validated" ) ) {
$fields.data( "being_validated", true );
$fields.each( function() {
validator.element( this );
} );
$fields.data( "being_validated", false );
}
return isValid;
}, $.validator.format( "Please fill at least {0} of these fields." ) );
$.validator.addMethod( "skip_or_fill_minimum", function( value, element, options ) {
var $fields = $( options[ 1 ], element.form ),
$fieldsFirst = $fields.eq( 0 ),
validator = $fieldsFirst.data( "valid_skip" ) ? $fieldsFirst.data( "valid_skip" ) : $.extend( {}, this ),
numberFilled = $fields.filter( function() {
return validator.elementValue( this );
} ).length,
isValid = numberFilled === 0 || numberFilled >= options[ 0 ];
$fieldsFirst.data( "valid_skip", validator );
if ( !$( element ).data( "being_validated" ) ) {
$fields.data( "being_validated", true );
$fields.each( function() {
validator.element( this );
} );
$fields.data( "being_validated", false );
}
return isValid;
}, $.validator.format( "Please either skip these fields or fill at least {0} of them." ) );
$.validator.addMethod( "stateUS", function( value, element, options ) {
var isDefault = typeof options === "undefined",
caseSensitive = ( isDefault || typeof options.caseSensitive === "undefined" ) ? false : options.caseSensitive,
includeTerritories = ( isDefault || typeof options.includeTerritories === "undefined" ) ? false : options.includeTerritories,
includeMilitary = ( isDefault || typeof options.includeMilitary === "undefined" ) ? false : options.includeMilitary,
regex;
if ( !includeTerritories && !includeMilitary ) {
regex = "^(A[KLRZ]|C[AOT]|D[CE]|FL|GA|HI|I[ADLN]|K[SY]|LA|M[ADEINOST]|N[CDEHJMVY]|O[HKR]|PA|RI|S[CD]|T[NX]|UT|V[AT]|W[AIVY])$";
} else if ( includeTerritories && includeMilitary ) {
regex = "^(A[AEKLPRSZ]|C[AOT]|D[CE]|FL|G[AU]|HI|I[ADLN]|K[SY]|LA|M[ADEINOPST]|N[CDEHJMVY]|O[HKR]|P[AR]|RI|S[CD]|T[NX]|UT|V[AIT]|W[AIVY])$";
} else if ( includeTerritories ) {
regex = "^(A[KLRSZ]|C[AOT]|D[CE]|FL|G[AU]|HI|I[ADLN]|K[SY]|LA|M[ADEINOPST]|N[CDEHJMVY]|O[HKR]|P[AR]|RI|S[CD]|T[NX]|UT|V[AIT]|W[AIVY])$";
} else {
regex = "^(A[AEKLPRZ]|C[AOT]|D[CE]|FL|GA|HI|I[ADLN]|K[SY]|LA|M[ADEINOST]|N[CDEHJMVY]|O[HKR]|PA|RI|S[CD]|T[NX]|UT|V[AT]|W[AIVY])$";
}
regex = caseSensitive ? new RegExp( regex ) : new RegExp( regex, "i" );
return this.optional( element ) || regex.test( value );
}, "Please specify a valid state" );
$.validator.addMethod( "strippedminlength", function( value, element, param ) {
return $( value ).text().length >= param;
}, $.validator.format( "Please enter at least {0} characters" ) );
$.validator.addMethod( "time", function( value, element ) {
return this.optional( element ) || /^([01]\d|2[0-3]|[0-9])(:[0-5]\d){1,2}$/.test( value );
}, "Please enter a valid time, between 00:00 and 23:59" );
$.validator.addMethod( "time12h", function( value, element ) {
return this.optional( element ) || /^((0?[1-9]|1[012])(:[0-5]\d){1,2}(\ ?[AP]M))$/i.test( value );
}, "Please enter a valid time in 12-hour am/pm format" );
$.validator.addMethod( "url2", function( value, element ) {
return this.optional( element ) || /^(https?|ftp):\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)*(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i.test( value );
}, $.validator.messages.url );
$.validator.addMethod( "vinUS", function( v ) {
if ( v.length !== 17 ) {
return false;
}
var LL = [ "A", "B", "C", "D", "E", "F", "G", "H", "J", "K", "L", "M", "N", "P", "R", "S", "T", "U", "V", "W", "X", "Y", "Z" ],
VL = [ 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 7, 9, 2, 3, 4, 5, 6, 7, 8, 9 ],
FL = [ 8, 7, 6, 5, 4, 3, 2, 10, 0, 9, 8, 7, 6, 5, 4, 3, 2 ],
rs = 0,
i, n, d, f, cd, cdv;
for ( i = 0; i < 17; i++ ) {
f = FL[ i ];
d = v.slice( i, i + 1 );
if ( i === 8 ) {
cdv = d;
}
if ( !isNaN( d ) ) {
d *= f;
} else {
for ( n = 0; n < LL.length; n++ ) {
if ( d.toUpperCase() === LL[ n ] ) {
d = VL[ n ];
d *= f;
if ( isNaN( cdv ) && n === 8 ) {
cdv = LL[ n ];
}
break;
}
}
}
rs += d;
}
cd = rs % 11;
if ( cd === 10 ) {
cd = "X";
}
if ( cd === cdv ) {
return true;
}
return false;
}, "The specified vehicle identification number (VIN) is invalid." );
$.validator.addMethod( "zipcodeUS", function( value, element ) {
return this.optional( element ) || /^\d{5}(-\d{4})?$/.test( value );
}, "The specified US ZIP Code is invalid" );
$.validator.addMethod( "ziprange", function( value, element ) {
return this.optional( element ) || /^90[2-5]\d\{2\}-\d{4}$/.test( value );
}, "Your ZIP-code must be in the range 902xx-xxxx to 905xx-xxxx" );
return $;
}));
jQuery.validator.setDefaults({
errorElement: 'div', //default input error message container
errorClass: 'form-control-feedback', // default input error message class
focusInvalid: false, // do not focus the last invalid input
ignore: "",  // validate all fields including form hidden input
errorPlacement: function(error, element) { // render error placement for each input type
var group = $(element).closest('.m-form__group-sub').length > 0 ? $(element).closest('.m-form__group-sub') : $(element).closest('.m-form__group');
var help = group.find('.m-form__help');
if (group.find('.form-control-feedback').length !== 0) {
return;
}
if (help.length > 0) {
help.before(error);
} else {
if ($(element).closest('.input-group').length > 0) {
$(element).closest('.input-group').after(error);
} else {
if ($(element).is(':checkbox')) {
$(element).closest('.m-checkbox').find('>span').after(error);
} else {
$(element).after(error);
}
}
}
},
highlight: function(element) { // hightlight error inputs
var group = $(element).closest('.m-form__group-sub').length > 0  ? $(element).closest('.m-form__group-sub') : $(element).closest('.m-form__group');
console.log('add' + group.attr('class'));
group.addClass('has-danger'); // set error class to the control groupx
},
unhighlight: function(element) { // revert the change done by hightlight
var group = $(element).closest('.m-form__group-sub').length > 0  ? $(element).closest('.m-form__group-sub') : $(element).closest('.m-form__group');
group.removeClass('has-danger'); // set error class to the control group
},
success: function(label, element) {
var group = $(label).closest('.m-form__group-sub').length > 0  ? $(label).closest('.m-form__group-sub') : $(label).closest('.m-form__group');
group.removeClass('has-danger'); // hide error class
group.find('.form-control-feedback').remove();
}
});
jQuery.validator.addMethod("email", function(value, element) {
if (/^([a-zA-Z0-9_\.\-])+\@(([a-zA-Z0-9\-])+\.)+([a-zA-Z0-9]{2,4})+$/.test(value)) {
return true;
} else {
return false;
}
}, "Please enter a valid Email.");
!function(a){"function"==typeof define&&define.amd?define(["jquery"],a):a("object"==typeof exports?require("jquery"):jQuery)}(function(a){function b(b,d,e){var d={content:{message:"object"==typeof d?d.message:d,title:d.title?d.title:"",icon:d.icon?d.icon:"",url:d.url?d.url:"#",target:d.target?d.target:"-"}};e=a.extend(!0,{},d,e),this.settings=a.extend(!0,{},c,e),this._defaults=c,"-"==this.settings.content.target&&(this.settings.content.target=this.settings.url_target),this.animations={start:"webkitAnimationStart oanimationstart MSAnimationStart animationstart",end:"webkitAnimationEnd oanimationend MSAnimationEnd animationend"},"number"==typeof this.settings.offset&&(this.settings.offset={x:this.settings.offset,y:this.settings.offset}),this.init()}var c={element:"body",position:null,type:"info",allow_dismiss:!0,newest_on_top:!1,showProgressbar:!1,placement:{from:"top",align:"right"},offset:20,spacing:10,z_index:1031,delay:5e3,timer:1e3,url_target:"_blank",mouse_over:null,animate:{enter:"animated fadeInDown",exit:"animated fadeOutUp"},onShow:null,onShown:null,onClose:null,onClosed:null,icon_type:"class",template:'<div data-notify="container" class="col-xs-11 col-sm-4 alert alert-{0}" role="alert"><button type="button" aria-hidden="true" class="close" data-notify="dismiss">&times;</button><span data-notify="icon"></span> <span data-notify="title">{1}</span> <span data-notify="message">{2}</span><div class="progress" data-notify="progressbar"><div class="progress-bar progress-bar-{0}" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" style="width: 0%;"></div></div><a href="{3}" target="{4}" data-notify="url"></a></div>'};String.format=function(){for(var a=arguments[0],b=1;b<arguments.length;b++)a=a.replace(RegExp("\\{"+(b-1)+"\\}","gm"),arguments[b]);return a},a.extend(b.prototype,{init:function(){var a=this;this.buildNotify(),this.settings.content.icon&&this.setIcon(),"#"!=this.settings.content.url&&this.styleURL(),this.styleDismiss(),this.placement(),this.bind(),this.notify={$ele:this.$ele,update:function(b,c){var d={};"string"==typeof b?d[b]=c:d=b;for(var b in d)switch(b){case"type":this.$ele.removeClass("alert-"+a.settings.type),this.$ele.find('[data-notify="progressbar"] > .progress-bar').removeClass("progress-bar-"+a.settings.type),a.settings.type=d[b],this.$ele.addClass("alert-"+d[b]).find('[data-notify="progressbar"] > .progress-bar').addClass("progress-bar-"+d[b]);break;case"icon":var e=this.$ele.find('[data-notify="icon"]');"class"==a.settings.icon_type.toLowerCase()?e.removeClass(a.settings.content.icon).addClass(d[b]):(e.is("img")||e.find("img"),e.attr("src",d[b]));break;case"progress":var f=a.settings.delay-a.settings.delay*(d[b]/100);this.$ele.data("notify-delay",f),this.$ele.find('[data-notify="progressbar"] > div').attr("aria-valuenow",d[b]).css("width",d[b]+"%");break;case"url":this.$ele.find('[data-notify="url"]').attr("href",d[b]);break;case"target":this.$ele.find('[data-notify="url"]').attr("target",d[b]);break;default:this.$ele.find('[data-notify="'+b+'"]').html(d[b])}var g=this.$ele.outerHeight()+parseInt(a.settings.spacing)+parseInt(a.settings.offset.y);a.reposition(g)},close:function(){a.close()}}},buildNotify:function(){var b=this.settings.content;this.$ele=a(String.format(this.settings.template,this.settings.type,b.title,b.message,b.url,b.target)),this.$ele.attr("data-notify-position",this.settings.placement.from+"-"+this.settings.placement.align),this.settings.allow_dismiss||this.$ele.find('[data-notify="dismiss"]').css("display","none"),(this.settings.delay<=0&&!this.settings.showProgressbar||!this.settings.showProgressbar)&&this.$ele.find('[data-notify="progressbar"]').remove()},setIcon:function(){"class"==this.settings.icon_type.toLowerCase()?this.$ele.find('[data-notify="icon"]').addClass(this.settings.content.icon):this.$ele.find('[data-notify="icon"]').is("img")?this.$ele.find('[data-notify="icon"]').attr("src",this.settings.content.icon):this.$ele.find('[data-notify="icon"]').append('<img src="'+this.settings.content.icon+'" alt="Notify Icon" />')},styleDismiss:function(){this.$ele.find('[data-notify="dismiss"]').css({position:"absolute",right:"10px",top:"5px",zIndex:this.settings.z_index+2})},styleURL:function(){this.$ele.find('[data-notify="url"]').css({backgroundImage:"url(data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)",height:"100%",left:"0px",position:"absolute",top:"0px",width:"100%",zIndex:this.settings.z_index+1})},placement:function(){var b=this,c=this.settings.offset.y,d={display:"inline-block",margin:"0px auto",position:this.settings.position?this.settings.position:"body"===this.settings.element?"fixed":"absolute",transition:"all .5s ease-in-out",zIndex:this.settings.z_index},e=!1,f=this.settings;switch(a('[data-notify-position="'+this.settings.placement.from+"-"+this.settings.placement.align+'"]:not([data-closing="true"])').each(function(){return c=Math.max(c,parseInt(a(this).css(f.placement.from))+parseInt(a(this).outerHeight())+parseInt(f.spacing))}),1==this.settings.newest_on_top&&(c=this.settings.offset.y),d[this.settings.placement.from]=c+"px",this.settings.placement.align){case"left":case"right":d[this.settings.placement.align]=this.settings.offset.x+"px";break;case"center":d.left=0,d.right=0}this.$ele.css(d).addClass(this.settings.animate.enter),a.each(Array("webkit","moz","o","ms",""),function(a,c){b.$ele[0].style[c+"AnimationIterationCount"]=1}),a(this.settings.element).append(this.$ele),1==this.settings.newest_on_top&&(c=parseInt(c)+parseInt(this.settings.spacing)+this.$ele.outerHeight(),this.reposition(c)),a.isFunction(b.settings.onShow)&&b.settings.onShow.call(this.$ele),this.$ele.one(this.animations.start,function(a){e=!0}).one(this.animations.end,function(c){a.isFunction(b.settings.onShown)&&b.settings.onShown.call(this)}),setTimeout(function(){e||a.isFunction(b.settings.onShown)&&b.settings.onShown.call(this)},600)},bind:function(){var b=this;if(this.$ele.find('[data-notify="dismiss"]').on("click",function(){b.close()}),this.$ele.mouseover(function(b){a(this).data("data-hover","true")}).mouseout(function(b){a(this).data("data-hover","false")}),this.$ele.data("data-hover","false"),this.settings.delay>0){b.$ele.data("notify-delay",b.settings.delay);var c=setInterval(function(){var a=parseInt(b.$ele.data("notify-delay"))-b.settings.timer;if("false"===b.$ele.data("data-hover")&&"pause"==b.settings.mouse_over||"pause"!=b.settings.mouse_over){var d=(b.settings.delay-a)/b.settings.delay*100;b.$ele.data("notify-delay",a),b.$ele.find('[data-notify="progressbar"] > div').attr("aria-valuenow",d).css("width",d+"%")}a<=-b.settings.timer&&(clearInterval(c),b.close())},b.settings.timer)}},close:function(){var b=this,c=parseInt(this.$ele.css(this.settings.placement.from)),d=!1;this.$ele.data("closing","true").addClass(this.settings.animate.exit),b.reposition(c),a.isFunction(b.settings.onClose)&&b.settings.onClose.call(this.$ele),this.$ele.one(this.animations.start,function(a){d=!0}).one(this.animations.end,function(c){a(this).remove(),a.isFunction(b.settings.onClosed)&&b.settings.onClosed.call(this)}),setTimeout(function(){d||(b.$ele.remove(),b.settings.onClosed&&b.settings.onClosed(b.$ele))},600)},reposition:function(b){var c=this,d='[data-notify-position="'+this.settings.placement.from+"-"+this.settings.placement.align+'"]:not([data-closing="true"])',e=this.$ele.nextAll(d);1==this.settings.newest_on_top&&(e=this.$ele.prevAll(d)),e.each(function(){a(this).css(c.settings.placement.from,b),b=parseInt(b)+parseInt(c.settings.spacing)+a(this).outerHeight()})}}),a.notify=function(a,c){var d=new b(this,a,c);return d.notify},a.notifyDefaults=function(b){return c=a.extend(!0,{},c,b)},a.notifyClose=function(b){"undefined"==typeof b||"all"==b?a("[data-notify]").find('[data-notify="dismiss"]').trigger("click"):a('[data-notify-position="'+b+'"]').find('[data-notify="dismiss"]').trigger("click")}});
$.notifyDefaults({
template: '' +
'<div data-notify="container" class="alert alert-{0} m-alert" role="alert">' +
'<button type="button" aria-hidden="true" class="close" data-notify="dismiss"></button>' +
'<span data-notify="icon"></span>' +
'<span data-notify="title">{1}</span>' +
'<span data-notify="message">{2}</span>' +
'<div class="progress" data-notify="progressbar">' +
'<div class="progress-bar progress-bar-animated bg-{0}" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100" style="width: 0%;"></div>' +
'</div>' +
'<a href="{3}" target="{4}" data-notify="url"></a>' +
'</div>'
});
!function(e){e(["jquery"],function(e){return function(){function t(e,t,n){return g({type:O.error,iconClass:m().iconClasses.error,message:e,optionsOverride:n,title:t})}function n(t,n){return t||(t=m()),v=e("#"+t.containerId),v.length?v:(n&&(v=d(t)),v)}function o(e,t,n){return g({type:O.info,iconClass:m().iconClasses.info,message:e,optionsOverride:n,title:t})}function s(e){C=e}function i(e,t,n){return g({type:O.success,iconClass:m().iconClasses.success,message:e,optionsOverride:n,title:t})}function a(e,t,n){return g({type:O.warning,iconClass:m().iconClasses.warning,message:e,optionsOverride:n,title:t})}function r(e,t){var o=m();v||n(o),u(e,o,t)||l(o)}function c(t){var o=m();return v||n(o),t&&0===e(":focus",t).length?void h(t):void(v.children().length&&v.remove())}function l(t){for(var n=v.children(),o=n.length-1;o>=0;o--)u(e(n[o]),t)}function u(t,n,o){var s=!(!o||!o.force)&&o.force;return!(!t||!s&&0!==e(":focus",t).length)&&(t[n.hideMethod]({duration:n.hideDuration,easing:n.hideEasing,complete:function(){h(t)}}),!0)}function d(t){return v=e("<div/>").attr("id",t.containerId).addClass(t.positionClass),v.appendTo(e(t.target)),v}function p(){return{tapToDismiss:!0,toastClass:"toast",containerId:"toast-container",debug:!1,showMethod:"fadeIn",showDuration:300,showEasing:"swing",onShown:void 0,hideMethod:"fadeOut",hideDuration:1e3,hideEasing:"swing",onHidden:void 0,closeMethod:!1,closeDuration:!1,closeEasing:!1,closeOnHover:!0,extendedTimeOut:1e3,iconClasses:{error:"toast-error",info:"toast-info",success:"toast-success",warning:"toast-warning"},iconClass:"toast-info",positionClass:"toast-top-right",timeOut:5e3,titleClass:"toast-title",messageClass:"toast-message",escapeHtml:!1,target:"body",closeHtml:'<button type="button">&times;</button>',closeClass:"toast-close-button",newestOnTop:!0,preventDuplicates:!1,progressBar:!1,progressClass:"toast-progress",rtl:!1}}function f(e){C&&C(e)}function g(t){function o(e){return null==e&&(e=""),e.replace(/&/g,"&amp;").replace(/"/g,"&quot;").replace(/'/g,"&#39;").replace(/</g,"&lt;").replace(/>/g,"&gt;")}function s(){c(),u(),d(),p(),g(),C(),l(),i()}function i(){var e="";switch(t.iconClass){case"toast-success":case"toast-info":e="polite";break;default:e="assertive"}I.attr("aria-live",e)}function a(){E.closeOnHover&&I.hover(H,D),!E.onclick&&E.tapToDismiss&&I.click(b),E.closeButton&&j&&j.click(function(e){e.stopPropagation?e.stopPropagation():void 0!==e.cancelBubble&&e.cancelBubble!==!0&&(e.cancelBubble=!0),E.onCloseClick&&E.onCloseClick(e),b(!0)}),E.onclick&&I.click(function(e){E.onclick(e),b()})}function r(){I.hide(),I[E.showMethod]({duration:E.showDuration,easing:E.showEasing,complete:E.onShown}),E.timeOut>0&&(k=setTimeout(b,E.timeOut),F.maxHideTime=parseFloat(E.timeOut),F.hideEta=(new Date).getTime()+F.maxHideTime,E.progressBar&&(F.intervalId=setInterval(x,10)))}function c(){t.iconClass&&I.addClass(E.toastClass).addClass(y)}function l(){E.newestOnTop?v.prepend(I):v.append(I)}function u(){if(t.title){var e=t.title;E.escapeHtml&&(e=o(t.title)),M.append(e).addClass(E.titleClass),I.append(M)}}function d(){if(t.message){var e=t.message;E.escapeHtml&&(e=o(t.message)),B.append(e).addClass(E.messageClass),I.append(B)}}function p(){E.closeButton&&(j.addClass(E.closeClass).attr("role","button"),I.prepend(j))}function g(){E.progressBar&&(q.addClass(E.progressClass),I.prepend(q))}function C(){E.rtl&&I.addClass("rtl")}function O(e,t){if(e.preventDuplicates){if(t.message===w)return!0;w=t.message}return!1}function b(t){var n=t&&E.closeMethod!==!1?E.closeMethod:E.hideMethod,o=t&&E.closeDuration!==!1?E.closeDuration:E.hideDuration,s=t&&E.closeEasing!==!1?E.closeEasing:E.hideEasing;if(!e(":focus",I).length||t)return clearTimeout(F.intervalId),I[n]({duration:o,easing:s,complete:function(){h(I),clearTimeout(k),E.onHidden&&"hidden"!==P.state&&E.onHidden(),P.state="hidden",P.endTime=new Date,f(P)}})}function D(){(E.timeOut>0||E.extendedTimeOut>0)&&(k=setTimeout(b,E.extendedTimeOut),F.maxHideTime=parseFloat(E.extendedTimeOut),F.hideEta=(new Date).getTime()+F.maxHideTime)}function H(){clearTimeout(k),F.hideEta=0,I.stop(!0,!0)[E.showMethod]({duration:E.showDuration,easing:E.showEasing})}function x(){var e=(F.hideEta-(new Date).getTime())/F.maxHideTime*100;q.width(e+"%")}var E=m(),y=t.iconClass||E.iconClass;if("undefined"!=typeof t.optionsOverride&&(E=e.extend(E,t.optionsOverride),y=t.optionsOverride.iconClass||y),!O(E,t)){T++,v=n(E,!0);var k=null,I=e("<div/>"),M=e("<div/>"),B=e("<div/>"),q=e("<div/>"),j=e(E.closeHtml),F={intervalId:null,hideEta:null,maxHideTime:null},P={toastId:T,state:"visible",startTime:new Date,options:E,map:t};return s(),r(),a(),f(P),E.debug&&console&&console.log(P),I}}function m(){return e.extend({},p(),b.options)}function h(e){v||(v=n()),e.is(":visible")||(e.remove(),e=null,0===v.children().length&&(v.remove(),w=void 0))}var v,C,w,T=0,O={error:"error",info:"info",success:"success",warning:"warning"},b={clear:r,remove:c,error:t,getContainer:n,info:o,options:{},subscribe:s,success:i,version:"2.1.4",warning:a};return b}()})}("function"==typeof define&&define.amd?define:function(e,t){"undefined"!=typeof module&&module.exports?module.exports=t(require("jquery")):window.toastr=t(window.jQuery)});
(function (factory) {
"use strict";
if (typeof define === 'function' && define.amd) {
define(['jquery'], factory);
}
else if(typeof module !== 'undefined' && module.exports) {
module.exports = factory(require('jquery'));
}
else {
factory(jQuery);
}
}(function ($, undefined) {
"use strict";
if($.jstree) {
return;
}
var instance_counter = 0,
ccp_node = false,
ccp_mode = false,
ccp_inst = false,
themes_loaded = [],
src = $('script:last').attr('src'),
document = window.document; // local variable is always faster to access then a global
$.jstree = {
version : '3.3.4',
defaults : {
plugins : []
},
plugins : {},
path : src && src.indexOf('/') !== -1 ? src.replace(/\/[^\/]+$/,'') : '',
idregex : /[\\:&!^|()\[\]<>@*'+~#";.,=\- \/${}%?`]/g,
root : '#'
};
$.jstree.create = function (el, options) {
var tmp = new $.jstree.core(++instance_counter),
opt = options;
options = $.extend(true, {}, $.jstree.defaults, options);
if(opt && opt.plugins) {
options.plugins = opt.plugins;
}
$.each(options.plugins, function (i, k) {
if(i !== 'core') {
tmp = tmp.plugin(k, options[k]);
}
});
$(el).data('jstree', tmp);
tmp.init(el, options);
return tmp;
};
$.jstree.destroy = function () {
$('.jstree:jstree').jstree('destroy');
$(document).off('.jstree');
};
$.jstree.core = function (id) {
this._id = id;
this._cnt = 0;
this._wrk = null;
this._data = {
core : {
themes : {
name : false,
dots : false,
icons : false,
ellipsis : false
},
selected : [],
last_error : {},
working : false,
worker_queue : [],
focused : null
}
};
};
$.jstree.reference = function (needle) {
var tmp = null,
obj = null;
if(needle && needle.id && (!needle.tagName || !needle.nodeType)) { needle = needle.id; }
if(!obj || !obj.length) {
try { obj = $(needle); } catch (ignore) { }
}
if(!obj || !obj.length) {
try { obj = $('#' + needle.replace($.jstree.idregex,'\\$&')); } catch (ignore) { }
}
if(obj && obj.length && (obj = obj.closest('.jstree')).length && (obj = obj.data('jstree'))) {
tmp = obj;
}
else {
$('.jstree').each(function () {
var inst = $(this).data('jstree');
if(inst && inst._model.data[needle]) {
tmp = inst;
return false;
}
});
}
return tmp;
};
$.fn.jstree = function (arg) {
var is_method	= (typeof arg === 'string'),
args		= Array.prototype.slice.call(arguments, 1),
result		= null;
if(arg === true && !this.length) { return false; }
this.each(function () {
var instance = $.jstree.reference(this),
method = is_method && instance ? instance[arg] : null;
result = is_method && method ?
method.apply(instance, args) :
null;
if(!instance && !is_method && (arg === undefined || $.isPlainObject(arg))) {
$.jstree.create(this, arg);
}
if( (instance && !is_method) || arg === true ) {
result = instance || false;
}
if(result !== null && result !== undefined) {
return false;
}
});
return result !== null && result !== undefined ?
result : this;
};
$.expr.pseudos.jstree = $.expr.createPseudo(function(search) {
return function(a) {
return $(a).hasClass('jstree') &&
$(a).data('jstree') !== undefined;
};
});
$.jstree.defaults.core = {
data			: false,
strings			: false,
check_callback	: false,
error			: $.noop,
animation		: 200,
multiple		: true,
themes			: {
name			: false,
url				: false,
dir				: false,
dots			: true,
icons			: true,
ellipsis		: false,
stripes			: false,
variant			: false,
responsive		: false
},
expand_selected_onload : true,
worker : true,
force_text : false,
dblclick_toggle : true
};
$.jstree.core.prototype = {
plugin : function (deco, opts) {
var Child = $.jstree.plugins[deco];
if(Child) {
this._data[deco] = {};
Child.prototype = this;
return new Child(opts, this);
}
return this;
},
init : function (el, options) {
this._model = {
data : {},
changed : [],
force_full_redraw : false,
redraw_timeout : false,
default_state : {
loaded : true,
opened : false,
selected : false,
disabled : false
}
};
this._model.data[$.jstree.root] = {
id : $.jstree.root,
parent : null,
parents : [],
children : [],
children_d : [],
state : { loaded : false }
};
this.element = $(el).addClass('jstree jstree-' + this._id);
this.settings = options;
this._data.core.ready = false;
this._data.core.loaded = false;
this._data.core.rtl = (this.element.css("direction") === "rtl");
this.element[this._data.core.rtl ? 'addClass' : 'removeClass']("jstree-rtl");
this.element.attr('role','tree');
if(this.settings.core.multiple) {
this.element.attr('aria-multiselectable', true);
}
if(!this.element.attr('tabindex')) {
this.element.attr('tabindex','0');
}
this.bind();
this.trigger("init");
this._data.core.original_container_html = this.element.find(" > ul > li").clone(true);
this._data.core.original_container_html
.find("li").addBack()
.contents().filter(function() {
return this.nodeType === 3 && (!this.nodeValue || /^\s+$/.test(this.nodeValue));
})
.remove();
this.element.html("<"+"ul class='jstree-container-ul jstree-children' role='group'><"+"li id='j"+this._id+"_loading' class='jstree-initial-node jstree-loading jstree-leaf jstree-last' role='tree-item'><i class='jstree-icon jstree-ocl'></i><"+"a class='jstree-anchor' href='#'><i class='jstree-icon jstree-themeicon-hidden'></i>" + this.get_string("Loading ...") + "</a></li></ul>");
this.element.attr('aria-activedescendant','j' + this._id + '_loading');
this._data.core.li_height = this.get_container_ul().children("li").first().outerHeight() || 24;
this._data.core.node = this._create_prototype_node();
this.trigger("loading");
this.load_node($.jstree.root);
},
destroy : function (keep_html) {
this.trigger("destroy");
if(this._wrk) {
try {
window.URL.revokeObjectURL(this._wrk);
this._wrk = null;
}
catch (ignore) { }
}
if(!keep_html) { this.element.empty(); }
this.teardown();
},
_create_prototype_node : function () {
var _node = document.createElement('LI'), _temp1, _temp2;
_node.setAttribute('role', 'treeitem');
_temp1 = document.createElement('I');
_temp1.className = 'jstree-icon jstree-ocl';
_temp1.setAttribute('role', 'presentation');
_node.appendChild(_temp1);
_temp1 = document.createElement('A');
_temp1.className = 'jstree-anchor';
_temp1.setAttribute('href','#');
_temp1.setAttribute('tabindex','-1');
_temp2 = document.createElement('I');
_temp2.className = 'jstree-icon jstree-themeicon';
_temp2.setAttribute('role', 'presentation');
_temp1.appendChild(_temp2);
_node.appendChild(_temp1);
_temp1 = _temp2 = null;
return _node;
},
teardown : function () {
this.unbind();
this.element
.removeClass('jstree')
.removeData('jstree')
.find("[class^='jstree']")
.addBack()
.attr("class", function () { return this.className.replace(/jstree[^ ]*|$/ig,''); });
this.element = null;
},
bind : function () {
var word = '',
tout = null,
was_click = 0;
this.element
.on("dblclick.jstree", function (e) {
if(e.target.tagName && e.target.tagName.toLowerCase() === "input") { return true; }
if(document.selection && document.selection.empty) {
document.selection.empty();
}
else {
if(window.getSelection) {
var sel = window.getSelection();
try {
sel.removeAllRanges();
sel.collapse();
} catch (ignore) { }
}
}
})
.on("mousedown.jstree", $.proxy(function (e) {
if(e.target === this.element[0]) {
e.preventDefault(); // prevent losing focus when clicking scroll arrows (FF, Chrome)
was_click = +(new Date()); // ie does not allow to prevent losing focus
}
}, this))
.on("mousedown.jstree", ".jstree-ocl", function (e) {
e.preventDefault(); // prevent any node inside from losing focus when clicking the open/close icon
})
.on("click.jstree", ".jstree-ocl", $.proxy(function (e) {
this.toggle_node(e.target);
}, this))
.on("dblclick.jstree", ".jstree-anchor", $.proxy(function (e) {
if(e.target.tagName && e.target.tagName.toLowerCase() === "input") { return true; }
if(this.settings.core.dblclick_toggle) {
this.toggle_node(e.target);
}
}, this))
.on("click.jstree", ".jstree-anchor", $.proxy(function (e) {
e.preventDefault();
if(e.currentTarget !== document.activeElement) { $(e.currentTarget).focus(); }
this.activate_node(e.currentTarget, e);
}, this))
.on('keydown.jstree', '.jstree-anchor', $.proxy(function (e) {
if(e.target.tagName && e.target.tagName.toLowerCase() === "input") { return true; }
if(e.which !== 32 && e.which !== 13 && (e.shiftKey || e.ctrlKey || e.altKey || e.metaKey)) { return true; }
var o = null;
if(this._data.core.rtl) {
if(e.which === 37) { e.which = 39; }
else if(e.which === 39) { e.which = 37; }
}
switch(e.which) {
case 32: // aria defines space only with Ctrl
if(e.ctrlKey) {
e.type = "click";
$(e.currentTarget).trigger(e);
}
break;
case 13: // enter
e.type = "click";
$(e.currentTarget).trigger(e);
break;
case 37: // left
e.preventDefault();
if(this.is_open(e.currentTarget)) {
this.close_node(e.currentTarget);
}
else {
o = this.get_parent(e.currentTarget);
if(o && o.id !== $.jstree.root) { this.get_node(o, true).children('.jstree-anchor').focus(); }
}
break;
case 38: // up
e.preventDefault();
o = this.get_prev_dom(e.currentTarget);
if(o && o.length) { o.children('.jstree-anchor').focus(); }
break;
case 39: // right
e.preventDefault();
if(this.is_closed(e.currentTarget)) {
this.open_node(e.currentTarget, function (o) { this.get_node(o, true).children('.jstree-anchor').focus(); });
}
else if (this.is_open(e.currentTarget)) {
o = this.get_node(e.currentTarget, true).children('.jstree-children')[0];
if(o) { $(this._firstChild(o)).children('.jstree-anchor').focus(); }
}
break;
case 40: // down
e.preventDefault();
o = this.get_next_dom(e.currentTarget);
if(o && o.length) { o.children('.jstree-anchor').focus(); }
break;
case 106: // aria defines * on numpad as open_all - not very common
this.open_all();
break;
case 36: // home
e.preventDefault();
o = this._firstChild(this.get_container_ul()[0]);
if(o) { $(o).children('.jstree-anchor').filter(':visible').focus(); }
break;
case 35: // end
e.preventDefault();
this.element.find('.jstree-anchor').filter(':visible').last().focus();
break;
case 113: // f2 - safe to include - if check_callback is false it will fail
e.preventDefault();
this.edit(e.currentTarget);
break;
default:
break;
}
}, this))
.on("load_node.jstree", $.proxy(function (e, data) {
if(data.status) {
if(data.node.id === $.jstree.root && !this._data.core.loaded) {
this._data.core.loaded = true;
if(this._firstChild(this.get_container_ul()[0])) {
this.element.attr('aria-activedescendant',this._firstChild(this.get_container_ul()[0]).id);
}
this.trigger("loaded");
}
if(!this._data.core.ready) {
setTimeout($.proxy(function() {
if(this.element && !this.get_container_ul().find('.jstree-loading').length) {
this._data.core.ready = true;
if(this._data.core.selected.length) {
if(this.settings.core.expand_selected_onload) {
var tmp = [], i, j;
for(i = 0, j = this._data.core.selected.length; i < j; i++) {
tmp = tmp.concat(this._model.data[this._data.core.selected[i]].parents);
}
tmp = $.vakata.array_unique(tmp);
for(i = 0, j = tmp.length; i < j; i++) {
this.open_node(tmp[i], false, 0);
}
}
this.trigger('changed', { 'action' : 'ready', 'selected' : this._data.core.selected });
}
this.trigger("ready");
}
}, this), 0);
}
}
}, this))
.on('keypress.jstree', $.proxy(function (e) {
if(e.target.tagName && e.target.tagName.toLowerCase() === "input") { return true; }
if(tout) { clearTimeout(tout); }
tout = setTimeout(function () {
word = '';
}, 500);
var chr = String.fromCharCode(e.which).toLowerCase(),
col = this.element.find('.jstree-anchor').filter(':visible'),
ind = col.index(document.activeElement) || 0,
end = false;
word += chr;
if(word.length > 1) {
col.slice(ind).each($.proxy(function (i, v) {
if($(v).text().toLowerCase().indexOf(word) === 0) {
$(v).focus();
end = true;
return false;
}
}, this));
if(end) { return; }
col.slice(0, ind).each($.proxy(function (i, v) {
if($(v).text().toLowerCase().indexOf(word) === 0) {
$(v).focus();
end = true;
return false;
}
}, this));
if(end) { return; }
}
if(new RegExp('^' + chr.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&') + '+$').test(word)) {
col.slice(ind + 1).each($.proxy(function (i, v) {
if($(v).text().toLowerCase().charAt(0) === chr) {
$(v).focus();
end = true;
return false;
}
}, this));
if(end) { return; }
col.slice(0, ind + 1).each($.proxy(function (i, v) {
if($(v).text().toLowerCase().charAt(0) === chr) {
$(v).focus();
end = true;
return false;
}
}, this));
if(end) { return; }
}
}, this))
.on("init.jstree", $.proxy(function () {
var s = this.settings.core.themes;
this._data.core.themes.dots			= s.dots;
this._data.core.themes.stripes		= s.stripes;
this._data.core.themes.icons		= s.icons;
this._data.core.themes.ellipsis		= s.ellipsis;
this.set_theme(s.name || "default", s.url);
this.set_theme_variant(s.variant);
}, this))
.on("loading.jstree", $.proxy(function () {
this[ this._data.core.themes.dots ? "show_dots" : "hide_dots" ]();
this[ this._data.core.themes.icons ? "show_icons" : "hide_icons" ]();
this[ this._data.core.themes.stripes ? "show_stripes" : "hide_stripes" ]();
this[ this._data.core.themes.ellipsis ? "show_ellipsis" : "hide_ellipsis" ]();
}, this))
.on('blur.jstree', '.jstree-anchor', $.proxy(function (e) {
this._data.core.focused = null;
$(e.currentTarget).filter('.jstree-hovered').mouseleave();
this.element.attr('tabindex', '0');
}, this))
.on('focus.jstree', '.jstree-anchor', $.proxy(function (e) {
var tmp = this.get_node(e.currentTarget);
if(tmp && tmp.id) {
this._data.core.focused = tmp.id;
}
this.element.find('.jstree-hovered').not(e.currentTarget).mouseleave();
$(e.currentTarget).mouseenter();
this.element.attr('tabindex', '-1');
}, this))
.on('focus.jstree', $.proxy(function () {
if(+(new Date()) - was_click > 500 && !this._data.core.focused) {
was_click = 0;
var act = this.get_node(this.element.attr('aria-activedescendant'), true);
if(act) {
act.find('> .jstree-anchor').focus();
}
}
}, this))
.on('mouseenter.jstree', '.jstree-anchor', $.proxy(function (e) {
this.hover_node(e.currentTarget);
}, this))
.on('mouseleave.jstree', '.jstree-anchor', $.proxy(function (e) {
this.dehover_node(e.currentTarget);
}, this));
},
unbind : function () {
this.element.off('.jstree');
$(document).off('.jstree-' + this._id);
},
trigger : function (ev, data) {
if(!data) {
data = {};
}
data.instance = this;
this.element.triggerHandler(ev.replace('.jstree','') + '.jstree', data);
},
get_container : function () {
return this.element;
},
get_container_ul : function () {
return this.element.children(".jstree-children").first();
},
get_string : function (key) {
var a = this.settings.core.strings;
if($.isFunction(a)) { return a.call(this, key); }
if(a && a[key]) { return a[key]; }
return key;
},
_firstChild : function (dom) {
dom = dom ? dom.firstChild : null;
while(dom !== null && dom.nodeType !== 1) {
dom = dom.nextSibling;
}
return dom;
},
_nextSibling : function (dom) {
dom = dom ? dom.nextSibling : null;
while(dom !== null && dom.nodeType !== 1) {
dom = dom.nextSibling;
}
return dom;
},
_previousSibling : function (dom) {
dom = dom ? dom.previousSibling : null;
while(dom !== null && dom.nodeType !== 1) {
dom = dom.previousSibling;
}
return dom;
},
get_node : function (obj, as_dom) {
if(obj && obj.id) {
obj = obj.id;
}
var dom;
try {
if(this._model.data[obj]) {
obj = this._model.data[obj];
}
else if(typeof obj === "string" && this._model.data[obj.replace(/^#/, '')]) {
obj = this._model.data[obj.replace(/^#/, '')];
}
else if(typeof obj === "string" && (dom = $('#' + obj.replace($.jstree.idregex,'\\$&'), this.element)).length && this._model.data[dom.closest('.jstree-node').attr('id')]) {
obj = this._model.data[dom.closest('.jstree-node').attr('id')];
}
else if((dom = $(obj, this.element)).length && this._model.data[dom.closest('.jstree-node').attr('id')]) {
obj = this._model.data[dom.closest('.jstree-node').attr('id')];
}
else if((dom = $(obj, this.element)).length && dom.hasClass('jstree')) {
obj = this._model.data[$.jstree.root];
}
else {
return false;
}
if(as_dom) {
obj = obj.id === $.jstree.root ? this.element : $('#' + obj.id.replace($.jstree.idregex,'\\$&'), this.element);
}
return obj;
} catch (ex) { return false; }
},
get_path : function (obj, glue, ids) {
obj = obj.parents ? obj : this.get_node(obj);
if(!obj || obj.id === $.jstree.root || !obj.parents) {
return false;
}
var i, j, p = [];
p.push(ids ? obj.id : obj.text);
for(i = 0, j = obj.parents.length; i < j; i++) {
p.push(ids ? obj.parents[i] : this.get_text(obj.parents[i]));
}
p = p.reverse().slice(1);
return glue ? p.join(glue) : p;
},
get_next_dom : function (obj, strict) {
var tmp;
obj = this.get_node(obj, true);
if(obj[0] === this.element[0]) {
tmp = this._firstChild(this.get_container_ul()[0]);
while (tmp && tmp.offsetHeight === 0) {
tmp = this._nextSibling(tmp);
}
return tmp ? $(tmp) : false;
}
if(!obj || !obj.length) {
return false;
}
if(strict) {
tmp = obj[0];
do {
tmp = this._nextSibling(tmp);
} while (tmp && tmp.offsetHeight === 0);
return tmp ? $(tmp) : false;
}
if(obj.hasClass("jstree-open")) {
tmp = this._firstChild(obj.children('.jstree-children')[0]);
while (tmp && tmp.offsetHeight === 0) {
tmp = this._nextSibling(tmp);
}
if(tmp !== null) {
return $(tmp);
}
}
tmp = obj[0];
do {
tmp = this._nextSibling(tmp);
} while (tmp && tmp.offsetHeight === 0);
if(tmp !== null) {
return $(tmp);
}
return obj.parentsUntil(".jstree",".jstree-node").nextAll(".jstree-node:visible").first();
},
get_prev_dom : function (obj, strict) {
var tmp;
obj = this.get_node(obj, true);
if(obj[0] === this.element[0]) {
tmp = this.get_container_ul()[0].lastChild;
while (tmp && tmp.offsetHeight === 0) {
tmp = this._previousSibling(tmp);
}
return tmp ? $(tmp) : false;
}
if(!obj || !obj.length) {
return false;
}
if(strict) {
tmp = obj[0];
do {
tmp = this._previousSibling(tmp);
} while (tmp && tmp.offsetHeight === 0);
return tmp ? $(tmp) : false;
}
tmp = obj[0];
do {
tmp = this._previousSibling(tmp);
} while (tmp && tmp.offsetHeight === 0);
if(tmp !== null) {
obj = $(tmp);
while(obj.hasClass("jstree-open")) {
obj = obj.children(".jstree-children").first().children(".jstree-node:visible:last");
}
return obj;
}
tmp = obj[0].parentNode.parentNode;
return tmp && tmp.className && tmp.className.indexOf('jstree-node') !== -1 ? $(tmp) : false;
},
get_parent : function (obj) {
obj = this.get_node(obj);
if(!obj || obj.id === $.jstree.root) {
return false;
}
return obj.parent;
},
get_children_dom : function (obj) {
obj = this.get_node(obj, true);
if(obj[0] === this.element[0]) {
return this.get_container_ul().children(".jstree-node");
}
if(!obj || !obj.length) {
return false;
}
return obj.children(".jstree-children").children(".jstree-node");
},
is_parent : function (obj) {
obj = this.get_node(obj);
return obj && (obj.state.loaded === false || obj.children.length > 0);
},
is_loaded : function (obj) {
obj = this.get_node(obj);
return obj && obj.state.loaded;
},
is_loading : function (obj) {
obj = this.get_node(obj);
return obj && obj.state && obj.state.loading;
},
is_open : function (obj) {
obj = this.get_node(obj);
return obj && obj.state.opened;
},
is_closed : function (obj) {
obj = this.get_node(obj);
return obj && this.is_parent(obj) && !obj.state.opened;
},
is_leaf : function (obj) {
return !this.is_parent(obj);
},
load_node : function (obj, callback) {
var k, l, i, j, c;
if($.isArray(obj)) {
this._load_nodes(obj.slice(), callback);
return true;
}
obj = this.get_node(obj);
if(!obj) {
if(callback) { callback.call(this, obj, false); }
return false;
}
if(obj.state.loaded) {
obj.state.loaded = false;
for(i = 0, j = obj.parents.length; i < j; i++) {
this._model.data[obj.parents[i]].children_d = $.vakata.array_filter(this._model.data[obj.parents[i]].children_d, function (v) {
return $.inArray(v, obj.children_d) === -1;
});
}
for(k = 0, l = obj.children_d.length; k < l; k++) {
if(this._model.data[obj.children_d[k]].state.selected) {
c = true;
}
delete this._model.data[obj.children_d[k]];
}
if (c) {
this._data.core.selected = $.vakata.array_filter(this._data.core.selected, function (v) {
return $.inArray(v, obj.children_d) === -1;
});
}
obj.children = [];
obj.children_d = [];
if(c) {
this.trigger('changed', { 'action' : 'load_node', 'node' : obj, 'selected' : this._data.core.selected });
}
}
obj.state.failed = false;
obj.state.loading = true;
this.get_node(obj, true).addClass("jstree-loading").attr('aria-busy',true);
this._load_node(obj, $.proxy(function (status) {
obj = this._model.data[obj.id];
obj.state.loading = false;
obj.state.loaded = status;
obj.state.failed = !obj.state.loaded;
var dom = this.get_node(obj, true), i = 0, j = 0, m = this._model.data, has_children = false;
for(i = 0, j = obj.children.length; i < j; i++) {
if(m[obj.children[i]] && !m[obj.children[i]].state.hidden) {
has_children = true;
break;
}
}
if(obj.state.loaded && dom && dom.length) {
dom.removeClass('jstree-closed jstree-open jstree-leaf');
if (!has_children) {
dom.addClass('jstree-leaf');
}
else {
if (obj.id !== '#') {
dom.addClass(obj.state.opened ? 'jstree-open' : 'jstree-closed');
}
}
}
dom.removeClass("jstree-loading").attr('aria-busy',false);
this.trigger('load_node', { "node" : obj, "status" : status });
if(callback) {
callback.call(this, obj, status);
}
}, this));
return true;
},
_load_nodes : function (nodes, callback, is_callback, force_reload) {
var r = true,
c = function () { this._load_nodes(nodes, callback, true); },
m = this._model.data, i, j, tmp = [];
for(i = 0, j = nodes.length; i < j; i++) {
if(m[nodes[i]] && ( (!m[nodes[i]].state.loaded && !m[nodes[i]].state.failed) || (!is_callback && force_reload) )) {
if(!this.is_loading(nodes[i])) {
this.load_node(nodes[i], c);
}
r = false;
}
}
if(r) {
for(i = 0, j = nodes.length; i < j; i++) {
if(m[nodes[i]] && m[nodes[i]].state.loaded) {
tmp.push(nodes[i]);
}
}
if(callback && !callback.done) {
callback.call(this, tmp);
callback.done = true;
}
}
},
load_all : function (obj, callback) {
if(!obj) { obj = $.jstree.root; }
obj = this.get_node(obj);
if(!obj) { return false; }
var to_load = [],
m = this._model.data,
c = m[obj.id].children_d,
i, j;
if(obj.state && !obj.state.loaded) {
to_load.push(obj.id);
}
for(i = 0, j = c.length; i < j; i++) {
if(m[c[i]] && m[c[i]].state && !m[c[i]].state.loaded) {
to_load.push(c[i]);
}
}
if(to_load.length) {
this._load_nodes(to_load, function () {
this.load_all(obj, callback);
});
}
else {
if(callback) { callback.call(this, obj); }
this.trigger('load_all', { "node" : obj });
}
},
_load_node : function (obj, callback) {
var s = this.settings.core.data, t;
var notTextOrCommentNode = function notTextOrCommentNode () {
return this.nodeType !== 3 && this.nodeType !== 8;
};
if(!s) {
if(obj.id === $.jstree.root) {
return this._append_html_data(obj, this._data.core.original_container_html.clone(true), function (status) {
callback.call(this, status);
});
}
else {
return callback.call(this, false);
}
}
if($.isFunction(s)) {
return s.call(this, obj, $.proxy(function (d) {
if(d === false) {
callback.call(this, false);
}
else {
this[typeof d === 'string' ? '_append_html_data' : '_append_json_data'](obj, typeof d === 'string' ? $($.parseHTML(d)).filter(notTextOrCommentNode) : d, function (status) {
callback.call(this, status);
});
}
}, this));
}
if(typeof s === 'object') {
if(s.url) {
s = $.extend(true, {}, s);
if($.isFunction(s.url)) {
s.url = s.url.call(this, obj);
}
if($.isFunction(s.data)) {
s.data = s.data.call(this, obj);
}
return $.ajax(s)
.done($.proxy(function (d,t,x) {
var type = x.getResponseHeader('Content-Type');
if((type && type.indexOf('json') !== -1) || typeof d === "object") {
return this._append_json_data(obj, d, function (status) { callback.call(this, status); });
}
if((type && type.indexOf('html') !== -1) || typeof d === "string") {
return this._append_html_data(obj, $($.parseHTML(d)).filter(notTextOrCommentNode), function (status) { callback.call(this, status); });
}
this._data.core.last_error = { 'error' : 'ajax', 'plugin' : 'core', 'id' : 'core_04', 'reason' : 'Could not load node', 'data' : JSON.stringify({ 'id' : obj.id, 'xhr' : x }) };
this.settings.core.error.call(this, this._data.core.last_error);
return callback.call(this, false);
}, this))
.fail($.proxy(function (f) {
this._data.core.last_error = { 'error' : 'ajax', 'plugin' : 'core', 'id' : 'core_04', 'reason' : 'Could not load node', 'data' : JSON.stringify({ 'id' : obj.id, 'xhr' : f }) };
callback.call(this, false);
this.settings.core.error.call(this, this._data.core.last_error);
}, this));
}
if ($.isArray(s)) {
t = $.extend(true, [], s);
} else if ($.isPlainObject(s)) {
t = $.extend(true, {}, s);
} else {
t = s;
}
if(obj.id === $.jstree.root) {
return this._append_json_data(obj, t, function (status) {
callback.call(this, status);
});
}
else {
this._data.core.last_error = { 'error' : 'nodata', 'plugin' : 'core', 'id' : 'core_05', 'reason' : 'Could not load node', 'data' : JSON.stringify({ 'id' : obj.id }) };
this.settings.core.error.call(this, this._data.core.last_error);
return callback.call(this, false);
}
}
if(typeof s === 'string') {
if(obj.id === $.jstree.root) {
return this._append_html_data(obj, $($.parseHTML(s)).filter(notTextOrCommentNode), function (status) {
callback.call(this, status);
});
}
else {
this._data.core.last_error = { 'error' : 'nodata', 'plugin' : 'core', 'id' : 'core_06', 'reason' : 'Could not load node', 'data' : JSON.stringify({ 'id' : obj.id }) };
this.settings.core.error.call(this, this._data.core.last_error);
return callback.call(this, false);
}
}
return callback.call(this, false);
},
_node_changed : function (obj) {
obj = this.get_node(obj);
if(obj) {
this._model.changed.push(obj.id);
}
},
_append_html_data : function (dom, data, cb) {
dom = this.get_node(dom);
dom.children = [];
dom.children_d = [];
var dat = data.is('ul') ? data.children() : data,
par = dom.id,
chd = [],
dpc = [],
m = this._model.data,
p = m[par],
s = this._data.core.selected.length,
tmp, i, j;
dat.each($.proxy(function (i, v) {
tmp = this._parse_model_from_html($(v), par, p.parents.concat());
if(tmp) {
chd.push(tmp);
dpc.push(tmp);
if(m[tmp].children_d.length) {
dpc = dpc.concat(m[tmp].children_d);
}
}
}, this));
p.children = chd;
p.children_d = dpc;
for(i = 0, j = p.parents.length; i < j; i++) {
m[p.parents[i]].children_d = m[p.parents[i]].children_d.concat(dpc);
}
this.trigger('model', { "nodes" : dpc, 'parent' : par });
if(par !== $.jstree.root) {
this._node_changed(par);
this.redraw();
}
else {
this.get_container_ul().children('.jstree-initial-node').remove();
this.redraw(true);
}
if(this._data.core.selected.length !== s) {
this.trigger('changed', { 'action' : 'model', 'selected' : this._data.core.selected });
}
cb.call(this, true);
},
_append_json_data : function (dom, data, cb, force_processing) {
if(this.element === null) { return; }
dom = this.get_node(dom);
dom.children = [];
dom.children_d = [];
if(data.d) {
data = data.d;
if(typeof data === "string") {
data = JSON.parse(data);
}
}
if(!$.isArray(data)) { data = [data]; }
var w = null,
args = {
'df'	: this._model.default_state,
'dat'	: data,
'par'	: dom.id,
'm'		: this._model.data,
't_id'	: this._id,
't_cnt'	: this._cnt,
'sel'	: this._data.core.selected
},
func = function (data, undefined) {
if(data.data) { data = data.data; }
var dat = data.dat,
par = data.par,
chd = [],
dpc = [],
add = [],
df = data.df,
t_id = data.t_id,
t_cnt = data.t_cnt,
m = data.m,
p = m[par],
sel = data.sel,
tmp, i, j, rslt,
parse_flat = function (d, p, ps) {
if(!ps) { ps = []; }
else { ps = ps.concat(); }
if(p) { ps.unshift(p); }
var tid = d.id.toString(),
i, j, c, e,
tmp = {
id			: tid,
text		: d.text || '',
icon		: d.icon !== undefined ? d.icon : true,
parent		: p,
parents		: ps,
children	: d.children || [],
children_d	: d.children_d || [],
data		: d.data,
state		: { },
li_attr		: { id : false },
a_attr		: { href : '#' },
original	: false
};
for(i in df) {
if(df.hasOwnProperty(i)) {
tmp.state[i] = df[i];
}
}
if(d && d.data && d.data.jstree && d.data.jstree.icon) {
tmp.icon = d.data.jstree.icon;
}
if(tmp.icon === undefined || tmp.icon === null || tmp.icon === "") {
tmp.icon = true;
}
if(d && d.data) {
tmp.data = d.data;
if(d.data.jstree) {
for(i in d.data.jstree) {
if(d.data.jstree.hasOwnProperty(i)) {
tmp.state[i] = d.data.jstree[i];
}
}
}
}
if(d && typeof d.state === 'object') {
for (i in d.state) {
if(d.state.hasOwnProperty(i)) {
tmp.state[i] = d.state[i];
}
}
}
if(d && typeof d.li_attr === 'object') {
for (i in d.li_attr) {
if(d.li_attr.hasOwnProperty(i)) {
tmp.li_attr[i] = d.li_attr[i];
}
}
}
if(!tmp.li_attr.id) {
tmp.li_attr.id = tid;
}
if(d && typeof d.a_attr === 'object') {
for (i in d.a_attr) {
if(d.a_attr.hasOwnProperty(i)) {
tmp.a_attr[i] = d.a_attr[i];
}
}
}
if(d && d.children && d.children === true) {
tmp.state.loaded = false;
tmp.children = [];
tmp.children_d = [];
}
m[tmp.id] = tmp;
for(i = 0, j = tmp.children.length; i < j; i++) {
c = parse_flat(m[tmp.children[i]], tmp.id, ps);
e = m[c];
tmp.children_d.push(c);
if(e.children_d.length) {
tmp.children_d = tmp.children_d.concat(e.children_d);
}
}
delete d.data;
delete d.children;
m[tmp.id].original = d;
if(tmp.state.selected) {
add.push(tmp.id);
}
return tmp.id;
},
parse_nest = function (d, p, ps) {
if(!ps) { ps = []; }
else { ps = ps.concat(); }
if(p) { ps.unshift(p); }
var tid = false, i, j, c, e, tmp;
do {
tid = 'j' + t_id + '_' + (++t_cnt);
} while(m[tid]);
tmp = {
id			: false,
text		: typeof d === 'string' ? d : '',
icon		: typeof d === 'object' && d.icon !== undefined ? d.icon : true,
parent		: p,
parents		: ps,
children	: [],
children_d	: [],
data		: null,
state		: { },
li_attr		: { id : false },
a_attr		: { href : '#' },
original	: false
};
for(i in df) {
if(df.hasOwnProperty(i)) {
tmp.state[i] = df[i];
}
}
if(d && d.id) { tmp.id = d.id.toString(); }
if(d && d.text) { tmp.text = d.text; }
if(d && d.data && d.data.jstree && d.data.jstree.icon) {
tmp.icon = d.data.jstree.icon;
}
if(tmp.icon === undefined || tmp.icon === null || tmp.icon === "") {
tmp.icon = true;
}
if(d && d.data) {
tmp.data = d.data;
if(d.data.jstree) {
for(i in d.data.jstree) {
if(d.data.jstree.hasOwnProperty(i)) {
tmp.state[i] = d.data.jstree[i];
}
}
}
}
if(d && typeof d.state === 'object') {
for (i in d.state) {
if(d.state.hasOwnProperty(i)) {
tmp.state[i] = d.state[i];
}
}
}
if(d && typeof d.li_attr === 'object') {
for (i in d.li_attr) {
if(d.li_attr.hasOwnProperty(i)) {
tmp.li_attr[i] = d.li_attr[i];
}
}
}
if(tmp.li_attr.id && !tmp.id) {
tmp.id = tmp.li_attr.id.toString();
}
if(!tmp.id) {
tmp.id = tid;
}
if(!tmp.li_attr.id) {
tmp.li_attr.id = tmp.id;
}
if(d && typeof d.a_attr === 'object') {
for (i in d.a_attr) {
if(d.a_attr.hasOwnProperty(i)) {
tmp.a_attr[i] = d.a_attr[i];
}
}
}
if(d && d.children && d.children.length) {
for(i = 0, j = d.children.length; i < j; i++) {
c = parse_nest(d.children[i], tmp.id, ps);
e = m[c];
tmp.children.push(c);
if(e.children_d.length) {
tmp.children_d = tmp.children_d.concat(e.children_d);
}
}
tmp.children_d = tmp.children_d.concat(tmp.children);
}
if(d && d.children && d.children === true) {
tmp.state.loaded = false;
tmp.children = [];
tmp.children_d = [];
}
delete d.data;
delete d.children;
tmp.original = d;
m[tmp.id] = tmp;
if(tmp.state.selected) {
add.push(tmp.id);
}
return tmp.id;
};
if(dat.length && dat[0].id !== undefined && dat[0].parent !== undefined) {
for(i = 0, j = dat.length; i < j; i++) {
if(!dat[i].children) {
dat[i].children = [];
}
m[dat[i].id.toString()] = dat[i];
}
for(i = 0, j = dat.length; i < j; i++) {
m[dat[i].parent.toString()].children.push(dat[i].id.toString());
p.children_d.push(dat[i].id.toString());
}
for(i = 0, j = p.children.length; i < j; i++) {
tmp = parse_flat(m[p.children[i]], par, p.parents.concat());
dpc.push(tmp);
if(m[tmp].children_d.length) {
dpc = dpc.concat(m[tmp].children_d);
}
}
for(i = 0, j = p.parents.length; i < j; i++) {
m[p.parents[i]].children_d = m[p.parents[i]].children_d.concat(dpc);
}
rslt = {
'cnt' : t_cnt,
'mod' : m,
'sel' : sel,
'par' : par,
'dpc' : dpc,
'add' : add
};
}
else {
for(i = 0, j = dat.length; i < j; i++) {
tmp = parse_nest(dat[i], par, p.parents.concat());
if(tmp) {
chd.push(tmp);
dpc.push(tmp);
if(m[tmp].children_d.length) {
dpc = dpc.concat(m[tmp].children_d);
}
}
}
p.children = chd;
p.children_d = dpc;
for(i = 0, j = p.parents.length; i < j; i++) {
m[p.parents[i]].children_d = m[p.parents[i]].children_d.concat(dpc);
}
rslt = {
'cnt' : t_cnt,
'mod' : m,
'sel' : sel,
'par' : par,
'dpc' : dpc,
'add' : add
};
}
if(typeof window === 'undefined' || typeof window.document === 'undefined') {
postMessage(rslt);
}
else {
return rslt;
}
},
rslt = function (rslt, worker) {
if(this.element === null) { return; }
this._cnt = rslt.cnt;
var i, m = this._model.data;
for (i in m) {
if (m.hasOwnProperty(i) && m[i].state && m[i].state.loading && rslt.mod[i]) {
rslt.mod[i].state.loading = true;
}
}
this._model.data = rslt.mod; // breaks the reference in load_node - careful
if(worker) {
var j, a = rslt.add, r = rslt.sel, s = this._data.core.selected.slice();
m = this._model.data;
if(r.length !== s.length || $.vakata.array_unique(r.concat(s)).length !== r.length) {
for(i = 0, j = r.length; i < j; i++) {
if($.inArray(r[i], a) === -1 && $.inArray(r[i], s) === -1) {
m[r[i]].state.selected = false;
}
}
for(i = 0, j = s.length; i < j; i++) {
if($.inArray(s[i], r) === -1) {
m[s[i]].state.selected = true;
}
}
}
}
if(rslt.add.length) {
this._data.core.selected = this._data.core.selected.concat(rslt.add);
}
this.trigger('model', { "nodes" : rslt.dpc, 'parent' : rslt.par });
if(rslt.par !== $.jstree.root) {
this._node_changed(rslt.par);
this.redraw();
}
else {
this.redraw(true);
}
if(rslt.add.length) {
this.trigger('changed', { 'action' : 'model', 'selected' : this._data.core.selected });
}
cb.call(this, true);
};
if(this.settings.core.worker && window.Blob && window.URL && window.Worker) {
try {
if(this._wrk === null) {
this._wrk = window.URL.createObjectURL(
new window.Blob(
['self.onmessage = ' + func.toString()],
{type:"text/javascript"}
)
);
}
if(!this._data.core.working || force_processing) {
this._data.core.working = true;
w = new window.Worker(this._wrk);
w.onmessage = $.proxy(function (e) {
rslt.call(this, e.data, true);
try { w.terminate(); w = null; } catch(ignore) { }
if(this._data.core.worker_queue.length) {
this._append_json_data.apply(this, this._data.core.worker_queue.shift());
}
else {
this._data.core.working = false;
}
}, this);
if(!args.par) {
if(this._data.core.worker_queue.length) {
this._append_json_data.apply(this, this._data.core.worker_queue.shift());
}
else {
this._data.core.working = false;
}
}
else {
w.postMessage(args);
}
}
else {
this._data.core.worker_queue.push([dom, data, cb, true]);
}
}
catch(e) {
rslt.call(this, func(args), false);
if(this._data.core.worker_queue.length) {
this._append_json_data.apply(this, this._data.core.worker_queue.shift());
}
else {
this._data.core.working = false;
}
}
}
else {
rslt.call(this, func(args), false);
}
},
_parse_model_from_html : function (d, p, ps) {
if(!ps) { ps = []; }
else { ps = [].concat(ps); }
if(p) { ps.unshift(p); }
var c, e, m = this._model.data,
data = {
id			: false,
text		: false,
icon		: true,
parent		: p,
parents		: ps,
children	: [],
children_d	: [],
data		: null,
state		: { },
li_attr		: { id : false },
a_attr		: { href : '#' },
original	: false
}, i, tmp, tid;
for(i in this._model.default_state) {
if(this._model.default_state.hasOwnProperty(i)) {
data.state[i] = this._model.default_state[i];
}
}
tmp = $.vakata.attributes(d, true);
$.each(tmp, function (i, v) {
v = $.trim(v);
if(!v.length) { return true; }
data.li_attr[i] = v;
if(i === 'id') {
data.id = v.toString();
}
});
tmp = d.children('a').first();
if(tmp.length) {
tmp = $.vakata.attributes(tmp, true);
$.each(tmp, function (i, v) {
v = $.trim(v);
if(v.length) {
data.a_attr[i] = v;
}
});
}
tmp = d.children("a").first().length ? d.children("a").first().clone() : d.clone();
tmp.children("ins, i, ul").remove();
tmp = tmp.html();
tmp = $('<div />').html(tmp);
data.text = this.settings.core.force_text ? tmp.text() : tmp.html();
tmp = d.data();
data.data = tmp ? $.extend(true, {}, tmp) : null;
data.state.opened = d.hasClass('jstree-open');
data.state.selected = d.children('a').hasClass('jstree-clicked');
data.state.disabled = d.children('a').hasClass('jstree-disabled');
if(data.data && data.data.jstree) {
for(i in data.data.jstree) {
if(data.data.jstree.hasOwnProperty(i)) {
data.state[i] = data.data.jstree[i];
}
}
}
tmp = d.children("a").children(".jstree-themeicon");
if(tmp.length) {
data.icon = tmp.hasClass('jstree-themeicon-hidden') ? false : tmp.attr('rel');
}
if(data.state.icon !== undefined) {
data.icon = data.state.icon;
}
if(data.icon === undefined || data.icon === null || data.icon === "") {
data.icon = true;
}
tmp = d.children("ul").children("li");
do {
tid = 'j' + this._id + '_' + (++this._cnt);
} while(m[tid]);
data.id = data.li_attr.id ? data.li_attr.id.toString() : tid;
if(tmp.length) {
tmp.each($.proxy(function (i, v) {
c = this._parse_model_from_html($(v), data.id, ps);
e = this._model.data[c];
data.children.push(c);
if(e.children_d.length) {
data.children_d = data.children_d.concat(e.children_d);
}
}, this));
data.children_d = data.children_d.concat(data.children);
}
else {
if(d.hasClass('jstree-closed')) {
data.state.loaded = false;
}
}
if(data.li_attr['class']) {
data.li_attr['class'] = data.li_attr['class'].replace('jstree-closed','').replace('jstree-open','');
}
if(data.a_attr['class']) {
data.a_attr['class'] = data.a_attr['class'].replace('jstree-clicked','').replace('jstree-disabled','');
}
m[data.id] = data;
if(data.state.selected) {
this._data.core.selected.push(data.id);
}
return data.id;
},
_parse_model_from_flat_json : function (d, p, ps) {
if(!ps) { ps = []; }
else { ps = ps.concat(); }
if(p) { ps.unshift(p); }
var tid = d.id.toString(),
m = this._model.data,
df = this._model.default_state,
i, j, c, e,
tmp = {
id			: tid,
text		: d.text || '',
icon		: d.icon !== undefined ? d.icon : true,
parent		: p,
parents		: ps,
children	: d.children || [],
children_d	: d.children_d || [],
data		: d.data,
state		: { },
li_attr		: { id : false },
a_attr		: { href : '#' },
original	: false
};
for(i in df) {
if(df.hasOwnProperty(i)) {
tmp.state[i] = df[i];
}
}
if(d && d.data && d.data.jstree && d.data.jstree.icon) {
tmp.icon = d.data.jstree.icon;
}
if(tmp.icon === undefined || tmp.icon === null || tmp.icon === "") {
tmp.icon = true;
}
if(d && d.data) {
tmp.data = d.data;
if(d.data.jstree) {
for(i in d.data.jstree) {
if(d.data.jstree.hasOwnProperty(i)) {
tmp.state[i] = d.data.jstree[i];
}
}
}
}
if(d && typeof d.state === 'object') {
for (i in d.state) {
if(d.state.hasOwnProperty(i)) {
tmp.state[i] = d.state[i];
}
}
}
if(d && typeof d.li_attr === 'object') {
for (i in d.li_attr) {
if(d.li_attr.hasOwnProperty(i)) {
tmp.li_attr[i] = d.li_attr[i];
}
}
}
if(!tmp.li_attr.id) {
tmp.li_attr.id = tid;
}
if(d && typeof d.a_attr === 'object') {
for (i in d.a_attr) {
if(d.a_attr.hasOwnProperty(i)) {
tmp.a_attr[i] = d.a_attr[i];
}
}
}
if(d && d.children && d.children === true) {
tmp.state.loaded = false;
tmp.children = [];
tmp.children_d = [];
}
m[tmp.id] = tmp;
for(i = 0, j = tmp.children.length; i < j; i++) {
c = this._parse_model_from_flat_json(m[tmp.children[i]], tmp.id, ps);
e = m[c];
tmp.children_d.push(c);
if(e.children_d.length) {
tmp.children_d = tmp.children_d.concat(e.children_d);
}
}
delete d.data;
delete d.children;
m[tmp.id].original = d;
if(tmp.state.selected) {
this._data.core.selected.push(tmp.id);
}
return tmp.id;
},
_parse_model_from_json : function (d, p, ps) {
if(!ps) { ps = []; }
else { ps = ps.concat(); }
if(p) { ps.unshift(p); }
var tid = false, i, j, c, e, m = this._model.data, df = this._model.default_state, tmp;
do {
tid = 'j' + this._id + '_' + (++this._cnt);
} while(m[tid]);
tmp = {
id			: false,
text		: typeof d === 'string' ? d : '',
icon		: typeof d === 'object' && d.icon !== undefined ? d.icon : true,
parent		: p,
parents		: ps,
children	: [],
children_d	: [],
data		: null,
state		: { },
li_attr		: { id : false },
a_attr		: { href : '#' },
original	: false
};
for(i in df) {
if(df.hasOwnProperty(i)) {
tmp.state[i] = df[i];
}
}
if(d && d.id) { tmp.id = d.id.toString(); }
if(d && d.text) { tmp.text = d.text; }
if(d && d.data && d.data.jstree && d.data.jstree.icon) {
tmp.icon = d.data.jstree.icon;
}
if(tmp.icon === undefined || tmp.icon === null || tmp.icon === "") {
tmp.icon = true;
}
if(d && d.data) {
tmp.data = d.data;
if(d.data.jstree) {
for(i in d.data.jstree) {
if(d.data.jstree.hasOwnProperty(i)) {
tmp.state[i] = d.data.jstree[i];
}
}
}
}
if(d && typeof d.state === 'object') {
for (i in d.state) {
if(d.state.hasOwnProperty(i)) {
tmp.state[i] = d.state[i];
}
}
}
if(d && typeof d.li_attr === 'object') {
for (i in d.li_attr) {
if(d.li_attr.hasOwnProperty(i)) {
tmp.li_attr[i] = d.li_attr[i];
}
}
}
if(tmp.li_attr.id && !tmp.id) {
tmp.id = tmp.li_attr.id.toString();
}
if(!tmp.id) {
tmp.id = tid;
}
if(!tmp.li_attr.id) {
tmp.li_attr.id = tmp.id;
}
if(d && typeof d.a_attr === 'object') {
for (i in d.a_attr) {
if(d.a_attr.hasOwnProperty(i)) {
tmp.a_attr[i] = d.a_attr[i];
}
}
}
if(d && d.children && d.children.length) {
for(i = 0, j = d.children.length; i < j; i++) {
c = this._parse_model_from_json(d.children[i], tmp.id, ps);
e = m[c];
tmp.children.push(c);
if(e.children_d.length) {
tmp.children_d = tmp.children_d.concat(e.children_d);
}
}
tmp.children_d = tmp.children_d.concat(tmp.children);
}
if(d && d.children && d.children === true) {
tmp.state.loaded = false;
tmp.children = [];
tmp.children_d = [];
}
delete d.data;
delete d.children;
tmp.original = d;
m[tmp.id] = tmp;
if(tmp.state.selected) {
this._data.core.selected.push(tmp.id);
}
return tmp.id;
},
_redraw : function () {
var nodes = this._model.force_full_redraw ? this._model.data[$.jstree.root].children.concat([]) : this._model.changed.concat([]),
f = document.createElement('UL'), tmp, i, j, fe = this._data.core.focused;
for(i = 0, j = nodes.length; i < j; i++) {
tmp = this.redraw_node(nodes[i], true, this._model.force_full_redraw);
if(tmp && this._model.force_full_redraw) {
f.appendChild(tmp);
}
}
if(this._model.force_full_redraw) {
f.className = this.get_container_ul()[0].className;
f.setAttribute('role','group');
this.element.empty().append(f);
}
if(fe !== null) {
tmp = this.get_node(fe, true);
if(tmp && tmp.length && tmp.children('.jstree-anchor')[0] !== document.activeElement) {
tmp.children('.jstree-anchor').focus();
}
else {
this._data.core.focused = null;
}
}
this._model.force_full_redraw = false;
this._model.changed = [];
this.trigger('redraw', { "nodes" : nodes });
},
redraw : function (full) {
if(full) {
this._model.force_full_redraw = true;
}
this._redraw();
},
draw_children : function (node) {
var obj = this.get_node(node),
i = false,
j = false,
k = false,
d = document;
if(!obj) { return false; }
if(obj.id === $.jstree.root) { return this.redraw(true); }
node = this.get_node(node, true);
if(!node || !node.length) { return false; } // TODO: quick toggle
node.children('.jstree-children').remove();
node = node[0];
if(obj.children.length && obj.state.loaded) {
k = d.createElement('UL');
k.setAttribute('role', 'group');
k.className = 'jstree-children';
for(i = 0, j = obj.children.length; i < j; i++) {
k.appendChild(this.redraw_node(obj.children[i], true, true));
}
node.appendChild(k);
}
},
redraw_node : function (node, deep, is_callback, force_render) {
var obj = this.get_node(node),
par = false,
ind = false,
old = false,
i = false,
j = false,
k = false,
c = '',
d = document,
m = this._model.data,
f = false,
s = false,
tmp = null,
t = 0,
l = 0,
has_children = false,
last_sibling = false;
if(!obj) { return false; }
if(obj.id === $.jstree.root) {  return this.redraw(true); }
deep = deep || obj.children.length === 0;
node = !document.querySelector ? document.getElementById(obj.id) : this.element[0].querySelector('#' + ("0123456789".indexOf(obj.id[0]) !== -1 ? '\\3' + obj.id[0] + ' ' + obj.id.substr(1).replace($.jstree.idregex,'\\$&') : obj.id.replace($.jstree.idregex,'\\$&')) ); //, this.element);
if(!node) {
deep = true;
if(!is_callback) {
par = obj.parent !== $.jstree.root ? $('#' + obj.parent.replace($.jstree.idregex,'\\$&'), this.element)[0] : null;
if(par !== null && (!par || !m[obj.parent].state.opened)) {
return false;
}
ind = $.inArray(obj.id, par === null ? m[$.jstree.root].children : m[obj.parent].children);
}
}
else {
node = $(node);
if(!is_callback) {
par = node.parent().parent()[0];
if(par === this.element[0]) {
par = null;
}
ind = node.index();
}
if(!deep && obj.children.length && !node.children('.jstree-children').length) {
deep = true;
}
if(!deep) {
old = node.children('.jstree-children')[0];
}
f = node.children('.jstree-anchor')[0] === document.activeElement;
node.remove();
}
node = this._data.core.node.cloneNode(true);
c = 'jstree-node ';
for(i in obj.li_attr) {
if(obj.li_attr.hasOwnProperty(i)) {
if(i === 'id') { continue; }
if(i !== 'class') {
node.setAttribute(i, obj.li_attr[i]);
}
else {
c += obj.li_attr[i];
}
}
}
if(!obj.a_attr.id) {
obj.a_attr.id = obj.id + '_anchor';
}
node.setAttribute('aria-selected', !!obj.state.selected);
node.setAttribute('aria-level', obj.parents.length);
node.setAttribute('aria-labelledby', obj.a_attr.id);
if(obj.state.disabled) {
node.setAttribute('aria-disabled', true);
}
for(i = 0, j = obj.children.length; i < j; i++) {
if(!m[obj.children[i]].state.hidden) {
has_children = true;
break;
}
}
if(obj.parent !== null && m[obj.parent] && !obj.state.hidden) {
i = $.inArray(obj.id, m[obj.parent].children);
last_sibling = obj.id;
if(i !== -1) {
i++;
for(j = m[obj.parent].children.length; i < j; i++) {
if(!m[m[obj.parent].children[i]].state.hidden) {
last_sibling = m[obj.parent].children[i];
}
if(last_sibling !== obj.id) {
break;
}
}
}
}
if(obj.state.hidden) {
c += ' jstree-hidden';
}
if(obj.state.loaded && !has_children) {
c += ' jstree-leaf';
}
else {
c += obj.state.opened && obj.state.loaded ? ' jstree-open' : ' jstree-closed';
node.setAttribute('aria-expanded', (obj.state.opened && obj.state.loaded) );
}
if(last_sibling === obj.id) {
c += ' jstree-last';
}
node.id = obj.id;
node.className = c;
c = ( obj.state.selected ? ' jstree-clicked' : '') + ( obj.state.disabled ? ' jstree-disabled' : '');
for(j in obj.a_attr) {
if(obj.a_attr.hasOwnProperty(j)) {
if(j === 'href' && obj.a_attr[j] === '#') { continue; }
if(j !== 'class') {
node.childNodes[1].setAttribute(j, obj.a_attr[j]);
}
else {
c += ' ' + obj.a_attr[j];
}
}
}
if(c.length) {
node.childNodes[1].className = 'jstree-anchor ' + c;
}
if((obj.icon && obj.icon !== true) || obj.icon === false) {
if(obj.icon === false) {
node.childNodes[1].childNodes[0].className += ' jstree-themeicon-hidden';
}
else if(obj.icon.indexOf('/') === -1 && obj.icon.indexOf('.') === -1) {
node.childNodes[1].childNodes[0].className += ' ' + obj.icon + ' jstree-themeicon-custom';
}
else {
node.childNodes[1].childNodes[0].style.backgroundImage = 'url("'+obj.icon+'")';
node.childNodes[1].childNodes[0].style.backgroundPosition = 'center center';
node.childNodes[1].childNodes[0].style.backgroundSize = 'auto';
node.childNodes[1].childNodes[0].className += ' jstree-themeicon-custom';
}
}
if(this.settings.core.force_text) {
node.childNodes[1].appendChild(d.createTextNode(obj.text));
}
else {
node.childNodes[1].innerHTML += obj.text;
}
if(deep && obj.children.length && (obj.state.opened || force_render) && obj.state.loaded) {
k = d.createElement('UL');
k.setAttribute('role', 'group');
k.className = 'jstree-children';
for(i = 0, j = obj.children.length; i < j; i++) {
k.appendChild(this.redraw_node(obj.children[i], deep, true));
}
node.appendChild(k);
}
if(old) {
node.appendChild(old);
}
if(!is_callback) {
if(!par) {
par = this.element[0];
}
for(i = 0, j = par.childNodes.length; i < j; i++) {
if(par.childNodes[i] && par.childNodes[i].className && par.childNodes[i].className.indexOf('jstree-children') !== -1) {
tmp = par.childNodes[i];
break;
}
}
if(!tmp) {
tmp = d.createElement('UL');
tmp.setAttribute('role', 'group');
tmp.className = 'jstree-children';
par.appendChild(tmp);
}
par = tmp;
if(ind < par.childNodes.length) {
par.insertBefore(node, par.childNodes[ind]);
}
else {
par.appendChild(node);
}
if(f) {
t = this.element[0].scrollTop;
l = this.element[0].scrollLeft;
node.childNodes[1].focus();
this.element[0].scrollTop = t;
this.element[0].scrollLeft = l;
}
}
if(obj.state.opened && !obj.state.loaded) {
obj.state.opened = false;
setTimeout($.proxy(function () {
this.open_node(obj.id, false, 0);
}, this), 0);
}
return node;
},
open_node : function (obj, callback, animation) {
var t1, t2, d, t;
if($.isArray(obj)) {
obj = obj.slice();
for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
this.open_node(obj[t1], callback, animation);
}
return true;
}
obj = this.get_node(obj);
if(!obj || obj.id === $.jstree.root) {
return false;
}
animation = animation === undefined ? this.settings.core.animation : animation;
if(!this.is_closed(obj)) {
if(callback) {
callback.call(this, obj, false);
}
return false;
}
if(!this.is_loaded(obj)) {
if(this.is_loading(obj)) {
return setTimeout($.proxy(function () {
this.open_node(obj, callback, animation);
}, this), 500);
}
this.load_node(obj, function (o, ok) {
return ok ? this.open_node(o, callback, animation) : (callback ? callback.call(this, o, false) : false);
});
}
else {
d = this.get_node(obj, true);
t = this;
if(d.length) {
if(animation && d.children(".jstree-children").length) {
d.children(".jstree-children").stop(true, true);
}
if(obj.children.length && !this._firstChild(d.children('.jstree-children')[0])) {
this.draw_children(obj);
}
if(!animation) {
this.trigger('before_open', { "node" : obj });
d[0].className = d[0].className.replace('jstree-closed', 'jstree-open');
d[0].setAttribute("aria-expanded", true);
}
else {
this.trigger('before_open', { "node" : obj });
d
.children(".jstree-children").css("display","none").end()
.removeClass("jstree-closed").addClass("jstree-open").attr("aria-expanded", true)
.children(".jstree-children").stop(true, true)
.slideDown(animation, function () {
this.style.display = "";
if (t.element) {
t.trigger("after_open", { "node" : obj });
}
});
}
}
obj.state.opened = true;
if(callback) {
callback.call(this, obj, true);
}
if(!d.length) {
this.trigger('before_open', { "node" : obj });
}
this.trigger('open_node', { "node" : obj });
if(!animation || !d.length) {
this.trigger("after_open", { "node" : obj });
}
return true;
}
},
_open_to : function (obj) {
obj = this.get_node(obj);
if(!obj || obj.id === $.jstree.root) {
return false;
}
var i, j, p = obj.parents;
for(i = 0, j = p.length; i < j; i+=1) {
if(i !== $.jstree.root) {
this.open_node(p[i], false, 0);
}
}
return $('#' + obj.id.replace($.jstree.idregex,'\\$&'), this.element);
},
close_node : function (obj, animation) {
var t1, t2, t, d;
if($.isArray(obj)) {
obj = obj.slice();
for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
this.close_node(obj[t1], animation);
}
return true;
}
obj = this.get_node(obj);
if(!obj || obj.id === $.jstree.root) {
return false;
}
if(this.is_closed(obj)) {
return false;
}
animation = animation === undefined ? this.settings.core.animation : animation;
t = this;
d = this.get_node(obj, true);
obj.state.opened = false;
this.trigger('close_node',{ "node" : obj });
if(!d.length) {
this.trigger("after_close", { "node" : obj });
}
else {
if(!animation) {
d[0].className = d[0].className.replace('jstree-open', 'jstree-closed');
d.attr("aria-expanded", false).children('.jstree-children').remove();
this.trigger("after_close", { "node" : obj });
}
else {
d
.children(".jstree-children").attr("style","display:block !important").end()
.removeClass("jstree-open").addClass("jstree-closed").attr("aria-expanded", false)
.children(".jstree-children").stop(true, true).slideUp(animation, function () {
this.style.display = "";
d.children('.jstree-children').remove();
if (t.element) {
t.trigger("after_close", { "node" : obj });
}
});
}
}
},
toggle_node : function (obj) {
var t1, t2;
if($.isArray(obj)) {
obj = obj.slice();
for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
this.toggle_node(obj[t1]);
}
return true;
}
if(this.is_closed(obj)) {
return this.open_node(obj);
}
if(this.is_open(obj)) {
return this.close_node(obj);
}
},
open_all : function (obj, animation, original_obj) {
if(!obj) { obj = $.jstree.root; }
obj = this.get_node(obj);
if(!obj) { return false; }
var dom = obj.id === $.jstree.root ? this.get_container_ul() : this.get_node(obj, true), i, j, _this;
if(!dom.length) {
for(i = 0, j = obj.children_d.length; i < j; i++) {
if(this.is_closed(this._model.data[obj.children_d[i]])) {
this._model.data[obj.children_d[i]].state.opened = true;
}
}
return this.trigger('open_all', { "node" : obj });
}
original_obj = original_obj || dom;
_this = this;
dom = this.is_closed(obj) ? dom.find('.jstree-closed').addBack() : dom.find('.jstree-closed');
dom.each(function () {
_this.open_node(
this,
function(node, status) { if(status && this.is_parent(node)) { this.open_all(node, animation, original_obj); } },
animation || 0
);
});
if(original_obj.find('.jstree-closed').length === 0) {
this.trigger('open_all', { "node" : this.get_node(original_obj) });
}
},
close_all : function (obj, animation) {
if(!obj) { obj = $.jstree.root; }
obj = this.get_node(obj);
if(!obj) { return false; }
var dom = obj.id === $.jstree.root ? this.get_container_ul() : this.get_node(obj, true),
_this = this, i, j;
if(dom.length) {
dom = this.is_open(obj) ? dom.find('.jstree-open').addBack() : dom.find('.jstree-open');
$(dom.get().reverse()).each(function () { _this.close_node(this, animation || 0); });
}
for(i = 0, j = obj.children_d.length; i < j; i++) {
this._model.data[obj.children_d[i]].state.opened = false;
}
this.trigger('close_all', { "node" : obj });
},
is_disabled : function (obj) {
obj = this.get_node(obj);
return obj && obj.state && obj.state.disabled;
},
enable_node : function (obj) {
var t1, t2;
if($.isArray(obj)) {
obj = obj.slice();
for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
this.enable_node(obj[t1]);
}
return true;
}
obj = this.get_node(obj);
if(!obj || obj.id === $.jstree.root) {
return false;
}
obj.state.disabled = false;
this.get_node(obj,true).children('.jstree-anchor').removeClass('jstree-disabled').attr('aria-disabled', false);
this.trigger('enable_node', { 'node' : obj });
},
disable_node : function (obj) {
var t1, t2;
if($.isArray(obj)) {
obj = obj.slice();
for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
this.disable_node(obj[t1]);
}
return true;
}
obj = this.get_node(obj);
if(!obj || obj.id === $.jstree.root) {
return false;
}
obj.state.disabled = true;
this.get_node(obj,true).children('.jstree-anchor').addClass('jstree-disabled').attr('aria-disabled', true);
this.trigger('disable_node', { 'node' : obj });
},
is_hidden : function (obj) {
obj = this.get_node(obj);
return obj.state.hidden === true;
},
hide_node : function (obj, skip_redraw) {
var t1, t2;
if($.isArray(obj)) {
obj = obj.slice();
for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
this.hide_node(obj[t1], true);
}
if (!skip_redraw) {
this.redraw();
}
return true;
}
obj = this.get_node(obj);
if(!obj || obj.id === $.jstree.root) {
return false;
}
if(!obj.state.hidden) {
obj.state.hidden = true;
this._node_changed(obj.parent);
if(!skip_redraw) {
this.redraw();
}
this.trigger('hide_node', { 'node' : obj });
}
},
show_node : function (obj, skip_redraw) {
var t1, t2;
if($.isArray(obj)) {
obj = obj.slice();
for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
this.show_node(obj[t1], true);
}
if (!skip_redraw) {
this.redraw();
}
return true;
}
obj = this.get_node(obj);
if(!obj || obj.id === $.jstree.root) {
return false;
}
if(obj.state.hidden) {
obj.state.hidden = false;
this._node_changed(obj.parent);
if(!skip_redraw) {
this.redraw();
}
this.trigger('show_node', { 'node' : obj });
}
},
hide_all : function (skip_redraw) {
var i, m = this._model.data, ids = [];
for(i in m) {
if(m.hasOwnProperty(i) && i !== $.jstree.root && !m[i].state.hidden) {
m[i].state.hidden = true;
ids.push(i);
}
}
this._model.force_full_redraw = true;
if(!skip_redraw) {
this.redraw();
}
this.trigger('hide_all', { 'nodes' : ids });
return ids;
},
show_all : function (skip_redraw) {
var i, m = this._model.data, ids = [];
for(i in m) {
if(m.hasOwnProperty(i) && i !== $.jstree.root && m[i].state.hidden) {
m[i].state.hidden = false;
ids.push(i);
}
}
this._model.force_full_redraw = true;
if(!skip_redraw) {
this.redraw();
}
this.trigger('show_all', { 'nodes' : ids });
return ids;
},
activate_node : function (obj, e) {
if(this.is_disabled(obj)) {
return false;
}
if(!e || typeof e !== 'object') {
e = {};
}
this._data.core.last_clicked = this._data.core.last_clicked && this._data.core.last_clicked.id !== undefined ? this.get_node(this._data.core.last_clicked.id) : null;
if(this._data.core.last_clicked && !this._data.core.last_clicked.state.selected) { this._data.core.last_clicked = null; }
if(!this._data.core.last_clicked && this._data.core.selected.length) { this._data.core.last_clicked = this.get_node(this._data.core.selected[this._data.core.selected.length - 1]); }
if(!this.settings.core.multiple || (!e.metaKey && !e.ctrlKey && !e.shiftKey) || (e.shiftKey && (!this._data.core.last_clicked || !this.get_parent(obj) || this.get_parent(obj) !== this._data.core.last_clicked.parent ) )) {
if(!this.settings.core.multiple && (e.metaKey || e.ctrlKey || e.shiftKey) && this.is_selected(obj)) {
this.deselect_node(obj, false, e);
}
else {
this.deselect_all(true);
this.select_node(obj, false, false, e);
this._data.core.last_clicked = this.get_node(obj);
}
}
else {
if(e.shiftKey) {
var o = this.get_node(obj).id,
l = this._data.core.last_clicked.id,
p = this.get_node(this._data.core.last_clicked.parent).children,
c = false,
i, j;
for(i = 0, j = p.length; i < j; i += 1) {
if(p[i] === o) {
c = !c;
}
if(p[i] === l) {
c = !c;
}
if(!this.is_disabled(p[i]) && (c || p[i] === o || p[i] === l)) {
if (!this.is_hidden(p[i])) {
this.select_node(p[i], true, false, e);
}
}
else {
this.deselect_node(p[i], true, e);
}
}
this.trigger('changed', { 'action' : 'select_node', 'node' : this.get_node(obj), 'selected' : this._data.core.selected, 'event' : e });
}
else {
if(!this.is_selected(obj)) {
this.select_node(obj, false, false, e);
}
else {
this.deselect_node(obj, false, e);
}
}
}
this.trigger('activate_node', { 'node' : this.get_node(obj), 'event' : e });
},
hover_node : function (obj) {
obj = this.get_node(obj, true);
if(!obj || !obj.length || obj.children('.jstree-hovered').length) {
return false;
}
var o = this.element.find('.jstree-hovered'), t = this.element;
if(o && o.length) { this.dehover_node(o); }
obj.children('.jstree-anchor').addClass('jstree-hovered');
this.trigger('hover_node', { 'node' : this.get_node(obj) });
setTimeout(function () { t.attr('aria-activedescendant', obj[0].id); }, 0);
},
dehover_node : function (obj) {
obj = this.get_node(obj, true);
if(!obj || !obj.length || !obj.children('.jstree-hovered').length) {
return false;
}
obj.children('.jstree-anchor').removeClass('jstree-hovered');
this.trigger('dehover_node', { 'node' : this.get_node(obj) });
},
select_node : function (obj, supress_event, prevent_open, e) {
var dom, t1, t2, th;
if($.isArray(obj)) {
obj = obj.slice();
for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
this.select_node(obj[t1], supress_event, prevent_open, e);
}
return true;
}
obj = this.get_node(obj);
if(!obj || obj.id === $.jstree.root) {
return false;
}
dom = this.get_node(obj, true);
if(!obj.state.selected) {
obj.state.selected = true;
this._data.core.selected.push(obj.id);
if(!prevent_open) {
dom = this._open_to(obj);
}
if(dom && dom.length) {
dom.attr('aria-selected', true).children('.jstree-anchor').addClass('jstree-clicked');
}
this.trigger('select_node', { 'node' : obj, 'selected' : this._data.core.selected, 'event' : e });
if(!supress_event) {
this.trigger('changed', { 'action' : 'select_node', 'node' : obj, 'selected' : this._data.core.selected, 'event' : e });
}
}
},
deselect_node : function (obj, supress_event, e) {
var t1, t2, dom;
if($.isArray(obj)) {
obj = obj.slice();
for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
this.deselect_node(obj[t1], supress_event, e);
}
return true;
}
obj = this.get_node(obj);
if(!obj || obj.id === $.jstree.root) {
return false;
}
dom = this.get_node(obj, true);
if(obj.state.selected) {
obj.state.selected = false;
this._data.core.selected = $.vakata.array_remove_item(this._data.core.selected, obj.id);
if(dom.length) {
dom.attr('aria-selected', false).children('.jstree-anchor').removeClass('jstree-clicked');
}
this.trigger('deselect_node', { 'node' : obj, 'selected' : this._data.core.selected, 'event' : e });
if(!supress_event) {
this.trigger('changed', { 'action' : 'deselect_node', 'node' : obj, 'selected' : this._data.core.selected, 'event' : e });
}
}
},
select_all : function (supress_event) {
var tmp = this._data.core.selected.concat([]), i, j;
this._data.core.selected = this._model.data[$.jstree.root].children_d.concat();
for(i = 0, j = this._data.core.selected.length; i < j; i++) {
if(this._model.data[this._data.core.selected[i]]) {
this._model.data[this._data.core.selected[i]].state.selected = true;
}
}
this.redraw(true);
this.trigger('select_all', { 'selected' : this._data.core.selected });
if(!supress_event) {
this.trigger('changed', { 'action' : 'select_all', 'selected' : this._data.core.selected, 'old_selection' : tmp });
}
},
deselect_all : function (supress_event) {
var tmp = this._data.core.selected.concat([]), i, j;
for(i = 0, j = this._data.core.selected.length; i < j; i++) {
if(this._model.data[this._data.core.selected[i]]) {
this._model.data[this._data.core.selected[i]].state.selected = false;
}
}
this._data.core.selected = [];
this.element.find('.jstree-clicked').removeClass('jstree-clicked').parent().attr('aria-selected', false);
this.trigger('deselect_all', { 'selected' : this._data.core.selected, 'node' : tmp });
if(!supress_event) {
this.trigger('changed', { 'action' : 'deselect_all', 'selected' : this._data.core.selected, 'old_selection' : tmp });
}
},
is_selected : function (obj) {
obj = this.get_node(obj);
if(!obj || obj.id === $.jstree.root) {
return false;
}
return obj.state.selected;
},
get_selected : function (full) {
return full ? $.map(this._data.core.selected, $.proxy(function (i) { return this.get_node(i); }, this)) : this._data.core.selected.slice();
},
get_top_selected : function (full) {
var tmp = this.get_selected(true),
obj = {}, i, j, k, l;
for(i = 0, j = tmp.length; i < j; i++) {
obj[tmp[i].id] = tmp[i];
}
for(i = 0, j = tmp.length; i < j; i++) {
for(k = 0, l = tmp[i].children_d.length; k < l; k++) {
if(obj[tmp[i].children_d[k]]) {
delete obj[tmp[i].children_d[k]];
}
}
}
tmp = [];
for(i in obj) {
if(obj.hasOwnProperty(i)) {
tmp.push(i);
}
}
return full ? $.map(tmp, $.proxy(function (i) { return this.get_node(i); }, this)) : tmp;
},
get_bottom_selected : function (full) {
var tmp = this.get_selected(true),
obj = [], i, j;
for(i = 0, j = tmp.length; i < j; i++) {
if(!tmp[i].children.length) {
obj.push(tmp[i].id);
}
}
return full ? $.map(obj, $.proxy(function (i) { return this.get_node(i); }, this)) : obj;
},
get_state : function () {
var state	= {
'core' : {
'open' : [],
'scroll' : {
'left' : this.element.scrollLeft(),
'top' : this.element.scrollTop()
},
'selected' : []
}
}, i;
for(i in this._model.data) {
if(this._model.data.hasOwnProperty(i)) {
if(i !== $.jstree.root) {
if(this._model.data[i].state.opened) {
state.core.open.push(i);
}
if(this._model.data[i].state.selected) {
state.core.selected.push(i);
}
}
}
}
return state;
},
set_state : function (state, callback) {
if(state) {
if(state.core && state.core.selected && state.core.initial_selection === undefined) {
state.core.initial_selection = this._data.core.selected.concat([]).sort().join(',');
}
if(state.core) {
var res, n, t, _this, i;
if(state.core.open) {
if(!$.isArray(state.core.open) || !state.core.open.length) {
delete state.core.open;
this.set_state(state, callback);
}
else {
this._load_nodes(state.core.open, function (nodes) {
this.open_node(nodes, false, 0);
delete state.core.open;
this.set_state(state, callback);
});
}
return false;
}
if(state.core.scroll) {
if(state.core.scroll && state.core.scroll.left !== undefined) {
this.element.scrollLeft(state.core.scroll.left);
}
if(state.core.scroll && state.core.scroll.top !== undefined) {
this.element.scrollTop(state.core.scroll.top);
}
delete state.core.scroll;
this.set_state(state, callback);
return false;
}
if(state.core.selected) {
_this = this;
if (state.core.initial_selection === undefined ||
state.core.initial_selection === this._data.core.selected.concat([]).sort().join(',')
) {
this.deselect_all();
$.each(state.core.selected, function (i, v) {
_this.select_node(v, false, true);
});
}
delete state.core.initial_selection;
delete state.core.selected;
this.set_state(state, callback);
return false;
}
for(i in state) {
if(state.hasOwnProperty(i) && i !== "core" && $.inArray(i, this.settings.plugins) === -1) {
delete state[i];
}
}
if($.isEmptyObject(state.core)) {
delete state.core;
this.set_state(state, callback);
return false;
}
}
if($.isEmptyObject(state)) {
state = null;
if(callback) { callback.call(this); }
this.trigger('set_state');
return false;
}
return true;
}
return false;
},
refresh : function (skip_loading, forget_state) {
this._data.core.state = forget_state === true ? {} : this.get_state();
if(forget_state && $.isFunction(forget_state)) { this._data.core.state = forget_state.call(this, this._data.core.state); }
this._cnt = 0;
this._model.data = {};
this._model.data[$.jstree.root] = {
id : $.jstree.root,
parent : null,
parents : [],
children : [],
children_d : [],
state : { loaded : false }
};
this._data.core.selected = [];
this._data.core.last_clicked = null;
this._data.core.focused = null;
var c = this.get_container_ul()[0].className;
if(!skip_loading) {
this.element.html("<"+"ul class='"+c+"' role='group'><"+"li class='jstree-initial-node jstree-loading jstree-leaf jstree-last' role='treeitem' id='j"+this._id+"_loading'><i class='jstree-icon jstree-ocl'></i><"+"a class='jstree-anchor' href='#'><i class='jstree-icon jstree-themeicon-hidden'></i>" + this.get_string("Loading ...") + "</a></li></ul>");
this.element.attr('aria-activedescendant','j'+this._id+'_loading');
}
this.load_node($.jstree.root, function (o, s) {
if(s) {
this.get_container_ul()[0].className = c;
if(this._firstChild(this.get_container_ul()[0])) {
this.element.attr('aria-activedescendant',this._firstChild(this.get_container_ul()[0]).id);
}
this.set_state($.extend(true, {}, this._data.core.state), function () {
this.trigger('refresh');
});
}
this._data.core.state = null;
});
},
refresh_node : function (obj) {
obj = this.get_node(obj);
if(!obj || obj.id === $.jstree.root) { return false; }
var opened = [], to_load = [], s = this._data.core.selected.concat([]);
to_load.push(obj.id);
if(obj.state.opened === true) { opened.push(obj.id); }
this.get_node(obj, true).find('.jstree-open').each(function() { to_load.push(this.id); opened.push(this.id); });
this._load_nodes(to_load, $.proxy(function (nodes) {
this.open_node(opened, false, 0);
this.select_node(s);
this.trigger('refresh_node', { 'node' : obj, 'nodes' : nodes });
}, this), false, true);
},
set_id : function (obj, id) {
obj = this.get_node(obj);
if(!obj || obj.id === $.jstree.root) { return false; }
var i, j, m = this._model.data, old = obj.id;
id = id.toString();
m[obj.parent].children[$.inArray(obj.id, m[obj.parent].children)] = id;
for(i = 0, j = obj.parents.length; i < j; i++) {
m[obj.parents[i]].children_d[$.inArray(obj.id, m[obj.parents[i]].children_d)] = id;
}
for(i = 0, j = obj.children.length; i < j; i++) {
m[obj.children[i]].parent = id;
}
for(i = 0, j = obj.children_d.length; i < j; i++) {
m[obj.children_d[i]].parents[$.inArray(obj.id, m[obj.children_d[i]].parents)] = id;
}
i = $.inArray(obj.id, this._data.core.selected);
if(i !== -1) { this._data.core.selected[i] = id; }
i = this.get_node(obj.id, true);
if(i) {
i.attr('id', id); //.children('.jstree-anchor').attr('id', id + '_anchor').end().attr('aria-labelledby', id + '_anchor');
if(this.element.attr('aria-activedescendant') === obj.id) {
this.element.attr('aria-activedescendant', id);
}
}
delete m[obj.id];
obj.id = id;
obj.li_attr.id = id;
m[id] = obj;
this.trigger('set_id',{ "node" : obj, "new" : obj.id, "old" : old });
return true;
},
get_text : function (obj) {
obj = this.get_node(obj);
return (!obj || obj.id === $.jstree.root) ? false : obj.text;
},
set_text : function (obj, val) {
var t1, t2;
if($.isArray(obj)) {
obj = obj.slice();
for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
this.set_text(obj[t1], val);
}
return true;
}
obj = this.get_node(obj);
if(!obj || obj.id === $.jstree.root) { return false; }
obj.text = val;
if(this.get_node(obj, true).length) {
this.redraw_node(obj.id);
}
this.trigger('set_text',{ "obj" : obj, "text" : val });
return true;
},
get_json : function (obj, options, flat) {
obj = this.get_node(obj || $.jstree.root);
if(!obj) { return false; }
if(options && options.flat && !flat) { flat = []; }
var tmp = {
'id' : obj.id,
'text' : obj.text,
'icon' : this.get_icon(obj),
'li_attr' : $.extend(true, {}, obj.li_attr),
'a_attr' : $.extend(true, {}, obj.a_attr),
'state' : {},
'data' : options && options.no_data ? false : $.extend(true, $.isArray(obj.data)?[]:{}, obj.data)
}, i, j;
if(options && options.flat) {
tmp.parent = obj.parent;
}
else {
tmp.children = [];
}
if(!options || !options.no_state) {
for(i in obj.state) {
if(obj.state.hasOwnProperty(i)) {
tmp.state[i] = obj.state[i];
}
}
} else {
delete tmp.state;
}
if(options && options.no_li_attr) {
delete tmp.li_attr;
}
if(options && options.no_a_attr) {
delete tmp.a_attr;
}
if(options && options.no_id) {
delete tmp.id;
if(tmp.li_attr && tmp.li_attr.id) {
delete tmp.li_attr.id;
}
if(tmp.a_attr && tmp.a_attr.id) {
delete tmp.a_attr.id;
}
}
if(options && options.flat && obj.id !== $.jstree.root) {
flat.push(tmp);
}
if(!options || !options.no_children) {
for(i = 0, j = obj.children.length; i < j; i++) {
if(options && options.flat) {
this.get_json(obj.children[i], options, flat);
}
else {
tmp.children.push(this.get_json(obj.children[i], options));
}
}
}
return options && options.flat ? flat : (obj.id === $.jstree.root ? tmp.children : tmp);
},
create_node : function (par, node, pos, callback, is_loaded) {
if(par === null) { par = $.jstree.root; }
par = this.get_node(par);
if(!par) { return false; }
pos = pos === undefined ? "last" : pos;
if(!pos.toString().match(/^(before|after)$/) && !is_loaded && !this.is_loaded(par)) {
return this.load_node(par, function () { this.create_node(par, node, pos, callback, true); });
}
if(!node) { node = { "text" : this.get_string('New node') }; }
if(typeof node === "string") {
node = { "text" : node };
} else {
node = $.extend(true, {}, node);
}
if(node.text === undefined) { node.text = this.get_string('New node'); }
var tmp, dpc, i, j;
if(par.id === $.jstree.root) {
if(pos === "before") { pos = "first"; }
if(pos === "after") { pos = "last"; }
}
switch(pos) {
case "before":
tmp = this.get_node(par.parent);
pos = $.inArray(par.id, tmp.children);
par = tmp;
break;
case "after" :
tmp = this.get_node(par.parent);
pos = $.inArray(par.id, tmp.children) + 1;
par = tmp;
break;
case "inside":
case "first":
pos = 0;
break;
case "last":
pos = par.children.length;
break;
default:
if(!pos) { pos = 0; }
break;
}
if(pos > par.children.length) { pos = par.children.length; }
if(!node.id) { node.id = true; }
if(!this.check("create_node", node, par, pos)) {
this.settings.core.error.call(this, this._data.core.last_error);
return false;
}
if(node.id === true) { delete node.id; }
node = this._parse_model_from_json(node, par.id, par.parents.concat());
if(!node) { return false; }
tmp = this.get_node(node);
dpc = [];
dpc.push(node);
dpc = dpc.concat(tmp.children_d);
this.trigger('model', { "nodes" : dpc, "parent" : par.id });
par.children_d = par.children_d.concat(dpc);
for(i = 0, j = par.parents.length; i < j; i++) {
this._model.data[par.parents[i]].children_d = this._model.data[par.parents[i]].children_d.concat(dpc);
}
node = tmp;
tmp = [];
for(i = 0, j = par.children.length; i < j; i++) {
tmp[i >= pos ? i+1 : i] = par.children[i];
}
tmp[pos] = node.id;
par.children = tmp;
this.redraw_node(par, true);
this.trigger('create_node', { "node" : this.get_node(node), "parent" : par.id, "position" : pos });
if(callback) { callback.call(this, this.get_node(node)); }
return node.id;
},
rename_node : function (obj, val) {
var t1, t2, old;
if($.isArray(obj)) {
obj = obj.slice();
for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
this.rename_node(obj[t1], val);
}
return true;
}
obj = this.get_node(obj);
if(!obj || obj.id === $.jstree.root) { return false; }
old = obj.text;
if(!this.check("rename_node", obj, this.get_parent(obj), val)) {
this.settings.core.error.call(this, this._data.core.last_error);
return false;
}
this.set_text(obj, val); // .apply(this, Array.prototype.slice.call(arguments))
this.trigger('rename_node', { "node" : obj, "text" : val, "old" : old });
return true;
},
delete_node : function (obj) {
var t1, t2, par, pos, tmp, i, j, k, l, c, top, lft;
if($.isArray(obj)) {
obj = obj.slice();
for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
this.delete_node(obj[t1]);
}
return true;
}
obj = this.get_node(obj);
if(!obj || obj.id === $.jstree.root) { return false; }
par = this.get_node(obj.parent);
pos = $.inArray(obj.id, par.children);
c = false;
if(!this.check("delete_node", obj, par, pos)) {
this.settings.core.error.call(this, this._data.core.last_error);
return false;
}
if(pos !== -1) {
par.children = $.vakata.array_remove(par.children, pos);
}
tmp = obj.children_d.concat([]);
tmp.push(obj.id);
for(i = 0, j = obj.parents.length; i < j; i++) {
this._model.data[obj.parents[i]].children_d = $.vakata.array_filter(this._model.data[obj.parents[i]].children_d, function (v) {
return $.inArray(v, tmp) === -1;
});
}
for(k = 0, l = tmp.length; k < l; k++) {
if(this._model.data[tmp[k]].state.selected) {
c = true;
break;
}
}
if (c) {
this._data.core.selected = $.vakata.array_filter(this._data.core.selected, function (v) {
return $.inArray(v, tmp) === -1;
});
}
this.trigger('delete_node', { "node" : obj, "parent" : par.id });
if(c) {
this.trigger('changed', { 'action' : 'delete_node', 'node' : obj, 'selected' : this._data.core.selected, 'parent' : par.id });
}
for(k = 0, l = tmp.length; k < l; k++) {
delete this._model.data[tmp[k]];
}
if($.inArray(this._data.core.focused, tmp) !== -1) {
this._data.core.focused = null;
top = this.element[0].scrollTop;
lft = this.element[0].scrollLeft;
if(par.id === $.jstree.root) {
if (this._model.data[$.jstree.root].children[0]) {
this.get_node(this._model.data[$.jstree.root].children[0], true).children('.jstree-anchor').focus();
}
}
else {
this.get_node(par, true).children('.jstree-anchor').focus();
}
this.element[0].scrollTop  = top;
this.element[0].scrollLeft = lft;
}
this.redraw_node(par, true);
return true;
},
check : function (chk, obj, par, pos, more) {
obj = obj && obj.id ? obj : this.get_node(obj);
par = par && par.id ? par : this.get_node(par);
var tmp = chk.match(/^move_node|copy_node|create_node$/i) ? par : obj,
chc = this.settings.core.check_callback;
if(chk === "move_node" || chk === "copy_node") {
if((!more || !more.is_multi) && (obj.id === par.id || (chk === "move_node" && $.inArray(obj.id, par.children) === pos) || $.inArray(par.id, obj.children_d) !== -1)) {
this._data.core.last_error = { 'error' : 'check', 'plugin' : 'core', 'id' : 'core_01', 'reason' : 'Moving parent inside child', 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };
return false;
}
}
if(tmp && tmp.data) { tmp = tmp.data; }
if(tmp && tmp.functions && (tmp.functions[chk] === false || tmp.functions[chk] === true)) {
if(tmp.functions[chk] === false) {
this._data.core.last_error = { 'error' : 'check', 'plugin' : 'core', 'id' : 'core_02', 'reason' : 'Node data prevents function: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };
}
return tmp.functions[chk];
}
if(chc === false || ($.isFunction(chc) && chc.call(this, chk, obj, par, pos, more) === false) || (chc && chc[chk] === false)) {
this._data.core.last_error = { 'error' : 'check', 'plugin' : 'core', 'id' : 'core_03', 'reason' : 'User config for core.check_callback prevents function: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };
return false;
}
return true;
},
last_error : function () {
return this._data.core.last_error;
},
move_node : function (obj, par, pos, callback, is_loaded, skip_redraw, origin) {
var t1, t2, old_par, old_pos, new_par, old_ins, is_multi, dpc, tmp, i, j, k, l, p;
par = this.get_node(par);
pos = pos === undefined ? 0 : pos;
if(!par) { return false; }
if(!pos.toString().match(/^(before|after)$/) && !is_loaded && !this.is_loaded(par)) {
return this.load_node(par, function () { this.move_node(obj, par, pos, callback, true, false, origin); });
}
if($.isArray(obj)) {
if(obj.length === 1) {
obj = obj[0];
}
else {
for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
if((tmp = this.move_node(obj[t1], par, pos, callback, is_loaded, false, origin))) {
par = tmp;
pos = "after";
}
}
this.redraw();
return true;
}
}
obj = obj && obj.id ? obj : this.get_node(obj);
if(!obj || obj.id === $.jstree.root) { return false; }
old_par = (obj.parent || $.jstree.root).toString();
new_par = (!pos.toString().match(/^(before|after)$/) || par.id === $.jstree.root) ? par : this.get_node(par.parent);
old_ins = origin ? origin : (this._model.data[obj.id] ? this : $.jstree.reference(obj.id));
is_multi = !old_ins || !old_ins._id || (this._id !== old_ins._id);
old_pos = old_ins && old_ins._id && old_par && old_ins._model.data[old_par] && old_ins._model.data[old_par].children ? $.inArray(obj.id, old_ins._model.data[old_par].children) : -1;
if(old_ins && old_ins._id) {
obj = old_ins._model.data[obj.id];
}
if(is_multi) {
if((tmp = this.copy_node(obj, par, pos, callback, is_loaded, false, origin))) {
if(old_ins) { old_ins.delete_node(obj); }
return tmp;
}
return false;
}
if(par.id === $.jstree.root) {
if(pos === "before") { pos = "first"; }
if(pos === "after") { pos = "last"; }
}
switch(pos) {
case "before":
pos = $.inArray(par.id, new_par.children);
break;
case "after" :
pos = $.inArray(par.id, new_par.children) + 1;
break;
case "inside":
case "first":
pos = 0;
break;
case "last":
pos = new_par.children.length;
break;
default:
if(!pos) { pos = 0; }
break;
}
if(pos > new_par.children.length) { pos = new_par.children.length; }
if(!this.check("move_node", obj, new_par, pos, { 'core' : true, 'origin' : origin, 'is_multi' : (old_ins && old_ins._id && old_ins._id !== this._id), 'is_foreign' : (!old_ins || !old_ins._id) })) {
this.settings.core.error.call(this, this._data.core.last_error);
return false;
}
if(obj.parent === new_par.id) {
dpc = new_par.children.concat();
tmp = $.inArray(obj.id, dpc);
if(tmp !== -1) {
dpc = $.vakata.array_remove(dpc, tmp);
if(pos > tmp) { pos--; }
}
tmp = [];
for(i = 0, j = dpc.length; i < j; i++) {
tmp[i >= pos ? i+1 : i] = dpc[i];
}
tmp[pos] = obj.id;
new_par.children = tmp;
this._node_changed(new_par.id);
this.redraw(new_par.id === $.jstree.root);
}
else {
tmp = obj.children_d.concat();
tmp.push(obj.id);
for(i = 0, j = obj.parents.length; i < j; i++) {
dpc = [];
p = old_ins._model.data[obj.parents[i]].children_d;
for(k = 0, l = p.length; k < l; k++) {
if($.inArray(p[k], tmp) === -1) {
dpc.push(p[k]);
}
}
old_ins._model.data[obj.parents[i]].children_d = dpc;
}
old_ins._model.data[old_par].children = $.vakata.array_remove_item(old_ins._model.data[old_par].children, obj.id);
for(i = 0, j = new_par.parents.length; i < j; i++) {
this._model.data[new_par.parents[i]].children_d = this._model.data[new_par.parents[i]].children_d.concat(tmp);
}
dpc = [];
for(i = 0, j = new_par.children.length; i < j; i++) {
dpc[i >= pos ? i+1 : i] = new_par.children[i];
}
dpc[pos] = obj.id;
new_par.children = dpc;
new_par.children_d.push(obj.id);
new_par.children_d = new_par.children_d.concat(obj.children_d);
obj.parent = new_par.id;
tmp = new_par.parents.concat();
tmp.unshift(new_par.id);
p = obj.parents.length;
obj.parents = tmp;
tmp = tmp.concat();
for(i = 0, j = obj.children_d.length; i < j; i++) {
this._model.data[obj.children_d[i]].parents = this._model.data[obj.children_d[i]].parents.slice(0,p*-1);
Array.prototype.push.apply(this._model.data[obj.children_d[i]].parents, tmp);
}
if(old_par === $.jstree.root || new_par.id === $.jstree.root) {
this._model.force_full_redraw = true;
}
if(!this._model.force_full_redraw) {
this._node_changed(old_par);
this._node_changed(new_par.id);
}
if(!skip_redraw) {
this.redraw();
}
}
if(callback) { callback.call(this, obj, new_par, pos); }
this.trigger('move_node', { "node" : obj, "parent" : new_par.id, "position" : pos, "old_parent" : old_par, "old_position" : old_pos, 'is_multi' : (old_ins && old_ins._id && old_ins._id !== this._id), 'is_foreign' : (!old_ins || !old_ins._id), 'old_instance' : old_ins, 'new_instance' : this });
return obj.id;
},
copy_node : function (obj, par, pos, callback, is_loaded, skip_redraw, origin) {
var t1, t2, dpc, tmp, i, j, node, old_par, new_par, old_ins, is_multi;
par = this.get_node(par);
pos = pos === undefined ? 0 : pos;
if(!par) { return false; }
if(!pos.toString().match(/^(before|after)$/) && !is_loaded && !this.is_loaded(par)) {
return this.load_node(par, function () { this.copy_node(obj, par, pos, callback, true, false, origin); });
}
if($.isArray(obj)) {
if(obj.length === 1) {
obj = obj[0];
}
else {
for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
if((tmp = this.copy_node(obj[t1], par, pos, callback, is_loaded, true, origin))) {
par = tmp;
pos = "after";
}
}
this.redraw();
return true;
}
}
obj = obj && obj.id ? obj : this.get_node(obj);
if(!obj || obj.id === $.jstree.root) { return false; }
old_par = (obj.parent || $.jstree.root).toString();
new_par = (!pos.toString().match(/^(before|after)$/) || par.id === $.jstree.root) ? par : this.get_node(par.parent);
old_ins = origin ? origin : (this._model.data[obj.id] ? this : $.jstree.reference(obj.id));
is_multi = !old_ins || !old_ins._id || (this._id !== old_ins._id);
if(old_ins && old_ins._id) {
obj = old_ins._model.data[obj.id];
}
if(par.id === $.jstree.root) {
if(pos === "before") { pos = "first"; }
if(pos === "after") { pos = "last"; }
}
switch(pos) {
case "before":
pos = $.inArray(par.id, new_par.children);
break;
case "after" :
pos = $.inArray(par.id, new_par.children) + 1;
break;
case "inside":
case "first":
pos = 0;
break;
case "last":
pos = new_par.children.length;
break;
default:
if(!pos) { pos = 0; }
break;
}
if(pos > new_par.children.length) { pos = new_par.children.length; }
if(!this.check("copy_node", obj, new_par, pos, { 'core' : true, 'origin' : origin, 'is_multi' : (old_ins && old_ins._id && old_ins._id !== this._id), 'is_foreign' : (!old_ins || !old_ins._id) })) {
this.settings.core.error.call(this, this._data.core.last_error);
return false;
}
node = old_ins ? old_ins.get_json(obj, { no_id : true, no_data : true, no_state : true }) : obj;
if(!node) { return false; }
if(node.id === true) { delete node.id; }
node = this._parse_model_from_json(node, new_par.id, new_par.parents.concat());
if(!node) { return false; }
tmp = this.get_node(node);
if(obj && obj.state && obj.state.loaded === false) { tmp.state.loaded = false; }
dpc = [];
dpc.push(node);
dpc = dpc.concat(tmp.children_d);
this.trigger('model', { "nodes" : dpc, "parent" : new_par.id });
for(i = 0, j = new_par.parents.length; i < j; i++) {
this._model.data[new_par.parents[i]].children_d = this._model.data[new_par.parents[i]].children_d.concat(dpc);
}
dpc = [];
for(i = 0, j = new_par.children.length; i < j; i++) {
dpc[i >= pos ? i+1 : i] = new_par.children[i];
}
dpc[pos] = tmp.id;
new_par.children = dpc;
new_par.children_d.push(tmp.id);
new_par.children_d = new_par.children_d.concat(tmp.children_d);
if(new_par.id === $.jstree.root) {
this._model.force_full_redraw = true;
}
if(!this._model.force_full_redraw) {
this._node_changed(new_par.id);
}
if(!skip_redraw) {
this.redraw(new_par.id === $.jstree.root);
}
if(callback) { callback.call(this, tmp, new_par, pos); }
this.trigger('copy_node', { "node" : tmp, "original" : obj, "parent" : new_par.id, "position" : pos, "old_parent" : old_par, "old_position" : old_ins && old_ins._id && old_par && old_ins._model.data[old_par] && old_ins._model.data[old_par].children ? $.inArray(obj.id, old_ins._model.data[old_par].children) : -1,'is_multi' : (old_ins && old_ins._id && old_ins._id !== this._id), 'is_foreign' : (!old_ins || !old_ins._id), 'old_instance' : old_ins, 'new_instance' : this });
return tmp.id;
},
cut : function (obj) {
if(!obj) { obj = this._data.core.selected.concat(); }
if(!$.isArray(obj)) { obj = [obj]; }
if(!obj.length) { return false; }
var tmp = [], o, t1, t2;
for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
o = this.get_node(obj[t1]);
if(o && o.id && o.id !== $.jstree.root) { tmp.push(o); }
}
if(!tmp.length) { return false; }
ccp_node = tmp;
ccp_inst = this;
ccp_mode = 'move_node';
this.trigger('cut', { "node" : obj });
},
copy : function (obj) {
if(!obj) { obj = this._data.core.selected.concat(); }
if(!$.isArray(obj)) { obj = [obj]; }
if(!obj.length) { return false; }
var tmp = [], o, t1, t2;
for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
o = this.get_node(obj[t1]);
if(o && o.id && o.id !== $.jstree.root) { tmp.push(o); }
}
if(!tmp.length) { return false; }
ccp_node = tmp;
ccp_inst = this;
ccp_mode = 'copy_node';
this.trigger('copy', { "node" : obj });
},
get_buffer : function () {
return { 'mode' : ccp_mode, 'node' : ccp_node, 'inst' : ccp_inst };
},
can_paste : function () {
return ccp_mode !== false && ccp_node !== false; // && ccp_inst._model.data[ccp_node];
},
paste : function (obj, pos) {
obj = this.get_node(obj);
if(!obj || !ccp_mode || !ccp_mode.match(/^(copy_node|move_node)$/) || !ccp_node) { return false; }
if(this[ccp_mode](ccp_node, obj, pos, false, false, false, ccp_inst)) {
this.trigger('paste', { "parent" : obj.id, "node" : ccp_node, "mode" : ccp_mode });
}
ccp_node = false;
ccp_mode = false;
ccp_inst = false;
},
clear_buffer : function () {
ccp_node = false;
ccp_mode = false;
ccp_inst = false;
this.trigger('clear_buffer');
},
edit : function (obj, default_text, callback) {
var rtl, w, a, s, t, h1, h2, fn, tmp, cancel = false;
obj = this.get_node(obj);
if(!obj) { return false; }
if(!this.check("edit", obj, this.get_parent(obj))) {
this.settings.core.error.call(this, this._data.core.last_error);
return false;
}
tmp = obj;
default_text = typeof default_text === 'string' ? default_text : obj.text;
this.set_text(obj, "");
obj = this._open_to(obj);
tmp.text = default_text;
rtl = this._data.core.rtl;
w  = this.element.width();
this._data.core.focused = tmp.id;
a  = obj.children('.jstree-anchor').focus();
s  = $('<span>');
t  = default_text;
h1 = $("<"+"div />", { css : { "position" : "absolute", "top" : "-200px", "left" : (rtl ? "0px" : "-1000px"), "visibility" : "hidden" } }).appendTo("body");
h2 = $("<"+"input />", {
"value" : t,
"class" : "jstree-rename-input",
"css" : {
"padding" : "0",
"border" : "1px solid silver",
"box-sizing" : "border-box",
"display" : "inline-block",
"height" : (this._data.core.li_height) + "px",
"lineHeight" : (this._data.core.li_height) + "px",
"width" : "150px" // will be set a bit further down
},
"blur" : $.proxy(function (e) {
e.stopImmediatePropagation();
e.preventDefault();
var i = s.children(".jstree-rename-input"),
v = i.val(),
f = this.settings.core.force_text,
nv;
if(v === "") { v = t; }
h1.remove();
s.replaceWith(a);
s.remove();
t = f ? t : $('<div></div>').append($.parseHTML(t)).html();
this.set_text(obj, t);
nv = !!this.rename_node(obj, f ? $('<div></div>').text(v).text() : $('<div></div>').append($.parseHTML(v)).html());
if(!nv) {
this.set_text(obj, t); // move this up? and fix #483
}
this._data.core.focused = tmp.id;
setTimeout($.proxy(function () {
var node = this.get_node(tmp.id, true);
if(node.length) {
this._data.core.focused = tmp.id;
node.children('.jstree-anchor').focus();
}
}, this), 0);
if(callback) {
callback.call(this, tmp, nv, cancel);
}
h2 = null;
}, this),
"keydown" : function (e) {
var key = e.which;
if(key === 27) {
cancel = true;
this.value = t;
}
if(key === 27 || key === 13 || key === 37 || key === 38 || key === 39 || key === 40 || key === 32) {
e.stopImmediatePropagation();
}
if(key === 27 || key === 13) {
e.preventDefault();
this.blur();
}
},
"click" : function (e) { e.stopImmediatePropagation(); },
"mousedown" : function (e) { e.stopImmediatePropagation(); },
"keyup" : function (e) {
h2.width(Math.min(h1.text("pW" + this.value).width(),w));
},
"keypress" : function(e) {
if(e.which === 13) { return false; }
}
});
fn = {
fontFamily		: a.css('fontFamily')		|| '',
fontSize		: a.css('fontSize')			|| '',
fontWeight		: a.css('fontWeight')		|| '',
fontStyle		: a.css('fontStyle')		|| '',
fontStretch		: a.css('fontStretch')		|| '',
fontVariant		: a.css('fontVariant')		|| '',
letterSpacing	: a.css('letterSpacing')	|| '',
wordSpacing		: a.css('wordSpacing')		|| ''
};
s.attr('class', a.attr('class')).append(a.contents().clone()).append(h2);
a.replaceWith(s);
h1.css(fn);
h2.css(fn).width(Math.min(h1.text("pW" + h2[0].value).width(),w))[0].select();
$(document).one('mousedown.jstree touchstart.jstree dnd_start.vakata', function (e) {
if (h2 && e.target !== h2) {
$(h2).blur();
}
});
},
set_theme : function (theme_name, theme_url) {
if(!theme_name) { return false; }
if(theme_url === true) {
var dir = this.settings.core.themes.dir;
if(!dir) { dir = $.jstree.path + '/themes'; }
theme_url = dir + '/' + theme_name + '/style.css';
}
if(theme_url && $.inArray(theme_url, themes_loaded) === -1) {
$('head').append('<'+'link rel="stylesheet" href="' + theme_url + '" type="text/css" />');
themes_loaded.push(theme_url);
}
if(this._data.core.themes.name) {
this.element.removeClass('jstree-' + this._data.core.themes.name);
}
this._data.core.themes.name = theme_name;
this.element.addClass('jstree-' + theme_name);
this.element[this.settings.core.themes.responsive ? 'addClass' : 'removeClass' ]('jstree-' + theme_name + '-responsive');
this.trigger('set_theme', { 'theme' : theme_name });
},
get_theme : function () { return this._data.core.themes.name; },
set_theme_variant : function (variant_name) {
if(this._data.core.themes.variant) {
this.element.removeClass('jstree-' + this._data.core.themes.name + '-' + this._data.core.themes.variant);
}
this._data.core.themes.variant = variant_name;
if(variant_name) {
this.element.addClass('jstree-' + this._data.core.themes.name + '-' + this._data.core.themes.variant);
}
},
get_theme_variant : function () { return this._data.core.themes.variant; },
show_stripes : function () {
this._data.core.themes.stripes = true;
this.get_container_ul().addClass("jstree-striped");
this.trigger('show_stripes');
},
hide_stripes : function () {
this._data.core.themes.stripes = false;
this.get_container_ul().removeClass("jstree-striped");
this.trigger('hide_stripes');
},
toggle_stripes : function () { if(this._data.core.themes.stripes) { this.hide_stripes(); } else { this.show_stripes(); } },
show_dots : function () {
this._data.core.themes.dots = true;
this.get_container_ul().removeClass("jstree-no-dots");
this.trigger('show_dots');
},
hide_dots : function () {
this._data.core.themes.dots = false;
this.get_container_ul().addClass("jstree-no-dots");
this.trigger('hide_dots');
},
toggle_dots : function () { if(this._data.core.themes.dots) { this.hide_dots(); } else { this.show_dots(); } },
show_icons : function () {
this._data.core.themes.icons = true;
this.get_container_ul().removeClass("jstree-no-icons");
this.trigger('show_icons');
},
hide_icons : function () {
this._data.core.themes.icons = false;
this.get_container_ul().addClass("jstree-no-icons");
this.trigger('hide_icons');
},
toggle_icons : function () { if(this._data.core.themes.icons) { this.hide_icons(); } else { this.show_icons(); } },
show_ellipsis : function () {
this._data.core.themes.ellipsis = true;
this.get_container_ul().addClass("jstree-ellipsis");
this.trigger('show_ellipsis');
},
hide_ellipsis : function () {
this._data.core.themes.ellipsis = false;
this.get_container_ul().removeClass("jstree-ellipsis");
this.trigger('hide_ellipsis');
},
toggle_ellipsis : function () { if(this._data.core.themes.ellipsis) { this.hide_ellipsis(); } else { this.show_ellipsis(); } },
set_icon : function (obj, icon) {
var t1, t2, dom, old;
if($.isArray(obj)) {
obj = obj.slice();
for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
this.set_icon(obj[t1], icon);
}
return true;
}
obj = this.get_node(obj);
if(!obj || obj.id === $.jstree.root) { return false; }
old = obj.icon;
obj.icon = icon === true || icon === null || icon === undefined || icon === '' ? true : icon;
dom = this.get_node(obj, true).children(".jstree-anchor").children(".jstree-themeicon");
if(icon === false) {
this.hide_icon(obj);
}
else if(icon === true || icon === null || icon === undefined || icon === '') {
dom.removeClass('jstree-themeicon-custom ' + old).css("background","").removeAttr("rel");
if(old === false) { this.show_icon(obj); }
}
else if(icon.indexOf("/") === -1 && icon.indexOf(".") === -1) {
dom.removeClass(old).css("background","");
dom.addClass(icon + ' jstree-themeicon-custom').attr("rel",icon);
if(old === false) { this.show_icon(obj); }
}
else {
dom.removeClass(old).css("background","");
dom.addClass('jstree-themeicon-custom').css("background", "url('" + icon + "') center center no-repeat").attr("rel",icon);
if(old === false) { this.show_icon(obj); }
}
return true;
},
get_icon : function (obj) {
obj = this.get_node(obj);
return (!obj || obj.id === $.jstree.root) ? false : obj.icon;
},
hide_icon : function (obj) {
var t1, t2;
if($.isArray(obj)) {
obj = obj.slice();
for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
this.hide_icon(obj[t1]);
}
return true;
}
obj = this.get_node(obj);
if(!obj || obj === $.jstree.root) { return false; }
obj.icon = false;
this.get_node(obj, true).children(".jstree-anchor").children(".jstree-themeicon").addClass('jstree-themeicon-hidden');
return true;
},
show_icon : function (obj) {
var t1, t2, dom;
if($.isArray(obj)) {
obj = obj.slice();
for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
this.show_icon(obj[t1]);
}
return true;
}
obj = this.get_node(obj);
if(!obj || obj === $.jstree.root) { return false; }
dom = this.get_node(obj, true);
obj.icon = dom.length ? dom.children(".jstree-anchor").children(".jstree-themeicon").attr('rel') : true;
if(!obj.icon) { obj.icon = true; }
dom.children(".jstree-anchor").children(".jstree-themeicon").removeClass('jstree-themeicon-hidden');
return true;
}
};
$.vakata = {};
$.vakata.attributes = function(node, with_values) {
node = $(node)[0];
var attr = with_values ? {} : [];
if(node && node.attributes) {
$.each(node.attributes, function (i, v) {
if($.inArray(v.name.toLowerCase(),['style','contenteditable','hasfocus','tabindex']) !== -1) { return; }
if(v.value !== null && $.trim(v.value) !== '') {
if(with_values) { attr[v.name] = v.value; }
else { attr.push(v.name); }
}
});
}
return attr;
};
$.vakata.array_unique = function(array) {
var a = [], i, j, l, o = {};
for(i = 0, l = array.length; i < l; i++) {
if(o[array[i]] === undefined) {
a.push(array[i]);
o[array[i]] = true;
}
}
return a;
};
$.vakata.array_remove = function(array, from) {
array.splice(from, 1);
return array;
};
$.vakata.array_remove_item = function(array, item) {
var tmp = $.inArray(item, array);
return tmp !== -1 ? $.vakata.array_remove(array, tmp) : array;
};
$.vakata.array_filter = function(c,a,b,d,e) {
if (c.filter) {
return c.filter(a, b);
}
d=[];
for (e in c) {
if (~~e+''===e+'' && e>=0 && a.call(b,c[e],+e,c)) {
d.push(c[e]);
}
}
return d;
};
$.jstree.plugins.changed = function (options, parent) {
var last = [];
this.trigger = function (ev, data) {
var i, j;
if(!data) {
data = {};
}
if(ev.replace('.jstree','') === 'changed') {
data.changed = { selected : [], deselected : [] };
var tmp = {};
for(i = 0, j = last.length; i < j; i++) {
tmp[last[i]] = 1;
}
for(i = 0, j = data.selected.length; i < j; i++) {
if(!tmp[data.selected[i]]) {
data.changed.selected.push(data.selected[i]);
}
else {
tmp[data.selected[i]] = 2;
}
}
for(i = 0, j = last.length; i < j; i++) {
if(tmp[last[i]] === 1) {
data.changed.deselected.push(last[i]);
}
}
last = data.selected.slice();
}
parent.trigger.call(this, ev, data);
};
this.refresh = function (skip_loading, forget_state) {
last = [];
return parent.refresh.apply(this, arguments);
};
};
var _i = document.createElement('I');
_i.className = 'jstree-icon jstree-checkbox';
_i.setAttribute('role', 'presentation');
$.jstree.defaults.checkbox = {
visible				: true,
three_state			: true,
whole_node			: true,
keep_selected_style	: true,
cascade				: '',
tie_selection		: true,
cascade_to_disabled : true,
cascade_to_hidden : true
};
$.jstree.plugins.checkbox = function (options, parent) {
this.bind = function () {
parent.bind.call(this);
this._data.checkbox.uto = false;
this._data.checkbox.selected = [];
if(this.settings.checkbox.three_state) {
this.settings.checkbox.cascade = 'up+down+undetermined';
}
this.element
.on("init.jstree", $.proxy(function () {
this._data.checkbox.visible = this.settings.checkbox.visible;
if(!this.settings.checkbox.keep_selected_style) {
this.element.addClass('jstree-checkbox-no-clicked');
}
if(this.settings.checkbox.tie_selection) {
this.element.addClass('jstree-checkbox-selection');
}
}, this))
.on("loading.jstree", $.proxy(function () {
this[ this._data.checkbox.visible ? 'show_checkboxes' : 'hide_checkboxes' ]();
}, this));
if(this.settings.checkbox.cascade.indexOf('undetermined') !== -1) {
this.element
.on('changed.jstree uncheck_node.jstree check_node.jstree uncheck_all.jstree check_all.jstree move_node.jstree copy_node.jstree redraw.jstree open_node.jstree', $.proxy(function () {
if(this._data.checkbox.uto) { clearTimeout(this._data.checkbox.uto); }
this._data.checkbox.uto = setTimeout($.proxy(this._undetermined, this), 50);
}, this));
}
if(!this.settings.checkbox.tie_selection) {
this.element
.on('model.jstree', $.proxy(function (e, data) {
var m = this._model.data,
p = m[data.parent],
dpc = data.nodes,
i, j;
for(i = 0, j = dpc.length; i < j; i++) {
m[dpc[i]].state.checked = m[dpc[i]].state.checked || (m[dpc[i]].original && m[dpc[i]].original.state && m[dpc[i]].original.state.checked);
if(m[dpc[i]].state.checked) {
this._data.checkbox.selected.push(dpc[i]);
}
}
}, this));
}
if(this.settings.checkbox.cascade.indexOf('up') !== -1 || this.settings.checkbox.cascade.indexOf('down') !== -1) {
this.element
.on('model.jstree', $.proxy(function (e, data) {
var m = this._model.data,
p = m[data.parent],
dpc = data.nodes,
chd = [],
c, i, j, k, l, tmp, s = this.settings.checkbox.cascade, t = this.settings.checkbox.tie_selection;
if(s.indexOf('down') !== -1) {
if(p.state[ t ? 'selected' : 'checked' ]) {
for(i = 0, j = dpc.length; i < j; i++) {
m[dpc[i]].state[ t ? 'selected' : 'checked' ] = true;
}
this._data[ t ? 'core' : 'checkbox' ].selected = this._data[ t ? 'core' : 'checkbox' ].selected.concat(dpc);
}
else {
for(i = 0, j = dpc.length; i < j; i++) {
if(m[dpc[i]].state[ t ? 'selected' : 'checked' ]) {
for(k = 0, l = m[dpc[i]].children_d.length; k < l; k++) {
m[m[dpc[i]].children_d[k]].state[ t ? 'selected' : 'checked' ] = true;
}
this._data[ t ? 'core' : 'checkbox' ].selected = this._data[ t ? 'core' : 'checkbox' ].selected.concat(m[dpc[i]].children_d);
}
}
}
}
if(s.indexOf('up') !== -1) {
for(i = 0, j = p.children_d.length; i < j; i++) {
if(!m[p.children_d[i]].children.length) {
chd.push(m[p.children_d[i]].parent);
}
}
chd = $.vakata.array_unique(chd);
for(k = 0, l = chd.length; k < l; k++) {
p = m[chd[k]];
while(p && p.id !== $.jstree.root) {
c = 0;
for(i = 0, j = p.children.length; i < j; i++) {
c += m[p.children[i]].state[ t ? 'selected' : 'checked' ];
}
if(c === j) {
p.state[ t ? 'selected' : 'checked' ] = true;
this._data[ t ? 'core' : 'checkbox' ].selected.push(p.id);
tmp = this.get_node(p, true);
if(tmp && tmp.length) {
tmp.attr('aria-selected', true).children('.jstree-anchor').addClass( t ? 'jstree-clicked' : 'jstree-checked');
}
}
else {
break;
}
p = this.get_node(p.parent);
}
}
}
this._data[ t ? 'core' : 'checkbox' ].selected = $.vakata.array_unique(this._data[ t ? 'core' : 'checkbox' ].selected);
}, this))
.on(this.settings.checkbox.tie_selection ? 'select_node.jstree' : 'check_node.jstree', $.proxy(function (e, data) {
var self = this,
obj = data.node,
m = this._model.data,
par = this.get_node(obj.parent),
i, j, c, tmp, s = this.settings.checkbox.cascade, t = this.settings.checkbox.tie_selection,
sel = {}, cur = this._data[ t ? 'core' : 'checkbox' ].selected;
for (i = 0, j = cur.length; i < j; i++) {
sel[cur[i]] = true;
}
if(s.indexOf('down') !== -1) {
var selectedIds = this._cascade_new_checked_state(obj.id, true);
obj.children_d.concat(obj.id).forEach(function(id) {
if (selectedIds.indexOf(id) > -1) {
sel[id] = true;
}
else {
delete sel[id];
}
});
}
if(s.indexOf('up') !== -1) {
while(par && par.id !== $.jstree.root) {
c = 0;
for(i = 0, j = par.children.length; i < j; i++) {
c += m[par.children[i]].state[ t ? 'selected' : 'checked' ];
}
if(c === j) {
par.state[ t ? 'selected' : 'checked' ] = true;
sel[par.id] = true;
tmp = this.get_node(par, true);
if(tmp && tmp.length) {
tmp.attr('aria-selected', true).children('.jstree-anchor').addClass(t ? 'jstree-clicked' : 'jstree-checked');
}
}
else {
break;
}
par = this.get_node(par.parent);
}
}
cur = [];
for (i in sel) {
if (sel.hasOwnProperty(i)) {
cur.push(i);
}
}
this._data[ t ? 'core' : 'checkbox' ].selected = cur;
}, this))
.on(this.settings.checkbox.tie_selection ? 'deselect_all.jstree' : 'uncheck_all.jstree', $.proxy(function (e, data) {
var obj = this.get_node($.jstree.root),
m = this._model.data,
i, j, tmp;
for(i = 0, j = obj.children_d.length; i < j; i++) {
tmp = m[obj.children_d[i]];
if(tmp && tmp.original && tmp.original.state && tmp.original.state.undetermined) {
tmp.original.state.undetermined = false;
}
}
}, this))
.on(this.settings.checkbox.tie_selection ? 'deselect_node.jstree' : 'uncheck_node.jstree', $.proxy(function (e, data) {
var self = this,
obj = data.node,
dom = this.get_node(obj, true),
i, j, tmp, s = this.settings.checkbox.cascade, t = this.settings.checkbox.tie_selection,
cur = this._data[ t ? 'core' : 'checkbox' ].selected, sel = {},
stillSelectedIds = [],
allIds = obj.children_d.concat(obj.id);
if(s.indexOf('down') !== -1) {
var selectedIds = this._cascade_new_checked_state(obj.id, false);
cur = cur.filter(function(id) {
return allIds.indexOf(id) === -1 || selectedIds.indexOf(id) > -1;
});
}
if(s.indexOf('up') !== -1 && cur.indexOf(obj.id) === -1) {
for(i = 0, j = obj.parents.length; i < j; i++) {
tmp = this._model.data[obj.parents[i]];
tmp.state[ t ? 'selected' : 'checked' ] = false;
if(tmp && tmp.original && tmp.original.state && tmp.original.state.undetermined) {
tmp.original.state.undetermined = false;
}
tmp = this.get_node(obj.parents[i], true);
if(tmp && tmp.length) {
tmp.attr('aria-selected', false).children('.jstree-anchor').removeClass(t ? 'jstree-clicked' : 'jstree-checked');
}
}
cur = cur.filter(function(id) {
return obj.parents.indexOf(id) === -1;
});
}
this._data[ t ? 'core' : 'checkbox' ].selected = cur;
}, this));
}
if(this.settings.checkbox.cascade.indexOf('up') !== -1) {
this.element
.on('delete_node.jstree', $.proxy(function (e, data) {
var p = this.get_node(data.parent),
m = this._model.data,
i, j, c, tmp, t = this.settings.checkbox.tie_selection;
while(p && p.id !== $.jstree.root && !p.state[ t ? 'selected' : 'checked' ]) {
c = 0;
for(i = 0, j = p.children.length; i < j; i++) {
c += m[p.children[i]].state[ t ? 'selected' : 'checked' ];
}
if(j > 0 && c === j) {
p.state[ t ? 'selected' : 'checked' ] = true;
this._data[ t ? 'core' : 'checkbox' ].selected.push(p.id);
tmp = this.get_node(p, true);
if(tmp && tmp.length) {
tmp.attr('aria-selected', true).children('.jstree-anchor').addClass(t ? 'jstree-clicked' : 'jstree-checked');
}
}
else {
break;
}
p = this.get_node(p.parent);
}
}, this))
.on('move_node.jstree', $.proxy(function (e, data) {
var is_multi = data.is_multi,
old_par = data.old_parent,
new_par = this.get_node(data.parent),
m = this._model.data,
p, c, i, j, tmp, t = this.settings.checkbox.tie_selection;
if(!is_multi) {
p = this.get_node(old_par);
while(p && p.id !== $.jstree.root && !p.state[ t ? 'selected' : 'checked' ]) {
c = 0;
for(i = 0, j = p.children.length; i < j; i++) {
c += m[p.children[i]].state[ t ? 'selected' : 'checked' ];
}
if(j > 0 && c === j) {
p.state[ t ? 'selected' : 'checked' ] = true;
this._data[ t ? 'core' : 'checkbox' ].selected.push(p.id);
tmp = this.get_node(p, true);
if(tmp && tmp.length) {
tmp.attr('aria-selected', true).children('.jstree-anchor').addClass(t ? 'jstree-clicked' : 'jstree-checked');
}
}
else {
break;
}
p = this.get_node(p.parent);
}
}
p = new_par;
while(p && p.id !== $.jstree.root) {
c = 0;
for(i = 0, j = p.children.length; i < j; i++) {
c += m[p.children[i]].state[ t ? 'selected' : 'checked' ];
}
if(c === j) {
if(!p.state[ t ? 'selected' : 'checked' ]) {
p.state[ t ? 'selected' : 'checked' ] = true;
this._data[ t ? 'core' : 'checkbox' ].selected.push(p.id);
tmp = this.get_node(p, true);
if(tmp && tmp.length) {
tmp.attr('aria-selected', true).children('.jstree-anchor').addClass(t ? 'jstree-clicked' : 'jstree-checked');
}
}
}
else {
if(p.state[ t ? 'selected' : 'checked' ]) {
p.state[ t ? 'selected' : 'checked' ] = false;
this._data[ t ? 'core' : 'checkbox' ].selected = $.vakata.array_remove_item(this._data[ t ? 'core' : 'checkbox' ].selected, p.id);
tmp = this.get_node(p, true);
if(tmp && tmp.length) {
tmp.attr('aria-selected', false).children('.jstree-anchor').removeClass(t ? 'jstree-clicked' : 'jstree-checked');
}
}
else {
break;
}
}
p = this.get_node(p.parent);
}
}, this));
}
};
this._undetermined = function () {
if(this.element === null) { return; }
var i, j, k, l, o = {}, m = this._model.data, t = this.settings.checkbox.tie_selection, s = this._data[ t ? 'core' : 'checkbox' ].selected, p = [], tt = this;
for(i = 0, j = s.length; i < j; i++) {
if(m[s[i]] && m[s[i]].parents) {
for(k = 0, l = m[s[i]].parents.length; k < l; k++) {
if(o[m[s[i]].parents[k]] !== undefined) {
break;
}
if(m[s[i]].parents[k] !== $.jstree.root) {
o[m[s[i]].parents[k]] = true;
p.push(m[s[i]].parents[k]);
}
}
}
}
this.element.find('.jstree-closed').not(':has(.jstree-children)')
.each(function () {
var tmp = tt.get_node(this), tmp2;
if(!tmp) { return; }
if(!tmp.state.loaded) {
if(tmp.original && tmp.original.state && tmp.original.state.undetermined && tmp.original.state.undetermined === true) {
if(o[tmp.id] === undefined && tmp.id !== $.jstree.root) {
o[tmp.id] = true;
p.push(tmp.id);
}
for(k = 0, l = tmp.parents.length; k < l; k++) {
if(o[tmp.parents[k]] === undefined && tmp.parents[k] !== $.jstree.root) {
o[tmp.parents[k]] = true;
p.push(tmp.parents[k]);
}
}
}
}
else {
for(i = 0, j = tmp.children_d.length; i < j; i++) {
tmp2 = m[tmp.children_d[i]];
if(!tmp2.state.loaded && tmp2.original && tmp2.original.state && tmp2.original.state.undetermined && tmp2.original.state.undetermined === true) {
if(o[tmp2.id] === undefined && tmp2.id !== $.jstree.root) {
o[tmp2.id] = true;
p.push(tmp2.id);
}
for(k = 0, l = tmp2.parents.length; k < l; k++) {
if(o[tmp2.parents[k]] === undefined && tmp2.parents[k] !== $.jstree.root) {
o[tmp2.parents[k]] = true;
p.push(tmp2.parents[k]);
}
}
}
}
}
});
this.element.find('.jstree-undetermined').removeClass('jstree-undetermined');
for(i = 0, j = p.length; i < j; i++) {
if(!m[p[i]].state[ t ? 'selected' : 'checked' ]) {
s = this.get_node(p[i], true);
if(s && s.length) {
s.children('.jstree-anchor').children('.jstree-checkbox').addClass('jstree-undetermined');
}
}
}
};
this.redraw_node = function(obj, deep, is_callback, force_render) {
obj = parent.redraw_node.apply(this, arguments);
if(obj) {
var i, j, tmp = null, icon = null;
for(i = 0, j = obj.childNodes.length; i < j; i++) {
if(obj.childNodes[i] && obj.childNodes[i].className && obj.childNodes[i].className.indexOf("jstree-anchor") !== -1) {
tmp = obj.childNodes[i];
break;
}
}
if(tmp) {
if(!this.settings.checkbox.tie_selection && this._model.data[obj.id].state.checked) { tmp.className += ' jstree-checked'; }
icon = _i.cloneNode(false);
if(this._model.data[obj.id].state.checkbox_disabled) { icon.className += ' jstree-checkbox-disabled'; }
tmp.insertBefore(icon, tmp.childNodes[0]);
}
}
if(!is_callback && this.settings.checkbox.cascade.indexOf('undetermined') !== -1) {
if(this._data.checkbox.uto) { clearTimeout(this._data.checkbox.uto); }
this._data.checkbox.uto = setTimeout($.proxy(this._undetermined, this), 50);
}
return obj;
};
this.show_checkboxes = function () { this._data.core.themes.checkboxes = true; this.get_container_ul().removeClass("jstree-no-checkboxes"); };
this.hide_checkboxes = function () { this._data.core.themes.checkboxes = false; this.get_container_ul().addClass("jstree-no-checkboxes"); };
this.toggle_checkboxes = function () { if(this._data.core.themes.checkboxes) { this.hide_checkboxes(); } else { this.show_checkboxes(); } };
this.is_undetermined = function (obj) {
obj = this.get_node(obj);
var s = this.settings.checkbox.cascade, i, j, t = this.settings.checkbox.tie_selection, d = this._data[ t ? 'core' : 'checkbox' ].selected, m = this._model.data;
if(!obj || obj.state[ t ? 'selected' : 'checked' ] === true || s.indexOf('undetermined') === -1 || (s.indexOf('down') === -1 && s.indexOf('up') === -1)) {
return false;
}
if(!obj.state.loaded && obj.original.state.undetermined === true) {
return true;
}
for(i = 0, j = obj.children_d.length; i < j; i++) {
if($.inArray(obj.children_d[i], d) !== -1 || (!m[obj.children_d[i]].state.loaded && m[obj.children_d[i]].original.state.undetermined)) {
return true;
}
}
return false;
};
this.disable_checkbox = function (obj) {
var t1, t2, dom;
if($.isArray(obj)) {
obj = obj.slice();
for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
this.disable_checkbox(obj[t1]);
}
return true;
}
obj = this.get_node(obj);
if(!obj || obj.id === $.jstree.root) {
return false;
}
dom = this.get_node(obj, true);
if(!obj.state.checkbox_disabled) {
obj.state.checkbox_disabled = true;
if(dom && dom.length) {
dom.children('.jstree-anchor').children('.jstree-checkbox').addClass('jstree-checkbox-disabled');
}
this.trigger('disable_checkbox', { 'node' : obj });
}
};
this.enable_checkbox = function (obj) {
var t1, t2, dom;
if($.isArray(obj)) {
obj = obj.slice();
for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
this.enable_checkbox(obj[t1]);
}
return true;
}
obj = this.get_node(obj);
if(!obj || obj.id === $.jstree.root) {
return false;
}
dom = this.get_node(obj, true);
if(obj.state.checkbox_disabled) {
obj.state.checkbox_disabled = false;
if(dom && dom.length) {
dom.children('.jstree-anchor').children('.jstree-checkbox').removeClass('jstree-checkbox-disabled');
}
this.trigger('enable_checkbox', { 'node' : obj });
}
};
this.activate_node = function (obj, e) {
if($(e.target).hasClass('jstree-checkbox-disabled')) {
return false;
}
if(this.settings.checkbox.tie_selection && (this.settings.checkbox.whole_node || $(e.target).hasClass('jstree-checkbox'))) {
e.ctrlKey = true;
}
if(this.settings.checkbox.tie_selection || (!this.settings.checkbox.whole_node && !$(e.target).hasClass('jstree-checkbox'))) {
return parent.activate_node.call(this, obj, e);
}
if(this.is_disabled(obj)) {
return false;
}
if(this.is_checked(obj)) {
this.uncheck_node(obj, e);
}
else {
this.check_node(obj, e);
}
this.trigger('activate_node', { 'node' : this.get_node(obj) });
};
this._cascade_new_checked_state = function(id, checkedState) {
var self = this;
var t = this.settings.checkbox.tie_selection;
var node = this._model.data[id];
var selectedNodeIds = [];
var selectedChildrenIds = [];
if (
(this.settings.checkbox.cascade_to_disabled || !node.state.disabled) &&
(this.settings.checkbox.cascade_to_hidden || !node.state.hidden)
) {
if (node.children) {
node.children.forEach(function(childId) {
var selectedChildIds = self._cascade_new_checked_state(childId, checkedState);
selectedNodeIds = selectedNodeIds.concat(selectedChildIds);
if (selectedChildIds.indexOf(childId) > -1) {
selectedChildrenIds.push(childId);
}
});
}
var dom = self.get_node(node, true);
var undetermined = selectedChildrenIds.length > 0 && selectedChildrenIds.length < node.children.length;
if(node.original && node.original.state && node.original.state.undetermined) {
node.original.state.undetermined = undetermined;
}
if (undetermined) {
node.state[ t ? 'selected' : 'checked' ] = false;
dom.attr('aria-selected', false).children('.jstree-anchor').removeClass(t ? 'jstree-clicked' : 'jstree-checked');
}
else if (checkedState && selectedChildrenIds.length === node.children.length) {
node.state[ t ? 'selected' : 'checked' ] = checkedState;
selectedNodeIds.push(node.id);
dom.attr('aria-selected', true).children('.jstree-anchor').addClass(t ? 'jstree-clicked' : 'jstree-checked');
}
else {
node.state[ t ? 'selected' : 'checked' ] = false;
dom.attr('aria-selected', false).children('.jstree-anchor').removeClass(t ? 'jstree-clicked' : 'jstree-checked');
}
}
else {
var selectedChildIds = this.get_checked_descendants(id);
if (node.state[ t ? 'selected' : 'checked' ]) {
selectedChildIds.push(node.id);
}
selectedNodeIds = selectedNodeIds.concat(selectedChildIds);
}
return selectedNodeIds;
};
this.get_checked_descendants = function(id) {
var self = this;
var t = self.settings.checkbox.tie_selection;
var node = self._model.data[id];
return node.children_d.filter(function(_id) {
return self._model.data[_id].state[ t ? 'selected' : 'checked' ];
});
};
this.check_node = function (obj, e) {
if(this.settings.checkbox.tie_selection) { return this.select_node(obj, false, true, e); }
var dom, t1, t2, th;
if($.isArray(obj)) {
obj = obj.slice();
for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
this.check_node(obj[t1], e);
}
return true;
}
obj = this.get_node(obj);
if(!obj || obj.id === $.jstree.root) {
return false;
}
dom = this.get_node(obj, true);
if(!obj.state.checked) {
obj.state.checked = true;
this._data.checkbox.selected.push(obj.id);
if(dom && dom.length) {
dom.children('.jstree-anchor').addClass('jstree-checked');
}
this.trigger('check_node', { 'node' : obj, 'selected' : this._data.checkbox.selected, 'event' : e });
}
};
this.uncheck_node = function (obj, e) {
if(this.settings.checkbox.tie_selection) { return this.deselect_node(obj, false, e); }
var t1, t2, dom;
if($.isArray(obj)) {
obj = obj.slice();
for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
this.uncheck_node(obj[t1], e);
}
return true;
}
obj = this.get_node(obj);
if(!obj || obj.id === $.jstree.root) {
return false;
}
dom = this.get_node(obj, true);
if(obj.state.checked) {
obj.state.checked = false;
this._data.checkbox.selected = $.vakata.array_remove_item(this._data.checkbox.selected, obj.id);
if(dom.length) {
dom.children('.jstree-anchor').removeClass('jstree-checked');
}
this.trigger('uncheck_node', { 'node' : obj, 'selected' : this._data.checkbox.selected, 'event' : e });
}
};
this.check_all = function () {
if(this.settings.checkbox.tie_selection) { return this.select_all(); }
var tmp = this._data.checkbox.selected.concat([]), i, j;
this._data.checkbox.selected = this._model.data[$.jstree.root].children_d.concat();
for(i = 0, j = this._data.checkbox.selected.length; i < j; i++) {
if(this._model.data[this._data.checkbox.selected[i]]) {
this._model.data[this._data.checkbox.selected[i]].state.checked = true;
}
}
this.redraw(true);
this.trigger('check_all', { 'selected' : this._data.checkbox.selected });
};
this.uncheck_all = function () {
if(this.settings.checkbox.tie_selection) { return this.deselect_all(); }
var tmp = this._data.checkbox.selected.concat([]), i, j;
for(i = 0, j = this._data.checkbox.selected.length; i < j; i++) {
if(this._model.data[this._data.checkbox.selected[i]]) {
this._model.data[this._data.checkbox.selected[i]].state.checked = false;
}
}
this._data.checkbox.selected = [];
this.element.find('.jstree-checked').removeClass('jstree-checked');
this.trigger('uncheck_all', { 'selected' : this._data.checkbox.selected, 'node' : tmp });
};
this.is_checked = function (obj) {
if(this.settings.checkbox.tie_selection) { return this.is_selected(obj); }
obj = this.get_node(obj);
if(!obj || obj.id === $.jstree.root) { return false; }
return obj.state.checked;
};
this.get_checked = function (full) {
if(this.settings.checkbox.tie_selection) { return this.get_selected(full); }
return full ? $.map(this._data.checkbox.selected, $.proxy(function (i) { return this.get_node(i); }, this)) : this._data.checkbox.selected;
};
this.get_top_checked = function (full) {
if(this.settings.checkbox.tie_selection) { return this.get_top_selected(full); }
var tmp = this.get_checked(true),
obj = {}, i, j, k, l;
for(i = 0, j = tmp.length; i < j; i++) {
obj[tmp[i].id] = tmp[i];
}
for(i = 0, j = tmp.length; i < j; i++) {
for(k = 0, l = tmp[i].children_d.length; k < l; k++) {
if(obj[tmp[i].children_d[k]]) {
delete obj[tmp[i].children_d[k]];
}
}
}
tmp = [];
for(i in obj) {
if(obj.hasOwnProperty(i)) {
tmp.push(i);
}
}
return full ? $.map(tmp, $.proxy(function (i) { return this.get_node(i); }, this)) : tmp;
};
this.get_bottom_checked = function (full) {
if(this.settings.checkbox.tie_selection) { return this.get_bottom_selected(full); }
var tmp = this.get_checked(true),
obj = [], i, j;
for(i = 0, j = tmp.length; i < j; i++) {
if(!tmp[i].children.length) {
obj.push(tmp[i].id);
}
}
return full ? $.map(obj, $.proxy(function (i) { return this.get_node(i); }, this)) : obj;
};
this.load_node = function (obj, callback) {
var k, l, i, j, c, tmp;
if(!$.isArray(obj) && !this.settings.checkbox.tie_selection) {
tmp = this.get_node(obj);
if(tmp && tmp.state.loaded) {
for(k = 0, l = tmp.children_d.length; k < l; k++) {
if(this._model.data[tmp.children_d[k]].state.checked) {
c = true;
this._data.checkbox.selected = $.vakata.array_remove_item(this._data.checkbox.selected, tmp.children_d[k]);
}
}
}
}
return parent.load_node.apply(this, arguments);
};
this.get_state = function () {
var state = parent.get_state.apply(this, arguments);
if(this.settings.checkbox.tie_selection) { return state; }
state.checkbox = this._data.checkbox.selected.slice();
return state;
};
this.set_state = function (state, callback) {
var res = parent.set_state.apply(this, arguments);
if(res && state.checkbox) {
if(!this.settings.checkbox.tie_selection) {
this.uncheck_all();
var _this = this;
$.each(state.checkbox, function (i, v) {
_this.check_node(v);
});
}
delete state.checkbox;
this.set_state(state, callback);
return false;
}
return res;
};
this.refresh = function (skip_loading, forget_state) {
if(!this.settings.checkbox.tie_selection) {
this._data.checkbox.selected = [];
}
return parent.refresh.apply(this, arguments);
};
};
$.jstree.defaults.conditionalselect = function () { return true; };
$.jstree.plugins.conditionalselect = function (options, parent) {
this.activate_node = function (obj, e) {
if(this.settings.conditionalselect.call(this, this.get_node(obj), e)) {
parent.activate_node.call(this, obj, e);
}
};
};
$.jstree.defaults.contextmenu = {
select_node : true,
show_at_node : true,
items : function (o, cb) { // Could be an object directly
return {
"create" : {
"separator_before"	: false,
"separator_after"	: true,
"_disabled"			: false, //(this.check("create_node", data.reference, {}, "last")),
"label"				: "Create",
"action"			: function (data) {
var inst = $.jstree.reference(data.reference),
obj = inst.get_node(data.reference);
inst.create_node(obj, {}, "last", function (new_node) {
try {
inst.edit(new_node);
} catch (ex) {
setTimeout(function () { inst.edit(new_node); },0);
}
});
}
},
"rename" : {
"separator_before"	: false,
"separator_after"	: false,
"_disabled"			: false, //(this.check("rename_node", data.reference, this.get_parent(data.reference), "")),
"label"				: "Rename",
"action"			: function (data) {
var inst = $.jstree.reference(data.reference),
obj = inst.get_node(data.reference);
inst.edit(obj);
}
},
"remove" : {
"separator_before"	: false,
"icon"				: false,
"separator_after"	: false,
"_disabled"			: false, //(this.check("delete_node", data.reference, this.get_parent(data.reference), "")),
"label"				: "Delete",
"action"			: function (data) {
var inst = $.jstree.reference(data.reference),
obj = inst.get_node(data.reference);
if(inst.is_selected(obj)) {
inst.delete_node(inst.get_selected());
}
else {
inst.delete_node(obj);
}
}
},
"ccp" : {
"separator_before"	: true,
"icon"				: false,
"separator_after"	: false,
"label"				: "Edit",
"action"			: false,
"submenu" : {
"cut" : {
"separator_before"	: false,
"separator_after"	: false,
"label"				: "Cut",
"action"			: function (data) {
var inst = $.jstree.reference(data.reference),
obj = inst.get_node(data.reference);
if(inst.is_selected(obj)) {
inst.cut(inst.get_top_selected());
}
else {
inst.cut(obj);
}
}
},
"copy" : {
"separator_before"	: false,
"icon"				: false,
"separator_after"	: false,
"label"				: "Copy",
"action"			: function (data) {
var inst = $.jstree.reference(data.reference),
obj = inst.get_node(data.reference);
if(inst.is_selected(obj)) {
inst.copy(inst.get_top_selected());
}
else {
inst.copy(obj);
}
}
},
"paste" : {
"separator_before"	: false,
"icon"				: false,
"_disabled"			: function (data) {
return !$.jstree.reference(data.reference).can_paste();
},
"separator_after"	: false,
"label"				: "Paste",
"action"			: function (data) {
var inst = $.jstree.reference(data.reference),
obj = inst.get_node(data.reference);
inst.paste(obj);
}
}
}
}
};
}
};
$.jstree.plugins.contextmenu = function (options, parent) {
this.bind = function () {
parent.bind.call(this);
var last_ts = 0, cto = null, ex, ey;
this.element
.on("init.jstree loading.jstree ready.jstree", $.proxy(function () {
this.get_container_ul().addClass('jstree-contextmenu');
}, this))
.on("contextmenu.jstree", ".jstree-anchor", $.proxy(function (e, data) {
if (e.target.tagName.toLowerCase() === 'input') {
return;
}
e.preventDefault();
last_ts = e.ctrlKey ? +new Date() : 0;
if(data || cto) {
last_ts = (+new Date()) + 10000;
}
if(cto) {
clearTimeout(cto);
}
if(!this.is_loading(e.currentTarget)) {
this.show_contextmenu(e.currentTarget, e.pageX, e.pageY, e);
}
}, this))
.on("click.jstree", ".jstree-anchor", $.proxy(function (e) {
if(this._data.contextmenu.visible && (!last_ts || (+new Date()) - last_ts > 250)) { // work around safari & macOS ctrl+click
$.vakata.context.hide();
}
last_ts = 0;
}, this))
.on("touchstart.jstree", ".jstree-anchor", function (e) {
if(!e.originalEvent || !e.originalEvent.changedTouches || !e.originalEvent.changedTouches[0]) {
return;
}
ex = e.originalEvent.changedTouches[0].clientX;
ey = e.originalEvent.changedTouches[0].clientY;
cto = setTimeout(function () {
$(e.currentTarget).trigger('contextmenu', true);
}, 750);
})
.on('touchmove.vakata.jstree', function (e) {
if(cto && e.originalEvent && e.originalEvent.changedTouches && e.originalEvent.changedTouches[0] && (Math.abs(ex - e.originalEvent.changedTouches[0].clientX) > 50 || Math.abs(ey - e.originalEvent.changedTouches[0].clientY) > 50)) {
clearTimeout(cto);
}
})
.on('touchend.vakata.jstree', function (e) {
if(cto) {
clearTimeout(cto);
}
});
$(document).on("context_hide.vakata.jstree", $.proxy(function (e, data) {
this._data.contextmenu.visible = false;
$(data.reference).removeClass('jstree-context');
}, this));
};
this.teardown = function () {
if(this._data.contextmenu.visible) {
$.vakata.context.hide();
}
parent.teardown.call(this);
};
this.show_contextmenu = function (obj, x, y, e) {
obj = this.get_node(obj);
if(!obj || obj.id === $.jstree.root) { return false; }
var s = this.settings.contextmenu,
d = this.get_node(obj, true),
a = d.children(".jstree-anchor"),
o = false,
i = false;
if(s.show_at_node || x === undefined || y === undefined) {
o = a.offset();
x = o.left;
y = o.top + this._data.core.li_height;
}
if(this.settings.contextmenu.select_node && !this.is_selected(obj)) {
this.activate_node(obj, e);
}
i = s.items;
if($.isFunction(i)) {
i = i.call(this, obj, $.proxy(function (i) {
this._show_contextmenu(obj, x, y, i);
}, this));
}
if($.isPlainObject(i)) {
this._show_contextmenu(obj, x, y, i);
}
};
this._show_contextmenu = function (obj, x, y, i) {
var d = this.get_node(obj, true),
a = d.children(".jstree-anchor");
$(document).one("context_show.vakata.jstree", $.proxy(function (e, data) {
var cls = 'jstree-contextmenu jstree-' + this.get_theme() + '-contextmenu';
$(data.element).addClass(cls);
a.addClass('jstree-context');
}, this));
this._data.contextmenu.visible = true;
$.vakata.context.show(a, { 'x' : x, 'y' : y }, i);
this.trigger('show_contextmenu', { "node" : obj, "x" : x, "y" : y });
};
};
(function ($) {
var right_to_left = false,
vakata_context = {
element		: false,
reference	: false,
position_x	: 0,
position_y	: 0,
items		: [],
html		: "",
is_visible	: false
};
$.vakata.context = {
settings : {
hide_onmouseleave	: 0,
icons				: true
},
_trigger : function (event_name) {
$(document).triggerHandler("context_" + event_name + ".vakata", {
"reference"	: vakata_context.reference,
"element"	: vakata_context.element,
"position"	: {
"x" : vakata_context.position_x,
"y" : vakata_context.position_y
}
});
},
_execute : function (i) {
i = vakata_context.items[i];
return i && (!i._disabled || ($.isFunction(i._disabled) && !i._disabled({ "item" : i, "reference" : vakata_context.reference, "element" : vakata_context.element }))) && i.action ? i.action.call(null, {
"item"		: i,
"reference"	: vakata_context.reference,
"element"	: vakata_context.element,
"position"	: {
"x" : vakata_context.position_x,
"y" : vakata_context.position_y
}
}) : false;
},
_parse : function (o, is_callback) {
if(!o) { return false; }
if(!is_callback) {
vakata_context.html		= "";
vakata_context.items	= [];
}
var str = "",
sep = false,
tmp;
if(is_callback) { str += "<"+"ul>"; }
$.each(o, function (i, val) {
if(!val) { return true; }
vakata_context.items.push(val);
if(!sep && val.separator_before) {
str += "<"+"li class='vakata-context-separator'><"+"a href='#' " + ($.vakata.context.settings.icons ? '' : 'style="margin-left:0px;"') + ">&#160;<"+"/a><"+"/li>";
}
sep = false;
str += "<"+"li class='" + (val._class || "") + (val._disabled === true || ($.isFunction(val._disabled) && val._disabled({ "item" : val, "reference" : vakata_context.reference, "element" : vakata_context.element })) ? " vakata-contextmenu-disabled " : "") + "' "+(val.shortcut?" data-shortcut='"+val.shortcut+"' ":'')+">";
str += "<"+"a href='#' rel='" + (vakata_context.items.length - 1) + "' " + (val.title ? "title='" + val.title + "'" : "") + ">";
if($.vakata.context.settings.icons) {
str += "<"+"i ";
if(val.icon) {
if(val.icon.indexOf("/") !== -1 || val.icon.indexOf(".") !== -1) { str += " style='background:url(\"" + val.icon + "\") center center no-repeat' "; }
else { str += " class='" + val.icon + "' "; }
}
str += "><"+"/i><"+"span class='vakata-contextmenu-sep'>&#160;<"+"/span>";
}
str += ($.isFunction(val.label) ? val.label({ "item" : i, "reference" : vakata_context.reference, "element" : vakata_context.element }) : val.label) + (val.shortcut?' <span class="vakata-contextmenu-shortcut vakata-contextmenu-shortcut-'+val.shortcut+'">'+ (val.shortcut_label || '') +'</span>':'') + "<"+"/a>";
if(val.submenu) {
tmp = $.vakata.context._parse(val.submenu, true);
if(tmp) { str += tmp; }
}
str += "<"+"/li>";
if(val.separator_after) {
str += "<"+"li class='vakata-context-separator'><"+"a href='#' " + ($.vakata.context.settings.icons ? '' : 'style="margin-left:0px;"') + ">&#160;<"+"/a><"+"/li>";
sep = true;
}
});
str  = str.replace(/<li class\='vakata-context-separator'\><\/li\>$/,"");
if(is_callback) { str += "</ul>"; }
if(!is_callback) { vakata_context.html = str; $.vakata.context._trigger("parse"); }
return str.length > 10 ? str : false;
},
_show_submenu : function (o) {
o = $(o);
if(!o.length || !o.children("ul").length) { return; }
var e = o.children("ul"),
xl = o.offset().left,
x = xl + o.outerWidth(),
y = o.offset().top,
w = e.width(),
h = e.height(),
dw = $(window).width() + $(window).scrollLeft(),
dh = $(window).height() + $(window).scrollTop();
if(right_to_left) {
o[x - (w + 10 + o.outerWidth()) < 0 ? "addClass" : "removeClass"]("vakata-context-left");
}
else {
o[x + w > dw  && xl > dw - x ? "addClass" : "removeClass"]("vakata-context-right");
}
if(y + h + 10 > dh) {
e.css("bottom","-1px");
}
if (o.hasClass('vakata-context-right')) {
if (xl < w) {
e.css("margin-right", xl - w);
}
} else {
if (dw - x < w) {
e.css("margin-left", dw - x - w);
}
}
e.show();
},
show : function (reference, position, data) {
var o, e, x, y, w, h, dw, dh, cond = true;
if(vakata_context.element && vakata_context.element.length) {
vakata_context.element.width('');
}
switch(cond) {
case (!position && !reference):
return false;
case (!!position && !!reference):
vakata_context.reference	= reference;
vakata_context.position_x	= position.x;
vakata_context.position_y	= position.y;
break;
case (!position && !!reference):
vakata_context.reference	= reference;
o = reference.offset();
vakata_context.position_x	= o.left + reference.outerHeight();
vakata_context.position_y	= o.top;
break;
case (!!position && !reference):
vakata_context.position_x	= position.x;
vakata_context.position_y	= position.y;
break;
}
if(!!reference && !data && $(reference).data('vakata_contextmenu')) {
data = $(reference).data('vakata_contextmenu');
}
if($.vakata.context._parse(data)) {
vakata_context.element.html(vakata_context.html);
}
if(vakata_context.items.length) {
vakata_context.element.appendTo("body");
e = vakata_context.element;
x = vakata_context.position_x;
y = vakata_context.position_y;
w = e.width();
h = e.height();
dw = $(window).width() + $(window).scrollLeft();
dh = $(window).height() + $(window).scrollTop();
if(right_to_left) {
x -= (e.outerWidth() - $(reference).outerWidth());
if(x < $(window).scrollLeft() + 20) {
x = $(window).scrollLeft() + 20;
}
}
if(x + w + 20 > dw) {
x = dw - (w + 20);
}
if(y + h + 20 > dh) {
y = dh - (h + 20);
}
vakata_context.element
.css({ "left" : x, "top" : y })
.show()
.find('a').first().focus().parent().addClass("vakata-context-hover");
vakata_context.is_visible = true;
$.vakata.context._trigger("show");
}
},
hide : function () {
if(vakata_context.is_visible) {
vakata_context.element.hide().find("ul").hide().end().find(':focus').blur().end().detach();
vakata_context.is_visible = false;
$.vakata.context._trigger("hide");
}
}
};
$(function () {
right_to_left = $("body").css("direction") === "rtl";
var to = false;
vakata_context.element = $("<ul class='vakata-context'></ul>");
vakata_context.element
.on("mouseenter", "li", function (e) {
e.stopImmediatePropagation();
if($.contains(this, e.relatedTarget)) {
return;
}
if(to) { clearTimeout(to); }
vakata_context.element.find(".vakata-context-hover").removeClass("vakata-context-hover").end();
$(this)
.siblings().find("ul").hide().end().end()
.parentsUntil(".vakata-context", "li").addBack().addClass("vakata-context-hover");
$.vakata.context._show_submenu(this);
})
.on("mouseleave", "li", function (e) {
if($.contains(this, e.relatedTarget)) { return; }
$(this).find(".vakata-context-hover").addBack().removeClass("vakata-context-hover");
})
.on("mouseleave", function (e) {
$(this).find(".vakata-context-hover").removeClass("vakata-context-hover");
if($.vakata.context.settings.hide_onmouseleave) {
to = setTimeout(
(function (t) {
return function () { $.vakata.context.hide(); };
}(this)), $.vakata.context.settings.hide_onmouseleave);
}
})
.on("click", "a", function (e) {
e.preventDefault();
if(!$(this).blur().parent().hasClass("vakata-context-disabled") && $.vakata.context._execute($(this).attr("rel")) !== false) {
$.vakata.context.hide();
}
})
.on('keydown', 'a', function (e) {
var o = null;
switch(e.which) {
case 13:
case 32:
e.type = "click";
e.preventDefault();
$(e.currentTarget).trigger(e);
break;
case 37:
if(vakata_context.is_visible) {
vakata_context.element.find(".vakata-context-hover").last().closest("li").first().find("ul").hide().find(".vakata-context-hover").removeClass("vakata-context-hover").end().end().children('a').focus();
e.stopImmediatePropagation();
e.preventDefault();
}
break;
case 38:
if(vakata_context.is_visible) {
o = vakata_context.element.find("ul:visible").addBack().last().children(".vakata-context-hover").removeClass("vakata-context-hover").prevAll("li:not(.vakata-context-separator)").first();
if(!o.length) { o = vakata_context.element.find("ul:visible").addBack().last().children("li:not(.vakata-context-separator)").last(); }
o.addClass("vakata-context-hover").children('a').focus();
e.stopImmediatePropagation();
e.preventDefault();
}
break;
case 39:
if(vakata_context.is_visible) {
vakata_context.element.find(".vakata-context-hover").last().children("ul").show().children("li:not(.vakata-context-separator)").removeClass("vakata-context-hover").first().addClass("vakata-context-hover").children('a').focus();
e.stopImmediatePropagation();
e.preventDefault();
}
break;
case 40:
if(vakata_context.is_visible) {
o = vakata_context.element.find("ul:visible").addBack().last().children(".vakata-context-hover").removeClass("vakata-context-hover").nextAll("li:not(.vakata-context-separator)").first();
if(!o.length) { o = vakata_context.element.find("ul:visible").addBack().last().children("li:not(.vakata-context-separator)").first(); }
o.addClass("vakata-context-hover").children('a').focus();
e.stopImmediatePropagation();
e.preventDefault();
}
break;
case 27:
$.vakata.context.hide();
e.preventDefault();
break;
default:
break;
}
})
.on('keydown', function (e) {
e.preventDefault();
var a = vakata_context.element.find('.vakata-contextmenu-shortcut-' + e.which).parent();
if(a.parent().not('.vakata-context-disabled')) {
a.click();
}
});
$(document)
.on("mousedown.vakata.jstree", function (e) {
if(vakata_context.is_visible && vakata_context.element[0] !== e.target  && !$.contains(vakata_context.element[0], e.target)) {
$.vakata.context.hide();
}
})
.on("context_show.vakata.jstree", function (e, data) {
vakata_context.element.find("li:has(ul)").children("a").addClass("vakata-context-parent");
if(right_to_left) {
vakata_context.element.addClass("vakata-context-rtl").css("direction", "rtl");
}
vakata_context.element.find("ul").hide().end();
});
});
}($));
$.jstree.defaults.dnd = {
copy : true,
open_timeout : 500,
is_draggable : true,
check_while_dragging : true,
always_copy : false,
inside_pos : 0,
drag_selection : true,
touch : true,
large_drop_target : false,
large_drag_target : false,
use_html5: false
};
var drg, elm;
$.jstree.plugins.dnd = function (options, parent) {
this.init = function (el, options) {
parent.init.call(this, el, options);
this.settings.dnd.use_html5 = this.settings.dnd.use_html5 && ('draggable' in document.createElement('span'));
};
this.bind = function () {
parent.bind.call(this);
this.element
.on(this.settings.dnd.use_html5 ? 'dragstart.jstree' : 'mousedown.jstree touchstart.jstree', this.settings.dnd.large_drag_target ? '.jstree-node' : '.jstree-anchor', $.proxy(function (e) {
if(this.settings.dnd.large_drag_target && $(e.target).closest('.jstree-node')[0] !== e.currentTarget) {
return true;
}
if(e.type === "touchstart" && (!this.settings.dnd.touch || (this.settings.dnd.touch === 'selected' && !$(e.currentTarget).closest('.jstree-node').children('.jstree-anchor').hasClass('jstree-clicked')))) {
return true;
}
var obj = this.get_node(e.target),
mlt = this.is_selected(obj) && this.settings.dnd.drag_selection ? this.get_top_selected().length : 1,
txt = (mlt > 1 ? mlt + ' ' + this.get_string('nodes') : this.get_text(e.currentTarget));
if(this.settings.core.force_text) {
txt = $.vakata.html.escape(txt);
}
if(obj && obj.id && obj.id !== $.jstree.root && (e.which === 1 || e.type === "touchstart" || e.type === "dragstart") &&
(this.settings.dnd.is_draggable === true || ($.isFunction(this.settings.dnd.is_draggable) && this.settings.dnd.is_draggable.call(this, (mlt > 1 ? this.get_top_selected(true) : [obj]), e)))
) {
drg = { 'jstree' : true, 'origin' : this, 'obj' : this.get_node(obj,true), 'nodes' : mlt > 1 ? this.get_top_selected() : [obj.id] };
elm = e.currentTarget;
if (this.settings.dnd.use_html5) {
$.vakata.dnd._trigger('start', e, { 'helper': $(), 'element': elm, 'data': drg });
} else {
this.element.trigger('mousedown.jstree');
return $.vakata.dnd.start(e, drg, '<div id="jstree-dnd" class="jstree-' + this.get_theme() + ' jstree-' + this.get_theme() + '-' + this.get_theme_variant() + ' ' + ( this.settings.core.themes.responsive ? ' jstree-dnd-responsive' : '' ) + '"><i class="jstree-icon jstree-er"></i>' + txt + '<ins class="jstree-copy" style="display:none;">+</ins></div>');
}
}
}, this));
if (this.settings.dnd.use_html5) {
this.element
.on('dragover.jstree', function (e) {
e.preventDefault();
$.vakata.dnd._trigger('move', e, { 'helper': $(), 'element': elm, 'data': drg });
return false;
})
.on('drop.jstree', $.proxy(function (e) {
e.preventDefault();
$.vakata.dnd._trigger('stop', e, { 'helper': $(), 'element': elm, 'data': drg });
return false;
}, this));
}
};
this.redraw_node = function(obj, deep, callback, force_render) {
obj = parent.redraw_node.apply(this, arguments);
if (obj && this.settings.dnd.use_html5) {
if (this.settings.dnd.large_drag_target) {
obj.setAttribute('draggable', true);
} else {
var i, j, tmp = null;
for(i = 0, j = obj.childNodes.length; i < j; i++) {
if(obj.childNodes[i] && obj.childNodes[i].className && obj.childNodes[i].className.indexOf("jstree-anchor") !== -1) {
tmp = obj.childNodes[i];
break;
}
}
if(tmp) {
tmp.setAttribute('draggable', true);
}
}
}
return obj;
};
};
$(function() {
var lastmv = false,
laster = false,
lastev = false,
opento = false,
marker = $('<div id="jstree-marker">&#160;</div>').hide(); //.appendTo('body');
$(document)
.on('dnd_start.vakata.jstree', function (e, data) {
lastmv = false;
lastev = false;
if(!data || !data.data || !data.data.jstree) { return; }
marker.appendTo('body'); //.show();
})
.on('dnd_move.vakata.jstree', function (e, data) {
var isDifferentNode = data.event.target !== lastev.target;
if(opento) {
if (!data.event || data.event.type !== 'dragover' || isDifferentNode) {
clearTimeout(opento);
}
}
if(!data || !data.data || !data.data.jstree) { return; }
if(data.event.target.id && data.event.target.id === 'jstree-marker') {
return;
}
lastev = data.event;
var ins = $.jstree.reference(data.event.target),
ref = false,
off = false,
rel = false,
tmp, l, t, h, p, i, o, ok, t1, t2, op, ps, pr, ip, tm, is_copy, pn;
if(ins && ins._data && ins._data.dnd) {
marker.attr('class', 'jstree-' + ins.get_theme() + ( ins.settings.core.themes.responsive ? ' jstree-dnd-responsive' : '' ));
is_copy = data.data.origin && (data.data.origin.settings.dnd.always_copy || (data.data.origin.settings.dnd.copy && (data.event.metaKey || data.event.ctrlKey)));
data.helper
.children().attr('class', 'jstree-' + ins.get_theme() + ' jstree-' + ins.get_theme() + '-' + ins.get_theme_variant() + ' ' + ( ins.settings.core.themes.responsive ? ' jstree-dnd-responsive' : '' ))
.find('.jstree-copy').first()[ is_copy ? 'show' : 'hide' ]();
if( (data.event.target === ins.element[0] || data.event.target === ins.get_container_ul()[0]) && ins.get_container_ul().children().length === 0) {
ok = true;
for(t1 = 0, t2 = data.data.nodes.length; t1 < t2; t1++) {
ok = ok && ins.check( (data.data.origin && (data.data.origin.settings.dnd.always_copy || (data.data.origin.settings.dnd.copy && (data.event.metaKey || data.event.ctrlKey)) ) ? "copy_node" : "move_node"), (data.data.origin && data.data.origin !== ins ? data.data.origin.get_node(data.data.nodes[t1]) : data.data.nodes[t1]), $.jstree.root, 'last', { 'dnd' : true, 'ref' : ins.get_node($.jstree.root), 'pos' : 'i', 'origin' : data.data.origin, 'is_multi' : (data.data.origin && data.data.origin !== ins), 'is_foreign' : (!data.data.origin) });
if(!ok) { break; }
}
if(ok) {
lastmv = { 'ins' : ins, 'par' : $.jstree.root, 'pos' : 'last' };
marker.hide();
data.helper.find('.jstree-icon').first().removeClass('jstree-er').addClass('jstree-ok');
if (data.event.originalEvent && data.event.originalEvent.dataTransfer) {
data.event.originalEvent.dataTransfer.dropEffect = is_copy ? 'copy' : 'move';
}
return;
}
}
else {
ref = ins.settings.dnd.large_drop_target ? $(data.event.target).closest('.jstree-node').children('.jstree-anchor') : $(data.event.target).closest('.jstree-anchor');
if(ref && ref.length && ref.parent().is('.jstree-closed, .jstree-open, .jstree-leaf')) {
off = ref.offset();
rel = (data.event.pageY !== undefined ? data.event.pageY : data.event.originalEvent.pageY) - off.top;
h = ref.outerHeight();
if(rel < h / 3) {
o = ['b', 'i', 'a'];
}
else if(rel > h - h / 3) {
o = ['a', 'i', 'b'];
}
else {
o = rel > h / 2 ? ['i', 'a', 'b'] : ['i', 'b', 'a'];
}
$.each(o, function (j, v) {
switch(v) {
case 'b':
l = off.left - 6;
t = off.top;
p = ins.get_parent(ref);
i = ref.parent().index();
break;
case 'i':
ip = ins.settings.dnd.inside_pos;
tm = ins.get_node(ref.parent());
l = off.left - 2;
t = off.top + h / 2 + 1;
p = tm.id;
i = ip === 'first' ? 0 : (ip === 'last' ? tm.children.length : Math.min(ip, tm.children.length));
break;
case 'a':
l = off.left - 6;
t = off.top + h;
p = ins.get_parent(ref);
i = ref.parent().index() + 1;
break;
}
ok = true;
for(t1 = 0, t2 = data.data.nodes.length; t1 < t2; t1++) {
op = data.data.origin && (data.data.origin.settings.dnd.always_copy || (data.data.origin.settings.dnd.copy && (data.event.metaKey || data.event.ctrlKey))) ? "copy_node" : "move_node";
ps = i;
if(op === "move_node" && v === 'a' && (data.data.origin && data.data.origin === ins) && p === ins.get_parent(data.data.nodes[t1])) {
pr = ins.get_node(p);
if(ps > $.inArray(data.data.nodes[t1], pr.children)) {
ps -= 1;
}
}
ok = ok && ( (ins && ins.settings && ins.settings.dnd && ins.settings.dnd.check_while_dragging === false) || ins.check(op, (data.data.origin && data.data.origin !== ins ? data.data.origin.get_node(data.data.nodes[t1]) : data.data.nodes[t1]), p, ps, { 'dnd' : true, 'ref' : ins.get_node(ref.parent()), 'pos' : v, 'origin' : data.data.origin, 'is_multi' : (data.data.origin && data.data.origin !== ins), 'is_foreign' : (!data.data.origin) }) );
if(!ok) {
if(ins && ins.last_error) { laster = ins.last_error(); }
break;
}
}
if(v === 'i' && ref.parent().is('.jstree-closed') && ins.settings.dnd.open_timeout) {
if (!data.event || data.event.type !== 'dragover' || isDifferentNode) {
if (opento) { clearTimeout(opento); }
opento = setTimeout((function (x, z) { return function () { x.open_node(z); }; }(ins, ref)), ins.settings.dnd.open_timeout);
}
}
if(ok) {
pn = ins.get_node(p, true);
if (!pn.hasClass('.jstree-dnd-parent')) {
$('.jstree-dnd-parent').removeClass('jstree-dnd-parent');
pn.addClass('jstree-dnd-parent');
}
lastmv = { 'ins' : ins, 'par' : p, 'pos' : v === 'i' && ip === 'last' && i === 0 && !ins.is_loaded(tm) ? 'last' : i };
marker.css({ 'left' : l + 'px', 'top' : t + 'px' }).show();
data.helper.find('.jstree-icon').first().removeClass('jstree-er').addClass('jstree-ok');
if (data.event.originalEvent && data.event.originalEvent.dataTransfer) {
data.event.originalEvent.dataTransfer.dropEffect = is_copy ? 'copy' : 'move';
}
laster = {};
o = true;
return false;
}
});
if(o === true) { return; }
}
}
}
$('.jstree-dnd-parent').removeClass('jstree-dnd-parent');
lastmv = false;
data.helper.find('.jstree-icon').removeClass('jstree-ok').addClass('jstree-er');
if (data.event.originalEvent && data.event.originalEvent.dataTransfer) {
data.event.originalEvent.dataTransfer.dropEffect = 'none';
}
marker.hide();
})
.on('dnd_scroll.vakata.jstree', function (e, data) {
if(!data || !data.data || !data.data.jstree) { return; }
marker.hide();
lastmv = false;
lastev = false;
data.helper.find('.jstree-icon').first().removeClass('jstree-ok').addClass('jstree-er');
})
.on('dnd_stop.vakata.jstree', function (e, data) {
$('.jstree-dnd-parent').removeClass('jstree-dnd-parent');
if(opento) { clearTimeout(opento); }
if(!data || !data.data || !data.data.jstree) { return; }
marker.hide().detach();
var i, j, nodes = [];
if(lastmv) {
for(i = 0, j = data.data.nodes.length; i < j; i++) {
nodes[i] = data.data.origin ? data.data.origin.get_node(data.data.nodes[i]) : data.data.nodes[i];
}
lastmv.ins[ data.data.origin && (data.data.origin.settings.dnd.always_copy || (data.data.origin.settings.dnd.copy && (data.event.metaKey || data.event.ctrlKey))) ? 'copy_node' : 'move_node' ](nodes, lastmv.par, lastmv.pos, false, false, false, data.data.origin);
}
else {
i = $(data.event.target).closest('.jstree');
if(i.length && laster && laster.error && laster.error === 'check') {
i = i.jstree(true);
if(i) {
i.settings.core.error.call(this, laster);
}
}
}
lastev = false;
lastmv = false;
})
.on('keyup.jstree keydown.jstree', function (e, data) {
data = $.vakata.dnd._get();
if(data && data.data && data.data.jstree) {
if (e.type === "keyup" && e.which === 27) {
if (opento) { clearTimeout(opento); }
lastmv = false;
laster = false;
lastev = false;
opento = false;
marker.hide().detach();
$.vakata.dnd._clean();
} else {
data.helper.find('.jstree-copy').first()[ data.data.origin && (data.data.origin.settings.dnd.always_copy || (data.data.origin.settings.dnd.copy && (e.metaKey || e.ctrlKey))) ? 'show' : 'hide' ]();
if(lastev) {
lastev.metaKey = e.metaKey;
lastev.ctrlKey = e.ctrlKey;
$.vakata.dnd._trigger('move', lastev);
}
}
}
});
});
(function ($) {
$.vakata.html = {
div : $('<div />'),
escape : function (str) {
return $.vakata.html.div.text(str).html();
},
strip : function (str) {
return $.vakata.html.div.empty().append($.parseHTML(str)).text();
}
};
var vakata_dnd = {
element	: false,
target	: false,
is_down	: false,
is_drag	: false,
helper	: false,
helper_w: 0,
data	: false,
init_x	: 0,
init_y	: 0,
scroll_l: 0,
scroll_t: 0,
scroll_e: false,
scroll_i: false,
is_touch: false
};
$.vakata.dnd = {
settings : {
scroll_speed		: 10,
scroll_proximity	: 20,
helper_left			: 5,
helper_top			: 10,
threshold			: 5,
threshold_touch		: 50
},
_trigger : function (event_name, e, data) {
if (data === undefined) {
data = $.vakata.dnd._get();
}
data.event = e;
$(document).triggerHandler("dnd_" + event_name + ".vakata", data);
},
_get : function () {
return {
"data"		: vakata_dnd.data,
"element"	: vakata_dnd.element,
"helper"	: vakata_dnd.helper
};
},
_clean : function () {
if(vakata_dnd.helper) { vakata_dnd.helper.remove(); }
if(vakata_dnd.scroll_i) { clearInterval(vakata_dnd.scroll_i); vakata_dnd.scroll_i = false; }
vakata_dnd = {
element	: false,
target	: false,
is_down	: false,
is_drag	: false,
helper	: false,
helper_w: 0,
data	: false,
init_x	: 0,
init_y	: 0,
scroll_l: 0,
scroll_t: 0,
scroll_e: false,
scroll_i: false,
is_touch: false
};
$(document).off("mousemove.vakata.jstree touchmove.vakata.jstree", $.vakata.dnd.drag);
$(document).off("mouseup.vakata.jstree touchend.vakata.jstree", $.vakata.dnd.stop);
},
_scroll : function (init_only) {
if(!vakata_dnd.scroll_e || (!vakata_dnd.scroll_l && !vakata_dnd.scroll_t)) {
if(vakata_dnd.scroll_i) { clearInterval(vakata_dnd.scroll_i); vakata_dnd.scroll_i = false; }
return false;
}
if(!vakata_dnd.scroll_i) {
vakata_dnd.scroll_i = setInterval($.vakata.dnd._scroll, 100);
return false;
}
if(init_only === true) { return false; }
var i = vakata_dnd.scroll_e.scrollTop(),
j = vakata_dnd.scroll_e.scrollLeft();
vakata_dnd.scroll_e.scrollTop(i + vakata_dnd.scroll_t * $.vakata.dnd.settings.scroll_speed);
vakata_dnd.scroll_e.scrollLeft(j + vakata_dnd.scroll_l * $.vakata.dnd.settings.scroll_speed);
if(i !== vakata_dnd.scroll_e.scrollTop() || j !== vakata_dnd.scroll_e.scrollLeft()) {
$.vakata.dnd._trigger("scroll", vakata_dnd.scroll_e);
}
},
start : function (e, data, html) {
if(e.type === "touchstart" && e.originalEvent && e.originalEvent.changedTouches && e.originalEvent.changedTouches[0]) {
e.pageX = e.originalEvent.changedTouches[0].pageX;
e.pageY = e.originalEvent.changedTouches[0].pageY;
e.target = document.elementFromPoint(e.originalEvent.changedTouches[0].pageX - window.pageXOffset, e.originalEvent.changedTouches[0].pageY - window.pageYOffset);
}
if(vakata_dnd.is_drag) { $.vakata.dnd.stop({}); }
try {
e.currentTarget.unselectable = "on";
e.currentTarget.onselectstart = function() { return false; };
if(e.currentTarget.style) {
e.currentTarget.style.touchAction = "none";
e.currentTarget.style.msTouchAction = "none";
e.currentTarget.style.MozUserSelect = "none";
}
} catch(ignore) { }
vakata_dnd.init_x	= e.pageX;
vakata_dnd.init_y	= e.pageY;
vakata_dnd.data		= data;
vakata_dnd.is_down	= true;
vakata_dnd.element	= e.currentTarget;
vakata_dnd.target	= e.target;
vakata_dnd.is_touch	= e.type === "touchstart";
if(html !== false) {
vakata_dnd.helper = $("<div id='vakata-dnd'></div>").html(html).css({
"display"		: "block",
"margin"		: "0",
"padding"		: "0",
"position"		: "absolute",
"top"			: "-2000px",
"lineHeight"	: "16px",
"zIndex"		: "10000"
});
}
$(document).on("mousemove.vakata.jstree touchmove.vakata.jstree", $.vakata.dnd.drag);
$(document).on("mouseup.vakata.jstree touchend.vakata.jstree", $.vakata.dnd.stop);
return false;
},
drag : function (e) {
if(e.type === "touchmove" && e.originalEvent && e.originalEvent.changedTouches && e.originalEvent.changedTouches[0]) {
e.pageX = e.originalEvent.changedTouches[0].pageX;
e.pageY = e.originalEvent.changedTouches[0].pageY;
e.target = document.elementFromPoint(e.originalEvent.changedTouches[0].pageX - window.pageXOffset, e.originalEvent.changedTouches[0].pageY - window.pageYOffset);
}
if(!vakata_dnd.is_down) { return; }
if(!vakata_dnd.is_drag) {
if(
Math.abs(e.pageX - vakata_dnd.init_x) > (vakata_dnd.is_touch ? $.vakata.dnd.settings.threshold_touch : $.vakata.dnd.settings.threshold) ||
Math.abs(e.pageY - vakata_dnd.init_y) > (vakata_dnd.is_touch ? $.vakata.dnd.settings.threshold_touch : $.vakata.dnd.settings.threshold)
) {
if(vakata_dnd.helper) {
vakata_dnd.helper.appendTo("body");
vakata_dnd.helper_w = vakata_dnd.helper.outerWidth();
}
vakata_dnd.is_drag = true;
$(vakata_dnd.target).one('click.vakata', false);
$.vakata.dnd._trigger("start", e);
}
else { return; }
}
var d  = false, w  = false,
dh = false, wh = false,
dw = false, ww = false,
dt = false, dl = false,
ht = false, hl = false;
vakata_dnd.scroll_t = 0;
vakata_dnd.scroll_l = 0;
vakata_dnd.scroll_e = false;
$($(e.target).parentsUntil("body").addBack().get().reverse())
.filter(function () {
return	(/^auto|scroll$/).test($(this).css("overflow")) &&
(this.scrollHeight > this.offsetHeight || this.scrollWidth > this.offsetWidth);
})
.each(function () {
var t = $(this), o = t.offset();
if(this.scrollHeight > this.offsetHeight) {
if(o.top + t.height() - e.pageY < $.vakata.dnd.settings.scroll_proximity)	{ vakata_dnd.scroll_t = 1; }
if(e.pageY - o.top < $.vakata.dnd.settings.scroll_proximity)				{ vakata_dnd.scroll_t = -1; }
}
if(this.scrollWidth > this.offsetWidth) {
if(o.left + t.width() - e.pageX < $.vakata.dnd.settings.scroll_proximity)	{ vakata_dnd.scroll_l = 1; }
if(e.pageX - o.left < $.vakata.dnd.settings.scroll_proximity)				{ vakata_dnd.scroll_l = -1; }
}
if(vakata_dnd.scroll_t || vakata_dnd.scroll_l) {
vakata_dnd.scroll_e = $(this);
return false;
}
});
if(!vakata_dnd.scroll_e) {
d  = $(document); w = $(window);
dh = d.height(); wh = w.height();
dw = d.width(); ww = w.width();
dt = d.scrollTop(); dl = d.scrollLeft();
if(dh > wh && e.pageY - dt < $.vakata.dnd.settings.scroll_proximity)		{ vakata_dnd.scroll_t = -1;  }
if(dh > wh && wh - (e.pageY - dt) < $.vakata.dnd.settings.scroll_proximity)	{ vakata_dnd.scroll_t = 1; }
if(dw > ww && e.pageX - dl < $.vakata.dnd.settings.scroll_proximity)		{ vakata_dnd.scroll_l = -1; }
if(dw > ww && ww - (e.pageX - dl) < $.vakata.dnd.settings.scroll_proximity)	{ vakata_dnd.scroll_l = 1; }
if(vakata_dnd.scroll_t || vakata_dnd.scroll_l) {
vakata_dnd.scroll_e = d;
}
}
if(vakata_dnd.scroll_e) { $.vakata.dnd._scroll(true); }
if(vakata_dnd.helper) {
ht = parseInt(e.pageY + $.vakata.dnd.settings.helper_top, 10);
hl = parseInt(e.pageX + $.vakata.dnd.settings.helper_left, 10);
if(dh && ht + 25 > dh) { ht = dh - 50; }
if(dw && hl + vakata_dnd.helper_w > dw) { hl = dw - (vakata_dnd.helper_w + 2); }
vakata_dnd.helper.css({
left	: hl + "px",
top		: ht + "px"
});
}
$.vakata.dnd._trigger("move", e);
return false;
},
stop : function (e) {
if(e.type === "touchend" && e.originalEvent && e.originalEvent.changedTouches && e.originalEvent.changedTouches[0]) {
e.pageX = e.originalEvent.changedTouches[0].pageX;
e.pageY = e.originalEvent.changedTouches[0].pageY;
e.target = document.elementFromPoint(e.originalEvent.changedTouches[0].pageX - window.pageXOffset, e.originalEvent.changedTouches[0].pageY - window.pageYOffset);
}
if(vakata_dnd.is_drag) {
if (e.target !== vakata_dnd.target) {
$(vakata_dnd.target).off('click.vakata');
}
$.vakata.dnd._trigger("stop", e);
}
else {
if(e.type === "touchend" && e.target === vakata_dnd.target) {
var to = setTimeout(function () { $(e.target).click(); }, 100);
$(e.target).one('click', function() { if(to) { clearTimeout(to); } });
}
}
$.vakata.dnd._clean();
return false;
}
};
}($));
$.jstree.defaults.massload = null;
$.jstree.plugins.massload = function (options, parent) {
this.init = function (el, options) {
this._data.massload = {};
parent.init.call(this, el, options);
};
this._load_nodes = function (nodes, callback, is_callback, force_reload) {
var s = this.settings.massload,
nodesString = JSON.stringify(nodes),
toLoad = [],
m = this._model.data,
i, j, dom;
if (!is_callback) {
for(i = 0, j = nodes.length; i < j; i++) {
if(!m[nodes[i]] || ( (!m[nodes[i]].state.loaded && !m[nodes[i]].state.failed) || force_reload) ) {
toLoad.push(nodes[i]);
dom = this.get_node(nodes[i], true);
if (dom && dom.length) {
dom.addClass("jstree-loading").attr('aria-busy',true);
}
}
}
this._data.massload = {};
if (toLoad.length) {
if($.isFunction(s)) {
return s.call(this, toLoad, $.proxy(function (data) {
var i, j;
if(data) {
for(i in data) {
if(data.hasOwnProperty(i)) {
this._data.massload[i] = data[i];
}
}
}
for(i = 0, j = nodes.length; i < j; i++) {
dom = this.get_node(nodes[i], true);
if (dom && dom.length) {
dom.removeClass("jstree-loading").attr('aria-busy',false);
}
}
parent._load_nodes.call(this, nodes, callback, is_callback, force_reload);
}, this));
}
if(typeof s === 'object' && s && s.url) {
s = $.extend(true, {}, s);
if($.isFunction(s.url)) {
s.url = s.url.call(this, toLoad);
}
if($.isFunction(s.data)) {
s.data = s.data.call(this, toLoad);
}
return $.ajax(s)
.done($.proxy(function (data,t,x) {
var i, j;
if(data) {
for(i in data) {
if(data.hasOwnProperty(i)) {
this._data.massload[i] = data[i];
}
}
}
for(i = 0, j = nodes.length; i < j; i++) {
dom = this.get_node(nodes[i], true);
if (dom && dom.length) {
dom.removeClass("jstree-loading").attr('aria-busy',false);
}
}
parent._load_nodes.call(this, nodes, callback, is_callback, force_reload);
}, this))
.fail($.proxy(function (f) {
parent._load_nodes.call(this, nodes, callback, is_callback, force_reload);
}, this));
}
}
}
return parent._load_nodes.call(this, nodes, callback, is_callback, force_reload);
};
this._load_node = function (obj, callback) {
var data = this._data.massload[obj.id],
rslt = null, dom;
if(data) {
rslt = this[typeof data === 'string' ? '_append_html_data' : '_append_json_data'](
obj,
typeof data === 'string' ? $($.parseHTML(data)).filter(function () { return this.nodeType !== 3; }) : data,
function (status) { callback.call(this, status); }
);
dom = this.get_node(obj.id, true);
if (dom && dom.length) {
dom.removeClass("jstree-loading").attr('aria-busy',false);
}
delete this._data.massload[obj.id];
return rslt;
}
return parent._load_node.call(this, obj, callback);
};
};
$.jstree.defaults.search = {
ajax : false,
fuzzy : false,
case_sensitive : false,
show_only_matches : false,
show_only_matches_children : false,
close_opened_onclear : true,
search_leaves_only : false,
search_callback : false
};
$.jstree.plugins.search = function (options, parent) {
this.bind = function () {
parent.bind.call(this);
this._data.search.str = "";
this._data.search.dom = $();
this._data.search.res = [];
this._data.search.opn = [];
this._data.search.som = false;
this._data.search.smc = false;
this._data.search.hdn = [];
this.element
.on("search.jstree", $.proxy(function (e, data) {
if(this._data.search.som && data.res.length) {
var m = this._model.data, i, j, p = [], k, l;
for(i = 0, j = data.res.length; i < j; i++) {
if(m[data.res[i]] && !m[data.res[i]].state.hidden) {
p.push(data.res[i]);
p = p.concat(m[data.res[i]].parents);
if(this._data.search.smc) {
for (k = 0, l = m[data.res[i]].children_d.length; k < l; k++) {
if (m[m[data.res[i]].children_d[k]] && !m[m[data.res[i]].children_d[k]].state.hidden) {
p.push(m[data.res[i]].children_d[k]);
}
}
}
}
}
p = $.vakata.array_remove_item($.vakata.array_unique(p), $.jstree.root);
this._data.search.hdn = this.hide_all(true);
this.show_node(p, true);
this.redraw(true);
}
}, this))
.on("clear_search.jstree", $.proxy(function (e, data) {
if(this._data.search.som && data.res.length) {
this.show_node(this._data.search.hdn, true);
this.redraw(true);
}
}, this));
};
this.search = function (str, skip_async, show_only_matches, inside, append, show_only_matches_children) {
if(str === false || $.trim(str.toString()) === "") {
return this.clear_search();
}
inside = this.get_node(inside);
inside = inside && inside.id ? inside.id : null;
str = str.toString();
var s = this.settings.search,
a = s.ajax ? s.ajax : false,
m = this._model.data,
f = null,
r = [],
p = [], i, j;
if(this._data.search.res.length && !append) {
this.clear_search();
}
if(show_only_matches === undefined) {
show_only_matches = s.show_only_matches;
}
if(show_only_matches_children === undefined) {
show_only_matches_children = s.show_only_matches_children;
}
if(!skip_async && a !== false) {
if($.isFunction(a)) {
return a.call(this, str, $.proxy(function (d) {
if(d && d.d) { d = d.d; }
this._load_nodes(!$.isArray(d) ? [] : $.vakata.array_unique(d), function () {
this.search(str, true, show_only_matches, inside, append, show_only_matches_children);
});
}, this), inside);
}
else {
a = $.extend({}, a);
if(!a.data) { a.data = {}; }
a.data.str = str;
if(inside) {
a.data.inside = inside;
}
if (this._data.search.lastRequest) {
this._data.search.lastRequest.abort();
}
this._data.search.lastRequest = $.ajax(a)
.fail($.proxy(function () {
this._data.core.last_error = { 'error' : 'ajax', 'plugin' : 'search', 'id' : 'search_01', 'reason' : 'Could not load search parents', 'data' : JSON.stringify(a) };
this.settings.core.error.call(this, this._data.core.last_error);
}, this))
.done($.proxy(function (d) {
if(d && d.d) { d = d.d; }
this._load_nodes(!$.isArray(d) ? [] : $.vakata.array_unique(d), function () {
this.search(str, true, show_only_matches, inside, append, show_only_matches_children);
});
}, this));
return this._data.search.lastRequest;
}
}
if(!append) {
this._data.search.str = str;
this._data.search.dom = $();
this._data.search.res = [];
this._data.search.opn = [];
this._data.search.som = show_only_matches;
this._data.search.smc = show_only_matches_children;
}
f = new $.vakata.search(str, true, { caseSensitive : s.case_sensitive, fuzzy : s.fuzzy });
$.each(m[inside ? inside : $.jstree.root].children_d, function (ii, i) {
var v = m[i];
if(v.text && !v.state.hidden && (!s.search_leaves_only || (v.state.loaded && v.children.length === 0)) && ( (s.search_callback && s.search_callback.call(this, str, v)) || (!s.search_callback && f.search(v.text).isMatch) ) ) {
r.push(i);
p = p.concat(v.parents);
}
});
if(r.length) {
p = $.vakata.array_unique(p);
for(i = 0, j = p.length; i < j; i++) {
if(p[i] !== $.jstree.root && m[p[i]] && this.open_node(p[i], null, 0) === true) {
this._data.search.opn.push(p[i]);
}
}
if(!append) {
this._data.search.dom = $(this.element[0].querySelectorAll('#' + $.map(r, function (v) { return "0123456789".indexOf(v[0]) !== -1 ? '\\3' + v[0] + ' ' + v.substr(1).replace($.jstree.idregex,'\\$&') : v.replace($.jstree.idregex,'\\$&'); }).join(', #')));
this._data.search.res = r;
}
else {
this._data.search.dom = this._data.search.dom.add($(this.element[0].querySelectorAll('#' + $.map(r, function (v) { return "0123456789".indexOf(v[0]) !== -1 ? '\\3' + v[0] + ' ' + v.substr(1).replace($.jstree.idregex,'\\$&') : v.replace($.jstree.idregex,'\\$&'); }).join(', #'))));
this._data.search.res = $.vakata.array_unique(this._data.search.res.concat(r));
}
this._data.search.dom.children(".jstree-anchor").addClass('jstree-search');
}
this.trigger('search', { nodes : this._data.search.dom, str : str, res : this._data.search.res, show_only_matches : show_only_matches });
};
this.clear_search = function () {
if(this.settings.search.close_opened_onclear) {
this.close_node(this._data.search.opn, 0);
}
this.trigger('clear_search', { 'nodes' : this._data.search.dom, str : this._data.search.str, res : this._data.search.res });
if(this._data.search.res.length) {
this._data.search.dom = $(this.element[0].querySelectorAll('#' + $.map(this._data.search.res, function (v) {
return "0123456789".indexOf(v[0]) !== -1 ? '\\3' + v[0] + ' ' + v.substr(1).replace($.jstree.idregex,'\\$&') : v.replace($.jstree.idregex,'\\$&');
}).join(', #')));
this._data.search.dom.children(".jstree-anchor").removeClass("jstree-search");
}
this._data.search.str = "";
this._data.search.res = [];
this._data.search.opn = [];
this._data.search.dom = $();
};
this.redraw_node = function(obj, deep, callback, force_render) {
obj = parent.redraw_node.apply(this, arguments);
if(obj) {
if($.inArray(obj.id, this._data.search.res) !== -1) {
var i, j, tmp = null;
for(i = 0, j = obj.childNodes.length; i < j; i++) {
if(obj.childNodes[i] && obj.childNodes[i].className && obj.childNodes[i].className.indexOf("jstree-anchor") !== -1) {
tmp = obj.childNodes[i];
break;
}
}
if(tmp) {
tmp.className += ' jstree-search';
}
}
}
return obj;
};
};
(function ($) {
$.vakata.search = function(pattern, txt, options) {
options = options || {};
options = $.extend({}, $.vakata.search.defaults, options);
if(options.fuzzy !== false) {
options.fuzzy = true;
}
pattern = options.caseSensitive ? pattern : pattern.toLowerCase();
var MATCH_LOCATION	= options.location,
MATCH_DISTANCE	= options.distance,
MATCH_THRESHOLD	= options.threshold,
patternLen = pattern.length,
matchmask, pattern_alphabet, match_bitapScore, search;
if(patternLen > 32) {
options.fuzzy = false;
}
if(options.fuzzy) {
matchmask = 1 << (patternLen - 1);
pattern_alphabet = (function () {
var mask = {},
i = 0;
for (i = 0; i < patternLen; i++) {
mask[pattern.charAt(i)] = 0;
}
for (i = 0; i < patternLen; i++) {
mask[pattern.charAt(i)] |= 1 << (patternLen - i - 1);
}
return mask;
}());
match_bitapScore = function (e, x) {
var accuracy = e / patternLen,
proximity = Math.abs(MATCH_LOCATION - x);
if(!MATCH_DISTANCE) {
return proximity ? 1.0 : accuracy;
}
return accuracy + (proximity / MATCH_DISTANCE);
};
}
search = function (text) {
text = options.caseSensitive ? text : text.toLowerCase();
if(pattern === text || text.indexOf(pattern) !== -1) {
return {
isMatch: true,
score: 0
};
}
if(!options.fuzzy) {
return {
isMatch: false,
score: 1
};
}
var i, j,
textLen = text.length,
scoreThreshold = MATCH_THRESHOLD,
bestLoc = text.indexOf(pattern, MATCH_LOCATION),
binMin, binMid,
binMax = patternLen + textLen,
lastRd, start, finish, rd, charMatch,
score = 1,
locations = [];
if (bestLoc !== -1) {
scoreThreshold = Math.min(match_bitapScore(0, bestLoc), scoreThreshold);
bestLoc = text.lastIndexOf(pattern, MATCH_LOCATION + patternLen);
if (bestLoc !== -1) {
scoreThreshold = Math.min(match_bitapScore(0, bestLoc), scoreThreshold);
}
}
bestLoc = -1;
for (i = 0; i < patternLen; i++) {
binMin = 0;
binMid = binMax;
while (binMin < binMid) {
if (match_bitapScore(i, MATCH_LOCATION + binMid) <= scoreThreshold) {
binMin = binMid;
} else {
binMax = binMid;
}
binMid = Math.floor((binMax - binMin) / 2 + binMin);
}
binMax = binMid;
start = Math.max(1, MATCH_LOCATION - binMid + 1);
finish = Math.min(MATCH_LOCATION + binMid, textLen) + patternLen;
rd = new Array(finish + 2);
rd[finish + 1] = (1 << i) - 1;
for (j = finish; j >= start; j--) {
charMatch = pattern_alphabet[text.charAt(j - 1)];
if (i === 0) {
rd[j] = ((rd[j + 1] << 1) | 1) & charMatch;
} else {
rd[j] = ((rd[j + 1] << 1) | 1) & charMatch | (((lastRd[j + 1] | lastRd[j]) << 1) | 1) | lastRd[j + 1];
}
if (rd[j] & matchmask) {
score = match_bitapScore(i, j - 1);
if (score <= scoreThreshold) {
scoreThreshold = score;
bestLoc = j - 1;
locations.push(bestLoc);
if (bestLoc > MATCH_LOCATION) {
start = Math.max(1, 2 * MATCH_LOCATION - bestLoc);
} else {
break;
}
}
}
}
if (match_bitapScore(i + 1, MATCH_LOCATION) > scoreThreshold) {
break;
}
lastRd = rd;
}
return {
isMatch: bestLoc >= 0,
score: score
};
};
return txt === true ? { 'search' : search } : search(txt);
};
$.vakata.search.defaults = {
location : 0,
distance : 100,
threshold : 0.6,
fuzzy : false,
caseSensitive : false
};
}($));
$.jstree.defaults.sort = function (a, b) {
return this.get_text(a) > this.get_text(b) ? 1 : -1;
};
$.jstree.plugins.sort = function (options, parent) {
this.bind = function () {
parent.bind.call(this);
this.element
.on("model.jstree", $.proxy(function (e, data) {
this.sort(data.parent, true);
}, this))
.on("rename_node.jstree create_node.jstree", $.proxy(function (e, data) {
this.sort(data.parent || data.node.parent, false);
this.redraw_node(data.parent || data.node.parent, true);
}, this))
.on("move_node.jstree copy_node.jstree", $.proxy(function (e, data) {
this.sort(data.parent, false);
this.redraw_node(data.parent, true);
}, this));
};
this.sort = function (obj, deep) {
var i, j;
obj = this.get_node(obj);
if(obj && obj.children && obj.children.length) {
obj.children.sort($.proxy(this.settings.sort, this));
if(deep) {
for(i = 0, j = obj.children_d.length; i < j; i++) {
this.sort(obj.children_d[i], false);
}
}
}
};
};
var to = false;
$.jstree.defaults.state = {
key		: 'jstree',
events	: 'changed.jstree open_node.jstree close_node.jstree check_node.jstree uncheck_node.jstree',
ttl		: false,
filter	: false
};
$.jstree.plugins.state = function (options, parent) {
this.bind = function () {
parent.bind.call(this);
var bind = $.proxy(function () {
this.element.on(this.settings.state.events, $.proxy(function () {
if(to) { clearTimeout(to); }
to = setTimeout($.proxy(function () { this.save_state(); }, this), 100);
}, this));
this.trigger('state_ready');
}, this);
this.element
.on("ready.jstree", $.proxy(function (e, data) {
this.element.one("restore_state.jstree", bind);
if(!this.restore_state()) { bind(); }
}, this));
};
this.save_state = function () {
var st = { 'state' : this.get_state(), 'ttl' : this.settings.state.ttl, 'sec' : +(new Date()) };
$.vakata.storage.set(this.settings.state.key, JSON.stringify(st));
};
this.restore_state = function () {
var k = $.vakata.storage.get(this.settings.state.key);
if(!!k) { try { k = JSON.parse(k); } catch(ex) { return false; } }
if(!!k && k.ttl && k.sec && +(new Date()) - k.sec > k.ttl) { return false; }
if(!!k && k.state) { k = k.state; }
if(!!k && $.isFunction(this.settings.state.filter)) { k = this.settings.state.filter.call(this, k); }
if(!!k) {
this.element.one("set_state.jstree", function (e, data) { data.instance.trigger('restore_state', { 'state' : $.extend(true, {}, k) }); });
this.set_state(k);
return true;
}
return false;
};
this.clear_state = function () {
return $.vakata.storage.del(this.settings.state.key);
};
};
(function ($, undefined) {
$.vakata.storage = {
set : function (key, val) { return window.localStorage.setItem(key, val); },
get : function (key) { return window.localStorage.getItem(key); },
del : function (key) { return window.localStorage.removeItem(key); }
};
}($));
$.jstree.defaults.types = {
'default' : {}
};
$.jstree.defaults.types[$.jstree.root] = {};
$.jstree.plugins.types = function (options, parent) {
this.init = function (el, options) {
var i, j;
if(options && options.types && options.types['default']) {
for(i in options.types) {
if(i !== "default" && i !== $.jstree.root && options.types.hasOwnProperty(i)) {
for(j in options.types['default']) {
if(options.types['default'].hasOwnProperty(j) && options.types[i][j] === undefined) {
options.types[i][j] = options.types['default'][j];
}
}
}
}
}
parent.init.call(this, el, options);
this._model.data[$.jstree.root].type = $.jstree.root;
};
this.refresh = function (skip_loading, forget_state) {
parent.refresh.call(this, skip_loading, forget_state);
this._model.data[$.jstree.root].type = $.jstree.root;
};
this.bind = function () {
this.element
.on('model.jstree', $.proxy(function (e, data) {
var m = this._model.data,
dpc = data.nodes,
t = this.settings.types,
i, j, c = 'default', k;
for(i = 0, j = dpc.length; i < j; i++) {
c = 'default';
if(m[dpc[i]].original && m[dpc[i]].original.type && t[m[dpc[i]].original.type]) {
c = m[dpc[i]].original.type;
}
if(m[dpc[i]].data && m[dpc[i]].data.jstree && m[dpc[i]].data.jstree.type && t[m[dpc[i]].data.jstree.type]) {
c = m[dpc[i]].data.jstree.type;
}
m[dpc[i]].type = c;
if(m[dpc[i]].icon === true && t[c].icon !== undefined) {
m[dpc[i]].icon = t[c].icon;
}
if(t[c].li_attr !== undefined && typeof t[c].li_attr === 'object') {
for (k in t[c].li_attr) {
if (t[c].li_attr.hasOwnProperty(k)) {
if (k === 'id') {
continue;
}
else if (m[dpc[i]].li_attr[k] === undefined) {
m[dpc[i]].li_attr[k] = t[c].li_attr[k];
}
else if (k === 'class') {
m[dpc[i]].li_attr['class'] = t[c].li_attr['class'] + ' ' + m[dpc[i]].li_attr['class'];
}
}
}
}
if(t[c].a_attr !== undefined && typeof t[c].a_attr === 'object') {
for (k in t[c].a_attr) {
if (t[c].a_attr.hasOwnProperty(k)) {
if (k === 'id') {
continue;
}
else if (m[dpc[i]].a_attr[k] === undefined) {
m[dpc[i]].a_attr[k] = t[c].a_attr[k];
}
else if (k === 'href' && m[dpc[i]].a_attr[k] === '#') {
m[dpc[i]].a_attr['href'] = t[c].a_attr['href'];
}
else if (k === 'class') {
m[dpc[i]].a_attr['class'] = t[c].a_attr['class'] + ' ' + m[dpc[i]].a_attr['class'];
}
}
}
}
}
m[$.jstree.root].type = $.jstree.root;
}, this));
parent.bind.call(this);
};
this.get_json = function (obj, options, flat) {
var i, j,
m = this._model.data,
opt = options ? $.extend(true, {}, options, {no_id:false}) : {},
tmp = parent.get_json.call(this, obj, opt, flat);
if(tmp === false) { return false; }
if($.isArray(tmp)) {
for(i = 0, j = tmp.length; i < j; i++) {
tmp[i].type = tmp[i].id && m[tmp[i].id] && m[tmp[i].id].type ? m[tmp[i].id].type : "default";
if(options && options.no_id) {
delete tmp[i].id;
if(tmp[i].li_attr && tmp[i].li_attr.id) {
delete tmp[i].li_attr.id;
}
if(tmp[i].a_attr && tmp[i].a_attr.id) {
delete tmp[i].a_attr.id;
}
}
}
}
else {
tmp.type = tmp.id && m[tmp.id] && m[tmp.id].type ? m[tmp.id].type : "default";
if(options && options.no_id) {
tmp = this._delete_ids(tmp);
}
}
return tmp;
};
this._delete_ids = function (tmp) {
if($.isArray(tmp)) {
for(var i = 0, j = tmp.length; i < j; i++) {
tmp[i] = this._delete_ids(tmp[i]);
}
return tmp;
}
delete tmp.id;
if(tmp.li_attr && tmp.li_attr.id) {
delete tmp.li_attr.id;
}
if(tmp.a_attr && tmp.a_attr.id) {
delete tmp.a_attr.id;
}
if(tmp.children && $.isArray(tmp.children)) {
tmp.children = this._delete_ids(tmp.children);
}
return tmp;
};
this.check = function (chk, obj, par, pos, more) {
if(parent.check.call(this, chk, obj, par, pos, more) === false) { return false; }
obj = obj && obj.id ? obj : this.get_node(obj);
par = par && par.id ? par : this.get_node(par);
var m = obj && obj.id ? (more && more.origin ? more.origin : $.jstree.reference(obj.id)) : null, tmp, d, i, j;
m = m && m._model && m._model.data ? m._model.data : null;
switch(chk) {
case "create_node":
case "move_node":
case "copy_node":
if(chk !== 'move_node' || $.inArray(obj.id, par.children) === -1) {
tmp = this.get_rules(par);
if(tmp.max_children !== undefined && tmp.max_children !== -1 && tmp.max_children === par.children.length) {
this._data.core.last_error = { 'error' : 'check', 'plugin' : 'types', 'id' : 'types_01', 'reason' : 'max_children prevents function: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };
return false;
}
if(tmp.valid_children !== undefined && tmp.valid_children !== -1 && $.inArray((obj.type || 'default'), tmp.valid_children) === -1) {
this._data.core.last_error = { 'error' : 'check', 'plugin' : 'types', 'id' : 'types_02', 'reason' : 'valid_children prevents function: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };
return false;
}
if(m && obj.children_d && obj.parents) {
d = 0;
for(i = 0, j = obj.children_d.length; i < j; i++) {
d = Math.max(d, m[obj.children_d[i]].parents.length);
}
d = d - obj.parents.length + 1;
}
if(d <= 0 || d === undefined) { d = 1; }
do {
if(tmp.max_depth !== undefined && tmp.max_depth !== -1 && tmp.max_depth < d) {
this._data.core.last_error = { 'error' : 'check', 'plugin' : 'types', 'id' : 'types_03', 'reason' : 'max_depth prevents function: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };
return false;
}
par = this.get_node(par.parent);
tmp = this.get_rules(par);
d++;
} while(par);
}
break;
}
return true;
};
this.get_rules = function (obj) {
obj = this.get_node(obj);
if(!obj) { return false; }
var tmp = this.get_type(obj, true);
if(tmp.max_depth === undefined) { tmp.max_depth = -1; }
if(tmp.max_children === undefined) { tmp.max_children = -1; }
if(tmp.valid_children === undefined) { tmp.valid_children = -1; }
return tmp;
};
this.get_type = function (obj, rules) {
obj = this.get_node(obj);
return (!obj) ? false : ( rules ? $.extend({ 'type' : obj.type }, this.settings.types[obj.type]) : obj.type);
};
this.set_type = function (obj, type) {
var m = this._model.data, t, t1, t2, old_type, old_icon, k, d, a;
if($.isArray(obj)) {
obj = obj.slice();
for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
this.set_type(obj[t1], type);
}
return true;
}
t = this.settings.types;
obj = this.get_node(obj);
if(!t[type] || !obj) { return false; }
d = this.get_node(obj, true);
if (d && d.length) {
a = d.children('.jstree-anchor');
}
old_type = obj.type;
old_icon = this.get_icon(obj);
obj.type = type;
if(old_icon === true || !t[old_type] || (t[old_type].icon !== undefined && old_icon === t[old_type].icon)) {
this.set_icon(obj, t[type].icon !== undefined ? t[type].icon : true);
}
if(t[old_type] && t[old_type].li_attr !== undefined && typeof t[old_type].li_attr === 'object') {
for (k in t[old_type].li_attr) {
if (t[old_type].li_attr.hasOwnProperty(k)) {
if (k === 'id') {
continue;
}
else if (k === 'class') {
m[obj.id].li_attr['class'] = (m[obj.id].li_attr['class'] || '').replace(t[old_type].li_attr[k], '');
if (d) { d.removeClass(t[old_type].li_attr[k]); }
}
else if (m[obj.id].li_attr[k] === t[old_type].li_attr[k]) {
m[obj.id].li_attr[k] = null;
if (d) { d.removeAttr(k); }
}
}
}
}
if(t[old_type] && t[old_type].a_attr !== undefined && typeof t[old_type].a_attr === 'object') {
for (k in t[old_type].a_attr) {
if (t[old_type].a_attr.hasOwnProperty(k)) {
if (k === 'id') {
continue;
}
else if (k === 'class') {
m[obj.id].a_attr['class'] = (m[obj.id].a_attr['class'] || '').replace(t[old_type].a_attr[k], '');
if (a) { a.removeClass(t[old_type].a_attr[k]); }
}
else if (m[obj.id].a_attr[k] === t[old_type].a_attr[k]) {
if (k === 'href') {
m[obj.id].a_attr[k] = '#';
if (a) { a.attr('href', '#'); }
}
else {
delete m[obj.id].a_attr[k];
if (a) { a.removeAttr(k); }
}
}
}
}
}
if(t[type].li_attr !== undefined && typeof t[type].li_attr === 'object') {
for (k in t[type].li_attr) {
if (t[type].li_attr.hasOwnProperty(k)) {
if (k === 'id') {
continue;
}
else if (m[obj.id].li_attr[k] === undefined) {
m[obj.id].li_attr[k] = t[type].li_attr[k];
if (d) {
if (k === 'class') {
d.addClass(t[type].li_attr[k]);
}
else {
d.attr(k, t[type].li_attr[k]);
}
}
}
else if (k === 'class') {
m[obj.id].li_attr['class'] = t[type].li_attr[k] + ' ' + m[obj.id].li_attr['class'];
if (d) { d.addClass(t[type].li_attr[k]); }
}
}
}
}
if(t[type].a_attr !== undefined && typeof t[type].a_attr === 'object') {
for (k in t[type].a_attr) {
if (t[type].a_attr.hasOwnProperty(k)) {
if (k === 'id') {
continue;
}
else if (m[obj.id].a_attr[k] === undefined) {
m[obj.id].a_attr[k] = t[type].a_attr[k];
if (a) {
if (k === 'class') {
a.addClass(t[type].a_attr[k]);
}
else {
a.attr(k, t[type].a_attr[k]);
}
}
}
else if (k === 'href' && m[obj.id].a_attr[k] === '#') {
m[obj.id].a_attr['href'] = t[type].a_attr['href'];
if (a) { a.attr('href', t[type].a_attr['href']); }
}
else if (k === 'class') {
m[obj.id].a_attr['class'] = t[type].a_attr['class'] + ' ' + m[obj.id].a_attr['class'];
if (a) { a.addClass(t[type].a_attr[k]); }
}
}
}
}
return true;
};
};
$.jstree.defaults.unique = {
case_sensitive : false,
duplicate : function (name, counter) {
return name + ' (' + counter + ')';
}
};
$.jstree.plugins.unique = function (options, parent) {
this.check = function (chk, obj, par, pos, more) {
if(parent.check.call(this, chk, obj, par, pos, more) === false) { return false; }
obj = obj && obj.id ? obj : this.get_node(obj);
par = par && par.id ? par : this.get_node(par);
if(!par || !par.children) { return true; }
var n = chk === "rename_node" ? pos : obj.text,
c = [],
s = this.settings.unique.case_sensitive,
m = this._model.data, i, j;
for(i = 0, j = par.children.length; i < j; i++) {
c.push(s ? m[par.children[i]].text : m[par.children[i]].text.toLowerCase());
}
if(!s) { n = n.toLowerCase(); }
switch(chk) {
case "delete_node":
return true;
case "rename_node":
i = ($.inArray(n, c) === -1 || (obj.text && obj.text[ s ? 'toString' : 'toLowerCase']() === n));
if(!i) {
this._data.core.last_error = { 'error' : 'check', 'plugin' : 'unique', 'id' : 'unique_01', 'reason' : 'Child with name ' + n + ' already exists. Preventing: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };
}
return i;
case "create_node":
i = ($.inArray(n, c) === -1);
if(!i) {
this._data.core.last_error = { 'error' : 'check', 'plugin' : 'unique', 'id' : 'unique_04', 'reason' : 'Child with name ' + n + ' already exists. Preventing: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };
}
return i;
case "copy_node":
i = ($.inArray(n, c) === -1);
if(!i) {
this._data.core.last_error = { 'error' : 'check', 'plugin' : 'unique', 'id' : 'unique_02', 'reason' : 'Child with name ' + n + ' already exists. Preventing: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };
}
return i;
case "move_node":
i = ( (obj.parent === par.id && (!more || !more.is_multi)) || $.inArray(n, c) === -1);
if(!i) {
this._data.core.last_error = { 'error' : 'check', 'plugin' : 'unique', 'id' : 'unique_03', 'reason' : 'Child with name ' + n + ' already exists. Preventing: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };
}
return i;
}
return true;
};
this.create_node = function (par, node, pos, callback, is_loaded) {
if(!node || node.text === undefined) {
if(par === null) {
par = $.jstree.root;
}
par = this.get_node(par);
if(!par) {
return parent.create_node.call(this, par, node, pos, callback, is_loaded);
}
pos = pos === undefined ? "last" : pos;
if(!pos.toString().match(/^(before|after)$/) && !is_loaded && !this.is_loaded(par)) {
return parent.create_node.call(this, par, node, pos, callback, is_loaded);
}
if(!node) { node = {}; }
var tmp, n, dpc, i, j, m = this._model.data, s = this.settings.unique.case_sensitive, cb = this.settings.unique.duplicate;
n = tmp = this.get_string('New node');
dpc = [];
for(i = 0, j = par.children.length; i < j; i++) {
dpc.push(s ? m[par.children[i]].text : m[par.children[i]].text.toLowerCase());
}
i = 1;
while($.inArray(s ? n : n.toLowerCase(), dpc) !== -1) {
n = cb.call(this, tmp, (++i)).toString();
}
node.text = n;
}
return parent.create_node.call(this, par, node, pos, callback, is_loaded);
};
};
var div = document.createElement('DIV');
div.setAttribute('unselectable','on');
div.setAttribute('role','presentation');
div.className = 'jstree-wholerow';
div.innerHTML = '&#160;';
$.jstree.plugins.wholerow = function (options, parent) {
this.bind = function () {
parent.bind.call(this);
this.element
.on('ready.jstree set_state.jstree', $.proxy(function () {
this.hide_dots();
}, this))
.on("init.jstree loading.jstree ready.jstree", $.proxy(function () {
this.get_container_ul().addClass('jstree-wholerow-ul');
}, this))
.on("deselect_all.jstree", $.proxy(function (e, data) {
this.element.find('.jstree-wholerow-clicked').removeClass('jstree-wholerow-clicked');
}, this))
.on("changed.jstree", $.proxy(function (e, data) {
this.element.find('.jstree-wholerow-clicked').removeClass('jstree-wholerow-clicked');
var tmp = false, i, j;
for(i = 0, j = data.selected.length; i < j; i++) {
tmp = this.get_node(data.selected[i], true);
if(tmp && tmp.length) {
tmp.children('.jstree-wholerow').addClass('jstree-wholerow-clicked');
}
}
}, this))
.on("open_node.jstree", $.proxy(function (e, data) {
this.get_node(data.node, true).find('.jstree-clicked').parent().children('.jstree-wholerow').addClass('jstree-wholerow-clicked');
}, this))
.on("hover_node.jstree dehover_node.jstree", $.proxy(function (e, data) {
if(e.type === "hover_node" && this.is_disabled(data.node)) { return; }
this.get_node(data.node, true).children('.jstree-wholerow')[e.type === "hover_node"?"addClass":"removeClass"]('jstree-wholerow-hovered');
}, this))
.on("contextmenu.jstree", ".jstree-wholerow", $.proxy(function (e) {
if (this._data.contextmenu) {
e.preventDefault();
var tmp = $.Event('contextmenu', { metaKey : e.metaKey, ctrlKey : e.ctrlKey, altKey : e.altKey, shiftKey : e.shiftKey, pageX : e.pageX, pageY : e.pageY });
$(e.currentTarget).closest(".jstree-node").children(".jstree-anchor").first().trigger(tmp);
}
}, this))
.on("click.jstree", ".jstree-wholerow", function (e) {
e.stopImmediatePropagation();
var tmp = $.Event('click', { metaKey : e.metaKey, ctrlKey : e.ctrlKey, altKey : e.altKey, shiftKey : e.shiftKey });
$(e.currentTarget).closest(".jstree-node").children(".jstree-anchor").first().trigger(tmp).focus();
})
.on("dblclick.jstree", ".jstree-wholerow", function (e) {
e.stopImmediatePropagation();
var tmp = $.Event('dblclick', { metaKey : e.metaKey, ctrlKey : e.ctrlKey, altKey : e.altKey, shiftKey : e.shiftKey });
$(e.currentTarget).closest(".jstree-node").children(".jstree-anchor").first().trigger(tmp).focus();
})
.on("click.jstree", ".jstree-leaf > .jstree-ocl", $.proxy(function (e) {
e.stopImmediatePropagation();
var tmp = $.Event('click', { metaKey : e.metaKey, ctrlKey : e.ctrlKey, altKey : e.altKey, shiftKey : e.shiftKey });
$(e.currentTarget).closest(".jstree-node").children(".jstree-anchor").first().trigger(tmp).focus();
}, this))
.on("mouseover.jstree", ".jstree-wholerow, .jstree-icon", $.proxy(function (e) {
e.stopImmediatePropagation();
if(!this.is_disabled(e.currentTarget)) {
this.hover_node(e.currentTarget);
}
return false;
}, this))
.on("mouseleave.jstree", ".jstree-node", $.proxy(function (e) {
this.dehover_node(e.currentTarget);
}, this));
};
this.teardown = function () {
if(this.settings.wholerow) {
this.element.find(".jstree-wholerow").remove();
}
parent.teardown.call(this);
};
this.redraw_node = function(obj, deep, callback, force_render) {
obj = parent.redraw_node.apply(this, arguments);
if(obj) {
var tmp = div.cloneNode(true);
if($.inArray(obj.id, this._data.core.selected) !== -1) { tmp.className += ' jstree-wholerow-clicked'; }
if(this._data.core.focused && this._data.core.focused === obj.id) { tmp.className += ' jstree-wholerow-hovered'; }
obj.insertBefore(tmp, obj.childNodes[0]);
}
return obj;
};
};
if(document.registerElement && Object && Object.create) {
var proto = Object.create(HTMLElement.prototype);
proto.createdCallback = function () {
var c = { core : {}, plugins : [] }, i;
for(i in $.jstree.plugins) {
if($.jstree.plugins.hasOwnProperty(i) && this.attributes[i]) {
c.plugins.push(i);
if(this.getAttribute(i) && JSON.parse(this.getAttribute(i))) {
c[i] = JSON.parse(this.getAttribute(i));
}
}
}
for(i in $.jstree.defaults.core) {
if($.jstree.defaults.core.hasOwnProperty(i) && this.attributes[i]) {
c.core[i] = JSON.parse(this.getAttribute(i)) || this.getAttribute(i);
}
}
$(this).jstree(c);
};
try {
document.registerElement("vakata-jstree", { prototype: proto });
} catch(ignore) { }
}
}));
(function webpackUniversalModuleDefinition(root, factory) {
if(typeof exports === 'object' && typeof module === 'object')
module.exports = factory();
else if(typeof define === 'function' && define.amd)
define([], factory);
else if(typeof exports === 'object')
exports["Raphael"] = factory();
else
root["Raphael"] = factory();
})(this, function() {
return (function(modules) { // webpackBootstrap 	// The module cache 	var installedModules = {};
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1), __webpack_require__(3), __webpack_require__(4)], __WEBPACK_AMD_DEFINE_RESULT__ = function(R) {
return R;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}, function(module, exports, __webpack_require__) {
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2)], __WEBPACK_AMD_DEFINE_RESULT__ = function(eve) {
function R(first) {
if (R.is(first, "function")) {
return loaded ? first() : eve.on("raphael.DOMload", first);
} else if (R.is(first, array)) {
return R._engine.create[apply](R, first.splice(0, 3 + R.is(first[0], nu))).add(first);
} else {
var args = Array.prototype.slice.call(arguments, 0);
if (R.is(args[args.length - 1], "function")) {
var f = args.pop();
return loaded ? f.call(R._engine.create[apply](R, args)) : eve.on("raphael.DOMload", function () {
f.call(R._engine.create[apply](R, args));
});
} else {
return R._engine.create[apply](R, arguments);
}
}
}
R.version = "2.2.0";
R.eve = eve;
var loaded,
separator = /[, ]+/,
elements = {circle: 1, rect: 1, path: 1, ellipse: 1, text: 1, image: 1},
formatrg = /\{(\d+)\}/g,
proto = "prototype",
has = "hasOwnProperty",
g = {
doc: document,
win: window
},
oldRaphael = {
was: Object.prototype[has].call(g.win, "Raphael"),
is: g.win.Raphael
},
Paper = function () {
this.ca = this.customAttributes = {};
},
paperproto,
appendChild = "appendChild",
apply = "apply",
concat = "concat",
supportsTouch = ('ontouchstart' in g.win) || g.win.DocumentTouch && g.doc instanceof DocumentTouch, //taken from Modernizr touch test
E = "",
S = " ",
Str = String,
split = "split",
events = "click dblclick mousedown mousemove mouseout mouseover mouseup touchstart touchmove touchend touchcancel"[split](S),
touchMap = {
mousedown: "touchstart",
mousemove: "touchmove",
mouseup: "touchend"
},
lowerCase = Str.prototype.toLowerCase,
math = Math,
mmax = math.max,
mmin = math.min,
abs = math.abs,
pow = math.pow,
PI = math.PI,
nu = "number",
string = "string",
array = "array",
toString = "toString",
fillString = "fill",
objectToString = Object.prototype.toString,
paper = {},
push = "push",
ISURL = R._ISURL = /^url\(['"]?(.+?)['"]?\)$/i,
colourRegExp = /^\s*((#[a-f\d]{6})|(#[a-f\d]{3})|rgba?\(\s*([\d\.]+%?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+%?)?)\s*\)|hsba?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\)|hsla?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\))\s*$/i,
isnan = {"NaN": 1, "Infinity": 1, "-Infinity": 1},
bezierrg = /^(?:cubic-)?bezier\(([^,]+),([^,]+),([^,]+),([^\)]+)\)/,
round = math.round,
setAttribute = "setAttribute",
toFloat = parseFloat,
toInt = parseInt,
upperCase = Str.prototype.toUpperCase,
availableAttrs = R._availableAttrs = {
"arrow-end": "none",
"arrow-start": "none",
blur: 0,
"clip-rect": "0 0 1e9 1e9",
cursor: "default",
cx: 0,
cy: 0,
fill: "#fff",
"fill-opacity": 1,
font: '10px "Arial"',
"font-family": '"Arial"',
"font-size": "10",
"font-style": "normal",
"font-weight": 400,
gradient: 0,
height: 0,
href: "http://raphaeljs.com/",
"letter-spacing": 0,
opacity: 1,
path: "M0,0",
r: 0,
rx: 0,
ry: 0,
src: "",
stroke: "#000",
"stroke-dasharray": "",
"stroke-linecap": "butt",
"stroke-linejoin": "butt",
"stroke-miterlimit": 0,
"stroke-opacity": 1,
"stroke-width": 1,
target: "_blank",
"text-anchor": "middle",
title: "Raphael",
transform: "",
width: 0,
x: 0,
y: 0,
"class": ""
},
availableAnimAttrs = R._availableAnimAttrs = {
blur: nu,
"clip-rect": "csv",
cx: nu,
cy: nu,
fill: "colour",
"fill-opacity": nu,
"font-size": nu,
height: nu,
opacity: nu,
path: "path",
r: nu,
rx: nu,
ry: nu,
stroke: "colour",
"stroke-opacity": nu,
"stroke-width": nu,
transform: "transform",
width: nu,
x: nu,
y: nu
},
whitespace = /[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]/g,
commaSpaces = /[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*/,
hsrg = {hs: 1, rg: 1},
p2s = /,?([achlmqrstvxz]),?/gi,
pathCommand = /([achlmrqstvz])[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*)+)/ig,
tCommand = /([rstm])[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*)+)/ig,
pathValues = /(-?\d*\.?\d*(?:e[\-+]?\d+)?)[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*/ig,
radial_gradient = R._radial_gradient = /^r(?:\(([^,]+?)[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*([^\)]+?)\))?/,
eldata = {},
sortByKey = function (a, b) {
return a.key - b.key;
},
sortByNumber = function (a, b) {
return toFloat(a) - toFloat(b);
},
fun = function () {},
pipe = function (x) {
return x;
},
rectPath = R._rectPath = function (x, y, w, h, r) {
if (r) {
return [["M", x + r, y], ["l", w - r * 2, 0], ["a", r, r, 0, 0, 1, r, r], ["l", 0, h - r * 2], ["a", r, r, 0, 0, 1, -r, r], ["l", r * 2 - w, 0], ["a", r, r, 0, 0, 1, -r, -r], ["l", 0, r * 2 - h], ["a", r, r, 0, 0, 1, r, -r], ["z"]];
}
return [["M", x, y], ["l", w, 0], ["l", 0, h], ["l", -w, 0], ["z"]];
},
ellipsePath = function (x, y, rx, ry) {
if (ry == null) {
ry = rx;
}
return [["M", x, y], ["m", 0, -ry], ["a", rx, ry, 0, 1, 1, 0, 2 * ry], ["a", rx, ry, 0, 1, 1, 0, -2 * ry], ["z"]];
},
getPath = R._getPath = {
path: function (el) {
return el.attr("path");
},
circle: function (el) {
var a = el.attrs;
return ellipsePath(a.cx, a.cy, a.r);
},
ellipse: function (el) {
var a = el.attrs;
return ellipsePath(a.cx, a.cy, a.rx, a.ry);
},
rect: function (el) {
var a = el.attrs;
return rectPath(a.x, a.y, a.width, a.height, a.r);
},
image: function (el) {
var a = el.attrs;
return rectPath(a.x, a.y, a.width, a.height);
},
text: function (el) {
var bbox = el._getBBox();
return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);
},
set : function(el) {
var bbox = el._getBBox();
return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);
}
},
mapPath = R.mapPath = function (path, matrix) {
if (!matrix) {
return path;
}
var x, y, i, j, ii, jj, pathi;
path = path2curve(path);
for (i = 0, ii = path.length; i < ii; i++) {
pathi = path[i];
for (j = 1, jj = pathi.length; j < jj; j += 2) {
x = matrix.x(pathi[j], pathi[j + 1]);
y = matrix.y(pathi[j], pathi[j + 1]);
pathi[j] = x;
pathi[j + 1] = y;
}
}
return path;
};
R._g = g;
R.type = (g.win.SVGAngle || g.doc.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1") ? "SVG" : "VML");
if (R.type == "VML") {
var d = g.doc.createElement("div"),
b;
d.innerHTML = '<v:shape adj="1"/>';
b = d.firstChild;
b.style.behavior = "url(#default#VML)";
if (!(b && typeof b.adj == "object")) {
return (R.type = E);
}
d = null;
}
R.svg = !(R.vml = R.type == "VML");
R._Paper = Paper;
R.fn = paperproto = Paper.prototype = R.prototype;
R._id = 0;
R.is = function (o, type) {
type = lowerCase.call(type);
if (type == "finite") {
return !isnan[has](+o);
}
if (type == "array") {
return o instanceof Array;
}
return  (type == "null" && o === null) ||
(type == typeof o && o !== null) ||
(type == "object" && o === Object(o)) ||
(type == "array" && Array.isArray && Array.isArray(o)) ||
objectToString.call(o).slice(8, -1).toLowerCase() == type;
};
function clone(obj) {
if (typeof obj == "function" || Object(obj) !== obj) {
return obj;
}
var res = new obj.constructor;
for (var key in obj) if (obj[has](key)) {
res[key] = clone(obj[key]);
}
return res;
}
R.angle = function (x1, y1, x2, y2, x3, y3) {
if (x3 == null) {
var x = x1 - x2,
y = y1 - y2;
if (!x && !y) {
return 0;
}
return (180 + math.atan2(-y, -x) * 180 / PI + 360) % 360;
} else {
return R.angle(x1, y1, x3, y3) - R.angle(x2, y2, x3, y3);
}
};
R.rad = function (deg) {
return deg % 360 * PI / 180;
};
R.deg = function (rad) {
return Math.round ((rad * 180 / PI% 360)* 1000) / 1000;
};
R.snapTo = function (values, value, tolerance) {
tolerance = R.is(tolerance, "finite") ? tolerance : 10;
if (R.is(values, array)) {
var i = values.length;
while (i--) if (abs(values[i] - value) <= tolerance) {
return values[i];
}
} else {
values = +values;
var rem = value % values;
if (rem < tolerance) {
return value - rem;
}
if (rem > values - tolerance) {
return value - rem + values;
}
}
return value;
};
var createUUID = R.createUUID = (function (uuidRegEx, uuidReplacer) {
return function () {
return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(uuidRegEx, uuidReplacer).toUpperCase();
};
})(/[xy]/g, function (c) {
var r = math.random() * 16 | 0,
v = c == "x" ? r : (r & 3 | 8);
return v.toString(16);
});
R.setWindow = function (newwin) {
eve("raphael.setWindow", R, g.win, newwin);
g.win = newwin;
g.doc = g.win.document;
if (R._engine.initWin) {
R._engine.initWin(g.win);
}
};
var toHex = function (color) {
if (R.vml) {
var trim = /^\s+|\s+$/g;
var bod;
try {
var docum = new ActiveXObject("htmlfile");
docum.write("<body>");
docum.close();
bod = docum.body;
} catch(e) {
bod = createPopup().document.body;
}
var range = bod.createTextRange();
toHex = cacher(function (color) {
try {
bod.style.color = Str(color).replace(trim, E);
var value = range.queryCommandValue("ForeColor");
value = ((value & 255) << 16) | (value & 65280) | ((value & 16711680) >>> 16);
return "#" + ("000000" + value.toString(16)).slice(-6);
} catch(e) {
return "none";
}
});
} else {
var i = g.doc.createElement("i");
i.title = "Rapha\xebl Colour Picker";
i.style.display = "none";
g.doc.body.appendChild(i);
toHex = cacher(function (color) {
i.style.color = color;
return g.doc.defaultView.getComputedStyle(i, E).getPropertyValue("color");
});
}
return toHex(color);
},
hsbtoString = function () {
return "hsb(" + [this.h, this.s, this.b] + ")";
},
hsltoString = function () {
return "hsl(" + [this.h, this.s, this.l] + ")";
},
rgbtoString = function () {
return this.hex;
},
prepareRGB = function (r, g, b) {
if (g == null && R.is(r, "object") && "r" in r && "g" in r && "b" in r) {
b = r.b;
g = r.g;
r = r.r;
}
if (g == null && R.is(r, string)) {
var clr = R.getRGB(r);
r = clr.r;
g = clr.g;
b = clr.b;
}
if (r > 1 || g > 1 || b > 1) {
r /= 255;
g /= 255;
b /= 255;
}
return [r, g, b];
},
packageRGB = function (r, g, b, o) {
r *= 255;
g *= 255;
b *= 255;
var rgb = {
r: r,
g: g,
b: b,
hex: R.rgb(r, g, b),
toString: rgbtoString
};
R.is(o, "finite") && (rgb.opacity = o);
return rgb;
};
R.color = function (clr) {
var rgb;
if (R.is(clr, "object") && "h" in clr && "s" in clr && "b" in clr) {
rgb = R.hsb2rgb(clr);
clr.r = rgb.r;
clr.g = rgb.g;
clr.b = rgb.b;
clr.hex = rgb.hex;
} else if (R.is(clr, "object") && "h" in clr && "s" in clr && "l" in clr) {
rgb = R.hsl2rgb(clr);
clr.r = rgb.r;
clr.g = rgb.g;
clr.b = rgb.b;
clr.hex = rgb.hex;
} else {
if (R.is(clr, "string")) {
clr = R.getRGB(clr);
}
if (R.is(clr, "object") && "r" in clr && "g" in clr && "b" in clr) {
rgb = R.rgb2hsl(clr);
clr.h = rgb.h;
clr.s = rgb.s;
clr.l = rgb.l;
rgb = R.rgb2hsb(clr);
clr.v = rgb.b;
} else {
clr = {hex: "none"};
clr.r = clr.g = clr.b = clr.h = clr.s = clr.v = clr.l = -1;
}
}
clr.toString = rgbtoString;
return clr;
};
R.hsb2rgb = function (h, s, v, o) {
if (this.is(h, "object") && "h" in h && "s" in h && "b" in h) {
v = h.b;
s = h.s;
o = h.o;
h = h.h;
}
h *= 360;
var R, G, B, X, C;
h = (h % 360) / 60;
C = v * s;
X = C * (1 - abs(h % 2 - 1));
R = G = B = v - C;
h = ~~h;
R += [C, X, 0, 0, X, C][h];
G += [X, C, C, X, 0, 0][h];
B += [0, 0, X, C, C, X][h];
return packageRGB(R, G, B, o);
};
R.hsl2rgb = function (h, s, l, o) {
if (this.is(h, "object") && "h" in h && "s" in h && "l" in h) {
l = h.l;
s = h.s;
h = h.h;
}
if (h > 1 || s > 1 || l > 1) {
h /= 360;
s /= 100;
l /= 100;
}
h *= 360;
var R, G, B, X, C;
h = (h % 360) / 60;
C = 2 * s * (l < .5 ? l : 1 - l);
X = C * (1 - abs(h % 2 - 1));
R = G = B = l - C / 2;
h = ~~h;
R += [C, X, 0, 0, X, C][h];
G += [X, C, C, X, 0, 0][h];
B += [0, 0, X, C, C, X][h];
return packageRGB(R, G, B, o);
};
R.rgb2hsb = function (r, g, b) {
b = prepareRGB(r, g, b);
r = b[0];
g = b[1];
b = b[2];
var H, S, V, C;
V = mmax(r, g, b);
C = V - mmin(r, g, b);
H = (C == 0 ? null :
V == r ? (g - b) / C :
V == g ? (b - r) / C + 2 :
(r - g) / C + 4
);
H = ((H + 360) % 6) * 60 / 360;
S = C == 0 ? 0 : C / V;
return {h: H, s: S, b: V, toString: hsbtoString};
};
R.rgb2hsl = function (r, g, b) {
b = prepareRGB(r, g, b);
r = b[0];
g = b[1];
b = b[2];
var H, S, L, M, m, C;
M = mmax(r, g, b);
m = mmin(r, g, b);
C = M - m;
H = (C == 0 ? null :
M == r ? (g - b) / C :
M == g ? (b - r) / C + 2 :
(r - g) / C + 4);
H = ((H + 360) % 6) * 60 / 360;
L = (M + m) / 2;
S = (C == 0 ? 0 :
L < .5 ? C / (2 * L) :
C / (2 - 2 * L));
return {h: H, s: S, l: L, toString: hsltoString};
};
R._path2string = function () {
return this.join(",").replace(p2s, "$1");
};
function repush(array, item) {
for (var i = 0, ii = array.length; i < ii; i++) if (array[i] === item) {
return array.push(array.splice(i, 1)[0]);
}
}
function cacher(f, scope, postprocessor) {
function newf() {
var arg = Array.prototype.slice.call(arguments, 0),
args = arg.join("\u2400"),
cache = newf.cache = newf.cache || {},
count = newf.count = newf.count || [];
if (cache[has](args)) {
repush(count, args);
return postprocessor ? postprocessor(cache[args]) : cache[args];
}
count.length >= 1e3 && delete cache[count.shift()];
count.push(args);
cache[args] = f[apply](scope, arg);
return postprocessor ? postprocessor(cache[args]) : cache[args];
}
return newf;
}
var preload = R._preload = function (src, f) {
var img = g.doc.createElement("img");
img.style.cssText = "position:absolute;left:-9999em;top:-9999em";
img.onload = function () {
f.call(this);
this.onload = null;
g.doc.body.removeChild(this);
};
img.onerror = function () {
g.doc.body.removeChild(this);
};
g.doc.body.appendChild(img);
img.src = src;
};
function clrToString() {
return this.hex;
}
R.getRGB = cacher(function (colour) {
if (!colour || !!((colour = Str(colour)).indexOf("-") + 1)) {
return {r: -1, g: -1, b: -1, hex: "none", error: 1, toString: clrToString};
}
if (colour == "none") {
return {r: -1, g: -1, b: -1, hex: "none", toString: clrToString};
}
!(hsrg[has](colour.toLowerCase().substring(0, 2)) || colour.charAt() == "#") && (colour = toHex(colour));
var res,
red,
green,
blue,
opacity,
t,
values,
rgb = colour.match(colourRegExp);
if (rgb) {
if (rgb[2]) {
blue = toInt(rgb[2].substring(5), 16);
green = toInt(rgb[2].substring(3, 5), 16);
red = toInt(rgb[2].substring(1, 3), 16);
}
if (rgb[3]) {
blue = toInt((t = rgb[3].charAt(3)) + t, 16);
green = toInt((t = rgb[3].charAt(2)) + t, 16);
red = toInt((t = rgb[3].charAt(1)) + t, 16);
}
if (rgb[4]) {
values = rgb[4][split](commaSpaces);
red = toFloat(values[0]);
values[0].slice(-1) == "%" && (red *= 2.55);
green = toFloat(values[1]);
values[1].slice(-1) == "%" && (green *= 2.55);
blue = toFloat(values[2]);
values[2].slice(-1) == "%" && (blue *= 2.55);
rgb[1].toLowerCase().slice(0, 4) == "rgba" && (opacity = toFloat(values[3]));
values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
}
if (rgb[5]) {
values = rgb[5][split](commaSpaces);
red = toFloat(values[0]);
values[0].slice(-1) == "%" && (red *= 2.55);
green = toFloat(values[1]);
values[1].slice(-1) == "%" && (green *= 2.55);
blue = toFloat(values[2]);
values[2].slice(-1) == "%" && (blue *= 2.55);
(values[0].slice(-3) == "deg" || values[0].slice(-1) == "\xb0") && (red /= 360);
rgb[1].toLowerCase().slice(0, 4) == "hsba" && (opacity = toFloat(values[3]));
values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
return R.hsb2rgb(red, green, blue, opacity);
}
if (rgb[6]) {
values = rgb[6][split](commaSpaces);
red = toFloat(values[0]);
values[0].slice(-1) == "%" && (red *= 2.55);
green = toFloat(values[1]);
values[1].slice(-1) == "%" && (green *= 2.55);
blue = toFloat(values[2]);
values[2].slice(-1) == "%" && (blue *= 2.55);
(values[0].slice(-3) == "deg" || values[0].slice(-1) == "\xb0") && (red /= 360);
rgb[1].toLowerCase().slice(0, 4) == "hsla" && (opacity = toFloat(values[3]));
values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
return R.hsl2rgb(red, green, blue, opacity);
}
rgb = {r: red, g: green, b: blue, toString: clrToString};
rgb.hex = "#" + (16777216 | blue | (green << 8) | (red << 16)).toString(16).slice(1);
R.is(opacity, "finite") && (rgb.opacity = opacity);
return rgb;
}
return {r: -1, g: -1, b: -1, hex: "none", error: 1, toString: clrToString};
}, R);
R.hsb = cacher(function (h, s, b) {
return R.hsb2rgb(h, s, b).hex;
});
R.hsl = cacher(function (h, s, l) {
return R.hsl2rgb(h, s, l).hex;
});
R.rgb = cacher(function (r, g, b) {
function round(x) { return (x + 0.5) | 0; }
return "#" + (16777216 | round(b) | (round(g) << 8) | (round(r) << 16)).toString(16).slice(1);
});
R.getColor = function (value) {
var start = this.getColor.start = this.getColor.start || {h: 0, s: 1, b: value || .75},
rgb = this.hsb2rgb(start.h, start.s, start.b);
start.h += .075;
if (start.h > 1) {
start.h = 0;
start.s -= .2;
start.s <= 0 && (this.getColor.start = {h: 0, s: 1, b: start.b});
}
return rgb.hex;
};
R.getColor.reset = function () {
delete this.start;
};
function catmullRom2bezier(crp, z) {
var d = [];
for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {
var p = [
{x: +crp[i - 2], y: +crp[i - 1]},
{x: +crp[i],     y: +crp[i + 1]},
{x: +crp[i + 2], y: +crp[i + 3]},
{x: +crp[i + 4], y: +crp[i + 5]}
];
if (z) {
if (!i) {
p[0] = {x: +crp[iLen - 2], y: +crp[iLen - 1]};
} else if (iLen - 4 == i) {
p[3] = {x: +crp[0], y: +crp[1]};
} else if (iLen - 2 == i) {
p[2] = {x: +crp[0], y: +crp[1]};
p[3] = {x: +crp[2], y: +crp[3]};
}
} else {
if (iLen - 4 == i) {
p[3] = p[2];
} else if (!i) {
p[0] = {x: +crp[i], y: +crp[i + 1]};
}
}
d.push(["C",
(-p[0].x + 6 * p[1].x + p[2].x) / 6,
(-p[0].y + 6 * p[1].y + p[2].y) / 6,
(p[1].x + 6 * p[2].x - p[3].x) / 6,
(p[1].y + 6*p[2].y - p[3].y) / 6,
p[2].x,
p[2].y
]);
}
return d;
}
R.parsePathString = function (pathString) {
if (!pathString) {
return null;
}
var pth = paths(pathString);
if (pth.arr) {
return pathClone(pth.arr);
}
var paramCounts = {a: 7, c: 6, h: 1, l: 2, m: 2, r: 4, q: 4, s: 4, t: 2, v: 1, z: 0},
data = [];
if (R.is(pathString, array) && R.is(pathString[0], array)) { // rough assumption
data = pathClone(pathString);
}
if (!data.length) {
Str(pathString).replace(pathCommand, function (a, b, c) {
var params = [],
name = b.toLowerCase();
c.replace(pathValues, function (a, b) {
b && params.push(+b);
});
if (name == "m" && params.length > 2) {
data.push([b][concat](params.splice(0, 2)));
name = "l";
b = b == "m" ? "l" : "L";
}
if (name == "r") {
data.push([b][concat](params));
} else while (params.length >= paramCounts[name]) {
data.push([b][concat](params.splice(0, paramCounts[name])));
if (!paramCounts[name]) {
break;
}
}
});
}
data.toString = R._path2string;
pth.arr = pathClone(data);
return data;
};
R.parseTransformString = cacher(function (TString) {
if (!TString) {
return null;
}
var paramCounts = {r: 3, s: 4, t: 2, m: 6},
data = [];
if (R.is(TString, array) && R.is(TString[0], array)) { // rough assumption
data = pathClone(TString);
}
if (!data.length) {
Str(TString).replace(tCommand, function (a, b, c) {
var params = [],
name = lowerCase.call(b);
c.replace(pathValues, function (a, b) {
b && params.push(+b);
});
data.push([b][concat](params));
});
}
data.toString = R._path2string;
return data;
});
var paths = function (ps) {
var p = paths.ps = paths.ps || {};
if (p[ps]) {
p[ps].sleep = 100;
} else {
p[ps] = {
sleep: 100
};
}
setTimeout(function () {
for (var key in p) if (p[has](key) && key != ps) {
p[key].sleep--;
!p[key].sleep && delete p[key];
}
});
return p[ps];
};
R.findDotsAtSegment = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
var t1 = 1 - t,
t13 = pow(t1, 3),
t12 = pow(t1, 2),
t2 = t * t,
t3 = t2 * t,
x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x,
y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y,
mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x),
my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y),
nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x),
ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y),
ax = t1 * p1x + t * c1x,
ay = t1 * p1y + t * c1y,
cx = t1 * c2x + t * p2x,
cy = t1 * c2y + t * p2y,
alpha = (90 - math.atan2(mx - nx, my - ny) * 180 / PI);
(mx > nx || my < ny) && (alpha += 180);
return {
x: x,
y: y,
m: {x: mx, y: my},
n: {x: nx, y: ny},
start: {x: ax, y: ay},
end: {x: cx, y: cy},
alpha: alpha
};
};
R.bezierBBox = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
if (!R.is(p1x, "array")) {
p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];
}
var bbox = curveDim.apply(null, p1x);
return {
x: bbox.min.x,
y: bbox.min.y,
x2: bbox.max.x,
y2: bbox.max.y,
width: bbox.max.x - bbox.min.x,
height: bbox.max.y - bbox.min.y
};
};
R.isPointInsideBBox = function (bbox, x, y) {
return x >= bbox.x && x <= bbox.x2 && y >= bbox.y && y <= bbox.y2;
};
R.isBBoxIntersect = function (bbox1, bbox2) {
var i = R.isPointInsideBBox;
return i(bbox2, bbox1.x, bbox1.y)
|| i(bbox2, bbox1.x2, bbox1.y)
|| i(bbox2, bbox1.x, bbox1.y2)
|| i(bbox2, bbox1.x2, bbox1.y2)
|| i(bbox1, bbox2.x, bbox2.y)
|| i(bbox1, bbox2.x2, bbox2.y)
|| i(bbox1, bbox2.x, bbox2.y2)
|| i(bbox1, bbox2.x2, bbox2.y2)
|| (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x)
&& (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);
};
function base3(t, p1, p2, p3, p4) {
var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4,
t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;
return t * t2 - 3 * p1 + 3 * p2;
}
function bezlen(x1, y1, x2, y2, x3, y3, x4, y4, z) {
if (z == null) {
z = 1;
}
z = z > 1 ? 1 : z < 0 ? 0 : z;
var z2 = z / 2,
n = 12,
Tvalues = [-0.1252,0.1252,-0.3678,0.3678,-0.5873,0.5873,-0.7699,0.7699,-0.9041,0.9041,-0.9816,0.9816],
Cvalues = [0.2491,0.2491,0.2335,0.2335,0.2032,0.2032,0.1601,0.1601,0.1069,0.1069,0.0472,0.0472],
sum = 0;
for (var i = 0; i < n; i++) {
var ct = z2 * Tvalues[i] + z2,
xbase = base3(ct, x1, x2, x3, x4),
ybase = base3(ct, y1, y2, y3, y4),
comb = xbase * xbase + ybase * ybase;
sum += Cvalues[i] * math.sqrt(comb);
}
return z2 * sum;
}
function getTatLen(x1, y1, x2, y2, x3, y3, x4, y4, ll) {
if (ll < 0 || bezlen(x1, y1, x2, y2, x3, y3, x4, y4) < ll) {
return;
}
var t = 1,
step = t / 2,
t2 = t - step,
l,
e = .01;
l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);
while (abs(l - ll) > e) {
step /= 2;
t2 += (l < ll ? 1 : -1) * step;
l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);
}
return t2;
}
function intersect(x1, y1, x2, y2, x3, y3, x4, y4) {
if (
mmax(x1, x2) < mmin(x3, x4) ||
mmin(x1, x2) > mmax(x3, x4) ||
mmax(y1, y2) < mmin(y3, y4) ||
mmin(y1, y2) > mmax(y3, y4)
) {
return;
}
var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),
ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),
denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
if (!denominator) {
return;
}
var px = nx / denominator,
py = ny / denominator,
px2 = +px.toFixed(2),
py2 = +py.toFixed(2);
if (
px2 < +mmin(x1, x2).toFixed(2) ||
px2 > +mmax(x1, x2).toFixed(2) ||
px2 < +mmin(x3, x4).toFixed(2) ||
px2 > +mmax(x3, x4).toFixed(2) ||
py2 < +mmin(y1, y2).toFixed(2) ||
py2 > +mmax(y1, y2).toFixed(2) ||
py2 < +mmin(y3, y4).toFixed(2) ||
py2 > +mmax(y3, y4).toFixed(2)
) {
return;
}
return {x: px, y: py};
}
function inter(bez1, bez2) {
return interHelper(bez1, bez2);
}
function interCount(bez1, bez2) {
return interHelper(bez1, bez2, 1);
}
function interHelper(bez1, bez2, justCount) {
var bbox1 = R.bezierBBox(bez1),
bbox2 = R.bezierBBox(bez2);
if (!R.isBBoxIntersect(bbox1, bbox2)) {
return justCount ? 0 : [];
}
var l1 = bezlen.apply(0, bez1),
l2 = bezlen.apply(0, bez2),
n1 = mmax(~~(l1 / 5), 1),
n2 = mmax(~~(l2 / 5), 1),
dots1 = [],
dots2 = [],
xy = {},
res = justCount ? 0 : [];
for (var i = 0; i < n1 + 1; i++) {
var p = R.findDotsAtSegment.apply(R, bez1.concat(i / n1));
dots1.push({x: p.x, y: p.y, t: i / n1});
}
for (i = 0; i < n2 + 1; i++) {
p = R.findDotsAtSegment.apply(R, bez2.concat(i / n2));
dots2.push({x: p.x, y: p.y, t: i / n2});
}
for (i = 0; i < n1; i++) {
for (var j = 0; j < n2; j++) {
var di = dots1[i],
di1 = dots1[i + 1],
dj = dots2[j],
dj1 = dots2[j + 1],
ci = abs(di1.x - di.x) < .001 ? "y" : "x",
cj = abs(dj1.x - dj.x) < .001 ? "y" : "x",
is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);
if (is) {
if (xy[is.x.toFixed(4)] == is.y.toFixed(4)) {
continue;
}
xy[is.x.toFixed(4)] = is.y.toFixed(4);
var t1 = di.t + abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t),
t2 = dj.t + abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);
if (t1 >= 0 && t1 <= 1.001 && t2 >= 0 && t2 <= 1.001) {
if (justCount) {
res++;
} else {
res.push({
x: is.x,
y: is.y,
t1: mmin(t1, 1),
t2: mmin(t2, 1)
});
}
}
}
}
}
return res;
}
R.pathIntersection = function (path1, path2) {
return interPathHelper(path1, path2);
};
R.pathIntersectionNumber = function (path1, path2) {
return interPathHelper(path1, path2, 1);
};
function interPathHelper(path1, path2, justCount) {
path1 = R._path2curve(path1);
path2 = R._path2curve(path2);
var x1, y1, x2, y2, x1m, y1m, x2m, y2m, bez1, bez2,
res = justCount ? 0 : [];
for (var i = 0, ii = path1.length; i < ii; i++) {
var pi = path1[i];
if (pi[0] == "M") {
x1 = x1m = pi[1];
y1 = y1m = pi[2];
} else {
if (pi[0] == "C") {
bez1 = [x1, y1].concat(pi.slice(1));
x1 = bez1[6];
y1 = bez1[7];
} else {
bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];
x1 = x1m;
y1 = y1m;
}
for (var j = 0, jj = path2.length; j < jj; j++) {
var pj = path2[j];
if (pj[0] == "M") {
x2 = x2m = pj[1];
y2 = y2m = pj[2];
} else {
if (pj[0] == "C") {
bez2 = [x2, y2].concat(pj.slice(1));
x2 = bez2[6];
y2 = bez2[7];
} else {
bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];
x2 = x2m;
y2 = y2m;
}
var intr = interHelper(bez1, bez2, justCount);
if (justCount) {
res += intr;
} else {
for (var k = 0, kk = intr.length; k < kk; k++) {
intr[k].segment1 = i;
intr[k].segment2 = j;
intr[k].bez1 = bez1;
intr[k].bez2 = bez2;
}
res = res.concat(intr);
}
}
}
}
}
return res;
}
R.isPointInsidePath = function (path, x, y) {
var bbox = R.pathBBox(path);
return R.isPointInsideBBox(bbox, x, y) &&
interPathHelper(path, [["M", x, y], ["H", bbox.x2 + 10]], 1) % 2 == 1;
};
R._removedFactory = function (methodname) {
return function () {
eve("raphael.log", null, "Rapha\xebl: you are calling to method \u201c" + methodname + "\u201d of removed object", methodname);
};
};
var pathDimensions = R.pathBBox = function (path) {
var pth = paths(path);
if (pth.bbox) {
return clone(pth.bbox);
}
if (!path) {
return {x: 0, y: 0, width: 0, height: 0, x2: 0, y2: 0};
}
path = path2curve(path);
var x = 0,
y = 0,
X = [],
Y = [],
p;
for (var i = 0, ii = path.length; i < ii; i++) {
p = path[i];
if (p[0] == "M") {
x = p[1];
y = p[2];
X.push(x);
Y.push(y);
} else {
var dim = curveDim(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
X = X[concat](dim.min.x, dim.max.x);
Y = Y[concat](dim.min.y, dim.max.y);
x = p[5];
y = p[6];
}
}
var xmin = mmin[apply](0, X),
ymin = mmin[apply](0, Y),
xmax = mmax[apply](0, X),
ymax = mmax[apply](0, Y),
width = xmax - xmin,
height = ymax - ymin,
bb = {
x: xmin,
y: ymin,
x2: xmax,
y2: ymax,
width: width,
height: height,
cx: xmin + width / 2,
cy: ymin + height / 2
};
pth.bbox = clone(bb);
return bb;
},
pathClone = function (pathArray) {
var res = clone(pathArray);
res.toString = R._path2string;
return res;
},
pathToRelative = R._pathToRelative = function (pathArray) {
var pth = paths(pathArray);
if (pth.rel) {
return pathClone(pth.rel);
}
if (!R.is(pathArray, array) || !R.is(pathArray && pathArray[0], array)) { // rough assumption
pathArray = R.parsePathString(pathArray);
}
var res = [],
x = 0,
y = 0,
mx = 0,
my = 0,
start = 0;
if (pathArray[0][0] == "M") {
x = pathArray[0][1];
y = pathArray[0][2];
mx = x;
my = y;
start++;
res.push(["M", x, y]);
}
for (var i = start, ii = pathArray.length; i < ii; i++) {
var r = res[i] = [],
pa = pathArray[i];
if (pa[0] != lowerCase.call(pa[0])) {
r[0] = lowerCase.call(pa[0]);
switch (r[0]) {
case "a":
r[1] = pa[1];
r[2] = pa[2];
r[3] = pa[3];
r[4] = pa[4];
r[5] = pa[5];
r[6] = +(pa[6] - x).toFixed(3);
r[7] = +(pa[7] - y).toFixed(3);
break;
case "v":
r[1] = +(pa[1] - y).toFixed(3);
break;
case "m":
mx = pa[1];
my = pa[2];
default:
for (var j = 1, jj = pa.length; j < jj; j++) {
r[j] = +(pa[j] - ((j % 2) ? x : y)).toFixed(3);
}
}
} else {
r = res[i] = [];
if (pa[0] == "m") {
mx = pa[1] + x;
my = pa[2] + y;
}
for (var k = 0, kk = pa.length; k < kk; k++) {
res[i][k] = pa[k];
}
}
var len = res[i].length;
switch (res[i][0]) {
case "z":
x = mx;
y = my;
break;
case "h":
x += +res[i][len - 1];
break;
case "v":
y += +res[i][len - 1];
break;
default:
x += +res[i][len - 2];
y += +res[i][len - 1];
}
}
res.toString = R._path2string;
pth.rel = pathClone(res);
return res;
},
pathToAbsolute = R._pathToAbsolute = function (pathArray) {
var pth = paths(pathArray);
if (pth.abs) {
return pathClone(pth.abs);
}
if (!R.is(pathArray, array) || !R.is(pathArray && pathArray[0], array)) { // rough assumption
pathArray = R.parsePathString(pathArray);
}
if (!pathArray || !pathArray.length) {
return [["M", 0, 0]];
}
var res = [],
x = 0,
y = 0,
mx = 0,
my = 0,
start = 0;
if (pathArray[0][0] == "M") {
x = +pathArray[0][1];
y = +pathArray[0][2];
mx = x;
my = y;
start++;
res[0] = ["M", x, y];
}
var crz = pathArray.length == 3 && pathArray[0][0] == "M" && pathArray[1][0].toUpperCase() == "R" && pathArray[2][0].toUpperCase() == "Z";
for (var r, pa, i = start, ii = pathArray.length; i < ii; i++) {
res.push(r = []);
pa = pathArray[i];
if (pa[0] != upperCase.call(pa[0])) {
r[0] = upperCase.call(pa[0]);
switch (r[0]) {
case "A":
r[1] = pa[1];
r[2] = pa[2];
r[3] = pa[3];
r[4] = pa[4];
r[5] = pa[5];
r[6] = +(pa[6] + x);
r[7] = +(pa[7] + y);
break;
case "V":
r[1] = +pa[1] + y;
break;
case "H":
r[1] = +pa[1] + x;
break;
case "R":
var dots = [x, y][concat](pa.slice(1));
for (var j = 2, jj = dots.length; j < jj; j++) {
dots[j] = +dots[j] + x;
dots[++j] = +dots[j] + y;
}
res.pop();
res = res[concat](catmullRom2bezier(dots, crz));
break;
case "M":
mx = +pa[1] + x;
my = +pa[2] + y;
default:
for (j = 1, jj = pa.length; j < jj; j++) {
r[j] = +pa[j] + ((j % 2) ? x : y);
}
}
} else if (pa[0] == "R") {
dots = [x, y][concat](pa.slice(1));
res.pop();
res = res[concat](catmullRom2bezier(dots, crz));
r = ["R"][concat](pa.slice(-2));
} else {
for (var k = 0, kk = pa.length; k < kk; k++) {
r[k] = pa[k];
}
}
switch (r[0]) {
case "Z":
x = mx;
y = my;
break;
case "H":
x = r[1];
break;
case "V":
y = r[1];
break;
case "M":
mx = r[r.length - 2];
my = r[r.length - 1];
default:
x = r[r.length - 2];
y = r[r.length - 1];
}
}
res.toString = R._path2string;
pth.abs = pathClone(res);
return res;
},
l2c = function (x1, y1, x2, y2) {
return [x1, y1, x2, y2, x2, y2];
},
q2c = function (x1, y1, ax, ay, x2, y2) {
var _13 = 1 / 3,
_23 = 2 / 3;
return [
_13 * x1 + _23 * ax,
_13 * y1 + _23 * ay,
_13 * x2 + _23 * ax,
_13 * y2 + _23 * ay,
x2,
y2
];
},
a2c = function (x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
var _120 = PI * 120 / 180,
rad = PI / 180 * (+angle || 0),
res = [],
xy,
rotate = cacher(function (x, y, rad) {
var X = x * math.cos(rad) - y * math.sin(rad),
Y = x * math.sin(rad) + y * math.cos(rad);
return {x: X, y: Y};
});
if (!recursive) {
xy = rotate(x1, y1, -rad);
x1 = xy.x;
y1 = xy.y;
xy = rotate(x2, y2, -rad);
x2 = xy.x;
y2 = xy.y;
var cos = math.cos(PI / 180 * angle),
sin = math.sin(PI / 180 * angle),
x = (x1 - x2) / 2,
y = (y1 - y2) / 2;
var h = (x * x) / (rx * rx) + (y * y) / (ry * ry);
if (h > 1) {
h = math.sqrt(h);
rx = h * rx;
ry = h * ry;
}
var rx2 = rx * rx,
ry2 = ry * ry,
k = (large_arc_flag == sweep_flag ? -1 : 1) *
math.sqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))),
cx = k * rx * y / ry + (x1 + x2) / 2,
cy = k * -ry * x / rx + (y1 + y2) / 2,
f1 = math.asin(((y1 - cy) / ry).toFixed(9)),
f2 = math.asin(((y2 - cy) / ry).toFixed(9));
f1 = x1 < cx ? PI - f1 : f1;
f2 = x2 < cx ? PI - f2 : f2;
f1 < 0 && (f1 = PI * 2 + f1);
f2 < 0 && (f2 = PI * 2 + f2);
if (sweep_flag && f1 > f2) {
f1 = f1 - PI * 2;
}
if (!sweep_flag && f2 > f1) {
f2 = f2 - PI * 2;
}
} else {
f1 = recursive[0];
f2 = recursive[1];
cx = recursive[2];
cy = recursive[3];
}
var df = f2 - f1;
if (abs(df) > _120) {
var f2old = f2,
x2old = x2,
y2old = y2;
f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
x2 = cx + rx * math.cos(f2);
y2 = cy + ry * math.sin(f2);
res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
}
df = f2 - f1;
var c1 = math.cos(f1),
s1 = math.sin(f1),
c2 = math.cos(f2),
s2 = math.sin(f2),
t = math.tan(df / 4),
hx = 4 / 3 * rx * t,
hy = 4 / 3 * ry * t,
m1 = [x1, y1],
m2 = [x1 + hx * s1, y1 - hy * c1],
m3 = [x2 + hx * s2, y2 - hy * c2],
m4 = [x2, y2];
m2[0] = 2 * m1[0] - m2[0];
m2[1] = 2 * m1[1] - m2[1];
if (recursive) {
return [m2, m3, m4][concat](res);
} else {
res = [m2, m3, m4][concat](res).join()[split](",");
var newres = [];
for (var i = 0, ii = res.length; i < ii; i++) {
newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;
}
return newres;
}
},
findDotAtSegment = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
var t1 = 1 - t;
return {
x: pow(t1, 3) * p1x + pow(t1, 2) * 3 * t * c1x + t1 * 3 * t * t * c2x + pow(t, 3) * p2x,
y: pow(t1, 3) * p1y + pow(t1, 2) * 3 * t * c1y + t1 * 3 * t * t * c2y + pow(t, 3) * p2y
};
},
curveDim = cacher(function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
var a = (c2x - 2 * c1x + p1x) - (p2x - 2 * c2x + c1x),
b = 2 * (c1x - p1x) - 2 * (c2x - c1x),
c = p1x - c1x,
t1 = (-b + math.sqrt(b * b - 4 * a * c)) / 2 / a,
t2 = (-b - math.sqrt(b * b - 4 * a * c)) / 2 / a,
y = [p1y, p2y],
x = [p1x, p2x],
dot;
abs(t1) > "1e12" && (t1 = .5);
abs(t2) > "1e12" && (t2 = .5);
if (t1 > 0 && t1 < 1) {
dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t1);
x.push(dot.x);
y.push(dot.y);
}
if (t2 > 0 && t2 < 1) {
dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2);
x.push(dot.x);
y.push(dot.y);
}
a = (c2y - 2 * c1y + p1y) - (p2y - 2 * c2y + c1y);
b = 2 * (c1y - p1y) - 2 * (c2y - c1y);
c = p1y - c1y;
t1 = (-b + math.sqrt(b * b - 4 * a * c)) / 2 / a;
t2 = (-b - math.sqrt(b * b - 4 * a * c)) / 2 / a;
abs(t1) > "1e12" && (t1 = .5);
abs(t2) > "1e12" && (t2 = .5);
if (t1 > 0 && t1 < 1) {
dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t1);
x.push(dot.x);
y.push(dot.y);
}
if (t2 > 0 && t2 < 1) {
dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2);
x.push(dot.x);
y.push(dot.y);
}
return {
min: {x: mmin[apply](0, x), y: mmin[apply](0, y)},
max: {x: mmax[apply](0, x), y: mmax[apply](0, y)}
};
}),
path2curve = R._path2curve = cacher(function (path, path2) {
var pth = !path2 && paths(path);
if (!path2 && pth.curve) {
return pathClone(pth.curve);
}
var p = pathToAbsolute(path),
p2 = path2 && pathToAbsolute(path2),
attrs = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},
attrs2 = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},
processPath = function (path, d, pcom) {
var nx, ny, tq = {T:1, Q:1};
if (!path) {
return ["C", d.x, d.y, d.x, d.y, d.x, d.y];
}
!(path[0] in tq) && (d.qx = d.qy = null);
switch (path[0]) {
case "M":
d.X = path[1];
d.Y = path[2];
break;
case "A":
path = ["C"][concat](a2c[apply](0, [d.x, d.y][concat](path.slice(1))));
break;
case "S":
if (pcom == "C" || pcom == "S") { // In "S" case we have to take into account, if the previous command is C/S.
nx = d.x * 2 - d.bx;          // And reflect the previous
ny = d.y * 2 - d.by;          // command's control point relative to the current point.
}
else {                            // or some else or nothing
nx = d.x;
ny = d.y;
}
path = ["C", nx, ny][concat](path.slice(1));
break;
case "T":
if (pcom == "Q" || pcom == "T") { // In "T" case we have to take into account, if the previous command is Q/T.
d.qx = d.x * 2 - d.qx;        // And make a reflection similar
d.qy = d.y * 2 - d.qy;        // to case "S".
}
else {                            // or something else or nothing
d.qx = d.x;
d.qy = d.y;
}
path = ["C"][concat](q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));
break;
case "Q":
d.qx = path[1];
d.qy = path[2];
path = ["C"][concat](q2c(d.x, d.y, path[1], path[2], path[3], path[4]));
break;
case "L":
path = ["C"][concat](l2c(d.x, d.y, path[1], path[2]));
break;
case "H":
path = ["C"][concat](l2c(d.x, d.y, path[1], d.y));
break;
case "V":
path = ["C"][concat](l2c(d.x, d.y, d.x, path[1]));
break;
case "Z":
path = ["C"][concat](l2c(d.x, d.y, d.X, d.Y));
break;
}
return path;
},
fixArc = function (pp, i) {
if (pp[i].length > 7) {
pp[i].shift();
var pi = pp[i];
while (pi.length) {
pcoms1[i]="A"; // if created multiple C:s, their original seg is saved
p2 && (pcoms2[i]="A"); // the same as above
pp.splice(i++, 0, ["C"][concat](pi.splice(0, 6)));
}
pp.splice(i, 1);
ii = mmax(p.length, p2 && p2.length || 0);
}
},
fixM = function (path1, path2, a1, a2, i) {
if (path1 && path2 && path1[i][0] == "M" && path2[i][0] != "M") {
path2.splice(i, 0, ["M", a2.x, a2.y]);
a1.bx = 0;
a1.by = 0;
a1.x = path1[i][1];
a1.y = path1[i][2];
ii = mmax(p.length, p2 && p2.length || 0);
}
},
pcoms1 = [], // path commands of original path p
pcoms2 = [], // path commands of original path p2
pfirst = "", // temporary holder for original path command
pcom = ""; // holder for previous path command of original path
for (var i = 0, ii = mmax(p.length, p2 && p2.length || 0); i < ii; i++) {
p[i] && (pfirst = p[i][0]); // save current path command
if (pfirst != "C") // C is not saved yet, because it may be result of conversion
{
pcoms1[i] = pfirst; // Save current path command
i && ( pcom = pcoms1[i-1]); // Get previous path command pcom
}
p[i] = processPath(p[i], attrs, pcom); // Previous path command is inputted to processPath
if (pcoms1[i] != "A" && pfirst == "C") pcoms1[i] = "C"; // A is the only command
fixArc(p, i); // fixArc adds also the right amount of A:s to pcoms1
if (p2) { // the same procedures is done to p2
p2[i] && (pfirst = p2[i][0]);
if (pfirst != "C")
{
pcoms2[i] = pfirst;
i && (pcom = pcoms2[i-1]);
}
p2[i] = processPath(p2[i], attrs2, pcom);
if (pcoms2[i]!="A" && pfirst=="C") pcoms2[i]="C";
fixArc(p2, i);
}
fixM(p, p2, attrs, attrs2, i);
fixM(p2, p, attrs2, attrs, i);
var seg = p[i],
seg2 = p2 && p2[i],
seglen = seg.length,
seg2len = p2 && seg2.length;
attrs.x = seg[seglen - 2];
attrs.y = seg[seglen - 1];
attrs.bx = toFloat(seg[seglen - 4]) || attrs.x;
attrs.by = toFloat(seg[seglen - 3]) || attrs.y;
attrs2.bx = p2 && (toFloat(seg2[seg2len - 4]) || attrs2.x);
attrs2.by = p2 && (toFloat(seg2[seg2len - 3]) || attrs2.y);
attrs2.x = p2 && seg2[seg2len - 2];
attrs2.y = p2 && seg2[seg2len - 1];
}
if (!p2) {
pth.curve = pathClone(p);
}
return p2 ? [p, p2] : p;
}, null, pathClone),
parseDots = R._parseDots = cacher(function (gradient) {
var dots = [];
for (var i = 0, ii = gradient.length; i < ii; i++) {
var dot = {},
par = gradient[i].match(/^([^:]*):?([\d\.]*)/);
dot.color = R.getRGB(par[1]);
if (dot.color.error) {
return null;
}
dot.opacity = dot.color.opacity;
dot.color = dot.color.hex;
par[2] && (dot.offset = par[2] + "%");
dots.push(dot);
}
for (i = 1, ii = dots.length - 1; i < ii; i++) {
if (!dots[i].offset) {
var start = toFloat(dots[i - 1].offset || 0),
end = 0;
for (var j = i + 1; j < ii; j++) {
if (dots[j].offset) {
end = dots[j].offset;
break;
}
}
if (!end) {
end = 100;
j = ii;
}
end = toFloat(end);
var d = (end - start) / (j - i + 1);
for (; i < j; i++) {
start += d;
dots[i].offset = start + "%";
}
}
}
return dots;
}),
tear = R._tear = function (el, paper) {
el == paper.top && (paper.top = el.prev);
el == paper.bottom && (paper.bottom = el.next);
el.next && (el.next.prev = el.prev);
el.prev && (el.prev.next = el.next);
},
tofront = R._tofront = function (el, paper) {
if (paper.top === el) {
return;
}
tear(el, paper);
el.next = null;
el.prev = paper.top;
paper.top.next = el;
paper.top = el;
},
toback = R._toback = function (el, paper) {
if (paper.bottom === el) {
return;
}
tear(el, paper);
el.next = paper.bottom;
el.prev = null;
paper.bottom.prev = el;
paper.bottom = el;
},
insertafter = R._insertafter = function (el, el2, paper) {
tear(el, paper);
el2 == paper.top && (paper.top = el);
el2.next && (el2.next.prev = el);
el.next = el2.next;
el.prev = el2;
el2.next = el;
},
insertbefore = R._insertbefore = function (el, el2, paper) {
tear(el, paper);
el2 == paper.bottom && (paper.bottom = el);
el2.prev && (el2.prev.next = el);
el.prev = el2.prev;
el2.prev = el;
el.next = el2;
},
toMatrix = R.toMatrix = function (path, transform) {
var bb = pathDimensions(path),
el = {
_: {
transform: E
},
getBBox: function () {
return bb;
}
};
extractTransform(el, transform);
return el.matrix;
},
transformPath = R.transformPath = function (path, transform) {
return mapPath(path, toMatrix(path, transform));
},
extractTransform = R._extractTransform = function (el, tstr) {
if (tstr == null) {
return el._.transform;
}
tstr = Str(tstr).replace(/\.{3}|\u2026/g, el._.transform || E);
var tdata = R.parseTransformString(tstr),
deg = 0,
dx = 0,
dy = 0,
sx = 1,
sy = 1,
_ = el._,
m = new Matrix;
_.transform = tdata || [];
if (tdata) {
for (var i = 0, ii = tdata.length; i < ii; i++) {
var t = tdata[i],
tlen = t.length,
command = Str(t[0]).toLowerCase(),
absolute = t[0] != command,
inver = absolute ? m.invert() : 0,
x1,
y1,
x2,
y2,
bb;
if (command == "t" && tlen == 3) {
if (absolute) {
x1 = inver.x(0, 0);
y1 = inver.y(0, 0);
x2 = inver.x(t[1], t[2]);
y2 = inver.y(t[1], t[2]);
m.translate(x2 - x1, y2 - y1);
} else {
m.translate(t[1], t[2]);
}
} else if (command == "r") {
if (tlen == 2) {
bb = bb || el.getBBox(1);
m.rotate(t[1], bb.x + bb.width / 2, bb.y + bb.height / 2);
deg += t[1];
} else if (tlen == 4) {
if (absolute) {
x2 = inver.x(t[2], t[3]);
y2 = inver.y(t[2], t[3]);
m.rotate(t[1], x2, y2);
} else {
m.rotate(t[1], t[2], t[3]);
}
deg += t[1];
}
} else if (command == "s") {
if (tlen == 2 || tlen == 3) {
bb = bb || el.getBBox(1);
m.scale(t[1], t[tlen - 1], bb.x + bb.width / 2, bb.y + bb.height / 2);
sx *= t[1];
sy *= t[tlen - 1];
} else if (tlen == 5) {
if (absolute) {
x2 = inver.x(t[3], t[4]);
y2 = inver.y(t[3], t[4]);
m.scale(t[1], t[2], x2, y2);
} else {
m.scale(t[1], t[2], t[3], t[4]);
}
sx *= t[1];
sy *= t[2];
}
} else if (command == "m" && tlen == 7) {
m.add(t[1], t[2], t[3], t[4], t[5], t[6]);
}
_.dirtyT = 1;
el.matrix = m;
}
}
el.matrix = m;
_.sx = sx;
_.sy = sy;
_.deg = deg;
_.dx = dx = m.e;
_.dy = dy = m.f;
if (sx == 1 && sy == 1 && !deg && _.bbox) {
_.bbox.x += +dx;
_.bbox.y += +dy;
} else {
_.dirtyT = 1;
}
},
getEmpty = function (item) {
var l = item[0];
switch (l.toLowerCase()) {
case "t": return [l, 0, 0];
case "m": return [l, 1, 0, 0, 1, 0, 0];
case "r": if (item.length == 4) {
return [l, 0, item[2], item[3]];
} else {
return [l, 0];
}
case "s": if (item.length == 5) {
return [l, 1, 1, item[3], item[4]];
} else if (item.length == 3) {
return [l, 1, 1];
} else {
return [l, 1];
}
}
},
equaliseTransform = R._equaliseTransform = function (t1, t2) {
t2 = Str(t2).replace(/\.{3}|\u2026/g, t1);
t1 = R.parseTransformString(t1) || [];
t2 = R.parseTransformString(t2) || [];
var maxlength = mmax(t1.length, t2.length),
from = [],
to = [],
i = 0, j, jj,
tt1, tt2;
for (; i < maxlength; i++) {
tt1 = t1[i] || getEmpty(t2[i]);
tt2 = t2[i] || getEmpty(tt1);
if ((tt1[0] != tt2[0]) ||
(tt1[0].toLowerCase() == "r" && (tt1[2] != tt2[2] || tt1[3] != tt2[3])) ||
(tt1[0].toLowerCase() == "s" && (tt1[3] != tt2[3] || tt1[4] != tt2[4]))
) {
return;
}
from[i] = [];
to[i] = [];
for (j = 0, jj = mmax(tt1.length, tt2.length); j < jj; j++) {
j in tt1 && (from[i][j] = tt1[j]);
j in tt2 && (to[i][j] = tt2[j]);
}
}
return {
from: from,
to: to
};
};
R._getContainer = function (x, y, w, h) {
var container;
container = h == null && !R.is(x, "object") ? g.doc.getElementById(x) : x;
if (container == null) {
return;
}
if (container.tagName) {
if (y == null) {
return {
container: container,
width: container.style.pixelWidth || container.offsetWidth,
height: container.style.pixelHeight || container.offsetHeight
};
} else {
return {
container: container,
width: y,
height: w
};
}
}
return {
container: 1,
x: x,
y: y,
width: w,
height: h
};
};
R.pathToRelative = pathToRelative;
R._engine = {};
R.path2curve = path2curve;
R.matrix = function (a, b, c, d, e, f) {
return new Matrix(a, b, c, d, e, f);
};
function Matrix(a, b, c, d, e, f) {
if (a != null) {
this.a = +a;
this.b = +b;
this.c = +c;
this.d = +d;
this.e = +e;
this.f = +f;
} else {
this.a = 1;
this.b = 0;
this.c = 0;
this.d = 1;
this.e = 0;
this.f = 0;
}
}
(function (matrixproto) {
matrixproto.add = function (a, b, c, d, e, f) {
var out = [[], [], []],
m = [[this.a, this.c, this.e], [this.b, this.d, this.f], [0, 0, 1]],
matrix = [[a, c, e], [b, d, f], [0, 0, 1]],
x, y, z, res;
if (a && a instanceof Matrix) {
matrix = [[a.a, a.c, a.e], [a.b, a.d, a.f], [0, 0, 1]];
}
for (x = 0; x < 3; x++) {
for (y = 0; y < 3; y++) {
res = 0;
for (z = 0; z < 3; z++) {
res += m[x][z] * matrix[z][y];
}
out[x][y] = res;
}
}
this.a = out[0][0];
this.b = out[1][0];
this.c = out[0][1];
this.d = out[1][1];
this.e = out[0][2];
this.f = out[1][2];
};
matrixproto.invert = function () {
var me = this,
x = me.a * me.d - me.b * me.c;
return new Matrix(me.d / x, -me.b / x, -me.c / x, me.a / x, (me.c * me.f - me.d * me.e) / x, (me.b * me.e - me.a * me.f) / x);
};
matrixproto.clone = function () {
return new Matrix(this.a, this.b, this.c, this.d, this.e, this.f);
};
matrixproto.translate = function (x, y) {
this.add(1, 0, 0, 1, x, y);
};
matrixproto.scale = function (x, y, cx, cy) {
y == null && (y = x);
(cx || cy) && this.add(1, 0, 0, 1, cx, cy);
this.add(x, 0, 0, y, 0, 0);
(cx || cy) && this.add(1, 0, 0, 1, -cx, -cy);
};
matrixproto.rotate = function (a, x, y) {
a = R.rad(a);
x = x || 0;
y = y || 0;
var cos = +math.cos(a).toFixed(9),
sin = +math.sin(a).toFixed(9);
this.add(cos, sin, -sin, cos, x, y);
this.add(1, 0, 0, 1, -x, -y);
};
matrixproto.x = function (x, y) {
return x * this.a + y * this.c + this.e;
};
matrixproto.y = function (x, y) {
return x * this.b + y * this.d + this.f;
};
matrixproto.get = function (i) {
return +this[Str.fromCharCode(97 + i)].toFixed(4);
};
matrixproto.toString = function () {
return R.svg ?
"matrix(" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)].join() + ")" :
[this.get(0), this.get(2), this.get(1), this.get(3), 0, 0].join();
};
matrixproto.toFilter = function () {
return "progid:DXImageTransform.Microsoft.Matrix(M11=" + this.get(0) +
", M12=" + this.get(2) + ", M21=" + this.get(1) + ", M22=" + this.get(3) +
", Dx=" + this.get(4) + ", Dy=" + this.get(5) + ", sizingmethod='auto expand')";
};
matrixproto.offset = function () {
return [this.e.toFixed(4), this.f.toFixed(4)];
};
function norm(a) {
return a[0] * a[0] + a[1] * a[1];
}
function normalize(a) {
var mag = math.sqrt(norm(a));
a[0] && (a[0] /= mag);
a[1] && (a[1] /= mag);
}
matrixproto.split = function () {
var out = {};
out.dx = this.e;
out.dy = this.f;
var row = [[this.a, this.c], [this.b, this.d]];
out.scalex = math.sqrt(norm(row[0]));
normalize(row[0]);
out.shear = row[0][0] * row[1][0] + row[0][1] * row[1][1];
row[1] = [row[1][0] - row[0][0] * out.shear, row[1][1] - row[0][1] * out.shear];
out.scaley = math.sqrt(norm(row[1]));
normalize(row[1]);
out.shear /= out.scaley;
var sin = -row[0][1],
cos = row[1][1];
if (cos < 0) {
out.rotate = R.deg(math.acos(cos));
if (sin < 0) {
out.rotate = 360 - out.rotate;
}
} else {
out.rotate = R.deg(math.asin(sin));
}
out.isSimple = !+out.shear.toFixed(9) && (out.scalex.toFixed(9) == out.scaley.toFixed(9) || !out.rotate);
out.isSuperSimple = !+out.shear.toFixed(9) && out.scalex.toFixed(9) == out.scaley.toFixed(9) && !out.rotate;
out.noRotation = !+out.shear.toFixed(9) && !out.rotate;
return out;
};
matrixproto.toTransformString = function (shorter) {
var s = shorter || this[split]();
if (s.isSimple) {
s.scalex = +s.scalex.toFixed(4);
s.scaley = +s.scaley.toFixed(4);
s.rotate = +s.rotate.toFixed(4);
return  (s.dx || s.dy ? "t" + [s.dx, s.dy] : E) +
(s.scalex != 1 || s.scaley != 1 ? "s" + [s.scalex, s.scaley, 0, 0] : E) +
(s.rotate ? "r" + [s.rotate, 0, 0] : E);
} else {
return "m" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)];
}
};
})(Matrix.prototype);
var preventDefault = function () {
this.returnValue = false;
},
preventTouch = function () {
return this.originalEvent.preventDefault();
},
stopPropagation = function () {
this.cancelBubble = true;
},
stopTouch = function () {
return this.originalEvent.stopPropagation();
},
getEventPosition = function (e) {
var scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,
scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft;
return {
x: e.clientX + scrollX,
y: e.clientY + scrollY
};
},
addEvent = (function () {
if (g.doc.addEventListener) {
return function (obj, type, fn, element) {
var f = function (e) {
var pos = getEventPosition(e);
return fn.call(element, e, pos.x, pos.y);
};
obj.addEventListener(type, f, false);
if (supportsTouch && touchMap[type]) {
var _f = function (e) {
var pos = getEventPosition(e),
olde = e;
for (var i = 0, ii = e.targetTouches && e.targetTouches.length; i < ii; i++) {
if (e.targetTouches[i].target == obj) {
e = e.targetTouches[i];
e.originalEvent = olde;
e.preventDefault = preventTouch;
e.stopPropagation = stopTouch;
break;
}
}
return fn.call(element, e, pos.x, pos.y);
};
obj.addEventListener(touchMap[type], _f, false);
}
return function () {
obj.removeEventListener(type, f, false);
if (supportsTouch && touchMap[type])
obj.removeEventListener(touchMap[type], _f, false);
return true;
};
};
} else if (g.doc.attachEvent) {
return function (obj, type, fn, element) {
var f = function (e) {
e = e || g.win.event;
var scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,
scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft,
x = e.clientX + scrollX,
y = e.clientY + scrollY;
e.preventDefault = e.preventDefault || preventDefault;
e.stopPropagation = e.stopPropagation || stopPropagation;
return fn.call(element, e, x, y);
};
obj.attachEvent("on" + type, f);
var detacher = function () {
obj.detachEvent("on" + type, f);
return true;
};
return detacher;
};
}
})(),
drag = [],
dragMove = function (e) {
var x = e.clientX,
y = e.clientY,
scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,
scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft,
dragi,
j = drag.length;
while (j--) {
dragi = drag[j];
if (supportsTouch && e.touches) {
var i = e.touches.length,
touch;
while (i--) {
touch = e.touches[i];
if (touch.identifier == dragi.el._drag.id) {
x = touch.clientX;
y = touch.clientY;
(e.originalEvent ? e.originalEvent : e).preventDefault();
break;
}
}
} else {
e.preventDefault();
}
var node = dragi.el.node,
o,
next = node.nextSibling,
parent = node.parentNode,
display = node.style.display;
g.win.opera && parent.removeChild(node);
node.style.display = "none";
o = dragi.el.paper.getElementByPoint(x, y);
node.style.display = display;
g.win.opera && (next ? parent.insertBefore(node, next) : parent.appendChild(node));
o && eve("raphael.drag.over." + dragi.el.id, dragi.el, o);
x += scrollX;
y += scrollY;
eve("raphael.drag.move." + dragi.el.id, dragi.move_scope || dragi.el, x - dragi.el._drag.x, y - dragi.el._drag.y, x, y, e);
}
},
dragUp = function (e) {
R.unmousemove(dragMove).unmouseup(dragUp);
var i = drag.length,
dragi;
while (i--) {
dragi = drag[i];
dragi.el._drag = {};
eve("raphael.drag.end." + dragi.el.id, dragi.end_scope || dragi.start_scope || dragi.move_scope || dragi.el, e);
}
drag = [];
},
elproto = R.el = {};
for (var i = events.length; i--;) {
(function (eventName) {
R[eventName] = elproto[eventName] = function (fn, scope) {
if (R.is(fn, "function")) {
this.events = this.events || [];
this.events.push({name: eventName, f: fn, unbind: addEvent(this.shape || this.node || g.doc, eventName, fn, scope || this)});
}
return this;
};
R["un" + eventName] = elproto["un" + eventName] = function (fn) {
var events = this.events || [],
l = events.length;
while (l--){
if (events[l].name == eventName && (R.is(fn, "undefined") || events[l].f == fn)) {
events[l].unbind();
events.splice(l, 1);
!events.length && delete this.events;
}
}
return this;
};
})(events[i]);
}
elproto.data = function (key, value) {
var data = eldata[this.id] = eldata[this.id] || {};
if (arguments.length == 0) {
return data;
}
if (arguments.length == 1) {
if (R.is(key, "object")) {
for (var i in key) if (key[has](i)) {
this.data(i, key[i]);
}
return this;
}
eve("raphael.data.get." + this.id, this, data[key], key);
return data[key];
}
data[key] = value;
eve("raphael.data.set." + this.id, this, value, key);
return this;
};
elproto.removeData = function (key) {
if (key == null) {
eldata[this.id] = {};
} else {
eldata[this.id] && delete eldata[this.id][key];
}
return this;
};
elproto.getData = function () {
return clone(eldata[this.id] || {});
};
elproto.hover = function (f_in, f_out, scope_in, scope_out) {
return this.mouseover(f_in, scope_in).mouseout(f_out, scope_out || scope_in);
};
elproto.unhover = function (f_in, f_out) {
return this.unmouseover(f_in).unmouseout(f_out);
};
var draggable = [];
elproto.drag = function (onmove, onstart, onend, move_scope, start_scope, end_scope) {
function start(e) {
(e.originalEvent || e).preventDefault();
var x = e.clientX,
y = e.clientY,
scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,
scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft;
this._drag.id = e.identifier;
if (supportsTouch && e.touches) {
var i = e.touches.length, touch;
while (i--) {
touch = e.touches[i];
this._drag.id = touch.identifier;
if (touch.identifier == this._drag.id) {
x = touch.clientX;
y = touch.clientY;
break;
}
}
}
this._drag.x = x + scrollX;
this._drag.y = y + scrollY;
!drag.length && R.mousemove(dragMove).mouseup(dragUp);
drag.push({el: this, move_scope: move_scope, start_scope: start_scope, end_scope: end_scope});
onstart && eve.on("raphael.drag.start." + this.id, onstart);
onmove && eve.on("raphael.drag.move." + this.id, onmove);
onend && eve.on("raphael.drag.end." + this.id, onend);
eve("raphael.drag.start." + this.id, start_scope || move_scope || this, e.clientX + scrollX, e.clientY + scrollY, e);
}
this._drag = {};
draggable.push({el: this, start: start});
this.mousedown(start);
return this;
};
elproto.onDragOver = function (f) {
f ? eve.on("raphael.drag.over." + this.id, f) : eve.unbind("raphael.drag.over." + this.id);
};
elproto.undrag = function () {
var i = draggable.length;
while (i--) if (draggable[i].el == this) {
this.unmousedown(draggable[i].start);
draggable.splice(i, 1);
eve.unbind("raphael.drag.*." + this.id);
}
!draggable.length && R.unmousemove(dragMove).unmouseup(dragUp);
drag = [];
};
paperproto.circle = function (x, y, r) {
var out = R._engine.circle(this, x || 0, y || 0, r || 0);
this.__set__ && this.__set__.push(out);
return out;
};
paperproto.rect = function (x, y, w, h, r) {
var out = R._engine.rect(this, x || 0, y || 0, w || 0, h || 0, r || 0);
this.__set__ && this.__set__.push(out);
return out;
};
paperproto.ellipse = function (x, y, rx, ry) {
var out = R._engine.ellipse(this, x || 0, y || 0, rx || 0, ry || 0);
this.__set__ && this.__set__.push(out);
return out;
};
paperproto.path = function (pathString) {
pathString && !R.is(pathString, string) && !R.is(pathString[0], array) && (pathString += E);
var out = R._engine.path(R.format[apply](R, arguments), this);
this.__set__ && this.__set__.push(out);
return out;
};
paperproto.image = function (src, x, y, w, h) {
var out = R._engine.image(this, src || "about:blank", x || 0, y || 0, w || 0, h || 0);
this.__set__ && this.__set__.push(out);
return out;
};
paperproto.text = function (x, y, text) {
var out = R._engine.text(this, x || 0, y || 0, Str(text));
this.__set__ && this.__set__.push(out);
return out;
};
paperproto.set = function (itemsArray) {
!R.is(itemsArray, "array") && (itemsArray = Array.prototype.splice.call(arguments, 0, arguments.length));
var out = new Set(itemsArray);
this.__set__ && this.__set__.push(out);
out["paper"] = this;
out["type"] = "set";
return out;
};
paperproto.setStart = function (set) {
this.__set__ = set || this.set();
};
paperproto.setFinish = function (set) {
var out = this.__set__;
delete this.__set__;
return out;
};
paperproto.getSize = function () {
var container = this.canvas.parentNode;
return {
width: container.offsetWidth,
height: container.offsetHeight
};
};
paperproto.setSize = function (width, height) {
return R._engine.setSize.call(this, width, height);
};
paperproto.setViewBox = function (x, y, w, h, fit) {
return R._engine.setViewBox.call(this, x, y, w, h, fit);
};
paperproto.top = paperproto.bottom = null;
paperproto.raphael = R;
var getOffset = function (elem) {
var box = elem.getBoundingClientRect(),
doc = elem.ownerDocument,
body = doc.body,
docElem = doc.documentElement,
clientTop = docElem.clientTop || body.clientTop || 0, clientLeft = docElem.clientLeft || body.clientLeft || 0,
top  = box.top  + (g.win.pageYOffset || docElem.scrollTop || body.scrollTop ) - clientTop,
left = box.left + (g.win.pageXOffset || docElem.scrollLeft || body.scrollLeft) - clientLeft;
return {
y: top,
x: left
};
};
paperproto.getElementByPoint = function (x, y) {
var paper = this,
svg = paper.canvas,
target = g.doc.elementFromPoint(x, y);
if (g.win.opera && target.tagName == "svg") {
var so = getOffset(svg),
sr = svg.createSVGRect();
sr.x = x - so.x;
sr.y = y - so.y;
sr.width = sr.height = 1;
var hits = svg.getIntersectionList(sr, null);
if (hits.length) {
target = hits[hits.length - 1];
}
}
if (!target) {
return null;
}
while (target.parentNode && target != svg.parentNode && !target.raphael) {
target = target.parentNode;
}
target == paper.canvas.parentNode && (target = svg);
target = target && target.raphael ? paper.getById(target.raphaelid) : null;
return target;
};
paperproto.getElementsByBBox = function (bbox) {
var set = this.set();
this.forEach(function (el) {
if (R.isBBoxIntersect(el.getBBox(), bbox)) {
set.push(el);
}
});
return set;
};
paperproto.getById = function (id) {
var bot = this.bottom;
while (bot) {
if (bot.id == id) {
return bot;
}
bot = bot.next;
}
return null;
};
paperproto.forEach = function (callback, thisArg) {
var bot = this.bottom;
while (bot) {
if (callback.call(thisArg, bot) === false) {
return this;
}
bot = bot.next;
}
return this;
};
paperproto.getElementsByPoint = function (x, y) {
var set = this.set();
this.forEach(function (el) {
if (el.isPointInside(x, y)) {
set.push(el);
}
});
return set;
};
function x_y() {
return this.x + S + this.y;
}
function x_y_w_h() {
return this.x + S + this.y + S + this.width + " \xd7 " + this.height;
}
elproto.isPointInside = function (x, y) {
var rp = this.realPath = getPath[this.type](this);
if (this.attr('transform') && this.attr('transform').length) {
rp = R.transformPath(rp, this.attr('transform'));
}
return R.isPointInsidePath(rp, x, y);
};
elproto.getBBox = function (isWithoutTransform) {
if (this.removed) {
return {};
}
var _ = this._;
if (isWithoutTransform) {
if (_.dirty || !_.bboxwt) {
this.realPath = getPath[this.type](this);
_.bboxwt = pathDimensions(this.realPath);
_.bboxwt.toString = x_y_w_h;
_.dirty = 0;
}
return _.bboxwt;
}
if (_.dirty || _.dirtyT || !_.bbox) {
if (_.dirty || !this.realPath) {
_.bboxwt = 0;
this.realPath = getPath[this.type](this);
}
_.bbox = pathDimensions(mapPath(this.realPath, this.matrix));
_.bbox.toString = x_y_w_h;
_.dirty = _.dirtyT = 0;
}
return _.bbox;
};
elproto.clone = function () {
if (this.removed) {
return null;
}
var out = this.paper[this.type]().attr(this.attr());
this.__set__ && this.__set__.push(out);
return out;
};
elproto.glow = function (glow) {
if (this.type == "text") {
return null;
}
glow = glow || {};
var s = {
width: (glow.width || 10) + (+this.attr("stroke-width") || 1),
fill: glow.fill || false,
opacity: glow.opacity == null ? .5 : glow.opacity,
offsetx: glow.offsetx || 0,
offsety: glow.offsety || 0,
color: glow.color || "#000"
},
c = s.width / 2,
r = this.paper,
out = r.set(),
path = this.realPath || getPath[this.type](this);
path = this.matrix ? mapPath(path, this.matrix) : path;
for (var i = 1; i < c + 1; i++) {
out.push(r.path(path).attr({
stroke: s.color,
fill: s.fill ? s.color : "none",
"stroke-linejoin": "round",
"stroke-linecap": "round",
"stroke-width": +(s.width / c * i).toFixed(3),
opacity: +(s.opacity / c).toFixed(3)
}));
}
return out.insertBefore(this).translate(s.offsetx, s.offsety);
};
var curveslengths = {},
getPointAtSegmentLength = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length) {
if (length == null) {
return bezlen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y);
} else {
return R.findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, getTatLen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length));
}
},
getLengthFactory = function (istotal, subpath) {
return function (path, length, onlystart) {
path = path2curve(path);
var x, y, p, l, sp = "", subpaths = {}, point,
len = 0;
for (var i = 0, ii = path.length; i < ii; i++) {
p = path[i];
if (p[0] == "M") {
x = +p[1];
y = +p[2];
} else {
l = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
if (len + l > length) {
if (subpath && !subpaths.start) {
point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
sp += ["C" + point.start.x, point.start.y, point.m.x, point.m.y, point.x, point.y];
if (onlystart) {return sp;}
subpaths.start = sp;
sp = ["M" + point.x, point.y + "C" + point.n.x, point.n.y, point.end.x, point.end.y, p[5], p[6]].join();
len += l;
x = +p[5];
y = +p[6];
continue;
}
if (!istotal && !subpath) {
point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
return {x: point.x, y: point.y, alpha: point.alpha};
}
}
len += l;
x = +p[5];
y = +p[6];
}
sp += p.shift() + p;
}
subpaths.end = sp;
point = istotal ? len : subpath ? subpaths : R.findDotsAtSegment(x, y, p[0], p[1], p[2], p[3], p[4], p[5], 1);
point.alpha && (point = {x: point.x, y: point.y, alpha: point.alpha});
return point;
};
};
var getTotalLength = getLengthFactory(1),
getPointAtLength = getLengthFactory(),
getSubpathsAtLength = getLengthFactory(0, 1);
R.getTotalLength = getTotalLength;
R.getPointAtLength = getPointAtLength;
R.getSubpath = function (path, from, to) {
if (this.getTotalLength(path) - to < 1e-6) {
return getSubpathsAtLength(path, from).end;
}
var a = getSubpathsAtLength(path, to, 1);
return from ? getSubpathsAtLength(a, from).end : a;
};
elproto.getTotalLength = function () {
var path = this.getPath();
if (!path) {
return;
}
if (this.node.getTotalLength) {
return this.node.getTotalLength();
}
return getTotalLength(path);
};
elproto.getPointAtLength = function (length) {
var path = this.getPath();
if (!path) {
return;
}
return getPointAtLength(path, length);
};
elproto.getPath = function () {
var path,
getPath = R._getPath[this.type];
if (this.type == "text" || this.type == "set") {
return;
}
if (getPath) {
path = getPath(this);
}
return path;
};
elproto.getSubpath = function (from, to) {
var path = this.getPath();
if (!path) {
return;
}
return R.getSubpath(path, from, to);
};
var ef = R.easing_formulas = {
linear: function (n) {
return n;
},
"<": function (n) {
return pow(n, 1.7);
},
">": function (n) {
return pow(n, .48);
},
"<>": function (n) {
var q = .48 - n / 1.04,
Q = math.sqrt(.1734 + q * q),
x = Q - q,
X = pow(abs(x), 1 / 3) * (x < 0 ? -1 : 1),
y = -Q - q,
Y = pow(abs(y), 1 / 3) * (y < 0 ? -1 : 1),
t = X + Y + .5;
return (1 - t) * 3 * t * t + t * t * t;
},
backIn: function (n) {
var s = 1.70158;
return n * n * ((s + 1) * n - s);
},
backOut: function (n) {
n = n - 1;
var s = 1.70158;
return n * n * ((s + 1) * n + s) + 1;
},
elastic: function (n) {
if (n == !!n) {
return n;
}
return pow(2, -10 * n) * math.sin((n - .075) * (2 * PI) / .3) + 1;
},
bounce: function (n) {
var s = 7.5625,
p = 2.75,
l;
if (n < (1 / p)) {
l = s * n * n;
} else {
if (n < (2 / p)) {
n -= (1.5 / p);
l = s * n * n + .75;
} else {
if (n < (2.5 / p)) {
n -= (2.25 / p);
l = s * n * n + .9375;
} else {
n -= (2.625 / p);
l = s * n * n + .984375;
}
}
}
return l;
}
};
ef.easeIn = ef["ease-in"] = ef["<"];
ef.easeOut = ef["ease-out"] = ef[">"];
ef.easeInOut = ef["ease-in-out"] = ef["<>"];
ef["back-in"] = ef.backIn;
ef["back-out"] = ef.backOut;
var animationElements = [],
requestAnimFrame = window.requestAnimationFrame       ||
window.webkitRequestAnimationFrame ||
window.mozRequestAnimationFrame    ||
window.oRequestAnimationFrame      ||
window.msRequestAnimationFrame     ||
function (callback) {
setTimeout(callback, 16);
},
animation = function () {
var Now = +new Date,
l = 0;
for (; l < animationElements.length; l++) {
var e = animationElements[l];
if (e.el.removed || e.paused) {
continue;
}
var time = Now - e.start,
ms = e.ms,
easing = e.easing,
from = e.from,
diff = e.diff,
to = e.to,
t = e.t,
that = e.el,
set = {},
now,
init = {},
key;
if (e.initstatus) {
time = (e.initstatus * e.anim.top - e.prev) / (e.percent - e.prev) * ms;
e.status = e.initstatus;
delete e.initstatus;
e.stop && animationElements.splice(l--, 1);
} else {
e.status = (e.prev + (e.percent - e.prev) * (time / ms)) / e.anim.top;
}
if (time < 0) {
continue;
}
if (time < ms) {
var pos = easing(time / ms);
for (var attr in from) if (from[has](attr)) {
switch (availableAnimAttrs[attr]) {
case nu:
now = +from[attr] + pos * ms * diff[attr];
break;
case "colour":
now = "rgb(" + [
upto255(round(from[attr].r + pos * ms * diff[attr].r)),
upto255(round(from[attr].g + pos * ms * diff[attr].g)),
upto255(round(from[attr].b + pos * ms * diff[attr].b))
].join(",") + ")";
break;
case "path":
now = [];
for (var i = 0, ii = from[attr].length; i < ii; i++) {
now[i] = [from[attr][i][0]];
for (var j = 1, jj = from[attr][i].length; j < jj; j++) {
now[i][j] = +from[attr][i][j] + pos * ms * diff[attr][i][j];
}
now[i] = now[i].join(S);
}
now = now.join(S);
break;
case "transform":
if (diff[attr].real) {
now = [];
for (i = 0, ii = from[attr].length; i < ii; i++) {
now[i] = [from[attr][i][0]];
for (j = 1, jj = from[attr][i].length; j < jj; j++) {
now[i][j] = from[attr][i][j] + pos * ms * diff[attr][i][j];
}
}
} else {
var get = function (i) {
return +from[attr][i] + pos * ms * diff[attr][i];
};
now = [["m", get(0), get(1), get(2), get(3), get(4), get(5)]];
}
break;
case "csv":
if (attr == "clip-rect") {
now = [];
i = 4;
while (i--) {
now[i] = +from[attr][i] + pos * ms * diff[attr][i];
}
}
break;
default:
var from2 = [][concat](from[attr]);
now = [];
i = that.paper.customAttributes[attr].length;
while (i--) {
now[i] = +from2[i] + pos * ms * diff[attr][i];
}
break;
}
set[attr] = now;
}
that.attr(set);
(function (id, that, anim) {
setTimeout(function () {
eve("raphael.anim.frame." + id, that, anim);
});
})(that.id, that, e.anim);
} else {
(function(f, el, a) {
setTimeout(function() {
eve("raphael.anim.frame." + el.id, el, a);
eve("raphael.anim.finish." + el.id, el, a);
R.is(f, "function") && f.call(el);
});
})(e.callback, that, e.anim);
that.attr(to);
animationElements.splice(l--, 1);
if (e.repeat > 1 && !e.next) {
for (key in to) if (to[has](key)) {
init[key] = e.totalOrigin[key];
}
e.el.attr(init);
runAnimation(e.anim, e.el, e.anim.percents[0], null, e.totalOrigin, e.repeat - 1);
}
if (e.next && !e.stop) {
runAnimation(e.anim, e.el, e.next, null, e.totalOrigin, e.repeat);
}
}
}
animationElements.length && requestAnimFrame(animation);
},
upto255 = function (color) {
return color > 255 ? 255 : color < 0 ? 0 : color;
};
elproto.animateWith = function (el, anim, params, ms, easing, callback) {
var element = this;
if (element.removed) {
callback && callback.call(element);
return element;
}
var a = params instanceof Animation ? params : R.animation(params, ms, easing, callback),
x, y;
runAnimation(a, element, a.percents[0], null, element.attr());
for (var i = 0, ii = animationElements.length; i < ii; i++) {
if (animationElements[i].anim == anim && animationElements[i].el == el) {
animationElements[ii - 1].start = animationElements[i].start;
break;
}
}
return element;
};
function CubicBezierAtTime(t, p1x, p1y, p2x, p2y, duration) {
var cx = 3 * p1x,
bx = 3 * (p2x - p1x) - cx,
ax = 1 - cx - bx,
cy = 3 * p1y,
by = 3 * (p2y - p1y) - cy,
ay = 1 - cy - by;
function sampleCurveX(t) {
return ((ax * t + bx) * t + cx) * t;
}
function solve(x, epsilon) {
var t = solveCurveX(x, epsilon);
return ((ay * t + by) * t + cy) * t;
}
function solveCurveX(x, epsilon) {
var t0, t1, t2, x2, d2, i;
for(t2 = x, i = 0; i < 8; i++) {
x2 = sampleCurveX(t2) - x;
if (abs(x2) < epsilon) {
return t2;
}
d2 = (3 * ax * t2 + 2 * bx) * t2 + cx;
if (abs(d2) < 1e-6) {
break;
}
t2 = t2 - x2 / d2;
}
t0 = 0;
t1 = 1;
t2 = x;
if (t2 < t0) {
return t0;
}
if (t2 > t1) {
return t1;
}
while (t0 < t1) {
x2 = sampleCurveX(t2);
if (abs(x2 - x) < epsilon) {
return t2;
}
if (x > x2) {
t0 = t2;
} else {
t1 = t2;
}
t2 = (t1 - t0) / 2 + t0;
}
return t2;
}
return solve(t, 1 / (200 * duration));
}
elproto.onAnimation = function (f) {
f ? eve.on("raphael.anim.frame." + this.id, f) : eve.unbind("raphael.anim.frame." + this.id);
return this;
};
function Animation(anim, ms) {
var percents = [],
newAnim = {};
this.ms = ms;
this.times = 1;
if (anim) {
for (var attr in anim) if (anim[has](attr)) {
newAnim[toFloat(attr)] = anim[attr];
percents.push(toFloat(attr));
}
percents.sort(sortByNumber);
}
this.anim = newAnim;
this.top = percents[percents.length - 1];
this.percents = percents;
}
Animation.prototype.delay = function (delay) {
var a = new Animation(this.anim, this.ms);
a.times = this.times;
a.del = +delay || 0;
return a;
};
Animation.prototype.repeat = function (times) {
var a = new Animation(this.anim, this.ms);
a.del = this.del;
a.times = math.floor(mmax(times, 0)) || 1;
return a;
};
function runAnimation(anim, element, percent, status, totalOrigin, times) {
percent = toFloat(percent);
var params,
isInAnim,
isInAnimSet,
percents = [],
next,
prev,
timestamp,
ms = anim.ms,
from = {},
to = {},
diff = {};
if (status) {
for (i = 0, ii = animationElements.length; i < ii; i++) {
var e = animationElements[i];
if (e.el.id == element.id && e.anim == anim) {
if (e.percent != percent) {
animationElements.splice(i, 1);
isInAnimSet = 1;
} else {
isInAnim = e;
}
element.attr(e.totalOrigin);
break;
}
}
} else {
status = +to; // NaN
}
for (var i = 0, ii = anim.percents.length; i < ii; i++) {
if (anim.percents[i] == percent || anim.percents[i] > status * anim.top) {
percent = anim.percents[i];
prev = anim.percents[i - 1] || 0;
ms = ms / anim.top * (percent - prev);
next = anim.percents[i + 1];
params = anim.anim[percent];
break;
} else if (status) {
element.attr(anim.anim[anim.percents[i]]);
}
}
if (!params) {
return;
}
if (!isInAnim) {
for (var attr in params) if (params[has](attr)) {
if (availableAnimAttrs[has](attr) || element.paper.customAttributes[has](attr)) {
from[attr] = element.attr(attr);
(from[attr] == null) && (from[attr] = availableAttrs[attr]);
to[attr] = params[attr];
switch (availableAnimAttrs[attr]) {
case nu:
diff[attr] = (to[attr] - from[attr]) / ms;
break;
case "colour":
from[attr] = R.getRGB(from[attr]);
var toColour = R.getRGB(to[attr]);
diff[attr] = {
r: (toColour.r - from[attr].r) / ms,
g: (toColour.g - from[attr].g) / ms,
b: (toColour.b - from[attr].b) / ms
};
break;
case "path":
var pathes = path2curve(from[attr], to[attr]),
toPath = pathes[1];
from[attr] = pathes[0];
diff[attr] = [];
for (i = 0, ii = from[attr].length; i < ii; i++) {
diff[attr][i] = [0];
for (var j = 1, jj = from[attr][i].length; j < jj; j++) {
diff[attr][i][j] = (toPath[i][j] - from[attr][i][j]) / ms;
}
}
break;
case "transform":
var _ = element._,
eq = equaliseTransform(_[attr], to[attr]);
if (eq) {
from[attr] = eq.from;
to[attr] = eq.to;
diff[attr] = [];
diff[attr].real = true;
for (i = 0, ii = from[attr].length; i < ii; i++) {
diff[attr][i] = [from[attr][i][0]];
for (j = 1, jj = from[attr][i].length; j < jj; j++) {
diff[attr][i][j] = (to[attr][i][j] - from[attr][i][j]) / ms;
}
}
} else {
var m = (element.matrix || new Matrix),
to2 = {
_: {transform: _.transform},
getBBox: function () {
return element.getBBox(1);
}
};
from[attr] = [
m.a,
m.b,
m.c,
m.d,
m.e,
m.f
];
extractTransform(to2, to[attr]);
to[attr] = to2._.transform;
diff[attr] = [
(to2.matrix.a - m.a) / ms,
(to2.matrix.b - m.b) / ms,
(to2.matrix.c - m.c) / ms,
(to2.matrix.d - m.d) / ms,
(to2.matrix.e - m.e) / ms,
(to2.matrix.f - m.f) / ms
];
}
break;
case "csv":
var values = Str(params[attr])[split](separator),
from2 = Str(from[attr])[split](separator);
if (attr == "clip-rect") {
from[attr] = from2;
diff[attr] = [];
i = from2.length;
while (i--) {
diff[attr][i] = (values[i] - from[attr][i]) / ms;
}
}
to[attr] = values;
break;
default:
values = [][concat](params[attr]);
from2 = [][concat](from[attr]);
diff[attr] = [];
i = element.paper.customAttributes[attr].length;
while (i--) {
diff[attr][i] = ((values[i] || 0) - (from2[i] || 0)) / ms;
}
break;
}
}
}
var easing = params.easing,
easyeasy = R.easing_formulas[easing];
if (!easyeasy) {
easyeasy = Str(easing).match(bezierrg);
if (easyeasy && easyeasy.length == 5) {
var curve = easyeasy;
easyeasy = function (t) {
return CubicBezierAtTime(t, +curve[1], +curve[2], +curve[3], +curve[4], ms);
};
} else {
easyeasy = pipe;
}
}
timestamp = params.start || anim.start || +new Date;
e = {
anim: anim,
percent: percent,
timestamp: timestamp,
start: timestamp + (anim.del || 0),
status: 0,
initstatus: status || 0,
stop: false,
ms: ms,
easing: easyeasy,
from: from,
diff: diff,
to: to,
el: element,
callback: params.callback,
prev: prev,
next: next,
repeat: times || anim.times,
origin: element.attr(),
totalOrigin: totalOrigin
};
animationElements.push(e);
if (status && !isInAnim && !isInAnimSet) {
e.stop = true;
e.start = new Date - ms * status;
if (animationElements.length == 1) {
return animation();
}
}
if (isInAnimSet) {
e.start = new Date - e.ms * status;
}
animationElements.length == 1 && requestAnimFrame(animation);
} else {
isInAnim.initstatus = status;
isInAnim.start = new Date - isInAnim.ms * status;
}
eve("raphael.anim.start." + element.id, element, anim);
}
R.animation = function (params, ms, easing, callback) {
if (params instanceof Animation) {
return params;
}
if (R.is(easing, "function") || !easing) {
callback = callback || easing || null;
easing = null;
}
params = Object(params);
ms = +ms || 0;
var p = {},
json,
attr;
for (attr in params) if (params[has](attr) && toFloat(attr) != attr && toFloat(attr) + "%" != attr) {
json = true;
p[attr] = params[attr];
}
if (!json) {
if(callback){
var lastKey = 0;
for(var i in params){
var percent = toInt(i);
if(params[has](i) && percent > lastKey){
lastKey = percent;
}
}
lastKey += '%';
!params[lastKey].callback && (params[lastKey].callback = callback);
}
return new Animation(params, ms);
} else {
easing && (p.easing = easing);
callback && (p.callback = callback);
return new Animation({100: p}, ms);
}
};
elproto.animate = function (params, ms, easing, callback) {
var element = this;
if (element.removed) {
callback && callback.call(element);
return element;
}
var anim = params instanceof Animation ? params : R.animation(params, ms, easing, callback);
runAnimation(anim, element, anim.percents[0], null, element.attr());
return element;
};
elproto.setTime = function (anim, value) {
if (anim && value != null) {
this.status(anim, mmin(value, anim.ms) / anim.ms);
}
return this;
};
elproto.status = function (anim, value) {
var out = [],
i = 0,
len,
e;
if (value != null) {
runAnimation(anim, this, -1, mmin(value, 1));
return this;
} else {
len = animationElements.length;
for (; i < len; i++) {
e = animationElements[i];
if (e.el.id == this.id && (!anim || e.anim == anim)) {
if (anim) {
return e.status;
}
out.push({
anim: e.anim,
status: e.status
});
}
}
if (anim) {
return 0;
}
return out;
}
};
elproto.pause = function (anim) {
for (var i = 0; i < animationElements.length; i++) if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {
if (eve("raphael.anim.pause." + this.id, this, animationElements[i].anim) !== false) {
animationElements[i].paused = true;
}
}
return this;
};
elproto.resume = function (anim) {
for (var i = 0; i < animationElements.length; i++) if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {
var e = animationElements[i];
if (eve("raphael.anim.resume." + this.id, this, e.anim) !== false) {
delete e.paused;
this.status(e.anim, e.status);
}
}
return this;
};
elproto.stop = function (anim) {
for (var i = 0; i < animationElements.length; i++) if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {
if (eve("raphael.anim.stop." + this.id, this, animationElements[i].anim) !== false) {
animationElements.splice(i--, 1);
}
}
return this;
};
function stopAnimation(paper) {
for (var i = 0; i < animationElements.length; i++) if (animationElements[i].el.paper == paper) {
animationElements.splice(i--, 1);
}
}
eve.on("raphael.remove", stopAnimation);
eve.on("raphael.clear", stopAnimation);
elproto.toString = function () {
return "Rapha\xebl\u2019s object";
};
var Set = function (items) {
this.items = [];
this.length = 0;
this.type = "set";
if (items) {
for (var i = 0, ii = items.length; i < ii; i++) {
if (items[i] && (items[i].constructor == elproto.constructor || items[i].constructor == Set)) {
this[this.items.length] = this.items[this.items.length] = items[i];
this.length++;
}
}
}
},
setproto = Set.prototype;
setproto.push = function () {
var item,
len;
for (var i = 0, ii = arguments.length; i < ii; i++) {
item = arguments[i];
if (item && (item.constructor == elproto.constructor || item.constructor == Set)) {
len = this.items.length;
this[len] = this.items[len] = item;
this.length++;
}
}
return this;
};
setproto.pop = function () {
this.length && delete this[this.length--];
return this.items.pop();
};
setproto.forEach = function (callback, thisArg) {
for (var i = 0, ii = this.items.length; i < ii; i++) {
if (callback.call(thisArg, this.items[i], i) === false) {
return this;
}
}
return this;
};
for (var method in elproto) if (elproto[has](method)) {
setproto[method] = (function (methodname) {
return function () {
var arg = arguments;
return this.forEach(function (el) {
el[methodname][apply](el, arg);
});
};
})(method);
}
setproto.attr = function (name, value) {
if (name && R.is(name, array) && R.is(name[0], "object")) {
for (var j = 0, jj = name.length; j < jj; j++) {
this.items[j].attr(name[j]);
}
} else {
for (var i = 0, ii = this.items.length; i < ii; i++) {
this.items[i].attr(name, value);
}
}
return this;
};
setproto.clear = function () {
while (this.length) {
this.pop();
}
};
setproto.splice = function (index, count, insertion) {
index = index < 0 ? mmax(this.length + index, 0) : index;
count = mmax(0, mmin(this.length - index, count));
var tail = [],
todel = [],
args = [],
i;
for (i = 2; i < arguments.length; i++) {
args.push(arguments[i]);
}
for (i = 0; i < count; i++) {
todel.push(this[index + i]);
}
for (; i < this.length - index; i++) {
tail.push(this[index + i]);
}
var arglen = args.length;
for (i = 0; i < arglen + tail.length; i++) {
this.items[index + i] = this[index + i] = i < arglen ? args[i] : tail[i - arglen];
}
i = this.items.length = this.length -= count - arglen;
while (this[i]) {
delete this[i++];
}
return new Set(todel);
};
setproto.exclude = function (el) {
for (var i = 0, ii = this.length; i < ii; i++) if (this[i] == el) {
this.splice(i, 1);
return true;
}
};
setproto.animate = function (params, ms, easing, callback) {
(R.is(easing, "function") || !easing) && (callback = easing || null);
var len = this.items.length,
i = len,
item,
set = this,
collector;
if (!len) {
return this;
}
callback && (collector = function () {
!--len && callback.call(set);
});
easing = R.is(easing, string) ? easing : collector;
var anim = R.animation(params, ms, easing, collector);
item = this.items[--i].animate(anim);
while (i--) {
this.items[i] && !this.items[i].removed && this.items[i].animateWith(item, anim, anim);
(this.items[i] && !this.items[i].removed) || len--;
}
return this;
};
setproto.insertAfter = function (el) {
var i = this.items.length;
while (i--) {
this.items[i].insertAfter(el);
}
return this;
};
setproto.getBBox = function () {
var x = [],
y = [],
x2 = [],
y2 = [];
for (var i = this.items.length; i--;) if (!this.items[i].removed) {
var box = this.items[i].getBBox();
x.push(box.x);
y.push(box.y);
x2.push(box.x + box.width);
y2.push(box.y + box.height);
}
x = mmin[apply](0, x);
y = mmin[apply](0, y);
x2 = mmax[apply](0, x2);
y2 = mmax[apply](0, y2);
return {
x: x,
y: y,
x2: x2,
y2: y2,
width: x2 - x,
height: y2 - y
};
};
setproto.clone = function (s) {
s = this.paper.set();
for (var i = 0, ii = this.items.length; i < ii; i++) {
s.push(this.items[i].clone());
}
return s;
};
setproto.toString = function () {
return "Rapha\xebl\u2018s set";
};
setproto.glow = function(glowConfig) {
var ret = this.paper.set();
this.forEach(function(shape, index){
var g = shape.glow(glowConfig);
if(g != null){
g.forEach(function(shape2, index2){
ret.push(shape2);
});
}
});
return ret;
};
setproto.isPointInside = function (x, y) {
var isPointInside = false;
this.forEach(function (el) {
if (el.isPointInside(x, y)) {
isPointInside = true;
return false; // stop loop
}
});
return isPointInside;
};
R.registerFont = function (font) {
if (!font.face) {
return font;
}
this.fonts = this.fonts || {};
var fontcopy = {
w: font.w,
face: {},
glyphs: {}
},
family = font.face["font-family"];
for (var prop in font.face) if (font.face[has](prop)) {
fontcopy.face[prop] = font.face[prop];
}
if (this.fonts[family]) {
this.fonts[family].push(fontcopy);
} else {
this.fonts[family] = [fontcopy];
}
if (!font.svg) {
fontcopy.face["units-per-em"] = toInt(font.face["units-per-em"], 10);
for (var glyph in font.glyphs) if (font.glyphs[has](glyph)) {
var path = font.glyphs[glyph];
fontcopy.glyphs[glyph] = {
w: path.w,
k: {},
d: path.d && "M" + path.d.replace(/[mlcxtrv]/g, function (command) {
return {l: "L", c: "C", x: "z", t: "m", r: "l", v: "c"}[command] || "M";
}) + "z"
};
if (path.k) {
for (var k in path.k) if (path[has](k)) {
fontcopy.glyphs[glyph].k[k] = path.k[k];
}
}
}
}
return font;
};
paperproto.getFont = function (family, weight, style, stretch) {
stretch = stretch || "normal";
style = style || "normal";
weight = +weight || {normal: 400, bold: 700, lighter: 300, bolder: 800}[weight] || 400;
if (!R.fonts) {
return;
}
var font = R.fonts[family];
if (!font) {
var name = new RegExp("(^|\\s)" + family.replace(/[^\w\d\s+!~.:_-]/g, E) + "(\\s|$)", "i");
for (var fontName in R.fonts) if (R.fonts[has](fontName)) {
if (name.test(fontName)) {
font = R.fonts[fontName];
break;
}
}
}
var thefont;
if (font) {
for (var i = 0, ii = font.length; i < ii; i++) {
thefont = font[i];
if (thefont.face["font-weight"] == weight && (thefont.face["font-style"] == style || !thefont.face["font-style"]) && thefont.face["font-stretch"] == stretch) {
break;
}
}
}
return thefont;
};
paperproto.print = function (x, y, string, font, size, origin, letter_spacing, line_spacing) {
origin = origin || "middle"; // baseline|middle
letter_spacing = mmax(mmin(letter_spacing || 0, 1), -1);
line_spacing = mmax(mmin(line_spacing || 1, 3), 1);
var letters = Str(string)[split](E),
shift = 0,
notfirst = 0,
path = E,
scale;
R.is(font, "string") && (font = this.getFont(font));
if (font) {
scale = (size || 16) / font.face["units-per-em"];
var bb = font.face.bbox[split](separator),
top = +bb[0],
lineHeight = bb[3] - bb[1],
shifty = 0,
height = +bb[1] + (origin == "baseline" ? lineHeight + (+font.face.descent) : lineHeight / 2);
for (var i = 0, ii = letters.length; i < ii; i++) {
if (letters[i] == "\n") {
shift = 0;
curr = 0;
notfirst = 0;
shifty += lineHeight * line_spacing;
} else {
var prev = notfirst && font.glyphs[letters[i - 1]] || {},
curr = font.glyphs[letters[i]];
shift += notfirst ? (prev.w || font.w) + (prev.k && prev.k[letters[i]] || 0) + (font.w * letter_spacing) : 0;
notfirst = 1;
}
if (curr && curr.d) {
path += R.transformPath(curr.d, ["t", shift * scale, shifty * scale, "s", scale, scale, top, height, "t", (x - top) / scale, (y - height) / scale]);
}
}
}
return this.path(path).attr({
fill: "#000",
stroke: "none"
});
};
paperproto.add = function (json) {
if (R.is(json, "array")) {
var res = this.set(),
i = 0,
ii = json.length,
j;
for (; i < ii; i++) {
j = json[i] || {};
elements[has](j.type) && res.push(this[j.type]().attr(j));
}
}
return res;
};
R.format = function (token, params) {
var args = R.is(params, array) ? [0][concat](params) : arguments;
token && R.is(token, string) && args.length - 1 && (token = token.replace(formatrg, function (str, i) {
return args[++i] == null ? E : args[i];
}));
return token || E;
};
R.fullfill = (function () {
var tokenRegex = /\{([^\}]+)\}/g,
objNotationRegex = /(?:(?:^|\.)(.+?)(?=\[|\.|$|\()|\[('|")(.+?)\2\])(\(\))?/g, // matches .xxxxx or ["xxxxx"] to run over object properties
replacer = function (all, key, obj) {
var res = obj;
key.replace(objNotationRegex, function (all, name, quote, quotedName, isFunc) {
name = name || quotedName;
if (res) {
if (name in res) {
res = res[name];
}
typeof res == "function" && isFunc && (res = res());
}
});
res = (res == null || res == obj ? all : res) + "";
return res;
};
return function (str, obj) {
return String(str).replace(tokenRegex, function (all, key) {
return replacer(all, key, obj);
});
};
})();
R.ninja = function () {
if (oldRaphael.was) {
g.win.Raphael = oldRaphael.is;
} else {
window.Raphael = undefined;
try {
delete window.Raphael;
} catch(e) {}
}
return R;
};
R.st = setproto;
eve.on("raphael.DOMload", function () {
loaded = true;
});
(function (doc, loaded, f) {
if (doc.readyState == null && doc.addEventListener){
doc.addEventListener(loaded, f = function () {
doc.removeEventListener(loaded, f, false);
doc.readyState = "complete";
}, false);
doc.readyState = "loading";
}
function isLoaded() {
(/in/).test(doc.readyState) ? setTimeout(isLoaded, 9) : R.eve("raphael.DOMload");
}
isLoaded();
})(document, "DOMContentLoaded");
return R;
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}, function(module, exports, __webpack_require__) {
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
(function (glob) {
var version = "0.5.0",
has = "hasOwnProperty",
separator = /[\.\/]/,
comaseparator = /\s*,\s*/,
wildcard = "*",
fun = function () {},
numsort = function (a, b) {
return a - b;
},
current_event,
stop,
events = {n: {}},
firstDefined = function () {
for (var i = 0, ii = this.length; i < ii; i++) {
if (typeof this[i] != "undefined") {
return this[i];
}
}
},
lastDefined = function () {
var i = this.length;
while (--i) {
if (typeof this[i] != "undefined") {
return this[i];
}
}
},
objtos = Object.prototype.toString,
Str = String,
isArray = Array.isArray || function (ar) {
return ar instanceof Array || objtos.call(ar) == "[object Array]";
};
eve = function (name, scope) {
var e = events,
oldstop = stop,
args = Array.prototype.slice.call(arguments, 2),
listeners = eve.listeners(name),
z = 0,
f = false,
l,
indexed = [],
queue = {},
out = [],
ce = current_event,
errors = [];
out.firstDefined = firstDefined;
out.lastDefined = lastDefined;
current_event = name;
stop = 0;
for (var i = 0, ii = listeners.length; i < ii; i++) if ("zIndex" in listeners[i]) {
indexed.push(listeners[i].zIndex);
if (listeners[i].zIndex < 0) {
queue[listeners[i].zIndex] = listeners[i];
}
}
indexed.sort(numsort);
while (indexed[z] < 0) {
l = queue[indexed[z++]];
out.push(l.apply(scope, args));
if (stop) {
stop = oldstop;
return out;
}
}
for (i = 0; i < ii; i++) {
l = listeners[i];
if ("zIndex" in l) {
if (l.zIndex == indexed[z]) {
out.push(l.apply(scope, args));
if (stop) {
break;
}
do {
z++;
l = queue[indexed[z]];
l && out.push(l.apply(scope, args));
if (stop) {
break;
}
} while (l)
} else {
queue[l.zIndex] = l;
}
} else {
out.push(l.apply(scope, args));
if (stop) {
break;
}
}
}
stop = oldstop;
current_event = ce;
return out;
};
eve._events = events;
eve.listeners = function (name) {
var names = isArray(name) ? name : name.split(separator),
e = events,
item,
items,
k,
i,
ii,
j,
jj,
nes,
es = [e],
out = [];
for (i = 0, ii = names.length; i < ii; i++) {
nes = [];
for (j = 0, jj = es.length; j < jj; j++) {
e = es[j].n;
items = [e[names[i]], e[wildcard]];
k = 2;
while (k--) {
item = items[k];
if (item) {
nes.push(item);
out = out.concat(item.f || []);
}
}
}
es = nes;
}
return out;
};
eve.separator = function (sep) {
if (sep) {
sep = Str(sep).replace(/(?=[\.\^\]\[\-])/g, "\\");
sep = "[" + sep + "]";
separator = new RegExp(sep);
} else {
separator = /[\.\/]/;
}
};
eve.on = function (name, f) {
if (typeof f != "function") {
return function () {};
}
var names = isArray(name) ? (isArray(name[0]) ? name : [name]) : Str(name).split(comaseparator);
for (var i = 0, ii = names.length; i < ii; i++) {
(function (name) {
var names = isArray(name) ? name : Str(name).split(separator),
e = events,
exist;
for (var i = 0, ii = names.length; i < ii; i++) {
e = e.n;
e = e.hasOwnProperty(names[i]) && e[names[i]] || (e[names[i]] = {n: {}});
}
e.f = e.f || [];
for (i = 0, ii = e.f.length; i < ii; i++) if (e.f[i] == f) {
exist = true;
break;
}
!exist && e.f.push(f);
}(names[i]));
}
return function (zIndex) {
if (+zIndex == +zIndex) {
f.zIndex = +zIndex;
}
};
};
eve.f = function (event) {
var attrs = [].slice.call(arguments, 1);
return function () {
eve.apply(null, [event, null].concat(attrs).concat([].slice.call(arguments, 0)));
};
};
eve.stop = function () {
stop = 1;
};
eve.nt = function (subname) {
var cur = isArray(current_event) ? current_event.join(".") : current_event;
if (subname) {
return new RegExp("(?:\\.|\\/|^)" + subname + "(?:\\.|\\/|$)").test(cur);
}
return cur;
};
eve.nts = function () {
return isArray(current_event) ? current_event : current_event.split(separator);
};
eve.off = eve.unbind = function (name, f) {
if (!name) {
eve._events = events = {n: {}};
return;
}
var names = isArray(name) ? (isArray(name[0]) ? name : [name]) : Str(name).split(comaseparator);
if (names.length > 1) {
for (var i = 0, ii = names.length; i < ii; i++) {
eve.off(names[i], f);
}
return;
}
names = isArray(name) ? name : Str(name).split(separator);
var e,
key,
splice,
i, ii, j, jj,
cur = [events];
for (i = 0, ii = names.length; i < ii; i++) {
for (j = 0; j < cur.length; j += splice.length - 2) {
splice = [j, 1];
e = cur[j].n;
if (names[i] != wildcard) {
if (e[names[i]]) {
splice.push(e[names[i]]);
}
} else {
for (key in e) if (e[has](key)) {
splice.push(e[key]);
}
}
cur.splice.apply(cur, splice);
}
}
for (i = 0, ii = cur.length; i < ii; i++) {
e = cur[i];
while (e.n) {
if (f) {
if (e.f) {
for (j = 0, jj = e.f.length; j < jj; j++) if (e.f[j] == f) {
e.f.splice(j, 1);
break;
}
!e.f.length && delete e.f;
}
for (key in e.n) if (e.n[has](key) && e.n[key].f) {
var funcs = e.n[key].f;
for (j = 0, jj = funcs.length; j < jj; j++) if (funcs[j] == f) {
funcs.splice(j, 1);
break;
}
!funcs.length && delete e.n[key].f;
}
} else {
delete e.f;
for (key in e.n) if (e.n[has](key) && e.n[key].f) {
delete e.n[key].f;
}
}
e = e.n;
}
}
};
eve.once = function (name, f) {
var f2 = function () {
eve.off(name, f2);
return f.apply(this, arguments);
};
return eve.on(name, f2);
};
eve.version = version;
eve.toString = function () {
return "You are running Eve " + version;
};
(typeof module != "undefined" && module.exports) ? (module.exports = eve) : ( true ? (!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() { return eve; }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))) : (glob.eve = eve));
})(this);
}, function(module, exports, __webpack_require__) {
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_RESULT__ = function(R) {
if (R && !R.svg) {
return;
}
var has = "hasOwnProperty",
Str = String,
toFloat = parseFloat,
toInt = parseInt,
math = Math,
mmax = math.max,
abs = math.abs,
pow = math.pow,
separator = /[, ]+/,
eve = R.eve,
E = "",
S = " ";
var xlink = "http://www.w3.org/1999/xlink",
markers = {
block: "M5,0 0,2.5 5,5z",
classic: "M5,0 0,2.5 5,5 3.5,3 3.5,2z",
diamond: "M2.5,0 5,2.5 2.5,5 0,2.5z",
open: "M6,1 1,3.5 6,6",
oval: "M2.5,0A2.5,2.5,0,0,1,2.5,5 2.5,2.5,0,0,1,2.5,0z"
},
markerCounter = {};
R.toString = function () {
return  "Your browser supports SVG.\nYou are running Rapha\xebl " + this.version;
};
var $ = function (el, attr) {
if (attr) {
if (typeof el == "string") {
el = $(el);
}
for (var key in attr) if (attr[has](key)) {
if (key.substring(0, 6) == "xlink:") {
el.setAttributeNS(xlink, key.substring(6), Str(attr[key]));
} else {
el.setAttribute(key, Str(attr[key]));
}
}
} else {
el = R._g.doc.createElementNS("http://www.w3.org/2000/svg", el);
el.style && (el.style.webkitTapHighlightColor = "rgba(0,0,0,0)");
}
return el;
},
addGradientFill = function (element, gradient) {
var type = "linear",
id = element.id + gradient,
fx = .5, fy = .5,
o = element.node,
SVG = element.paper,
s = o.style,
el = R._g.doc.getElementById(id);
if (!el) {
gradient = Str(gradient).replace(R._radial_gradient, function (all, _fx, _fy) {
type = "radial";
if (_fx && _fy) {
fx = toFloat(_fx);
fy = toFloat(_fy);
var dir = ((fy > .5) * 2 - 1);
pow(fx - .5, 2) + pow(fy - .5, 2) > .25 &&
(fy = math.sqrt(.25 - pow(fx - .5, 2)) * dir + .5) &&
fy != .5 &&
(fy = fy.toFixed(5) - 1e-5 * dir);
}
return E;
});
gradient = gradient.split(/\s*\-\s*/);
if (type == "linear") {
var angle = gradient.shift();
angle = -toFloat(angle);
if (isNaN(angle)) {
return null;
}
var vector = [0, 0, math.cos(R.rad(angle)), math.sin(R.rad(angle))],
max = 1 / (mmax(abs(vector[2]), abs(vector[3])) || 1);
vector[2] *= max;
vector[3] *= max;
if (vector[2] < 0) {
vector[0] = -vector[2];
vector[2] = 0;
}
if (vector[3] < 0) {
vector[1] = -vector[3];
vector[3] = 0;
}
}
var dots = R._parseDots(gradient);
if (!dots) {
return null;
}
id = id.replace(/[\(\)\s,\xb0#]/g, "_");
if (element.gradient && id != element.gradient.id) {
SVG.defs.removeChild(element.gradient);
delete element.gradient;
}
if (!element.gradient) {
el = $(type + "Gradient", {id: id});
element.gradient = el;
$(el, type == "radial" ? {
fx: fx,
fy: fy
} : {
x1: vector[0],
y1: vector[1],
x2: vector[2],
y2: vector[3],
gradientTransform: element.matrix.invert()
});
SVG.defs.appendChild(el);
for (var i = 0, ii = dots.length; i < ii; i++) {
el.appendChild($("stop", {
offset: dots[i].offset ? dots[i].offset : i ? "100%" : "0%",
"stop-color": dots[i].color || "#fff",
"stop-opacity": isFinite(dots[i].opacity) ? dots[i].opacity : 1
}));
}
}
}
$(o, {
fill: fillurl(id),
opacity: 1,
"fill-opacity": 1
});
s.fill = E;
s.opacity = 1;
s.fillOpacity = 1;
return 1;
},
isIE9or10 = function () {
var mode = document.documentMode;
return mode && (mode === 9 || mode === 10);
},
fillurl = function (id) {
if (isIE9or10()) {
return "url('#" + id + "')";
}
var location = document.location;
var locationString = (
location.protocol + '//' +
location.host +
location.pathname +
location.search
);
return "url('" + locationString + "#" + id + "')";
},
updatePosition = function (o) {
var bbox = o.getBBox(1);
$(o.pattern, {patternTransform: o.matrix.invert() + " translate(" + bbox.x + "," + bbox.y + ")"});
},
addArrow = function (o, value, isEnd) {
if (o.type == "path") {
var values = Str(value).toLowerCase().split("-"),
p = o.paper,
se = isEnd ? "end" : "start",
node = o.node,
attrs = o.attrs,
stroke = attrs["stroke-width"],
i = values.length,
type = "classic",
from,
to,
dx,
refX,
attr,
w = 3,
h = 3,
t = 5;
while (i--) {
switch (values[i]) {
case "block":
case "classic":
case "oval":
case "diamond":
case "open":
case "none":
type = values[i];
break;
case "wide": h = 5; break;
case "narrow": h = 2; break;
case "long": w = 5; break;
case "short": w = 2; break;
}
}
if (type == "open") {
w += 2;
h += 2;
t += 2;
dx = 1;
refX = isEnd ? 4 : 1;
attr = {
fill: "none",
stroke: attrs.stroke
};
} else {
refX = dx = w / 2;
attr = {
fill: attrs.stroke,
stroke: "none"
};
}
if (o._.arrows) {
if (isEnd) {
o._.arrows.endPath && markerCounter[o._.arrows.endPath]--;
o._.arrows.endMarker && markerCounter[o._.arrows.endMarker]--;
} else {
o._.arrows.startPath && markerCounter[o._.arrows.startPath]--;
o._.arrows.startMarker && markerCounter[o._.arrows.startMarker]--;
}
} else {
o._.arrows = {};
}
if (type != "none") {
var pathId = "raphael-marker-" + type,
markerId = "raphael-marker-" + se + type + w + h + "-obj" + o.id;
if (!R._g.doc.getElementById(pathId)) {
p.defs.appendChild($($("path"), {
"stroke-linecap": "round",
d: markers[type],
id: pathId
}));
markerCounter[pathId] = 1;
} else {
markerCounter[pathId]++;
}
var marker = R._g.doc.getElementById(markerId),
use;
if (!marker) {
marker = $($("marker"), {
id: markerId,
markerHeight: h,
markerWidth: w,
orient: "auto",
refX: refX,
refY: h / 2
});
use = $($("use"), {
"xlink:href": "#" + pathId,
transform: (isEnd ? "rotate(180 " + w / 2 + " " + h / 2 + ") " : E) + "scale(" + w / t + "," + h / t + ")",
"stroke-width": (1 / ((w / t + h / t) / 2)).toFixed(4)
});
marker.appendChild(use);
p.defs.appendChild(marker);
markerCounter[markerId] = 1;
} else {
markerCounter[markerId]++;
use = marker.getElementsByTagName("use")[0];
}
$(use, attr);
var delta = dx * (type != "diamond" && type != "oval");
if (isEnd) {
from = o._.arrows.startdx * stroke || 0;
to = R.getTotalLength(attrs.path) - delta * stroke;
} else {
from = delta * stroke;
to = R.getTotalLength(attrs.path) - (o._.arrows.enddx * stroke || 0);
}
attr = {};
attr["marker-" + se] = "url(#" + markerId + ")";
if (to || from) {
attr.d = R.getSubpath(attrs.path, from, to);
}
$(node, attr);
o._.arrows[se + "Path"] = pathId;
o._.arrows[se + "Marker"] = markerId;
o._.arrows[se + "dx"] = delta;
o._.arrows[se + "Type"] = type;
o._.arrows[se + "String"] = value;
} else {
if (isEnd) {
from = o._.arrows.startdx * stroke || 0;
to = R.getTotalLength(attrs.path) - from;
} else {
from = 0;
to = R.getTotalLength(attrs.path) - (o._.arrows.enddx * stroke || 0);
}
o._.arrows[se + "Path"] && $(node, {d: R.getSubpath(attrs.path, from, to)});
delete o._.arrows[se + "Path"];
delete o._.arrows[se + "Marker"];
delete o._.arrows[se + "dx"];
delete o._.arrows[se + "Type"];
delete o._.arrows[se + "String"];
}
for (attr in markerCounter) if (markerCounter[has](attr) && !markerCounter[attr]) {
var item = R._g.doc.getElementById(attr);
item && item.parentNode.removeChild(item);
}
}
},
dasharray = {
"-": [3, 1],
".": [1, 1],
"-.": [3, 1, 1, 1],
"-..": [3, 1, 1, 1, 1, 1],
". ": [1, 3],
"- ": [4, 3],
"--": [8, 3],
"- .": [4, 3, 1, 3],
"--.": [8, 3, 1, 3],
"--..": [8, 3, 1, 3, 1, 3]
},
addDashes = function (o, value, params) {
value = dasharray[Str(value).toLowerCase()];
if (value) {
var width = o.attrs["stroke-width"] || "1",
butt = {round: width, square: width, butt: 0}[o.attrs["stroke-linecap"] || params["stroke-linecap"]] || 0,
dashes = [],
i = value.length;
while (i--) {
dashes[i] = value[i] * width + ((i % 2) ? 1 : -1) * butt;
}
$(o.node, {"stroke-dasharray": dashes.join(",")});
}
else {
$(o.node, {"stroke-dasharray": "none"});
}
},
setFillAndStroke = function (o, params) {
var node = o.node,
attrs = o.attrs,
vis = node.style.visibility;
node.style.visibility = "hidden";
for (var att in params) {
if (params[has](att)) {
if (!R._availableAttrs[has](att)) {
continue;
}
var value = params[att];
attrs[att] = value;
switch (att) {
case "blur":
o.blur(value);
break;
case "title":
var title = node.getElementsByTagName("title");
if (title.length && (title = title[0])) {
title.firstChild.nodeValue = value;
} else {
title = $("title");
var val = R._g.doc.createTextNode(value);
title.appendChild(val);
node.appendChild(title);
}
break;
case "href":
case "target":
var pn = node.parentNode;
if (pn.tagName.toLowerCase() != "a") {
var hl = $("a");
pn.insertBefore(hl, node);
hl.appendChild(node);
pn = hl;
}
if (att == "target") {
pn.setAttributeNS(xlink, "show", value == "blank" ? "new" : value);
} else {
pn.setAttributeNS(xlink, att, value);
}
break;
case "cursor":
node.style.cursor = value;
break;
case "transform":
o.transform(value);
break;
case "arrow-start":
addArrow(o, value);
break;
case "arrow-end":
addArrow(o, value, 1);
break;
case "clip-rect":
var rect = Str(value).split(separator);
if (rect.length == 4) {
o.clip && o.clip.parentNode.parentNode.removeChild(o.clip.parentNode);
var el = $("clipPath"),
rc = $("rect");
el.id = R.createUUID();
$(rc, {
x: rect[0],
y: rect[1],
width: rect[2],
height: rect[3]
});
el.appendChild(rc);
o.paper.defs.appendChild(el);
$(node, {"clip-path": "url(#" + el.id + ")"});
o.clip = rc;
}
if (!value) {
var path = node.getAttribute("clip-path");
if (path) {
var clip = R._g.doc.getElementById(path.replace(/(^url\(#|\)$)/g, E));
clip && clip.parentNode.removeChild(clip);
$(node, {"clip-path": E});
delete o.clip;
}
}
break;
case "path":
if (o.type == "path") {
$(node, {d: value ? attrs.path = R._pathToAbsolute(value) : "M0,0"});
o._.dirty = 1;
if (o._.arrows) {
"startString" in o._.arrows && addArrow(o, o._.arrows.startString);
"endString" in o._.arrows && addArrow(o, o._.arrows.endString, 1);
}
}
break;
case "width":
node.setAttribute(att, value);
o._.dirty = 1;
if (attrs.fx) {
att = "x";
value = attrs.x;
} else {
break;
}
case "x":
if (attrs.fx) {
value = -attrs.x - (attrs.width || 0);
}
case "rx":
if (att == "rx" && o.type == "rect") {
break;
}
case "cx":
node.setAttribute(att, value);
o.pattern && updatePosition(o);
o._.dirty = 1;
break;
case "height":
node.setAttribute(att, value);
o._.dirty = 1;
if (attrs.fy) {
att = "y";
value = attrs.y;
} else {
break;
}
case "y":
if (attrs.fy) {
value = -attrs.y - (attrs.height || 0);
}
case "ry":
if (att == "ry" && o.type == "rect") {
break;
}
case "cy":
node.setAttribute(att, value);
o.pattern && updatePosition(o);
o._.dirty = 1;
break;
case "r":
if (o.type == "rect") {
$(node, {rx: value, ry: value});
} else {
node.setAttribute(att, value);
}
o._.dirty = 1;
break;
case "src":
if (o.type == "image") {
node.setAttributeNS(xlink, "href", value);
}
break;
case "stroke-width":
if (o._.sx != 1 || o._.sy != 1) {
value /= mmax(abs(o._.sx), abs(o._.sy)) || 1;
}
node.setAttribute(att, value);
if (attrs["stroke-dasharray"]) {
addDashes(o, attrs["stroke-dasharray"], params);
}
if (o._.arrows) {
"startString" in o._.arrows && addArrow(o, o._.arrows.startString);
"endString" in o._.arrows && addArrow(o, o._.arrows.endString, 1);
}
break;
case "stroke-dasharray":
addDashes(o, value, params);
break;
case "fill":
var isURL = Str(value).match(R._ISURL);
if (isURL) {
el = $("pattern");
var ig = $("image");
el.id = R.createUUID();
$(el, {x: 0, y: 0, patternUnits: "userSpaceOnUse", height: 1, width: 1});
$(ig, {x: 0, y: 0, "xlink:href": isURL[1]});
el.appendChild(ig);
(function (el) {
R._preload(isURL[1], function () {
var w = this.offsetWidth,
h = this.offsetHeight;
$(el, {width: w, height: h});
$(ig, {width: w, height: h});
});
})(el);
o.paper.defs.appendChild(el);
$(node, {fill: "url(#" + el.id + ")"});
o.pattern = el;
o.pattern && updatePosition(o);
break;
}
var clr = R.getRGB(value);
if (!clr.error) {
delete params.gradient;
delete attrs.gradient;
!R.is(attrs.opacity, "undefined") &&
R.is(params.opacity, "undefined") &&
$(node, {opacity: attrs.opacity});
!R.is(attrs["fill-opacity"], "undefined") &&
R.is(params["fill-opacity"], "undefined") &&
$(node, {"fill-opacity": attrs["fill-opacity"]});
} else if ((o.type == "circle" || o.type == "ellipse" || Str(value).charAt() != "r") && addGradientFill(o, value)) {
if ("opacity" in attrs || "fill-opacity" in attrs) {
var gradient = R._g.doc.getElementById(node.getAttribute("fill").replace(/^url\(#|\)$/g, E));
if (gradient) {
var stops = gradient.getElementsByTagName("stop");
$(stops[stops.length - 1], {"stop-opacity": ("opacity" in attrs ? attrs.opacity : 1) * ("fill-opacity" in attrs ? attrs["fill-opacity"] : 1)});
}
}
attrs.gradient = value;
attrs.fill = "none";
break;
}
clr[has]("opacity") && $(node, {"fill-opacity": clr.opacity > 1 ? clr.opacity / 100 : clr.opacity});
case "stroke":
clr = R.getRGB(value);
node.setAttribute(att, clr.hex);
att == "stroke" && clr[has]("opacity") && $(node, {"stroke-opacity": clr.opacity > 1 ? clr.opacity / 100 : clr.opacity});
if (att == "stroke" && o._.arrows) {
"startString" in o._.arrows && addArrow(o, o._.arrows.startString);
"endString" in o._.arrows && addArrow(o, o._.arrows.endString, 1);
}
break;
case "gradient":
(o.type == "circle" || o.type == "ellipse" || Str(value).charAt() != "r") && addGradientFill(o, value);
break;
case "opacity":
if (attrs.gradient && !attrs[has]("stroke-opacity")) {
$(node, {"stroke-opacity": value > 1 ? value / 100 : value});
}
case "fill-opacity":
if (attrs.gradient) {
gradient = R._g.doc.getElementById(node.getAttribute("fill").replace(/^url\(#|\)$/g, E));
if (gradient) {
stops = gradient.getElementsByTagName("stop");
$(stops[stops.length - 1], {"stop-opacity": value});
}
break;
}
default:
att == "font-size" && (value = toInt(value, 10) + "px");
var cssrule = att.replace(/(\-.)/g, function (w) {
return w.substring(1).toUpperCase();
});
node.style[cssrule] = value;
o._.dirty = 1;
node.setAttribute(att, value);
break;
}
}
}
tuneText(o, params);
node.style.visibility = vis;
},
leading = 1.2,
tuneText = function (el, params) {
if (el.type != "text" || !(params[has]("text") || params[has]("font") || params[has]("font-size") || params[has]("x") || params[has]("y"))) {
return;
}
var a = el.attrs,
node = el.node,
fontSize = node.firstChild ? toInt(R._g.doc.defaultView.getComputedStyle(node.firstChild, E).getPropertyValue("font-size"), 10) : 10;
if (params[has]("text")) {
a.text = params.text;
while (node.firstChild) {
node.removeChild(node.firstChild);
}
var texts = Str(params.text).split("\n"),
tspans = [],
tspan;
for (var i = 0, ii = texts.length; i < ii; i++) {
tspan = $("tspan");
i && $(tspan, {dy: fontSize * leading, x: a.x});
tspan.appendChild(R._g.doc.createTextNode(texts[i]));
node.appendChild(tspan);
tspans[i] = tspan;
}
} else {
tspans = node.getElementsByTagName("tspan");
for (i = 0, ii = tspans.length; i < ii; i++) if (i) {
$(tspans[i], {dy: fontSize * leading, x: a.x});
} else {
$(tspans[0], {dy: 0});
}
}
$(node, {x: a.x, y: a.y});
el._.dirty = 1;
var bb = el._getBBox(),
dif = a.y - (bb.y + bb.height / 2);
dif && R.is(dif, "finite") && $(tspans[0], {dy: dif});
},
getRealNode = function (node) {
if (node.parentNode && node.parentNode.tagName.toLowerCase() === "a") {
return node.parentNode;
} else {
return node;
}
},
Element = function (node, svg) {
var X = 0,
Y = 0;
this[0] = this.node = node;
node.raphael = true;
this.id = guid();
node.raphaelid = this.id;
function guid() {
return ("0000" + (Math.random()*Math.pow(36,5) << 0).toString(36)).slice(-5);
}
this.matrix = R.matrix();
this.realPath = null;
this.paper = svg;
this.attrs = this.attrs || {};
this._ = {
transform: [],
sx: 1,
sy: 1,
deg: 0,
dx: 0,
dy: 0,
dirty: 1
};
!svg.bottom && (svg.bottom = this);
this.prev = svg.top;
svg.top && (svg.top.next = this);
svg.top = this;
this.next = null;
},
elproto = R.el;
Element.prototype = elproto;
elproto.constructor = Element;
R._engine.path = function (pathString, SVG) {
var el = $("path");
SVG.canvas && SVG.canvas.appendChild(el);
var p = new Element(el, SVG);
p.type = "path";
setFillAndStroke(p, {
fill: "none",
stroke: "#000",
path: pathString
});
return p;
};
elproto.rotate = function (deg, cx, cy) {
if (this.removed) {
return this;
}
deg = Str(deg).split(separator);
if (deg.length - 1) {
cx = toFloat(deg[1]);
cy = toFloat(deg[2]);
}
deg = toFloat(deg[0]);
(cy == null) && (cx = cy);
if (cx == null || cy == null) {
var bbox = this.getBBox(1);
cx = bbox.x + bbox.width / 2;
cy = bbox.y + bbox.height / 2;
}
this.transform(this._.transform.concat([["r", deg, cx, cy]]));
return this;
};
elproto.scale = function (sx, sy, cx, cy) {
if (this.removed) {
return this;
}
sx = Str(sx).split(separator);
if (sx.length - 1) {
sy = toFloat(sx[1]);
cx = toFloat(sx[2]);
cy = toFloat(sx[3]);
}
sx = toFloat(sx[0]);
(sy == null) && (sy = sx);
(cy == null) && (cx = cy);
if (cx == null || cy == null) {
var bbox = this.getBBox(1);
}
cx = cx == null ? bbox.x + bbox.width / 2 : cx;
cy = cy == null ? bbox.y + bbox.height / 2 : cy;
this.transform(this._.transform.concat([["s", sx, sy, cx, cy]]));
return this;
};
elproto.translate = function (dx, dy) {
if (this.removed) {
return this;
}
dx = Str(dx).split(separator);
if (dx.length - 1) {
dy = toFloat(dx[1]);
}
dx = toFloat(dx[0]) || 0;
dy = +dy || 0;
this.transform(this._.transform.concat([["t", dx, dy]]));
return this;
};
elproto.transform = function (tstr) {
var _ = this._;
if (tstr == null) {
return _.transform;
}
R._extractTransform(this, tstr);
this.clip && $(this.clip, {transform: this.matrix.invert()});
this.pattern && updatePosition(this);
this.node && $(this.node, {transform: this.matrix});
if (_.sx != 1 || _.sy != 1) {
var sw = this.attrs[has]("stroke-width") ? this.attrs["stroke-width"] : 1;
this.attr({"stroke-width": sw});
}
return this;
};
elproto.hide = function () {
if(!this.removed) this.node.style.display = "none";
return this;
};
elproto.show = function () {
if(!this.removed) this.node.style.display = "";
return this;
};
elproto.remove = function () {
var node = getRealNode(this.node);
if (this.removed || !node.parentNode) {
return;
}
var paper = this.paper;
paper.__set__ && paper.__set__.exclude(this);
eve.unbind("raphael.*.*." + this.id);
if (this.gradient) {
paper.defs.removeChild(this.gradient);
}
R._tear(this, paper);
node.parentNode.removeChild(node);
this.removeData();
for (var i in this) {
this[i] = typeof this[i] == "function" ? R._removedFactory(i) : null;
}
this.removed = true;
};
elproto._getBBox = function () {
if (this.node.style.display == "none") {
this.show();
var hide = true;
}
var canvasHidden = false,
containerStyle;
if (this.paper.canvas.parentElement) {
containerStyle = this.paper.canvas.parentElement.style;
} //IE10+ can't find parentElement
else if (this.paper.canvas.parentNode) {
containerStyle = this.paper.canvas.parentNode.style;
}
if(containerStyle && containerStyle.display == "none") {
canvasHidden = true;
containerStyle.display = "";
}
var bbox = {};
try {
bbox = this.node.getBBox();
} catch(e) {
bbox = {
x: this.node.clientLeft,
y: this.node.clientTop,
width: this.node.clientWidth,
height: this.node.clientHeight
}
} finally {
bbox = bbox || {};
if(canvasHidden){
containerStyle.display = "none";
}
}
hide && this.hide();
return bbox;
};
elproto.attr = function (name, value) {
if (this.removed) {
return this;
}
if (name == null) {
var res = {};
for (var a in this.attrs) if (this.attrs[has](a)) {
res[a] = this.attrs[a];
}
res.gradient && res.fill == "none" && (res.fill = res.gradient) && delete res.gradient;
res.transform = this._.transform;
return res;
}
if (value == null && R.is(name, "string")) {
if (name == "fill" && this.attrs.fill == "none" && this.attrs.gradient) {
return this.attrs.gradient;
}
if (name == "transform") {
return this._.transform;
}
var names = name.split(separator),
out = {};
for (var i = 0, ii = names.length; i < ii; i++) {
name = names[i];
if (name in this.attrs) {
out[name] = this.attrs[name];
} else if (R.is(this.paper.customAttributes[name], "function")) {
out[name] = this.paper.customAttributes[name].def;
} else {
out[name] = R._availableAttrs[name];
}
}
return ii - 1 ? out : out[names[0]];
}
if (value == null && R.is(name, "array")) {
out = {};
for (i = 0, ii = name.length; i < ii; i++) {
out[name[i]] = this.attr(name[i]);
}
return out;
}
if (value != null) {
var params = {};
params[name] = value;
} else if (name != null && R.is(name, "object")) {
params = name;
}
for (var key in params) {
eve("raphael.attr." + key + "." + this.id, this, params[key]);
}
for (key in this.paper.customAttributes) if (this.paper.customAttributes[has](key) && params[has](key) && R.is(this.paper.customAttributes[key], "function")) {
var par = this.paper.customAttributes[key].apply(this, [].concat(params[key]));
this.attrs[key] = params[key];
for (var subkey in par) if (par[has](subkey)) {
params[subkey] = par[subkey];
}
}
setFillAndStroke(this, params);
return this;
};
elproto.toFront = function () {
if (this.removed) {
return this;
}
var node = getRealNode(this.node);
node.parentNode.appendChild(node);
var svg = this.paper;
svg.top != this && R._tofront(this, svg);
return this;
};
elproto.toBack = function () {
if (this.removed) {
return this;
}
var node = getRealNode(this.node);
var parentNode = node.parentNode;
parentNode.insertBefore(node, parentNode.firstChild);
R._toback(this, this.paper);
var svg = this.paper;
return this;
};
elproto.insertAfter = function (element) {
if (this.removed || !element) {
return this;
}
var node = getRealNode(this.node);
var afterNode = getRealNode(element.node || element[element.length - 1].node);
if (afterNode.nextSibling) {
afterNode.parentNode.insertBefore(node, afterNode.nextSibling);
} else {
afterNode.parentNode.appendChild(node);
}
R._insertafter(this, element, this.paper);
return this;
};
elproto.insertBefore = function (element) {
if (this.removed || !element) {
return this;
}
var node = getRealNode(this.node);
var beforeNode = getRealNode(element.node || element[0].node);
beforeNode.parentNode.insertBefore(node, beforeNode);
R._insertbefore(this, element, this.paper);
return this;
};
elproto.blur = function (size) {
var t = this;
if (+size !== 0) {
var fltr = $("filter"),
blur = $("feGaussianBlur");
t.attrs.blur = size;
fltr.id = R.createUUID();
$(blur, {stdDeviation: +size || 1.5});
fltr.appendChild(blur);
t.paper.defs.appendChild(fltr);
t._blur = fltr;
$(t.node, {filter: "url(#" + fltr.id + ")"});
} else {
if (t._blur) {
t._blur.parentNode.removeChild(t._blur);
delete t._blur;
delete t.attrs.blur;
}
t.node.removeAttribute("filter");
}
return t;
};
R._engine.circle = function (svg, x, y, r) {
var el = $("circle");
svg.canvas && svg.canvas.appendChild(el);
var res = new Element(el, svg);
res.attrs = {cx: x, cy: y, r: r, fill: "none", stroke: "#000"};
res.type = "circle";
$(el, res.attrs);
return res;
};
R._engine.rect = function (svg, x, y, w, h, r) {
var el = $("rect");
svg.canvas && svg.canvas.appendChild(el);
var res = new Element(el, svg);
res.attrs = {x: x, y: y, width: w, height: h, rx: r || 0, ry: r || 0, fill: "none", stroke: "#000"};
res.type = "rect";
$(el, res.attrs);
return res;
};
R._engine.ellipse = function (svg, x, y, rx, ry) {
var el = $("ellipse");
svg.canvas && svg.canvas.appendChild(el);
var res = new Element(el, svg);
res.attrs = {cx: x, cy: y, rx: rx, ry: ry, fill: "none", stroke: "#000"};
res.type = "ellipse";
$(el, res.attrs);
return res;
};
R._engine.image = function (svg, src, x, y, w, h) {
var el = $("image");
$(el, {x: x, y: y, width: w, height: h, preserveAspectRatio: "none"});
el.setAttributeNS(xlink, "href", src);
svg.canvas && svg.canvas.appendChild(el);
var res = new Element(el, svg);
res.attrs = {x: x, y: y, width: w, height: h, src: src};
res.type = "image";
return res;
};
R._engine.text = function (svg, x, y, text) {
var el = $("text");
svg.canvas && svg.canvas.appendChild(el);
var res = new Element(el, svg);
res.attrs = {
x: x,
y: y,
"text-anchor": "middle",
text: text,
"font-family": R._availableAttrs["font-family"],
"font-size": R._availableAttrs["font-size"],
stroke: "none",
fill: "#000"
};
res.type = "text";
setFillAndStroke(res, res.attrs);
return res;
};
R._engine.setSize = function (width, height) {
this.width = width || this.width;
this.height = height || this.height;
this.canvas.setAttribute("width", this.width);
this.canvas.setAttribute("height", this.height);
if (this._viewBox) {
this.setViewBox.apply(this, this._viewBox);
}
return this;
};
R._engine.create = function () {
var con = R._getContainer.apply(0, arguments),
container = con && con.container,
x = con.x,
y = con.y,
width = con.width,
height = con.height;
if (!container) {
throw new Error("SVG container not found.");
}
var cnvs = $("svg"),
css = "overflow:hidden;",
isFloating;
x = x || 0;
y = y || 0;
width = width || 512;
height = height || 342;
$(cnvs, {
height: height,
version: 1.1,
width: width,
xmlns: "http://www.w3.org/2000/svg",
"xmlns:xlink": "http://www.w3.org/1999/xlink"
});
if (container == 1) {
cnvs.style.cssText = css + "position:absolute;left:" + x + "px;top:" + y + "px";
R._g.doc.body.appendChild(cnvs);
isFloating = 1;
} else {
cnvs.style.cssText = css + "position:relative";
if (container.firstChild) {
container.insertBefore(cnvs, container.firstChild);
} else {
container.appendChild(cnvs);
}
}
container = new R._Paper;
container.width = width;
container.height = height;
container.canvas = cnvs;
container.clear();
container._left = container._top = 0;
isFloating && (container.renderfix = function () {});
container.renderfix();
return container;
};
R._engine.setViewBox = function (x, y, w, h, fit) {
eve("raphael.setViewBox", this, this._viewBox, [x, y, w, h, fit]);
var paperSize = this.getSize(),
size = mmax(w / paperSize.width, h / paperSize.height),
top = this.top,
aspectRatio = fit ? "xMidYMid meet" : "xMinYMin",
vb,
sw;
if (x == null) {
if (this._vbSize) {
size = 1;
}
delete this._vbSize;
vb = "0 0 " + this.width + S + this.height;
} else {
this._vbSize = size;
vb = x + S + y + S + w + S + h;
}
$(this.canvas, {
viewBox: vb,
preserveAspectRatio: aspectRatio
});
while (size && top) {
sw = "stroke-width" in top.attrs ? top.attrs["stroke-width"] : 1;
top.attr({"stroke-width": sw});
top._.dirty = 1;
top._.dirtyT = 1;
top = top.prev;
}
this._viewBox = [x, y, w, h, !!fit];
return this;
};
R.prototype.renderfix = function () {
var cnvs = this.canvas,
s = cnvs.style,
pos;
try {
pos = cnvs.getScreenCTM() || cnvs.createSVGMatrix();
} catch (e) {
pos = cnvs.createSVGMatrix();
}
var left = -pos.e % 1,
top = -pos.f % 1;
if (left || top) {
if (left) {
this._left = (this._left + left) % 1;
s.left = this._left + "px";
}
if (top) {
this._top = (this._top + top) % 1;
s.top = this._top + "px";
}
}
};
R.prototype.clear = function () {
R.eve("raphael.clear", this);
var c = this.canvas;
while (c.firstChild) {
c.removeChild(c.firstChild);
}
this.bottom = this.top = null;
(this.desc = $("desc")).appendChild(R._g.doc.createTextNode("Created with Rapha\xebl " + R.version));
c.appendChild(this.desc);
c.appendChild(this.defs = $("defs"));
};
R.prototype.remove = function () {
eve("raphael.remove", this);
this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas);
for (var i in this) {
this[i] = typeof this[i] == "function" ? R._removedFactory(i) : null;
}
};
var setproto = R.st;
for (var method in elproto) if (elproto[has](method) && !setproto[has](method)) {
setproto[method] = (function (methodname) {
return function () {
var arg = arguments;
return this.forEach(function (el) {
el[methodname].apply(el, arg);
});
};
})(method);
}
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}, function(module, exports, __webpack_require__) {
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_RESULT__ = function(R) {
if (R && !R.vml) {
return;
}
var has = "hasOwnProperty",
Str = String,
toFloat = parseFloat,
math = Math,
round = math.round,
mmax = math.max,
mmin = math.min,
abs = math.abs,
fillString = "fill",
separator = /[, ]+/,
eve = R.eve,
ms = " progid:DXImageTransform.Microsoft",
S = " ",
E = "",
map = {M: "m", L: "l", C: "c", Z: "x", m: "t", l: "r", c: "v", z: "x"},
bites = /([clmz]),?([^clmz]*)/gi,
blurregexp = / progid:\S+Blur\([^\)]+\)/g,
val = /-?[^,\s-]+/g,
cssDot = "position:absolute;left:0;top:0;width:1px;height:1px;behavior:url(#default#VML)",
zoom = 21600,
pathTypes = {path: 1, rect: 1, image: 1},
ovalTypes = {circle: 1, ellipse: 1},
path2vml = function (path) {
var total =  /[ahqstv]/ig,
command = R._pathToAbsolute;
Str(path).match(total) && (command = R._path2curve);
total = /[clmz]/g;
if (command == R._pathToAbsolute && !Str(path).match(total)) {
var res = Str(path).replace(bites, function (all, command, args) {
var vals = [],
isMove = command.toLowerCase() == "m",
res = map[command];
args.replace(val, function (value) {
if (isMove && vals.length == 2) {
res += vals + map[command == "m" ? "l" : "L"];
vals = [];
}
vals.push(round(value * zoom));
});
return res + vals;
});
return res;
}
var pa = command(path), p, r;
res = [];
for (var i = 0, ii = pa.length; i < ii; i++) {
p = pa[i];
r = pa[i][0].toLowerCase();
r == "z" && (r = "x");
for (var j = 1, jj = p.length; j < jj; j++) {
r += round(p[j] * zoom) + (j != jj - 1 ? "," : E);
}
res.push(r);
}
return res.join(S);
},
compensation = function (deg, dx, dy) {
var m = R.matrix();
m.rotate(-deg, .5, .5);
return {
dx: m.x(dx, dy),
dy: m.y(dx, dy)
};
},
setCoords = function (p, sx, sy, dx, dy, deg) {
var _ = p._,
m = p.matrix,
fillpos = _.fillpos,
o = p.node,
s = o.style,
y = 1,
flip = "",
dxdy,
kx = zoom / sx,
ky = zoom / sy;
s.visibility = "hidden";
if (!sx || !sy) {
return;
}
o.coordsize = abs(kx) + S + abs(ky);
s.rotation = deg * (sx * sy < 0 ? -1 : 1);
if (deg) {
var c = compensation(deg, dx, dy);
dx = c.dx;
dy = c.dy;
}
sx < 0 && (flip += "x");
sy < 0 && (flip += " y") && (y = -1);
s.flip = flip;
o.coordorigin = (dx * -kx) + S + (dy * -ky);
if (fillpos || _.fillsize) {
var fill = o.getElementsByTagName(fillString);
fill = fill && fill[0];
o.removeChild(fill);
if (fillpos) {
c = compensation(deg, m.x(fillpos[0], fillpos[1]), m.y(fillpos[0], fillpos[1]));
fill.position = c.dx * y + S + c.dy * y;
}
if (_.fillsize) {
fill.size = _.fillsize[0] * abs(sx) + S + _.fillsize[1] * abs(sy);
}
o.appendChild(fill);
}
s.visibility = "visible";
};
R.toString = function () {
return  "Your browser doesn\u2019t support SVG. Falling down to VML.\nYou are running Rapha\xebl " + this.version;
};
var addArrow = function (o, value, isEnd) {
var values = Str(value).toLowerCase().split("-"),
se = isEnd ? "end" : "start",
i = values.length,
type = "classic",
w = "medium",
h = "medium";
while (i--) {
switch (values[i]) {
case "block":
case "classic":
case "oval":
case "diamond":
case "open":
case "none":
type = values[i];
break;
case "wide":
case "narrow": h = values[i]; break;
case "long":
case "short": w = values[i]; break;
}
}
var stroke = o.node.getElementsByTagName("stroke")[0];
stroke[se + "arrow"] = type;
stroke[se + "arrowlength"] = w;
stroke[se + "arrowwidth"] = h;
},
setFillAndStroke = function (o, params) {
o.attrs = o.attrs || {};
var node = o.node,
a = o.attrs,
s = node.style,
xy,
newpath = pathTypes[o.type] && (params.x != a.x || params.y != a.y || params.width != a.width || params.height != a.height || params.cx != a.cx || params.cy != a.cy || params.rx != a.rx || params.ry != a.ry || params.r != a.r),
isOval = ovalTypes[o.type] && (a.cx != params.cx || a.cy != params.cy || a.r != params.r || a.rx != params.rx || a.ry != params.ry),
res = o;
for (var par in params) if (params[has](par)) {
a[par] = params[par];
}
if (newpath) {
a.path = R._getPath[o.type](o);
o._.dirty = 1;
}
params.href && (node.href = params.href);
params.title && (node.title = params.title);
params.target && (node.target = params.target);
params.cursor && (s.cursor = params.cursor);
"blur" in params && o.blur(params.blur);
if (params.path && o.type == "path" || newpath) {
node.path = path2vml(~Str(a.path).toLowerCase().indexOf("r") ? R._pathToAbsolute(a.path) : a.path);
o._.dirty = 1;
if (o.type == "image") {
o._.fillpos = [a.x, a.y];
o._.fillsize = [a.width, a.height];
setCoords(o, 1, 1, 0, 0, 0);
}
}
"transform" in params && o.transform(params.transform);
if (isOval) {
var cx = +a.cx,
cy = +a.cy,
rx = +a.rx || +a.r || 0,
ry = +a.ry || +a.r || 0;
node.path = R.format("ar{0},{1},{2},{3},{4},{1},{4},{1}x", round((cx - rx) * zoom), round((cy - ry) * zoom), round((cx + rx) * zoom), round((cy + ry) * zoom), round(cx * zoom));
o._.dirty = 1;
}
if ("clip-rect" in params) {
var rect = Str(params["clip-rect"]).split(separator);
if (rect.length == 4) {
rect[2] = +rect[2] + (+rect[0]);
rect[3] = +rect[3] + (+rect[1]);
var div = node.clipRect || R._g.doc.createElement("div"),
dstyle = div.style;
dstyle.clip = R.format("rect({1}px {2}px {3}px {0}px)", rect);
if (!node.clipRect) {
dstyle.position = "absolute";
dstyle.top = 0;
dstyle.left = 0;
dstyle.width = o.paper.width + "px";
dstyle.height = o.paper.height + "px";
node.parentNode.insertBefore(div, node);
div.appendChild(node);
node.clipRect = div;
}
}
if (!params["clip-rect"]) {
node.clipRect && (node.clipRect.style.clip = "auto");
}
}
if (o.textpath) {
var textpathStyle = o.textpath.style;
params.font && (textpathStyle.font = params.font);
params["font-family"] && (textpathStyle.fontFamily = '"' + params["font-family"].split(",")[0].replace(/^['"]+|['"]+$/g, E) + '"');
params["font-size"] && (textpathStyle.fontSize = params["font-size"]);
params["font-weight"] && (textpathStyle.fontWeight = params["font-weight"]);
params["font-style"] && (textpathStyle.fontStyle = params["font-style"]);
}
if ("arrow-start" in params) {
addArrow(res, params["arrow-start"]);
}
if ("arrow-end" in params) {
addArrow(res, params["arrow-end"], 1);
}
if (params.opacity != null ||
params.fill != null ||
params.src != null ||
params.stroke != null ||
params["stroke-width"] != null ||
params["stroke-opacity"] != null ||
params["fill-opacity"] != null ||
params["stroke-dasharray"] != null ||
params["stroke-miterlimit"] != null ||
params["stroke-linejoin"] != null ||
params["stroke-linecap"] != null) {
var fill = node.getElementsByTagName(fillString),
newfill = false;
fill = fill && fill[0];
!fill && (newfill = fill = createNode(fillString));
if (o.type == "image" && params.src) {
fill.src = params.src;
}
params.fill && (fill.on = true);
if (fill.on == null || params.fill == "none" || params.fill === null) {
fill.on = false;
}
if (fill.on && params.fill) {
var isURL = Str(params.fill).match(R._ISURL);
if (isURL) {
fill.parentNode == node && node.removeChild(fill);
fill.rotate = true;
fill.src = isURL[1];
fill.type = "tile";
var bbox = o.getBBox(1);
fill.position = bbox.x + S + bbox.y;
o._.fillpos = [bbox.x, bbox.y];
R._preload(isURL[1], function () {
o._.fillsize = [this.offsetWidth, this.offsetHeight];
});
} else {
fill.color = R.getRGB(params.fill).hex;
fill.src = E;
fill.type = "solid";
if (R.getRGB(params.fill).error && (res.type in {circle: 1, ellipse: 1} || Str(params.fill).charAt() != "r") && addGradientFill(res, params.fill, fill)) {
a.fill = "none";
a.gradient = params.fill;
fill.rotate = false;
}
}
}
if ("fill-opacity" in params || "opacity" in params) {
var opacity = ((+a["fill-opacity"] + 1 || 2) - 1) * ((+a.opacity + 1 || 2) - 1) * ((+R.getRGB(params.fill).o + 1 || 2) - 1);
opacity = mmin(mmax(opacity, 0), 1);
fill.opacity = opacity;
if (fill.src) {
fill.color = "none";
}
}
node.appendChild(fill);
var stroke = (node.getElementsByTagName("stroke") && node.getElementsByTagName("stroke")[0]),
newstroke = false;
!stroke && (newstroke = stroke = createNode("stroke"));
if ((params.stroke && params.stroke != "none") ||
params["stroke-width"] ||
params["stroke-opacity"] != null ||
params["stroke-dasharray"] ||
params["stroke-miterlimit"] ||
params["stroke-linejoin"] ||
params["stroke-linecap"]) {
stroke.on = true;
}
(params.stroke == "none" || params.stroke === null || stroke.on == null || params.stroke == 0 || params["stroke-width"] == 0) && (stroke.on = false);
var strokeColor = R.getRGB(params.stroke);
stroke.on && params.stroke && (stroke.color = strokeColor.hex);
opacity = ((+a["stroke-opacity"] + 1 || 2) - 1) * ((+a.opacity + 1 || 2) - 1) * ((+strokeColor.o + 1 || 2) - 1);
var width = (toFloat(params["stroke-width"]) || 1) * .75;
opacity = mmin(mmax(opacity, 0), 1);
params["stroke-width"] == null && (width = a["stroke-width"]);
params["stroke-width"] && (stroke.weight = width);
width && width < 1 && (opacity *= width) && (stroke.weight = 1);
stroke.opacity = opacity;
params["stroke-linejoin"] && (stroke.joinstyle = params["stroke-linejoin"] || "miter");
stroke.miterlimit = params["stroke-miterlimit"] || 8;
params["stroke-linecap"] && (stroke.endcap = params["stroke-linecap"] == "butt" ? "flat" : params["stroke-linecap"] == "square" ? "square" : "round");
if ("stroke-dasharray" in params) {
var dasharray = {
"-": "shortdash",
".": "shortdot",
"-.": "shortdashdot",
"-..": "shortdashdotdot",
". ": "dot",
"- ": "dash",
"--": "longdash",
"- .": "dashdot",
"--.": "longdashdot",
"--..": "longdashdotdot"
};
stroke.dashstyle = dasharray[has](params["stroke-dasharray"]) ? dasharray[params["stroke-dasharray"]] : E;
}
newstroke && node.appendChild(stroke);
}
if (res.type == "text") {
res.paper.canvas.style.display = E;
var span = res.paper.span,
m = 100,
fontSize = a.font && a.font.match(/\d+(?:\.\d*)?(?=px)/);
s = span.style;
a.font && (s.font = a.font);
a["font-family"] && (s.fontFamily = a["font-family"]);
a["font-weight"] && (s.fontWeight = a["font-weight"]);
a["font-style"] && (s.fontStyle = a["font-style"]);
fontSize = toFloat(a["font-size"] || fontSize && fontSize[0]) || 10;
s.fontSize = fontSize * m + "px";
res.textpath.string && (span.innerHTML = Str(res.textpath.string).replace(/</g, "&#60;").replace(/&/g, "&#38;").replace(/\n/g, "<br>"));
var brect = span.getBoundingClientRect();
res.W = a.w = (brect.right - brect.left) / m;
res.H = a.h = (brect.bottom - brect.top) / m;
res.X = a.x;
res.Y = a.y + res.H / 2;
("x" in params || "y" in params) && (res.path.v = R.format("m{0},{1}l{2},{1}", round(a.x * zoom), round(a.y * zoom), round(a.x * zoom) + 1));
var dirtyattrs = ["x", "y", "text", "font", "font-family", "font-weight", "font-style", "font-size"];
for (var d = 0, dd = dirtyattrs.length; d < dd; d++) if (dirtyattrs[d] in params) {
res._.dirty = 1;
break;
}
switch (a["text-anchor"]) {
case "start":
res.textpath.style["v-text-align"] = "left";
res.bbx = res.W / 2;
break;
case "end":
res.textpath.style["v-text-align"] = "right";
res.bbx = -res.W / 2;
break;
default:
res.textpath.style["v-text-align"] = "center";
res.bbx = 0;
break;
}
res.textpath.style["v-text-kern"] = true;
}
},
addGradientFill = function (o, gradient, fill) {
o.attrs = o.attrs || {};
var attrs = o.attrs,
pow = Math.pow,
opacity,
oindex,
type = "linear",
fxfy = ".5 .5";
o.attrs.gradient = gradient;
gradient = Str(gradient).replace(R._radial_gradient, function (all, fx, fy) {
type = "radial";
if (fx && fy) {
fx = toFloat(fx);
fy = toFloat(fy);
pow(fx - .5, 2) + pow(fy - .5, 2) > .25 && (fy = math.sqrt(.25 - pow(fx - .5, 2)) * ((fy > .5) * 2 - 1) + .5);
fxfy = fx + S + fy;
}
return E;
});
gradient = gradient.split(/\s*\-\s*/);
if (type == "linear") {
var angle = gradient.shift();
angle = -toFloat(angle);
if (isNaN(angle)) {
return null;
}
}
var dots = R._parseDots(gradient);
if (!dots) {
return null;
}
o = o.shape || o.node;
if (dots.length) {
o.removeChild(fill);
fill.on = true;
fill.method = "none";
fill.color = dots[0].color;
fill.color2 = dots[dots.length - 1].color;
var clrs = [];
for (var i = 0, ii = dots.length; i < ii; i++) {
dots[i].offset && clrs.push(dots[i].offset + S + dots[i].color);
}
fill.colors = clrs.length ? clrs.join() : "0% " + fill.color;
if (type == "radial") {
fill.type = "gradientTitle";
fill.focus = "100%";
fill.focussize = "0 0";
fill.focusposition = fxfy;
fill.angle = 0;
} else {
fill.type = "gradient";
fill.angle = (270 - angle) % 360;
}
o.appendChild(fill);
}
return 1;
},
Element = function (node, vml) {
this[0] = this.node = node;
node.raphael = true;
this.id = R._oid++;
node.raphaelid = this.id;
this.X = 0;
this.Y = 0;
this.attrs = {};
this.paper = vml;
this.matrix = R.matrix();
this._ = {
transform: [],
sx: 1,
sy: 1,
dx: 0,
dy: 0,
deg: 0,
dirty: 1,
dirtyT: 1
};
!vml.bottom && (vml.bottom = this);
this.prev = vml.top;
vml.top && (vml.top.next = this);
vml.top = this;
this.next = null;
};
var elproto = R.el;
Element.prototype = elproto;
elproto.constructor = Element;
elproto.transform = function (tstr) {
if (tstr == null) {
return this._.transform;
}
var vbs = this.paper._viewBoxShift,
vbt = vbs ? "s" + [vbs.scale, vbs.scale] + "-1-1t" + [vbs.dx, vbs.dy] : E,
oldt;
if (vbs) {
oldt = tstr = Str(tstr).replace(/\.{3}|\u2026/g, this._.transform || E);
}
R._extractTransform(this, vbt + tstr);
var matrix = this.matrix.clone(),
skew = this.skew,
o = this.node,
split,
isGrad = ~Str(this.attrs.fill).indexOf("-"),
isPatt = !Str(this.attrs.fill).indexOf("url(");
matrix.translate(1, 1);
if (isPatt || isGrad || this.type == "image") {
skew.matrix = "1 0 0 1";
skew.offset = "0 0";
split = matrix.split();
if ((isGrad && split.noRotation) || !split.isSimple) {
o.style.filter = matrix.toFilter();
var bb = this.getBBox(),
bbt = this.getBBox(1),
dx = bb.x - bbt.x,
dy = bb.y - bbt.y;
o.coordorigin = (dx * -zoom) + S + (dy * -zoom);
setCoords(this, 1, 1, dx, dy, 0);
} else {
o.style.filter = E;
setCoords(this, split.scalex, split.scaley, split.dx, split.dy, split.rotate);
}
} else {
o.style.filter = E;
skew.matrix = Str(matrix);
skew.offset = matrix.offset();
}
if (oldt !== null) { // empty string value is true as well
this._.transform = oldt;
R._extractTransform(this, oldt);
}
return this;
};
elproto.rotate = function (deg, cx, cy) {
if (this.removed) {
return this;
}
if (deg == null) {
return;
}
deg = Str(deg).split(separator);
if (deg.length - 1) {
cx = toFloat(deg[1]);
cy = toFloat(deg[2]);
}
deg = toFloat(deg[0]);
(cy == null) && (cx = cy);
if (cx == null || cy == null) {
var bbox = this.getBBox(1);
cx = bbox.x + bbox.width / 2;
cy = bbox.y + bbox.height / 2;
}
this._.dirtyT = 1;
this.transform(this._.transform.concat([["r", deg, cx, cy]]));
return this;
};
elproto.translate = function (dx, dy) {
if (this.removed) {
return this;
}
dx = Str(dx).split(separator);
if (dx.length - 1) {
dy = toFloat(dx[1]);
}
dx = toFloat(dx[0]) || 0;
dy = +dy || 0;
if (this._.bbox) {
this._.bbox.x += dx;
this._.bbox.y += dy;
}
this.transform(this._.transform.concat([["t", dx, dy]]));
return this;
};
elproto.scale = function (sx, sy, cx, cy) {
if (this.removed) {
return this;
}
sx = Str(sx).split(separator);
if (sx.length - 1) {
sy = toFloat(sx[1]);
cx = toFloat(sx[2]);
cy = toFloat(sx[3]);
isNaN(cx) && (cx = null);
isNaN(cy) && (cy = null);
}
sx = toFloat(sx[0]);
(sy == null) && (sy = sx);
(cy == null) && (cx = cy);
if (cx == null || cy == null) {
var bbox = this.getBBox(1);
}
cx = cx == null ? bbox.x + bbox.width / 2 : cx;
cy = cy == null ? bbox.y + bbox.height / 2 : cy;
this.transform(this._.transform.concat([["s", sx, sy, cx, cy]]));
this._.dirtyT = 1;
return this;
};
elproto.hide = function () {
!this.removed && (this.node.style.display = "none");
return this;
};
elproto.show = function () {
!this.removed && (this.node.style.display = E);
return this;
};
elproto.auxGetBBox = R.el.getBBox;
elproto.getBBox = function(){
var b = this.auxGetBBox();
if (this.paper && this.paper._viewBoxShift)
{
var c = {};
var z = 1/this.paper._viewBoxShift.scale;
c.x = b.x - this.paper._viewBoxShift.dx;
c.x *= z;
c.y = b.y - this.paper._viewBoxShift.dy;
c.y *= z;
c.width  = b.width  * z;
c.height = b.height * z;
c.x2 = c.x + c.width;
c.y2 = c.y + c.height;
return c;
}
return b;
};
elproto._getBBox = function () {
if (this.removed) {
return {};
}
return {
x: this.X + (this.bbx || 0) - this.W / 2,
y: this.Y - this.H,
width: this.W,
height: this.H
};
};
elproto.remove = function () {
if (this.removed || !this.node.parentNode) {
return;
}
this.paper.__set__ && this.paper.__set__.exclude(this);
R.eve.unbind("raphael.*.*." + this.id);
R._tear(this, this.paper);
this.node.parentNode.removeChild(this.node);
this.shape && this.shape.parentNode.removeChild(this.shape);
for (var i in this) {
this[i] = typeof this[i] == "function" ? R._removedFactory(i) : null;
}
this.removed = true;
};
elproto.attr = function (name, value) {
if (this.removed) {
return this;
}
if (name == null) {
var res = {};
for (var a in this.attrs) if (this.attrs[has](a)) {
res[a] = this.attrs[a];
}
res.gradient && res.fill == "none" && (res.fill = res.gradient) && delete res.gradient;
res.transform = this._.transform;
return res;
}
if (value == null && R.is(name, "string")) {
if (name == fillString && this.attrs.fill == "none" && this.attrs.gradient) {
return this.attrs.gradient;
}
var names = name.split(separator),
out = {};
for (var i = 0, ii = names.length; i < ii; i++) {
name = names[i];
if (name in this.attrs) {
out[name] = this.attrs[name];
} else if (R.is(this.paper.customAttributes[name], "function")) {
out[name] = this.paper.customAttributes[name].def;
} else {
out[name] = R._availableAttrs[name];
}
}
return ii - 1 ? out : out[names[0]];
}
if (this.attrs && value == null && R.is(name, "array")) {
out = {};
for (i = 0, ii = name.length; i < ii; i++) {
out[name[i]] = this.attr(name[i]);
}
return out;
}
var params;
if (value != null) {
params = {};
params[name] = value;
}
value == null && R.is(name, "object") && (params = name);
for (var key in params) {
eve("raphael.attr." + key + "." + this.id, this, params[key]);
}
if (params) {
for (key in this.paper.customAttributes) if (this.paper.customAttributes[has](key) && params[has](key) && R.is(this.paper.customAttributes[key], "function")) {
var par = this.paper.customAttributes[key].apply(this, [].concat(params[key]));
this.attrs[key] = params[key];
for (var subkey in par) if (par[has](subkey)) {
params[subkey] = par[subkey];
}
}
if (params.text && this.type == "text") {
this.textpath.string = params.text;
}
setFillAndStroke(this, params);
}
return this;
};
elproto.toFront = function () {
!this.removed && this.node.parentNode.appendChild(this.node);
this.paper && this.paper.top != this && R._tofront(this, this.paper);
return this;
};
elproto.toBack = function () {
if (this.removed) {
return this;
}
if (this.node.parentNode.firstChild != this.node) {
this.node.parentNode.insertBefore(this.node, this.node.parentNode.firstChild);
R._toback(this, this.paper);
}
return this;
};
elproto.insertAfter = function (element) {
if (this.removed) {
return this;
}
if (element.constructor == R.st.constructor) {
element = element[element.length - 1];
}
if (element.node.nextSibling) {
element.node.parentNode.insertBefore(this.node, element.node.nextSibling);
} else {
element.node.parentNode.appendChild(this.node);
}
R._insertafter(this, element, this.paper);
return this;
};
elproto.insertBefore = function (element) {
if (this.removed) {
return this;
}
if (element.constructor == R.st.constructor) {
element = element[0];
}
element.node.parentNode.insertBefore(this.node, element.node);
R._insertbefore(this, element, this.paper);
return this;
};
elproto.blur = function (size) {
var s = this.node.runtimeStyle,
f = s.filter;
f = f.replace(blurregexp, E);
if (+size !== 0) {
this.attrs.blur = size;
s.filter = f + S + ms + ".Blur(pixelradius=" + (+size || 1.5) + ")";
s.margin = R.format("-{0}px 0 0 -{0}px", round(+size || 1.5));
} else {
s.filter = f;
s.margin = 0;
delete this.attrs.blur;
}
return this;
};
R._engine.path = function (pathString, vml) {
var el = createNode("shape");
el.style.cssText = cssDot;
el.coordsize = zoom + S + zoom;
el.coordorigin = vml.coordorigin;
var p = new Element(el, vml),
attr = {fill: "none", stroke: "#000"};
pathString && (attr.path = pathString);
p.type = "path";
p.path = [];
p.Path = E;
setFillAndStroke(p, attr);
vml.canvas && vml.canvas.appendChild(el);
var skew = createNode("skew");
skew.on = true;
el.appendChild(skew);
p.skew = skew;
p.transform(E);
return p;
};
R._engine.rect = function (vml, x, y, w, h, r) {
var path = R._rectPath(x, y, w, h, r),
res = vml.path(path),
a = res.attrs;
res.X = a.x = x;
res.Y = a.y = y;
res.W = a.width = w;
res.H = a.height = h;
a.r = r;
a.path = path;
res.type = "rect";
return res;
};
R._engine.ellipse = function (vml, x, y, rx, ry) {
var res = vml.path(),
a = res.attrs;
res.X = x - rx;
res.Y = y - ry;
res.W = rx * 2;
res.H = ry * 2;
res.type = "ellipse";
setFillAndStroke(res, {
cx: x,
cy: y,
rx: rx,
ry: ry
});
return res;
};
R._engine.circle = function (vml, x, y, r) {
var res = vml.path(),
a = res.attrs;
res.X = x - r;
res.Y = y - r;
res.W = res.H = r * 2;
res.type = "circle";
setFillAndStroke(res, {
cx: x,
cy: y,
r: r
});
return res;
};
R._engine.image = function (vml, src, x, y, w, h) {
var path = R._rectPath(x, y, w, h),
res = vml.path(path).attr({stroke: "none"}),
a = res.attrs,
node = res.node,
fill = node.getElementsByTagName(fillString)[0];
a.src = src;
res.X = a.x = x;
res.Y = a.y = y;
res.W = a.width = w;
res.H = a.height = h;
a.path = path;
res.type = "image";
fill.parentNode == node && node.removeChild(fill);
fill.rotate = true;
fill.src = src;
fill.type = "tile";
res._.fillpos = [x, y];
res._.fillsize = [w, h];
node.appendChild(fill);
setCoords(res, 1, 1, 0, 0, 0);
return res;
};
R._engine.text = function (vml, x, y, text) {
var el = createNode("shape"),
path = createNode("path"),
o = createNode("textpath");
x = x || 0;
y = y || 0;
text = text || "";
path.v = R.format("m{0},{1}l{2},{1}", round(x * zoom), round(y * zoom), round(x * zoom) + 1);
path.textpathok = true;
o.string = Str(text);
o.on = true;
el.style.cssText = cssDot;
el.coordsize = zoom + S + zoom;
el.coordorigin = "0 0";
var p = new Element(el, vml),
attr = {
fill: "#000",
stroke: "none",
font: R._availableAttrs.font,
text: text
};
p.shape = el;
p.path = path;
p.textpath = o;
p.type = "text";
p.attrs.text = Str(text);
p.attrs.x = x;
p.attrs.y = y;
p.attrs.w = 1;
p.attrs.h = 1;
setFillAndStroke(p, attr);
el.appendChild(o);
el.appendChild(path);
vml.canvas.appendChild(el);
var skew = createNode("skew");
skew.on = true;
el.appendChild(skew);
p.skew = skew;
p.transform(E);
return p;
};
R._engine.setSize = function (width, height) {
var cs = this.canvas.style;
this.width = width;
this.height = height;
width == +width && (width += "px");
height == +height && (height += "px");
cs.width = width;
cs.height = height;
cs.clip = "rect(0 " + width + " " + height + " 0)";
if (this._viewBox) {
R._engine.setViewBox.apply(this, this._viewBox);
}
return this;
};
R._engine.setViewBox = function (x, y, w, h, fit) {
R.eve("raphael.setViewBox", this, this._viewBox, [x, y, w, h, fit]);
var paperSize = this.getSize(),
width = paperSize.width,
height = paperSize.height,
H, W;
if (fit) {
H = height / h;
W = width / w;
if (w * H < width) {
x -= (width - w * H) / 2 / H;
}
if (h * W < height) {
y -= (height - h * W) / 2 / W;
}
}
this._viewBox = [x, y, w, h, !!fit];
this._viewBoxShift = {
dx: -x,
dy: -y,
scale: paperSize
};
this.forEach(function (el) {
el.transform("...");
});
return this;
};
var createNode;
R._engine.initWin = function (win) {
var doc = win.document;
if (doc.styleSheets.length < 31) {
doc.createStyleSheet().addRule(".rvml", "behavior:url(#default#VML)");
} else {
doc.styleSheets[0].addRule(".rvml", "behavior:url(#default#VML)");
}
try {
!doc.namespaces.rvml && doc.namespaces.add("rvml", "urn:schemas-microsoft-com:vml");
createNode = function (tagName) {
return doc.createElement('<rvml:' + tagName + ' class="rvml">');
};
} catch (e) {
createNode = function (tagName) {
return doc.createElement('<' + tagName + ' xmlns="urn:schemas-microsoft.com:vml" class="rvml">');
};
}
};
R._engine.initWin(R._g.win);
R._engine.create = function () {
var con = R._getContainer.apply(0, arguments),
container = con.container,
height = con.height,
s,
width = con.width,
x = con.x,
y = con.y;
if (!container) {
throw new Error("VML container not found.");
}
var res = new R._Paper,
c = res.canvas = R._g.doc.createElement("div"),
cs = c.style;
x = x || 0;
y = y || 0;
width = width || 512;
height = height || 342;
res.width = width;
res.height = height;
width == +width && (width += "px");
height == +height && (height += "px");
res.coordsize = zoom * 1e3 + S + zoom * 1e3;
res.coordorigin = "0 0";
res.span = R._g.doc.createElement("span");
res.span.style.cssText = "position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;";
c.appendChild(res.span);
cs.cssText = R.format("top:0;left:0;width:{0};height:{1};display:inline-block;position:relative;clip:rect(0 {0} {1} 0);overflow:hidden", width, height);
if (container == 1) {
R._g.doc.body.appendChild(c);
cs.left = x + "px";
cs.top = y + "px";
cs.position = "absolute";
} else {
if (container.firstChild) {
container.insertBefore(c, container.firstChild);
} else {
container.appendChild(c);
}
}
res.renderfix = function () {};
return res;
};
R.prototype.clear = function () {
R.eve("raphael.clear", this);
this.canvas.innerHTML = E;
this.span = R._g.doc.createElement("span");
this.span.style.cssText = "position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;display:inline;";
this.canvas.appendChild(this.span);
this.bottom = this.top = null;
};
R.prototype.remove = function () {
R.eve("raphael.remove", this);
this.canvas.parentNode.removeChild(this.canvas);
for (var i in this) {
this[i] = typeof this[i] == "function" ? R._removedFactory(i) : null;
}
return true;
};
var setproto = R.st;
for (var method in elproto) if (elproto[has](method) && !setproto[has](method)) {
setproto[method] = (function (methodname) {
return function () {
var arg = arguments;
return this.forEach(function (el) {
el[methodname].apply(el, arg);
});
};
})(method);
}
}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} ])
});
;
(function() {
var $, Morris, minutesSpecHelper, secondsSpecHelper,
__slice = [].slice,
__bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
__hasProp = {}.hasOwnProperty,
__extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
__indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };
Morris = window.Morris = {};
$ = jQuery;
Morris.EventEmitter = (function() {
function EventEmitter() {}
EventEmitter.prototype.on = function(name, handler) {
if (this.handlers == null) {
this.handlers = {};
}
if (this.handlers[name] == null) {
this.handlers[name] = [];
}
this.handlers[name].push(handler);
return this;
};
EventEmitter.prototype.fire = function() {
var args, handler, name, _i, _len, _ref, _results;
name = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
if ((this.handlers != null) && (this.handlers[name] != null)) {
_ref = this.handlers[name];
_results = [];
for (_i = 0, _len = _ref.length; _i < _len; _i++) {
handler = _ref[_i];
_results.push(handler.apply(null, args));
}
return _results;
}
};
return EventEmitter;
})();
Morris.commas = function(num) {
var absnum, intnum, ret, strabsnum;
if (num != null) {
ret = num < 0 ? "-" : "";
absnum = Math.abs(num);
intnum = Math.floor(absnum).toFixed(0);
ret += intnum.replace(/(?=(?:\d{3})+$)(?!^)/g, ',');
strabsnum = absnum.toString();
if (strabsnum.length > intnum.length) {
ret += strabsnum.slice(intnum.length);
}
return ret;
} else {
return '-';
}
};
Morris.pad2 = function(number) {
return (number < 10 ? '0' : '') + number;
};
Morris.Grid = (function(_super) {
__extends(Grid, _super);
function Grid(options) {
this.resizeHandler = __bind(this.resizeHandler, this);
var _this = this;
if (typeof options.element === 'string') {
this.el = $(document.getElementById(options.element));
} else {
this.el = $(options.element);
}
if ((this.el == null) || this.el.length === 0) {
throw new Error("Graph container element not found");
}
if (this.el.css('position') === 'static') {
this.el.css('position', 'relative');
}
this.options = $.extend({}, this.gridDefaults, this.defaults || {}, options);
if (typeof this.options.units === 'string') {
this.options.postUnits = options.units;
}
this.raphael = new Raphael(this.el[0]);
this.elementWidth = null;
this.elementHeight = null;
this.dirty = false;
this.selectFrom = null;
if (this.init) {
this.init();
}
this.setData(this.options.data);
this.el.bind('mousemove', function(evt) {
var left, offset, right, width, x;
offset = _this.el.offset();
x = evt.pageX - offset.left;
if (_this.selectFrom) {
left = _this.data[_this.hitTest(Math.min(x, _this.selectFrom))]._x;
right = _this.data[_this.hitTest(Math.max(x, _this.selectFrom))]._x;
width = right - left;
return _this.selectionRect.attr({
x: left,
width: width
});
} else {
return _this.fire('hovermove', x, evt.pageY - offset.top);
}
});
this.el.bind('mouseleave', function(evt) {
if (_this.selectFrom) {
_this.selectionRect.hide();
_this.selectFrom = null;
}
return _this.fire('hoverout');
});
this.el.bind('touchstart touchmove touchend', function(evt) {
var offset, touch;
touch = evt.originalEvent.touches[0] || evt.originalEvent.changedTouches[0];
offset = _this.el.offset();
return _this.fire('hovermove', touch.pageX - offset.left, touch.pageY - offset.top);
});
this.el.bind('click', function(evt) {
var offset;
offset = _this.el.offset();
return _this.fire('gridclick', evt.pageX - offset.left, evt.pageY - offset.top);
});
if (this.options.rangeSelect) {
this.selectionRect = this.raphael.rect(0, 0, 0, this.el.innerHeight()).attr({
fill: this.options.rangeSelectColor,
stroke: false
}).toBack().hide();
this.el.bind('mousedown', function(evt) {
var offset;
offset = _this.el.offset();
return _this.startRange(evt.pageX - offset.left);
});
this.el.bind('mouseup', function(evt) {
var offset;
offset = _this.el.offset();
_this.endRange(evt.pageX - offset.left);
return _this.fire('hovermove', evt.pageX - offset.left, evt.pageY - offset.top);
});
}
if (this.options.resize) {
$(window).bind('resize', function(evt) {
if (_this.timeoutId != null) {
window.clearTimeout(_this.timeoutId);
}
return _this.timeoutId = window.setTimeout(_this.resizeHandler, 100);
});
}
this.el.css('-webkit-tap-highlight-color', 'rgba(0,0,0,0)');
if (this.postInit) {
this.postInit();
}
}
Grid.prototype.gridDefaults = {
dateFormat: null,
axes: true,
grid: true,
gridLineColor: '#aaa',
gridStrokeWidth: 0.5,
gridTextColor: '#888',
gridTextSize: 12,
gridTextFamily: 'sans-serif',
gridTextWeight: 'normal',
hideHover: false,
yLabelFormat: null,
xLabelAngle: 0,
numLines: 5,
padding: 25,
parseTime: true,
postUnits: '',
preUnits: '',
ymax: 'auto',
ymin: 'auto 0',
goals: [],
goalStrokeWidth: 1.0,
goalLineColors: ['#666633', '#999966', '#cc6666', '#663333'],
events: [],
eventStrokeWidth: 1.0,
eventLineColors: ['#005a04', '#ccffbb', '#3a5f0b', '#005502'],
rangeSelect: null,
rangeSelectColor: '#eef',
resize: false
};
Grid.prototype.setData = function(data, redraw) {
var e, idx, index, maxGoal, minGoal, ret, row, step, total, y, ykey, ymax, ymin, yval, _ref;
if (redraw == null) {
redraw = true;
}
this.options.data = data;
if ((data == null) || data.length === 0) {
this.data = [];
this.raphael.clear();
if (this.hover != null) {
this.hover.hide();
}
return;
}
ymax = this.cumulative ? 0 : null;
ymin = this.cumulative ? 0 : null;
if (this.options.goals.length > 0) {
minGoal = Math.min.apply(Math, this.options.goals);
maxGoal = Math.max.apply(Math, this.options.goals);
ymin = ymin != null ? Math.min(ymin, minGoal) : minGoal;
ymax = ymax != null ? Math.max(ymax, maxGoal) : maxGoal;
}
this.data = (function() {
var _i, _len, _results;
_results = [];
for (index = _i = 0, _len = data.length; _i < _len; index = ++_i) {
row = data[index];
ret = {
src: row
};
ret.label = row[this.options.xkey];
if (this.options.parseTime) {
ret.x = Morris.parseDate(ret.label);
if (this.options.dateFormat) {
ret.label = this.options.dateFormat(ret.x);
} else if (typeof ret.label === 'number') {
ret.label = new Date(ret.label).toString();
}
} else {
ret.x = index;
if (this.options.xLabelFormat) {
ret.label = this.options.xLabelFormat(ret);
}
}
total = 0;
ret.y = (function() {
var _j, _len1, _ref, _results1;
_ref = this.options.ykeys;
_results1 = [];
for (idx = _j = 0, _len1 = _ref.length; _j < _len1; idx = ++_j) {
ykey = _ref[idx];
yval = row[ykey];
if (typeof yval === 'string') {
yval = parseFloat(yval);
}
if ((yval != null) && typeof yval !== 'number') {
yval = null;
}
if (yval != null) {
if (this.cumulative) {
total += yval;
} else {
if (ymax != null) {
ymax = Math.max(yval, ymax);
ymin = Math.min(yval, ymin);
} else {
ymax = ymin = yval;
}
}
}
if (this.cumulative && (total != null)) {
ymax = Math.max(total, ymax);
ymin = Math.min(total, ymin);
}
_results1.push(yval);
}
return _results1;
}).call(this);
_results.push(ret);
}
return _results;
}).call(this);
if (this.options.parseTime) {
this.data = this.data.sort(function(a, b) {
return (a.x > b.x) - (b.x > a.x);
});
}
this.xmin = this.data[0].x;
this.xmax = this.data[this.data.length - 1].x;
this.events = [];
if (this.options.events.length > 0) {
if (this.options.parseTime) {
this.events = (function() {
var _i, _len, _ref, _results;
_ref = this.options.events;
_results = [];
for (_i = 0, _len = _ref.length; _i < _len; _i++) {
e = _ref[_i];
_results.push(Morris.parseDate(e));
}
return _results;
}).call(this);
} else {
this.events = this.options.events;
}
this.xmax = Math.max(this.xmax, Math.max.apply(Math, this.events));
this.xmin = Math.min(this.xmin, Math.min.apply(Math, this.events));
}
if (this.xmin === this.xmax) {
this.xmin -= 1;
this.xmax += 1;
}
this.ymin = this.yboundary('min', ymin);
this.ymax = this.yboundary('max', ymax);
if (this.ymin === this.ymax) {
if (ymin) {
this.ymin -= 1;
}
this.ymax += 1;
}
if (((_ref = this.options.axes) === true || _ref === 'both' || _ref === 'y') || this.options.grid === true) {
if (this.options.ymax === this.gridDefaults.ymax && this.options.ymin === this.gridDefaults.ymin) {
this.grid = this.autoGridLines(this.ymin, this.ymax, this.options.numLines);
this.ymin = Math.min(this.ymin, this.grid[0]);
this.ymax = Math.max(this.ymax, this.grid[this.grid.length - 1]);
} else {
step = (this.ymax - this.ymin) / (this.options.numLines - 1);
this.grid = (function() {
var _i, _ref1, _ref2, _results;
_results = [];
for (y = _i = _ref1 = this.ymin, _ref2 = this.ymax; step > 0 ? _i <= _ref2 : _i >= _ref2; y = _i += step) {
_results.push(y);
}
return _results;
}).call(this);
}
}
this.dirty = true;
if (redraw) {
return this.redraw();
}
};
Grid.prototype.yboundary = function(boundaryType, currentValue) {
var boundaryOption, suggestedValue;
boundaryOption = this.options["y" + boundaryType];
if (typeof boundaryOption === 'string') {
if (boundaryOption.slice(0, 4) === 'auto') {
if (boundaryOption.length > 5) {
suggestedValue = parseInt(boundaryOption.slice(5), 10);
if (currentValue == null) {
return suggestedValue;
}
return Math[boundaryType](currentValue, suggestedValue);
} else {
if (currentValue != null) {
return currentValue;
} else {
return 0;
}
}
} else {
return parseInt(boundaryOption, 10);
}
} else {
return boundaryOption;
}
};
Grid.prototype.autoGridLines = function(ymin, ymax, nlines) {
var gmax, gmin, grid, smag, span, step, unit, y, ymag;
span = ymax - ymin;
ymag = Math.floor(Math.log(span) / Math.log(10));
unit = Math.pow(10, ymag);
gmin = Math.floor(ymin / unit) * unit;
gmax = Math.ceil(ymax / unit) * unit;
step = (gmax - gmin) / (nlines - 1);
if (unit === 1 && step > 1 && Math.ceil(step) !== step) {
step = Math.ceil(step);
gmax = gmin + step * (nlines - 1);
}
if (gmin < 0 && gmax > 0) {
gmin = Math.floor(ymin / step) * step;
gmax = Math.ceil(ymax / step) * step;
}
if (step < 1) {
smag = Math.floor(Math.log(step) / Math.log(10));
grid = (function() {
var _i, _results;
_results = [];
for (y = _i = gmin; step > 0 ? _i <= gmax : _i >= gmax; y = _i += step) {
_results.push(parseFloat(y.toFixed(1 - smag)));
}
return _results;
})();
} else {
grid = (function() {
var _i, _results;
_results = [];
for (y = _i = gmin; step > 0 ? _i <= gmax : _i >= gmax; y = _i += step) {
_results.push(y);
}
return _results;
})();
}
return grid;
};
Grid.prototype._calc = function() {
var bottomOffsets, gridLine, h, i, w, yLabelWidths, _ref, _ref1;
w = this.el.width();
h = this.el.height();
if (this.elementWidth !== w || this.elementHeight !== h || this.dirty) {
this.elementWidth = w;
this.elementHeight = h;
this.dirty = false;
this.left = this.options.padding;
this.right = this.elementWidth - this.options.padding;
this.top = this.options.padding;
this.bottom = this.elementHeight - this.options.padding;
if ((_ref = this.options.axes) === true || _ref === 'both' || _ref === 'y') {
yLabelWidths = (function() {
var _i, _len, _ref1, _results;
_ref1 = this.grid;
_results = [];
for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
gridLine = _ref1[_i];
_results.push(this.measureText(this.yAxisFormat(gridLine)).width);
}
return _results;
}).call(this);
this.left += Math.max.apply(Math, yLabelWidths);
}
if ((_ref1 = this.options.axes) === true || _ref1 === 'both' || _ref1 === 'x') {
bottomOffsets = (function() {
var _i, _ref2, _results;
_results = [];
for (i = _i = 0, _ref2 = this.data.length; 0 <= _ref2 ? _i < _ref2 : _i > _ref2; i = 0 <= _ref2 ? ++_i : --_i) {
_results.push(this.measureText(this.data[i].text, -this.options.xLabelAngle).height);
}
return _results;
}).call(this);
this.bottom -= Math.max.apply(Math, bottomOffsets);
}
this.width = Math.max(1, this.right - this.left);
this.height = Math.max(1, this.bottom - this.top);
this.dx = this.width / (this.xmax - this.xmin);
this.dy = this.height / (this.ymax - this.ymin);
if (this.calc) {
return this.calc();
}
}
};
Grid.prototype.transY = function(y) {
return this.bottom - (y - this.ymin) * this.dy;
};
Grid.prototype.transX = function(x) {
if (this.data.length === 1) {
return (this.left + this.right) / 2;
} else {
return this.left + (x - this.xmin) * this.dx;
}
};
Grid.prototype.redraw = function() {
this.raphael.clear();
this._calc();
this.drawGrid();
this.drawGoals();
this.drawEvents();
if (this.draw) {
return this.draw();
}
};
Grid.prototype.measureText = function(text, angle) {
var ret, tt;
if (angle == null) {
angle = 0;
}
tt = this.raphael.text(100, 100, text).attr('font-size', this.options.gridTextSize).attr('font-family', this.options.gridTextFamily).attr('font-weight', this.options.gridTextWeight).rotate(angle);
ret = tt.getBBox();
tt.remove();
return ret;
};
Grid.prototype.yAxisFormat = function(label) {
return this.yLabelFormat(label);
};
Grid.prototype.yLabelFormat = function(label) {
if (typeof this.options.yLabelFormat === 'function') {
return this.options.yLabelFormat(label);
} else {
return "" + this.options.preUnits + (Morris.commas(label)) + this.options.postUnits;
}
};
Grid.prototype.drawGrid = function() {
var lineY, y, _i, _len, _ref, _ref1, _ref2, _results;
if (this.options.grid === false && ((_ref = this.options.axes) !== true && _ref !== 'both' && _ref !== 'y')) {
return;
}
_ref1 = this.grid;
_results = [];
for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
lineY = _ref1[_i];
y = this.transY(lineY);
if ((_ref2 = this.options.axes) === true || _ref2 === 'both' || _ref2 === 'y') {
this.drawYAxisLabel(this.left - this.options.padding / 2, y, this.yAxisFormat(lineY));
}
if (this.options.grid) {
_results.push(this.drawGridLine("M" + this.left + "," + y + "H" + (this.left + this.width)));
} else {
_results.push(void 0);
}
}
return _results;
};
Grid.prototype.drawGoals = function() {
var color, goal, i, _i, _len, _ref, _results;
_ref = this.options.goals;
_results = [];
for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
goal = _ref[i];
color = this.options.goalLineColors[i % this.options.goalLineColors.length];
_results.push(this.drawGoal(goal, color));
}
return _results;
};
Grid.prototype.drawEvents = function() {
var color, event, i, _i, _len, _ref, _results;
_ref = this.events;
_results = [];
for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
event = _ref[i];
color = this.options.eventLineColors[i % this.options.eventLineColors.length];
_results.push(this.drawEvent(event, color));
}
return _results;
};
Grid.prototype.drawGoal = function(goal, color) {
return this.raphael.path("M" + this.left + "," + (this.transY(goal)) + "H" + this.right).attr('stroke', color).attr('stroke-width', this.options.goalStrokeWidth);
};
Grid.prototype.drawEvent = function(event, color) {
return this.raphael.path("M" + (this.transX(event)) + "," + this.bottom + "V" + this.top).attr('stroke', color).attr('stroke-width', this.options.eventStrokeWidth);
};
Grid.prototype.drawYAxisLabel = function(xPos, yPos, text) {
return this.raphael.text(xPos, yPos, text).attr('font-size', this.options.gridTextSize).attr('font-family', this.options.gridTextFamily).attr('font-weight', this.options.gridTextWeight).attr('fill', this.options.gridTextColor).attr('text-anchor', 'end');
};
Grid.prototype.drawGridLine = function(path) {
return this.raphael.path(path).attr('stroke', this.options.gridLineColor).attr('stroke-width', this.options.gridStrokeWidth);
};
Grid.prototype.startRange = function(x) {
this.hover.hide();
this.selectFrom = x;
return this.selectionRect.attr({
x: x,
width: 0
}).show();
};
Grid.prototype.endRange = function(x) {
var end, start;
if (this.selectFrom) {
start = Math.min(this.selectFrom, x);
end = Math.max(this.selectFrom, x);
this.options.rangeSelect.call(this.el, {
start: this.data[this.hitTest(start)].x,
end: this.data[this.hitTest(end)].x
});
return this.selectFrom = null;
}
};
Grid.prototype.resizeHandler = function() {
this.timeoutId = null;
this.raphael.setSize(this.el.width(), this.el.height());
return this.redraw();
};
return Grid;
})(Morris.EventEmitter);
Morris.parseDate = function(date) {
var isecs, m, msecs, n, o, offsetmins, p, q, r, ret, secs;
if (typeof date === 'number') {
return date;
}
m = date.match(/^(\d+) Q(\d)$/);
n = date.match(/^(\d+)-(\d+)$/);
o = date.match(/^(\d+)-(\d+)-(\d+)$/);
p = date.match(/^(\d+) W(\d+)$/);
q = date.match(/^(\d+)-(\d+)-(\d+)[ T](\d+):(\d+)(Z|([+-])(\d\d):?(\d\d))?$/);
r = date.match(/^(\d+)-(\d+)-(\d+)[ T](\d+):(\d+):(\d+(\.\d+)?)(Z|([+-])(\d\d):?(\d\d))?$/);
if (m) {
return new Date(parseInt(m[1], 10), parseInt(m[2], 10) * 3 - 1, 1).getTime();
} else if (n) {
return new Date(parseInt(n[1], 10), parseInt(n[2], 10) - 1, 1).getTime();
} else if (o) {
return new Date(parseInt(o[1], 10), parseInt(o[2], 10) - 1, parseInt(o[3], 10)).getTime();
} else if (p) {
ret = new Date(parseInt(p[1], 10), 0, 1);
if (ret.getDay() !== 4) {
ret.setMonth(0, 1 + ((4 - ret.getDay()) + 7) % 7);
}
return ret.getTime() + parseInt(p[2], 10) * 604800000;
} else if (q) {
if (!q[6]) {
return new Date(parseInt(q[1], 10), parseInt(q[2], 10) - 1, parseInt(q[3], 10), parseInt(q[4], 10), parseInt(q[5], 10)).getTime();
} else {
offsetmins = 0;
if (q[6] !== 'Z') {
offsetmins = parseInt(q[8], 10) * 60 + parseInt(q[9], 10);
if (q[7] === '+') {
offsetmins = 0 - offsetmins;
}
}
return Date.UTC(parseInt(q[1], 10), parseInt(q[2], 10) - 1, parseInt(q[3], 10), parseInt(q[4], 10), parseInt(q[5], 10) + offsetmins);
}
} else if (r) {
secs = parseFloat(r[6]);
isecs = Math.floor(secs);
msecs = Math.round((secs - isecs) * 1000);
if (!r[8]) {
return new Date(parseInt(r[1], 10), parseInt(r[2], 10) - 1, parseInt(r[3], 10), parseInt(r[4], 10), parseInt(r[5], 10), isecs, msecs).getTime();
} else {
offsetmins = 0;
if (r[8] !== 'Z') {
offsetmins = parseInt(r[10], 10) * 60 + parseInt(r[11], 10);
if (r[9] === '+') {
offsetmins = 0 - offsetmins;
}
}
return Date.UTC(parseInt(r[1], 10), parseInt(r[2], 10) - 1, parseInt(r[3], 10), parseInt(r[4], 10), parseInt(r[5], 10) + offsetmins, isecs, msecs);
}
} else {
return new Date(parseInt(date, 10), 0, 1).getTime();
}
};
Morris.Hover = (function() {
Hover.defaults = {
"class": 'morris-hover morris-default-style'
};
function Hover(options) {
if (options == null) {
options = {};
}
this.options = $.extend({}, Morris.Hover.defaults, options);
this.el = $("<div class='" + this.options["class"] + "'></div>");
this.el.hide();
this.options.parent.append(this.el);
}
Hover.prototype.update = function(html, x, y) {
if (!html) {
return this.hide();
} else {
this.html(html);
this.show();
return this.moveTo(x, y);
}
};
Hover.prototype.html = function(content) {
return this.el.html(content);
};
Hover.prototype.moveTo = function(x, y) {
var hoverHeight, hoverWidth, left, parentHeight, parentWidth, top;
parentWidth = this.options.parent.innerWidth();
parentHeight = this.options.parent.innerHeight();
hoverWidth = this.el.outerWidth();
hoverHeight = this.el.outerHeight();
left = Math.min(Math.max(0, x - hoverWidth / 2), parentWidth - hoverWidth);
if (y != null) {
top = y - hoverHeight - 10;
if (top < 0) {
top = y + 10;
if (top + hoverHeight > parentHeight) {
top = parentHeight / 2 - hoverHeight / 2;
}
}
} else {
top = parentHeight / 2 - hoverHeight / 2;
}
return this.el.css({
left: left + "px",
top: parseInt(top) + "px"
});
};
Hover.prototype.show = function() {
return this.el.show();
};
Hover.prototype.hide = function() {
return this.el.hide();
};
return Hover;
})();
Morris.Line = (function(_super) {
__extends(Line, _super);
function Line(options) {
this.hilight = __bind(this.hilight, this);
this.onHoverOut = __bind(this.onHoverOut, this);
this.onHoverMove = __bind(this.onHoverMove, this);
this.onGridClick = __bind(this.onGridClick, this);
if (!(this instanceof Morris.Line)) {
return new Morris.Line(options);
}
Line.__super__.constructor.call(this, options);
}
Line.prototype.init = function() {
if (this.options.hideHover !== 'always') {
this.hover = new Morris.Hover({
parent: this.el
});
this.on('hovermove', this.onHoverMove);
this.on('hoverout', this.onHoverOut);
return this.on('gridclick', this.onGridClick);
}
};
Line.prototype.defaults = {
lineWidth: 3,
pointSize: 4,
lineColors: ['#0b62a4', '#7A92A3', '#4da74d', '#afd8f8', '#edc240', '#cb4b4b', '#9440ed'],
pointStrokeWidths: [1],
pointStrokeColors: ['#ffffff'],
pointFillColors: [],
smooth: true,
xLabels: 'auto',
xLabelFormat: null,
xLabelMargin: 24,
hideHover: false
};
Line.prototype.calc = function() {
this.calcPoints();
return this.generatePaths();
};
Line.prototype.calcPoints = function() {
var row, y, _i, _len, _ref, _results;
_ref = this.data;
_results = [];
for (_i = 0, _len = _ref.length; _i < _len; _i++) {
row = _ref[_i];
row._x = this.transX(row.x);
row._y = (function() {
var _j, _len1, _ref1, _results1;
_ref1 = row.y;
_results1 = [];
for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
y = _ref1[_j];
if (y != null) {
_results1.push(this.transY(y));
} else {
_results1.push(y);
}
}
return _results1;
}).call(this);
_results.push(row._ymax = Math.min.apply(Math, [this.bottom].concat((function() {
var _j, _len1, _ref1, _results1;
_ref1 = row._y;
_results1 = [];
for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
y = _ref1[_j];
if (y != null) {
_results1.push(y);
}
}
return _results1;
})())));
}
return _results;
};
Line.prototype.hitTest = function(x) {
var index, r, _i, _len, _ref;
if (this.data.length === 0) {
return null;
}
_ref = this.data.slice(1);
for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
r = _ref[index];
if (x < (r._x + this.data[index]._x) / 2) {
break;
}
}
return index;
};
Line.prototype.onGridClick = function(x, y) {
var index;
index = this.hitTest(x);
return this.fire('click', index, this.data[index].src, x, y);
};
Line.prototype.onHoverMove = function(x, y) {
var index;
index = this.hitTest(x);
return this.displayHoverForRow(index);
};
Line.prototype.onHoverOut = function() {
if (this.options.hideHover !== false) {
return this.displayHoverForRow(null);
}
};
Line.prototype.displayHoverForRow = function(index) {
var _ref;
if (index != null) {
(_ref = this.hover).update.apply(_ref, this.hoverContentForRow(index));
return this.hilight(index);
} else {
this.hover.hide();
return this.hilight();
}
};
Line.prototype.hoverContentForRow = function(index) {
var content, j, row, y, _i, _len, _ref;
row = this.data[index];
content = "<div class='morris-hover-row-label'>" + row.label + "</div>";
_ref = row.y;
for (j = _i = 0, _len = _ref.length; _i < _len; j = ++_i) {
y = _ref[j];
content += "<div class='morris-hover-point' style='color: " + (this.colorFor(row, j, 'label')) + "'>\n  " + this.options.labels[j] + ":\n  " + (this.yLabelFormat(y)) + "\n</div>";
}
if (typeof this.options.hoverCallback === 'function') {
content = this.options.hoverCallback(index, this.options, content, row.src);
}
return [content, row._x, row._ymax];
};
Line.prototype.generatePaths = function() {
var coords, i, r, smooth;
return this.paths = (function() {
var _i, _ref, _ref1, _results;
_results = [];
for (i = _i = 0, _ref = this.options.ykeys.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
smooth = typeof this.options.smooth === "boolean" ? this.options.smooth : (_ref1 = this.options.ykeys[i], __indexOf.call(this.options.smooth, _ref1) >= 0);
coords = (function() {
var _j, _len, _ref2, _results1;
_ref2 = this.data;
_results1 = [];
for (_j = 0, _len = _ref2.length; _j < _len; _j++) {
r = _ref2[_j];
if (r._y[i] !== void 0) {
_results1.push({
x: r._x,
y: r._y[i]
});
}
}
return _results1;
}).call(this);
if (coords.length > 1) {
_results.push(Morris.Line.createPath(coords, smooth, this.bottom));
} else {
_results.push(null);
}
}
return _results;
}).call(this);
};
Line.prototype.draw = function() {
var _ref;
if ((_ref = this.options.axes) === true || _ref === 'both' || _ref === 'x') {
this.drawXAxis();
}
this.drawSeries();
if (this.options.hideHover === false) {
return this.displayHoverForRow(this.data.length - 1);
}
};
Line.prototype.drawXAxis = function() {
var drawLabel, l, labels, prevAngleMargin, prevLabelMargin, row, ypos, _i, _len, _results,
_this = this;
ypos = this.bottom + this.options.padding / 2;
prevLabelMargin = null;
prevAngleMargin = null;
drawLabel = function(labelText, xpos) {
var label, labelBox, margin, offset, textBox;
label = _this.drawXAxisLabel(_this.transX(xpos), ypos, labelText);
textBox = label.getBBox();
label.transform("r" + (-_this.options.xLabelAngle));
labelBox = label.getBBox();
label.transform("t0," + (labelBox.height / 2) + "...");
if (_this.options.xLabelAngle !== 0) {
offset = -0.5 * textBox.width * Math.cos(_this.options.xLabelAngle * Math.PI / 180.0);
label.transform("t" + offset + ",0...");
}
labelBox = label.getBBox();
if (((prevLabelMargin == null) || prevLabelMargin >= labelBox.x + labelBox.width || (prevAngleMargin != null) && prevAngleMargin >= labelBox.x) && labelBox.x >= 0 && (labelBox.x + labelBox.width) < _this.el.width()) {
if (_this.options.xLabelAngle !== 0) {
margin = 1.25 * _this.options.gridTextSize / Math.sin(_this.options.xLabelAngle * Math.PI / 180.0);
prevAngleMargin = labelBox.x - margin;
}
return prevLabelMargin = labelBox.x - _this.options.xLabelMargin;
} else {
return label.remove();
}
};
if (this.options.parseTime) {
if (this.data.length === 1 && this.options.xLabels === 'auto') {
labels = [[this.data[0].label, this.data[0].x]];
} else {
labels = Morris.labelSeries(this.xmin, this.xmax, this.width, this.options.xLabels, this.options.xLabelFormat);
}
} else {
labels = (function() {
var _i, _len, _ref, _results;
_ref = this.data;
_results = [];
for (_i = 0, _len = _ref.length; _i < _len; _i++) {
row = _ref[_i];
_results.push([row.label, row.x]);
}
return _results;
}).call(this);
}
labels.reverse();
_results = [];
for (_i = 0, _len = labels.length; _i < _len; _i++) {
l = labels[_i];
_results.push(drawLabel(l[0], l[1]));
}
return _results;
};
Line.prototype.drawSeries = function() {
var i, _i, _j, _ref, _ref1, _results;
this.seriesPoints = [];
for (i = _i = _ref = this.options.ykeys.length - 1; _ref <= 0 ? _i <= 0 : _i >= 0; i = _ref <= 0 ? ++_i : --_i) {
this._drawLineFor(i);
}
_results = [];
for (i = _j = _ref1 = this.options.ykeys.length - 1; _ref1 <= 0 ? _j <= 0 : _j >= 0; i = _ref1 <= 0 ? ++_j : --_j) {
_results.push(this._drawPointFor(i));
}
return _results;
};
Line.prototype._drawPointFor = function(index) {
var circle, row, _i, _len, _ref, _results;
this.seriesPoints[index] = [];
_ref = this.data;
_results = [];
for (_i = 0, _len = _ref.length; _i < _len; _i++) {
row = _ref[_i];
circle = null;
if (row._y[index] != null) {
circle = this.drawLinePoint(row._x, row._y[index], this.colorFor(row, index, 'point'), index);
}
_results.push(this.seriesPoints[index].push(circle));
}
return _results;
};
Line.prototype._drawLineFor = function(index) {
var path;
path = this.paths[index];
if (path !== null) {
return this.drawLinePath(path, this.colorFor(null, index, 'line'), index);
}
};
Line.createPath = function(coords, smooth, bottom) {
var coord, g, grads, i, ix, lg, path, prevCoord, x1, x2, y1, y2, _i, _len;
path = "";
if (smooth) {
grads = Morris.Line.gradients(coords);
}
prevCoord = {
y: null
};
for (i = _i = 0, _len = coords.length; _i < _len; i = ++_i) {
coord = coords[i];
if (coord.y != null) {
if (prevCoord.y != null) {
if (smooth) {
g = grads[i];
lg = grads[i - 1];
ix = (coord.x - prevCoord.x) / 4;
x1 = prevCoord.x + ix;
y1 = Math.min(bottom, prevCoord.y + ix * lg);
x2 = coord.x - ix;
y2 = Math.min(bottom, coord.y - ix * g);
path += "C" + x1 + "," + y1 + "," + x2 + "," + y2 + "," + coord.x + "," + coord.y;
} else {
path += "L" + coord.x + "," + coord.y;
}
} else {
if (!smooth || (grads[i] != null)) {
path += "M" + coord.x + "," + coord.y;
}
}
}
prevCoord = coord;
}
return path;
};
Line.gradients = function(coords) {
var coord, grad, i, nextCoord, prevCoord, _i, _len, _results;
grad = function(a, b) {
return (a.y - b.y) / (a.x - b.x);
};
_results = [];
for (i = _i = 0, _len = coords.length; _i < _len; i = ++_i) {
coord = coords[i];
if (coord.y != null) {
nextCoord = coords[i + 1] || {
y: null
};
prevCoord = coords[i - 1] || {
y: null
};
if ((prevCoord.y != null) && (nextCoord.y != null)) {
_results.push(grad(prevCoord, nextCoord));
} else if (prevCoord.y != null) {
_results.push(grad(prevCoord, coord));
} else if (nextCoord.y != null) {
_results.push(grad(coord, nextCoord));
} else {
_results.push(null);
}
} else {
_results.push(null);
}
}
return _results;
};
Line.prototype.hilight = function(index) {
var i, _i, _j, _ref, _ref1;
if (this.prevHilight !== null && this.prevHilight !== index) {
for (i = _i = 0, _ref = this.seriesPoints.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
if (this.seriesPoints[i][this.prevHilight]) {
this.seriesPoints[i][this.prevHilight].animate(this.pointShrinkSeries(i));
}
}
}
if (index !== null && this.prevHilight !== index) {
for (i = _j = 0, _ref1 = this.seriesPoints.length - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
if (this.seriesPoints[i][index]) {
this.seriesPoints[i][index].animate(this.pointGrowSeries(i));
}
}
}
return this.prevHilight = index;
};
Line.prototype.colorFor = function(row, sidx, type) {
if (typeof this.options.lineColors === 'function') {
return this.options.lineColors.call(this, row, sidx, type);
} else if (type === 'point') {
return this.options.pointFillColors[sidx % this.options.pointFillColors.length] || this.options.lineColors[sidx % this.options.lineColors.length];
} else {
return this.options.lineColors[sidx % this.options.lineColors.length];
}
};
Line.prototype.drawXAxisLabel = function(xPos, yPos, text) {
return this.raphael.text(xPos, yPos, text).attr('font-size', this.options.gridTextSize).attr('font-family', this.options.gridTextFamily).attr('font-weight', this.options.gridTextWeight).attr('fill', this.options.gridTextColor);
};
Line.prototype.drawLinePath = function(path, lineColor, lineIndex) {
return this.raphael.path(path).attr('stroke', lineColor).attr('stroke-width', this.lineWidthForSeries(lineIndex));
};
Line.prototype.drawLinePoint = function(xPos, yPos, pointColor, lineIndex) {
return this.raphael.circle(xPos, yPos, this.pointSizeForSeries(lineIndex)).attr('fill', pointColor).attr('stroke-width', this.pointStrokeWidthForSeries(lineIndex)).attr('stroke', this.pointStrokeColorForSeries(lineIndex));
};
Line.prototype.pointStrokeWidthForSeries = function(index) {
return this.options.pointStrokeWidths[index % this.options.pointStrokeWidths.length];
};
Line.prototype.pointStrokeColorForSeries = function(index) {
return this.options.pointStrokeColors[index % this.options.pointStrokeColors.length];
};
Line.prototype.lineWidthForSeries = function(index) {
if (this.options.lineWidth instanceof Array) {
return this.options.lineWidth[index % this.options.lineWidth.length];
} else {
return this.options.lineWidth;
}
};
Line.prototype.pointSizeForSeries = function(index) {
if (this.options.pointSize instanceof Array) {
return this.options.pointSize[index % this.options.pointSize.length];
} else {
return this.options.pointSize;
}
};
Line.prototype.pointGrowSeries = function(index) {
return Raphael.animation({
r: this.pointSizeForSeries(index) + 3
}, 25, 'linear');
};
Line.prototype.pointShrinkSeries = function(index) {
return Raphael.animation({
r: this.pointSizeForSeries(index)
}, 25, 'linear');
};
return Line;
})(Morris.Grid);
Morris.labelSeries = function(dmin, dmax, pxwidth, specName, xLabelFormat) {
var d, d0, ddensity, name, ret, s, spec, t, _i, _len, _ref;
ddensity = 200 * (dmax - dmin) / pxwidth;
d0 = new Date(dmin);
spec = Morris.LABEL_SPECS[specName];
if (spec === void 0) {
_ref = Morris.AUTO_LABEL_ORDER;
for (_i = 0, _len = _ref.length; _i < _len; _i++) {
name = _ref[_i];
s = Morris.LABEL_SPECS[name];
if (ddensity >= s.span) {
spec = s;
break;
}
}
}
if (spec === void 0) {
spec = Morris.LABEL_SPECS["second"];
}
if (xLabelFormat) {
spec = $.extend({}, spec, {
fmt: xLabelFormat
});
}
d = spec.start(d0);
ret = [];
while ((t = d.getTime()) <= dmax) {
if (t >= dmin) {
ret.push([spec.fmt(d), t]);
}
spec.incr(d);
}
return ret;
};
minutesSpecHelper = function(interval) {
return {
span: interval * 60 * 1000,
start: function(d) {
return new Date(d.getFullYear(), d.getMonth(), d.getDate(), d.getHours());
},
fmt: function(d) {
return "" + (Morris.pad2(d.getHours())) + ":" + (Morris.pad2(d.getMinutes()));
},
incr: function(d) {
return d.setUTCMinutes(d.getUTCMinutes() + interval);
}
};
};
secondsSpecHelper = function(interval) {
return {
span: interval * 1000,
start: function(d) {
return new Date(d.getFullYear(), d.getMonth(), d.getDate(), d.getHours(), d.getMinutes());
},
fmt: function(d) {
return "" + (Morris.pad2(d.getHours())) + ":" + (Morris.pad2(d.getMinutes())) + ":" + (Morris.pad2(d.getSeconds()));
},
incr: function(d) {
return d.setUTCSeconds(d.getUTCSeconds() + interval);
}
};
};
Morris.LABEL_SPECS = {
"decade": {
span: 172800000000,
start: function(d) {
return new Date(d.getFullYear() - d.getFullYear() % 10, 0, 1);
},
fmt: function(d) {
return "" + (d.getFullYear());
},
incr: function(d) {
return d.setFullYear(d.getFullYear() + 10);
}
},
"year": {
span: 17280000000,
start: function(d) {
return new Date(d.getFullYear(), 0, 1);
},
fmt: function(d) {
return "" + (d.getFullYear());
},
incr: function(d) {
return d.setFullYear(d.getFullYear() + 1);
}
},
"month": {
span: 2419200000,
start: function(d) {
return new Date(d.getFullYear(), d.getMonth(), 1);
},
fmt: function(d) {
return "" + (d.getFullYear()) + "-" + (Morris.pad2(d.getMonth() + 1));
},
incr: function(d) {
return d.setMonth(d.getMonth() + 1);
}
},
"week": {
span: 604800000,
start: function(d) {
return new Date(d.getFullYear(), d.getMonth(), d.getDate());
},
fmt: function(d) {
return "" + (d.getFullYear()) + "-" + (Morris.pad2(d.getMonth() + 1)) + "-" + (Morris.pad2(d.getDate()));
},
incr: function(d) {
return d.setDate(d.getDate() + 7);
}
},
"day": {
span: 86400000,
start: function(d) {
return new Date(d.getFullYear(), d.getMonth(), d.getDate());
},
fmt: function(d) {
return "" + (d.getFullYear()) + "-" + (Morris.pad2(d.getMonth() + 1)) + "-" + (Morris.pad2(d.getDate()));
},
incr: function(d) {
return d.setDate(d.getDate() + 1);
}
},
"hour": minutesSpecHelper(60),
"30min": minutesSpecHelper(30),
"15min": minutesSpecHelper(15),
"10min": minutesSpecHelper(10),
"5min": minutesSpecHelper(5),
"minute": minutesSpecHelper(1),
"30sec": secondsSpecHelper(30),
"15sec": secondsSpecHelper(15),
"10sec": secondsSpecHelper(10),
"5sec": secondsSpecHelper(5),
"second": secondsSpecHelper(1)
};
Morris.AUTO_LABEL_ORDER = ["decade", "year", "month", "week", "day", "hour", "30min", "15min", "10min", "5min", "minute", "30sec", "15sec", "10sec", "5sec", "second"];
Morris.Area = (function(_super) {
var areaDefaults;
__extends(Area, _super);
areaDefaults = {
fillOpacity: 'auto',
behaveLikeLine: false
};
function Area(options) {
var areaOptions;
if (!(this instanceof Morris.Area)) {
return new Morris.Area(options);
}
areaOptions = $.extend({}, areaDefaults, options);
this.cumulative = !areaOptions.behaveLikeLine;
if (areaOptions.fillOpacity === 'auto') {
areaOptions.fillOpacity = areaOptions.behaveLikeLine ? .8 : 1;
}
Area.__super__.constructor.call(this, areaOptions);
}
Area.prototype.calcPoints = function() {
var row, total, y, _i, _len, _ref, _results;
_ref = this.data;
_results = [];
for (_i = 0, _len = _ref.length; _i < _len; _i++) {
row = _ref[_i];
row._x = this.transX(row.x);
total = 0;
row._y = (function() {
var _j, _len1, _ref1, _results1;
_ref1 = row.y;
_results1 = [];
for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
y = _ref1[_j];
if (this.options.behaveLikeLine) {
_results1.push(this.transY(y));
} else {
total += y || 0;
_results1.push(this.transY(total));
}
}
return _results1;
}).call(this);
_results.push(row._ymax = Math.max.apply(Math, row._y));
}
return _results;
};
Area.prototype.drawSeries = function() {
var i, range, _i, _j, _k, _len, _ref, _ref1, _results, _results1, _results2;
this.seriesPoints = [];
if (this.options.behaveLikeLine) {
range = (function() {
_results = [];
for (var _i = 0, _ref = this.options.ykeys.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; 0 <= _ref ? _i++ : _i--){ _results.push(_i); }
return _results;
}).apply(this);
} else {
range = (function() {
_results1 = [];
for (var _j = _ref1 = this.options.ykeys.length - 1; _ref1 <= 0 ? _j <= 0 : _j >= 0; _ref1 <= 0 ? _j++ : _j--){ _results1.push(_j); }
return _results1;
}).apply(this);
}
_results2 = [];
for (_k = 0, _len = range.length; _k < _len; _k++) {
i = range[_k];
this._drawFillFor(i);
this._drawLineFor(i);
_results2.push(this._drawPointFor(i));
}
return _results2;
};
Area.prototype._drawFillFor = function(index) {
var path;
path = this.paths[index];
if (path !== null) {
path = path + ("L" + (this.transX(this.xmax)) + "," + this.bottom + "L" + (this.transX(this.xmin)) + "," + this.bottom + "Z");
return this.drawFilledPath(path, this.fillForSeries(index));
}
};
Area.prototype.fillForSeries = function(i) {
var color;
color = Raphael.rgb2hsl(this.colorFor(this.data[i], i, 'line'));
return Raphael.hsl(color.h, this.options.behaveLikeLine ? color.s * 0.9 : color.s * 0.75, Math.min(0.98, this.options.behaveLikeLine ? color.l * 1.2 : color.l * 1.25));
};
Area.prototype.drawFilledPath = function(path, fill) {
return this.raphael.path(path).attr('fill', fill).attr('fill-opacity', this.options.fillOpacity).attr('stroke', 'none');
};
return Area;
})(Morris.Line);
Morris.Bar = (function(_super) {
__extends(Bar, _super);
function Bar(options) {
this.onHoverOut = __bind(this.onHoverOut, this);
this.onHoverMove = __bind(this.onHoverMove, this);
this.onGridClick = __bind(this.onGridClick, this);
if (!(this instanceof Morris.Bar)) {
return new Morris.Bar(options);
}
Bar.__super__.constructor.call(this, $.extend({}, options, {
parseTime: false
}));
}
Bar.prototype.init = function() {
this.cumulative = this.options.stacked;
if (this.options.hideHover !== 'always') {
this.hover = new Morris.Hover({
parent: this.el
});
this.on('hovermove', this.onHoverMove);
this.on('hoverout', this.onHoverOut);
return this.on('gridclick', this.onGridClick);
}
};
Bar.prototype.defaults = {
barSizeRatio: 0.75,
barGap: 3,
barColors: ['#0b62a4', '#7a92a3', '#4da74d', '#afd8f8', '#edc240', '#cb4b4b', '#9440ed'],
barOpacity: 1.0,
barRadius: [0, 0, 0, 0],
xLabelMargin: 50
};
Bar.prototype.calc = function() {
var _ref;
this.calcBars();
if (this.options.hideHover === false) {
return (_ref = this.hover).update.apply(_ref, this.hoverContentForRow(this.data.length - 1));
}
};
Bar.prototype.calcBars = function() {
var idx, row, y, _i, _len, _ref, _results;
_ref = this.data;
_results = [];
for (idx = _i = 0, _len = _ref.length; _i < _len; idx = ++_i) {
row = _ref[idx];
row._x = this.left + this.width * (idx + 0.5) / this.data.length;
_results.push(row._y = (function() {
var _j, _len1, _ref1, _results1;
_ref1 = row.y;
_results1 = [];
for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
y = _ref1[_j];
if (y != null) {
_results1.push(this.transY(y));
} else {
_results1.push(null);
}
}
return _results1;
}).call(this));
}
return _results;
};
Bar.prototype.draw = function() {
var _ref;
if ((_ref = this.options.axes) === true || _ref === 'both' || _ref === 'x') {
this.drawXAxis();
}
return this.drawSeries();
};
Bar.prototype.drawXAxis = function() {
var i, label, labelBox, margin, offset, prevAngleMargin, prevLabelMargin, row, textBox, ypos, _i, _ref, _results;
ypos = this.bottom + (this.options.xAxisLabelTopPadding || this.options.padding / 2);
prevLabelMargin = null;
prevAngleMargin = null;
_results = [];
for (i = _i = 0, _ref = this.data.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
row = this.data[this.data.length - 1 - i];
label = this.drawXAxisLabel(row._x, ypos, row.label);
textBox = label.getBBox();
label.transform("r" + (-this.options.xLabelAngle));
labelBox = label.getBBox();
label.transform("t0," + (labelBox.height / 2) + "...");
if (this.options.xLabelAngle !== 0) {
offset = -0.5 * textBox.width * Math.cos(this.options.xLabelAngle * Math.PI / 180.0);
label.transform("t" + offset + ",0...");
}
if (((prevLabelMargin == null) || prevLabelMargin >= labelBox.x + labelBox.width || (prevAngleMargin != null) && prevAngleMargin >= labelBox.x) && labelBox.x >= 0 && (labelBox.x + labelBox.width) < this.el.width()) {
if (this.options.xLabelAngle !== 0) {
margin = 1.25 * this.options.gridTextSize / Math.sin(this.options.xLabelAngle * Math.PI / 180.0);
prevAngleMargin = labelBox.x - margin;
}
_results.push(prevLabelMargin = labelBox.x - this.options.xLabelMargin);
} else {
_results.push(label.remove());
}
}
return _results;
};
Bar.prototype.drawSeries = function() {
var barWidth, bottom, groupWidth, idx, lastTop, left, leftPadding, numBars, row, sidx, size, spaceLeft, top, ypos, zeroPos;
groupWidth = this.width / this.options.data.length;
numBars = this.options.stacked ? 1 : this.options.ykeys.length;
barWidth = (groupWidth * this.options.barSizeRatio - this.options.barGap * (numBars - 1)) / numBars;
if (this.options.barSize) {
barWidth = Math.min(barWidth, this.options.barSize);
}
spaceLeft = groupWidth - barWidth * numBars - this.options.barGap * (numBars - 1);
leftPadding = spaceLeft / 2;
zeroPos = this.ymin <= 0 && this.ymax >= 0 ? this.transY(0) : null;
return this.bars = (function() {
var _i, _len, _ref, _results;
_ref = this.data;
_results = [];
for (idx = _i = 0, _len = _ref.length; _i < _len; idx = ++_i) {
row = _ref[idx];
lastTop = 0;
_results.push((function() {
var _j, _len1, _ref1, _results1;
_ref1 = row._y;
_results1 = [];
for (sidx = _j = 0, _len1 = _ref1.length; _j < _len1; sidx = ++_j) {
ypos = _ref1[sidx];
if (ypos !== null) {
if (zeroPos) {
top = Math.min(ypos, zeroPos);
bottom = Math.max(ypos, zeroPos);
} else {
top = ypos;
bottom = this.bottom;
}
left = this.left + idx * groupWidth + leftPadding;
if (!this.options.stacked) {
left += sidx * (barWidth + this.options.barGap);
}
size = bottom - top;
if (this.options.verticalGridCondition && this.options.verticalGridCondition(row.x)) {
this.drawBar(this.left + idx * groupWidth, this.top, groupWidth, Math.abs(this.top - this.bottom), this.options.verticalGridColor, this.options.verticalGridOpacity, this.options.barRadius);
}
if (this.options.stacked) {
top -= lastTop;
}
this.drawBar(left, top, barWidth, size, this.colorFor(row, sidx, 'bar'), this.options.barOpacity, this.options.barRadius);
_results1.push(lastTop += size);
} else {
_results1.push(null);
}
}
return _results1;
}).call(this));
}
return _results;
}).call(this);
};
Bar.prototype.colorFor = function(row, sidx, type) {
var r, s;
if (typeof this.options.barColors === 'function') {
r = {
x: row.x,
y: row.y[sidx],
label: row.label
};
s = {
index: sidx,
key: this.options.ykeys[sidx],
label: this.options.labels[sidx]
};
return this.options.barColors.call(this, r, s, type);
} else {
return this.options.barColors[sidx % this.options.barColors.length];
}
};
Bar.prototype.hitTest = function(x) {
if (this.data.length === 0) {
return null;
}
x = Math.max(Math.min(x, this.right), this.left);
return Math.min(this.data.length - 1, Math.floor((x - this.left) / (this.width / this.data.length)));
};
Bar.prototype.onGridClick = function(x, y) {
var index;
index = this.hitTest(x);
return this.fire('click', index, this.data[index].src, x, y);
};
Bar.prototype.onHoverMove = function(x, y) {
var index, _ref;
index = this.hitTest(x);
return (_ref = this.hover).update.apply(_ref, this.hoverContentForRow(index));
};
Bar.prototype.onHoverOut = function() {
if (this.options.hideHover !== false) {
return this.hover.hide();
}
};
Bar.prototype.hoverContentForRow = function(index) {
var content, j, row, x, y, _i, _len, _ref;
row = this.data[index];
content = "<div class='morris-hover-row-label'>" + row.label + "</div>";
_ref = row.y;
for (j = _i = 0, _len = _ref.length; _i < _len; j = ++_i) {
y = _ref[j];
content += "<div class='morris-hover-point' style='color: " + (this.colorFor(row, j, 'label')) + "'>\n  " + this.options.labels[j] + ":\n  " + (this.yLabelFormat(y)) + "\n</div>";
}
if (typeof this.options.hoverCallback === 'function') {
content = this.options.hoverCallback(index, this.options, content, row.src);
}
x = this.left + (index + 0.5) * this.width / this.data.length;
return [content, x];
};
Bar.prototype.drawXAxisLabel = function(xPos, yPos, text) {
var label;
return label = this.raphael.text(xPos, yPos, text).attr('font-size', this.options.gridTextSize).attr('font-family', this.options.gridTextFamily).attr('font-weight', this.options.gridTextWeight).attr('fill', this.options.gridTextColor);
};
Bar.prototype.drawBar = function(xPos, yPos, width, height, barColor, opacity, radiusArray) {
var maxRadius, path;
maxRadius = Math.max.apply(Math, radiusArray);
if (maxRadius === 0 || maxRadius > height) {
path = this.raphael.rect(xPos, yPos, width, height);
} else {
path = this.raphael.path(this.roundedRect(xPos, yPos, width, height, radiusArray));
}
return path.attr('fill', barColor).attr('fill-opacity', opacity).attr('stroke', 'none');
};
Bar.prototype.roundedRect = function(x, y, w, h, r) {
if (r == null) {
r = [0, 0, 0, 0];
}
return ["M", x, r[0] + y, "Q", x, y, x + r[0], y, "L", x + w - r[1], y, "Q", x + w, y, x + w, y + r[1], "L", x + w, y + h - r[2], "Q", x + w, y + h, x + w - r[2], y + h, "L", x + r[3], y + h, "Q", x, y + h, x, y + h - r[3], "Z"];
};
return Bar;
})(Morris.Grid);
Morris.Donut = (function(_super) {
__extends(Donut, _super);
Donut.prototype.defaults = {
colors: ['#0B62A4', '#3980B5', '#679DC6', '#95BBD7', '#B0CCE1', '#095791', '#095085', '#083E67', '#052C48', '#042135'],
backgroundColor: '#FFFFFF',
labelColor: '#000000',
formatter: Morris.commas,
resize: false
};
function Donut(options) {
this.resizeHandler = __bind(this.resizeHandler, this);
this.select = __bind(this.select, this);
this.click = __bind(this.click, this);
var _this = this;
if (!(this instanceof Morris.Donut)) {
return new Morris.Donut(options);
}
this.options = $.extend({}, this.defaults, options);
if (typeof options.element === 'string') {
this.el = $(document.getElementById(options.element));
} else {
this.el = $(options.element);
}
if (this.el === null || this.el.length === 0) {
throw new Error("Graph placeholder not found.");
}
if (options.data === void 0 || options.data.length === 0) {
return;
}
this.raphael = new Raphael(this.el[0]);
if (this.options.resize) {
$(window).bind('resize', function(evt) {
if (_this.timeoutId != null) {
window.clearTimeout(_this.timeoutId);
}
return _this.timeoutId = window.setTimeout(_this.resizeHandler, 100);
});
}
this.setData(options.data);
}
Donut.prototype.redraw = function() {
var C, cx, cy, i, idx, last, max_value, min, next, seg, total, value, w, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _results;
this.raphael.clear();
cx = this.el.width() / 2;
cy = this.el.height() / 2;
w = (Math.min(cx, cy) - 10) / 3;
total = 0;
_ref = this.values;
for (_i = 0, _len = _ref.length; _i < _len; _i++) {
value = _ref[_i];
total += value;
}
min = 5 / (2 * w);
C = 1.9999 * Math.PI - min * this.data.length;
last = 0;
idx = 0;
this.segments = [];
_ref1 = this.values;
for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
value = _ref1[i];
next = last + min + C * (value / total);
seg = new Morris.DonutSegment(cx, cy, w * 2, w, last, next, this.data[i].color || this.options.colors[idx % this.options.colors.length], this.options.backgroundColor, idx, this.raphael);
seg.render();
this.segments.push(seg);
seg.on('hover', this.select);
seg.on('click', this.click);
last = next;
idx += 1;
}
this.text1 = this.drawEmptyDonutLabel(cx, cy - 10, this.options.labelColor, 15, 800);
this.text2 = this.drawEmptyDonutLabel(cx, cy + 10, this.options.labelColor, 14);
max_value = Math.max.apply(Math, this.values);
idx = 0;
_ref2 = this.values;
_results = [];
for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
value = _ref2[_k];
if (value === max_value) {
this.select(idx);
break;
}
_results.push(idx += 1);
}
return _results;
};
Donut.prototype.setData = function(data) {
var row;
this.data = data;
this.values = (function() {
var _i, _len, _ref, _results;
_ref = this.data;
_results = [];
for (_i = 0, _len = _ref.length; _i < _len; _i++) {
row = _ref[_i];
_results.push(parseFloat(row.value));
}
return _results;
}).call(this);
return this.redraw();
};
Donut.prototype.click = function(idx) {
return this.fire('click', idx, this.data[idx]);
};
Donut.prototype.select = function(idx) {
var row, s, segment, _i, _len, _ref;
_ref = this.segments;
for (_i = 0, _len = _ref.length; _i < _len; _i++) {
s = _ref[_i];
s.deselect();
}
segment = this.segments[idx];
segment.select();
row = this.data[idx];
return this.setLabels(row.label, this.options.formatter(row.value, row));
};
Donut.prototype.setLabels = function(label1, label2) {
var inner, maxHeightBottom, maxHeightTop, maxWidth, text1bbox, text1scale, text2bbox, text2scale;
inner = (Math.min(this.el.width() / 2, this.el.height() / 2) - 10) * 2 / 3;
maxWidth = 1.8 * inner;
maxHeightTop = inner / 2;
maxHeightBottom = inner / 3;
this.text1.attr({
text: label1,
transform: ''
});
text1bbox = this.text1.getBBox();
text1scale = Math.min(maxWidth / text1bbox.width, maxHeightTop / text1bbox.height);
this.text1.attr({
transform: "S" + text1scale + "," + text1scale + "," + (text1bbox.x + text1bbox.width / 2) + "," + (text1bbox.y + text1bbox.height)
});
this.text2.attr({
text: label2,
transform: ''
});
text2bbox = this.text2.getBBox();
text2scale = Math.min(maxWidth / text2bbox.width, maxHeightBottom / text2bbox.height);
return this.text2.attr({
transform: "S" + text2scale + "," + text2scale + "," + (text2bbox.x + text2bbox.width / 2) + "," + text2bbox.y
});
};
Donut.prototype.drawEmptyDonutLabel = function(xPos, yPos, color, fontSize, fontWeight) {
var text;
text = this.raphael.text(xPos, yPos, '').attr('font-size', fontSize).attr('fill', color);
if (fontWeight != null) {
text.attr('font-weight', fontWeight);
}
return text;
};
Donut.prototype.resizeHandler = function() {
this.timeoutId = null;
this.raphael.setSize(this.el.width(), this.el.height());
return this.redraw();
};
return Donut;
})(Morris.EventEmitter);
Morris.DonutSegment = (function(_super) {
__extends(DonutSegment, _super);
function DonutSegment(cx, cy, inner, outer, p0, p1, color, backgroundColor, index, raphael) {
this.cx = cx;
this.cy = cy;
this.inner = inner;
this.outer = outer;
this.color = color;
this.backgroundColor = backgroundColor;
this.index = index;
this.raphael = raphael;
this.deselect = __bind(this.deselect, this);
this.select = __bind(this.select, this);
this.sin_p0 = Math.sin(p0);
this.cos_p0 = Math.cos(p0);
this.sin_p1 = Math.sin(p1);
this.cos_p1 = Math.cos(p1);
this.is_long = (p1 - p0) > Math.PI ? 1 : 0;
this.path = this.calcSegment(this.inner + 3, this.inner + this.outer - 5);
this.selectedPath = this.calcSegment(this.inner + 3, this.inner + this.outer);
this.hilight = this.calcArc(this.inner);
}
DonutSegment.prototype.calcArcPoints = function(r) {
return [this.cx + r * this.sin_p0, this.cy + r * this.cos_p0, this.cx + r * this.sin_p1, this.cy + r * this.cos_p1];
};
DonutSegment.prototype.calcSegment = function(r1, r2) {
var ix0, ix1, iy0, iy1, ox0, ox1, oy0, oy1, _ref, _ref1;
_ref = this.calcArcPoints(r1), ix0 = _ref[0], iy0 = _ref[1], ix1 = _ref[2], iy1 = _ref[3];
_ref1 = this.calcArcPoints(r2), ox0 = _ref1[0], oy0 = _ref1[1], ox1 = _ref1[2], oy1 = _ref1[3];
return ("M" + ix0 + "," + iy0) + ("A" + r1 + "," + r1 + ",0," + this.is_long + ",0," + ix1 + "," + iy1) + ("L" + ox1 + "," + oy1) + ("A" + r2 + "," + r2 + ",0," + this.is_long + ",1," + ox0 + "," + oy0) + "Z";
};
DonutSegment.prototype.calcArc = function(r) {
var ix0, ix1, iy0, iy1, _ref;
_ref = this.calcArcPoints(r), ix0 = _ref[0], iy0 = _ref[1], ix1 = _ref[2], iy1 = _ref[3];
return ("M" + ix0 + "," + iy0) + ("A" + r + "," + r + ",0," + this.is_long + ",0," + ix1 + "," + iy1);
};
DonutSegment.prototype.render = function() {
var _this = this;
this.arc = this.drawDonutArc(this.hilight, this.color);
return this.seg = this.drawDonutSegment(this.path, this.color, this.backgroundColor, function() {
return _this.fire('hover', _this.index);
}, function() {
return _this.fire('click', _this.index);
});
};
DonutSegment.prototype.drawDonutArc = function(path, color) {
return this.raphael.path(path).attr({
stroke: color,
'stroke-width': 2,
opacity: 0
});
};
DonutSegment.prototype.drawDonutSegment = function(path, fillColor, strokeColor, hoverFunction, clickFunction) {
return this.raphael.path(path).attr({
fill: fillColor,
stroke: strokeColor,
'stroke-width': 3
}).hover(hoverFunction).click(clickFunction);
};
DonutSegment.prototype.select = function() {
if (!this.selected) {
this.seg.animate({
path: this.selectedPath
}, 150, '<>');
this.arc.animate({
opacity: 1
}, 150, '<>');
return this.selected = true;
}
};
DonutSegment.prototype.deselect = function() {
if (this.selected) {
this.seg.animate({
path: this.path
}, 150, '<>');
this.arc.animate({
opacity: 0
}, 150, '<>');
return this.selected = false;
}
};
return DonutSegment;
})(Morris.EventEmitter);
}).call(this);
(function (root, factory) {
if (typeof define === 'function' && define.amd) {
define('Chartist', [], function () {
return (root['Chartist'] = factory());
});
} else if (typeof module === 'object' && module.exports) {
module.exports = factory();
} else {
root['Chartist'] = factory();
}
}(this, function () {
var Chartist = {
version: '0.11.0'
};
(function (window, document, Chartist) {
'use strict';
Chartist.namespaces = {
svg: 'http://www.w3.org/2000/svg',
xmlns: 'http://www.w3.org/2000/xmlns/',
xhtml: 'http://www.w3.org/1999/xhtml',
xlink: 'http://www.w3.org/1999/xlink',
ct: 'http://gionkunz.github.com/chartist-js/ct'
};
Chartist.noop = function (n) {
return n;
};
Chartist.alphaNumerate = function (n) {
return String.fromCharCode(97 + n % 26);
};
Chartist.extend = function (target) {
var i, source, sourceProp;
target = target || {};
for (i = 1; i < arguments.length; i++) {
source = arguments[i];
for (var prop in source) {
sourceProp = source[prop];
if (typeof sourceProp === 'object' && sourceProp !== null && !(sourceProp instanceof Array)) {
target[prop] = Chartist.extend(target[prop], sourceProp);
} else {
target[prop] = sourceProp;
}
}
}
return target;
};
Chartist.replaceAll = function(str, subStr, newSubStr) {
return str.replace(new RegExp(subStr, 'g'), newSubStr);
};
Chartist.ensureUnit = function(value, unit) {
if(typeof value === 'number') {
value = value + unit;
}
return value;
};
Chartist.quantity = function(input) {
if (typeof input === 'string') {
var match = (/^(\d+)\s*(.*)$/g).exec(input);
return {
value : +match[1],
unit: match[2] || undefined
};
}
return { value: input };
};
Chartist.querySelector = function(query) {
return query instanceof Node ? query : document.querySelector(query);
};
Chartist.times = function(length) {
return Array.apply(null, new Array(length));
};
Chartist.sum = function(previous, current) {
return previous + (current ? current : 0);
};
Chartist.mapMultiply = function(factor) {
return function(num) {
return num * factor;
};
};
Chartist.mapAdd = function(addend) {
return function(num) {
return num + addend;
};
};
Chartist.serialMap = function(arr, cb) {
var result = [],
length = Math.max.apply(null, arr.map(function(e) {
return e.length;
}));
Chartist.times(length).forEach(function(e, index) {
var args = arr.map(function(e) {
return e[index];
});
result[index] = cb.apply(null, args);
});
return result;
};
Chartist.roundWithPrecision = function(value, digits) {
var precision = Math.pow(10, digits || Chartist.precision);
return Math.round(value * precision) / precision;
};
Chartist.precision = 8;
Chartist.escapingMap = {
'&': '&amp;',
'<': '&lt;',
'>': '&gt;',
'"': '&quot;',
'\'': '&#039;'
};
Chartist.serialize = function(data) {
if(data === null || data === undefined) {
return data;
} else if(typeof data === 'number') {
data = ''+data;
} else if(typeof data === 'object') {
data = JSON.stringify({data: data});
}
return Object.keys(Chartist.escapingMap).reduce(function(result, key) {
return Chartist.replaceAll(result, key, Chartist.escapingMap[key]);
}, data);
};
Chartist.deserialize = function(data) {
if(typeof data !== 'string') {
return data;
}
data = Object.keys(Chartist.escapingMap).reduce(function(result, key) {
return Chartist.replaceAll(result, Chartist.escapingMap[key], key);
}, data);
try {
data = JSON.parse(data);
data = data.data !== undefined ? data.data : data;
} catch(e) {}
return data;
};
Chartist.createSvg = function (container, width, height, className) {
var svg;
width = width || '100%';
height = height || '100%';
Array.prototype.slice.call(container.querySelectorAll('svg')).filter(function filterChartistSvgObjects(svg) {
return svg.getAttributeNS(Chartist.namespaces.xmlns, 'ct');
}).forEach(function removePreviousElement(svg) {
container.removeChild(svg);
});
svg = new Chartist.Svg('svg').attr({
width: width,
height: height
}).addClass(className);
svg._node.style.width = width;
svg._node.style.height = height;
container.appendChild(svg._node);
return svg;
};
Chartist.normalizeData = function(data, reverse, multi) {
var labelCount;
var output = {
raw: data,
normalized: {}
};
output.normalized.series = Chartist.getDataArray({
series: data.series || []
}, reverse, multi);
if (output.normalized.series.every(function(value) {
return value instanceof Array;
})) {
labelCount = Math.max.apply(null, output.normalized.series.map(function(series) {
return series.length;
}));
} else {
labelCount = output.normalized.series.length;
}
output.normalized.labels = (data.labels || []).slice();
Array.prototype.push.apply(
output.normalized.labels,
Chartist.times(Math.max(0, labelCount - output.normalized.labels.length)).map(function() {
return '';
})
);
if(reverse) {
Chartist.reverseData(output.normalized);
}
return output;
};
Chartist.safeHasProperty = function(object, property) {
return object !== null &&
typeof object === 'object' &&
object.hasOwnProperty(property);
};
Chartist.isDataHoleValue = function(value) {
return value === null ||
value === undefined ||
(typeof value === 'number' && isNaN(value));
};
Chartist.reverseData = function(data) {
data.labels.reverse();
data.series.reverse();
for (var i = 0; i < data.series.length; i++) {
if(typeof(data.series[i]) === 'object' && data.series[i].data !== undefined) {
data.series[i].data.reverse();
} else if(data.series[i] instanceof Array) {
data.series[i].reverse();
}
}
};
Chartist.getDataArray = function(data, reverse, multi) {
function recursiveConvert(value) {
if(Chartist.safeHasProperty(value, 'value')) {
return recursiveConvert(value.value);
} else if(Chartist.safeHasProperty(value, 'data')) {
return recursiveConvert(value.data);
} else if(value instanceof Array) {
return value.map(recursiveConvert);
} else if(Chartist.isDataHoleValue(value)) {
return undefined;
} else {
if(multi) {
var multiValue = {};
if(typeof multi === 'string') {
multiValue[multi] = Chartist.getNumberOrUndefined(value);
} else {
multiValue.y = Chartist.getNumberOrUndefined(value);
}
multiValue.x = value.hasOwnProperty('x') ? Chartist.getNumberOrUndefined(value.x) : multiValue.x;
multiValue.y = value.hasOwnProperty('y') ? Chartist.getNumberOrUndefined(value.y) : multiValue.y;
return multiValue;
} else {
return Chartist.getNumberOrUndefined(value);
}
}
}
return data.series.map(recursiveConvert);
};
Chartist.normalizePadding = function(padding, fallback) {
fallback = fallback || 0;
return typeof padding === 'number' ? {
top: padding,
right: padding,
bottom: padding,
left: padding
} : {
top: typeof padding.top === 'number' ? padding.top : fallback,
right: typeof padding.right === 'number' ? padding.right : fallback,
bottom: typeof padding.bottom === 'number' ? padding.bottom : fallback,
left: typeof padding.left === 'number' ? padding.left : fallback
};
};
Chartist.getMetaData = function(series, index) {
var value = series.data ? series.data[index] : series[index];
return value ? value.meta : undefined;
};
Chartist.orderOfMagnitude = function (value) {
return Math.floor(Math.log(Math.abs(value)) / Math.LN10);
};
Chartist.projectLength = function (axisLength, length, bounds) {
return length / bounds.range * axisLength;
};
Chartist.getAvailableHeight = function (svg, options) {
return Math.max((Chartist.quantity(options.height).value || svg.height()) - (options.chartPadding.top +  options.chartPadding.bottom) - options.axisX.offset, 0);
};
Chartist.getHighLow = function (data, options, dimension) {
options = Chartist.extend({}, options, dimension ? options['axis' + dimension.toUpperCase()] : {});
var highLow = {
high: options.high === undefined ? -Number.MAX_VALUE : +options.high,
low: options.low === undefined ? Number.MAX_VALUE : +options.low
};
var findHigh = options.high === undefined;
var findLow = options.low === undefined;
function recursiveHighLow(data) {
if(data === undefined) {
return undefined;
} else if(data instanceof Array) {
for (var i = 0; i < data.length; i++) {
recursiveHighLow(data[i]);
}
} else {
var value = dimension ? +data[dimension] : +data;
if (findHigh && value > highLow.high) {
highLow.high = value;
}
if (findLow && value < highLow.low) {
highLow.low = value;
}
}
}
if(findHigh || findLow) {
recursiveHighLow(data);
}
if (options.referenceValue || options.referenceValue === 0) {
highLow.high = Math.max(options.referenceValue, highLow.high);
highLow.low = Math.min(options.referenceValue, highLow.low);
}
if (highLow.high <= highLow.low) {
if (highLow.low === 0) {
highLow.high = 1;
} else if (highLow.low < 0) {
highLow.high = 0;
} else if (highLow.high > 0) {
highLow.low = 0;
} else {
highLow.high = 1;
highLow.low = 0;
}
}
return highLow;
};
Chartist.isNumeric = function(value) {
return value === null ? false : isFinite(value);
};
Chartist.isFalseyButZero = function(value) {
return !value && value !== 0;
};
Chartist.getNumberOrUndefined = function(value) {
return Chartist.isNumeric(value) ? +value : undefined;
};
Chartist.isMultiValue = function(value) {
return typeof value === 'object' && ('x' in value || 'y' in value);
};
Chartist.getMultiValue = function(value, dimension) {
if(Chartist.isMultiValue(value)) {
return Chartist.getNumberOrUndefined(value[dimension || 'y']);
} else {
return Chartist.getNumberOrUndefined(value);
}
};
Chartist.rho = function(num) {
if(num === 1) {
return num;
}
function gcd(p, q) {
if (p % q === 0) {
return q;
} else {
return gcd(q, p % q);
}
}
function f(x) {
return x * x + 1;
}
var x1 = 2, x2 = 2, divisor;
if (num % 2 === 0) {
return 2;
}
do {
x1 = f(x1) % num;
x2 = f(f(x2)) % num;
divisor = gcd(Math.abs(x1 - x2), num);
} while (divisor === 1);
return divisor;
};
Chartist.getBounds = function (axisLength, highLow, scaleMinSpace, onlyInteger) {
var i,
optimizationCounter = 0,
newMin,
newMax,
bounds = {
high: highLow.high,
low: highLow.low
};
bounds.valueRange = bounds.high - bounds.low;
bounds.oom = Chartist.orderOfMagnitude(bounds.valueRange);
bounds.step = Math.pow(10, bounds.oom);
bounds.min = Math.floor(bounds.low / bounds.step) * bounds.step;
bounds.max = Math.ceil(bounds.high / bounds.step) * bounds.step;
bounds.range = bounds.max - bounds.min;
bounds.numberOfSteps = Math.round(bounds.range / bounds.step);
var length = Chartist.projectLength(axisLength, bounds.step, bounds);
var scaleUp = length < scaleMinSpace;
var smallestFactor = onlyInteger ? Chartist.rho(bounds.range) : 0;
if(onlyInteger && Chartist.projectLength(axisLength, 1, bounds) >= scaleMinSpace) {
bounds.step = 1;
} else if(onlyInteger && smallestFactor < bounds.step && Chartist.projectLength(axisLength, smallestFactor, bounds) >= scaleMinSpace) {
bounds.step = smallestFactor;
} else {
while (true) {
if (scaleUp && Chartist.projectLength(axisLength, bounds.step, bounds) <= scaleMinSpace) {
bounds.step *= 2;
} else if (!scaleUp && Chartist.projectLength(axisLength, bounds.step / 2, bounds) >= scaleMinSpace) {
bounds.step /= 2;
if(onlyInteger && bounds.step % 1 !== 0) {
bounds.step *= 2;
break;
}
} else {
break;
}
if(optimizationCounter++ > 1000) {
throw new Error('Exceeded maximum number of iterations while optimizing scale step!');
}
}
}
var EPSILON = 2.221E-16;
bounds.step = Math.max(bounds.step, EPSILON);
function safeIncrement(value, increment) {
if (value === (value += increment)) {
value *= (1 + (increment > 0 ? EPSILON : -EPSILON));
}
return value;
}
newMin = bounds.min;
newMax = bounds.max;
while (newMin + bounds.step <= bounds.low) {
newMin = safeIncrement(newMin, bounds.step);
}
while (newMax - bounds.step >= bounds.high) {
newMax = safeIncrement(newMax, -bounds.step);
}
bounds.min = newMin;
bounds.max = newMax;
bounds.range = bounds.max - bounds.min;
var values = [];
for (i = bounds.min; i <= bounds.max; i = safeIncrement(i, bounds.step)) {
var value = Chartist.roundWithPrecision(i);
if (value !== values[values.length - 1]) {
values.push(value);
}
}
bounds.values = values;
return bounds;
};
Chartist.polarToCartesian = function (centerX, centerY, radius, angleInDegrees) {
var angleInRadians = (angleInDegrees - 90) * Math.PI / 180.0;
return {
x: centerX + (radius * Math.cos(angleInRadians)),
y: centerY + (radius * Math.sin(angleInRadians))
};
};
Chartist.createChartRect = function (svg, options, fallbackPadding) {
var hasAxis = !!(options.axisX || options.axisY);
var yAxisOffset = hasAxis ? options.axisY.offset : 0;
var xAxisOffset = hasAxis ? options.axisX.offset : 0;
var width = svg.width() || Chartist.quantity(options.width).value || 0;
var height = svg.height() || Chartist.quantity(options.height).value || 0;
var normalizedPadding = Chartist.normalizePadding(options.chartPadding, fallbackPadding);
width = Math.max(width, yAxisOffset + normalizedPadding.left + normalizedPadding.right);
height = Math.max(height, xAxisOffset + normalizedPadding.top + normalizedPadding.bottom);
var chartRect = {
padding: normalizedPadding,
width: function () {
return this.x2 - this.x1;
},
height: function () {
return this.y1 - this.y2;
}
};
if(hasAxis) {
if (options.axisX.position === 'start') {
chartRect.y2 = normalizedPadding.top + xAxisOffset;
chartRect.y1 = Math.max(height - normalizedPadding.bottom, chartRect.y2 + 1);
} else {
chartRect.y2 = normalizedPadding.top;
chartRect.y1 = Math.max(height - normalizedPadding.bottom - xAxisOffset, chartRect.y2 + 1);
}
if (options.axisY.position === 'start') {
chartRect.x1 = normalizedPadding.left + yAxisOffset;
chartRect.x2 = Math.max(width - normalizedPadding.right, chartRect.x1 + 1);
} else {
chartRect.x1 = normalizedPadding.left;
chartRect.x2 = Math.max(width - normalizedPadding.right - yAxisOffset, chartRect.x1 + 1);
}
} else {
chartRect.x1 = normalizedPadding.left;
chartRect.x2 = Math.max(width - normalizedPadding.right, chartRect.x1 + 1);
chartRect.y2 = normalizedPadding.top;
chartRect.y1 = Math.max(height - normalizedPadding.bottom, chartRect.y2 + 1);
}
return chartRect;
};
Chartist.createGrid = function(position, index, axis, offset, length, group, classes, eventEmitter) {
var positionalData = {};
positionalData[axis.units.pos + '1'] = position;
positionalData[axis.units.pos + '2'] = position;
positionalData[axis.counterUnits.pos + '1'] = offset;
positionalData[axis.counterUnits.pos + '2'] = offset + length;
var gridElement = group.elem('line', positionalData, classes.join(' '));
eventEmitter.emit('draw',
Chartist.extend({
type: 'grid',
axis: axis,
index: index,
group: group,
element: gridElement
}, positionalData)
);
};
Chartist.createGridBackground = function (gridGroup, chartRect, className, eventEmitter) {
var gridBackground = gridGroup.elem('rect', {
x: chartRect.x1,
y: chartRect.y2,
width: chartRect.width(),
height: chartRect.height(),
}, className, true);
eventEmitter.emit('draw', {
type: 'gridBackground',
group: gridGroup,
element: gridBackground
});
};
Chartist.createLabel = function(position, length, index, labels, axis, axisOffset, labelOffset, group, classes, useForeignObject, eventEmitter) {
var labelElement;
var positionalData = {};
positionalData[axis.units.pos] = position + labelOffset[axis.units.pos];
positionalData[axis.counterUnits.pos] = labelOffset[axis.counterUnits.pos];
positionalData[axis.units.len] = length;
positionalData[axis.counterUnits.len] = Math.max(0, axisOffset - 10);
if(useForeignObject) {
var content = document.createElement('span');
content.className = classes.join(' ');
content.setAttribute('xmlns', Chartist.namespaces.xhtml);
content.innerText = labels[index];
content.style[axis.units.len] = Math.round(positionalData[axis.units.len]) + 'px';
content.style[axis.counterUnits.len] = Math.round(positionalData[axis.counterUnits.len]) + 'px';
labelElement = group.foreignObject(content, Chartist.extend({
style: 'overflow: visible;'
}, positionalData));
} else {
labelElement = group.elem('text', positionalData, classes.join(' ')).text(labels[index]);
}
eventEmitter.emit('draw', Chartist.extend({
type: 'label',
axis: axis,
index: index,
group: group,
element: labelElement,
text: labels[index]
}, positionalData));
};
Chartist.getSeriesOption = function(series, options, key) {
if(series.name && options.series && options.series[series.name]) {
var seriesOptions = options.series[series.name];
return seriesOptions.hasOwnProperty(key) ? seriesOptions[key] : options[key];
} else {
return options[key];
}
};
Chartist.optionsProvider = function (options, responsiveOptions, eventEmitter) {
var baseOptions = Chartist.extend({}, options),
currentOptions,
mediaQueryListeners = [],
i;
function updateCurrentOptions(mediaEvent) {
var previousOptions = currentOptions;
currentOptions = Chartist.extend({}, baseOptions);
if (responsiveOptions) {
for (i = 0; i < responsiveOptions.length; i++) {
var mql = window.matchMedia(responsiveOptions[i][0]);
if (mql.matches) {
currentOptions = Chartist.extend(currentOptions, responsiveOptions[i][1]);
}
}
}
if(eventEmitter && mediaEvent) {
eventEmitter.emit('optionsChanged', {
previousOptions: previousOptions,
currentOptions: currentOptions
});
}
}
function removeMediaQueryListeners() {
mediaQueryListeners.forEach(function(mql) {
mql.removeListener(updateCurrentOptions);
});
}
if (!window.matchMedia) {
throw 'window.matchMedia not found! Make sure you\'re using a polyfill.';
} else if (responsiveOptions) {
for (i = 0; i < responsiveOptions.length; i++) {
var mql = window.matchMedia(responsiveOptions[i][0]);
mql.addListener(updateCurrentOptions);
mediaQueryListeners.push(mql);
}
}
updateCurrentOptions();
return {
removeMediaQueryListeners: removeMediaQueryListeners,
getCurrentOptions: function getCurrentOptions() {
return Chartist.extend({}, currentOptions);
}
};
};
Chartist.splitIntoSegments = function(pathCoordinates, valueData, options) {
var defaultOptions = {
increasingX: false,
fillHoles: false
};
options = Chartist.extend({}, defaultOptions, options);
var segments = [];
var hole = true;
for(var i = 0; i < pathCoordinates.length; i += 2) {
if(Chartist.getMultiValue(valueData[i / 2].value) === undefined) {
if(!options.fillHoles) {
hole = true;
}
} else {
if(options.increasingX && i >= 2 && pathCoordinates[i] <= pathCoordinates[i-2]) {
hole = true;
}
if(hole) {
segments.push({
pathCoordinates: [],
valueData: []
});
hole = false;
}
segments[segments.length - 1].pathCoordinates.push(pathCoordinates[i], pathCoordinates[i + 1]);
segments[segments.length - 1].valueData.push(valueData[i / 2]);
}
}
return segments;
};
}(window, document, Chartist));
;
(function(window, document, Chartist) {
'use strict';
Chartist.Interpolation = {};
Chartist.Interpolation.none = function(options) {
var defaultOptions = {
fillHoles: false
};
options = Chartist.extend({}, defaultOptions, options);
return function none(pathCoordinates, valueData) {
var path = new Chartist.Svg.Path();
var hole = true;
for(var i = 0; i < pathCoordinates.length; i += 2) {
var currX = pathCoordinates[i];
var currY = pathCoordinates[i + 1];
var currData = valueData[i / 2];
if(Chartist.getMultiValue(currData.value) !== undefined) {
if(hole) {
path.move(currX, currY, false, currData);
} else {
path.line(currX, currY, false, currData);
}
hole = false;
} else if(!options.fillHoles) {
hole = true;
}
}
return path;
};
};
Chartist.Interpolation.simple = function(options) {
var defaultOptions = {
divisor: 2,
fillHoles: false
};
options = Chartist.extend({}, defaultOptions, options);
var d = 1 / Math.max(1, options.divisor);
return function simple(pathCoordinates, valueData) {
var path = new Chartist.Svg.Path();
var prevX, prevY, prevData;
for(var i = 0; i < pathCoordinates.length; i += 2) {
var currX = pathCoordinates[i];
var currY = pathCoordinates[i + 1];
var length = (currX - prevX) * d;
var currData = valueData[i / 2];
if(currData.value !== undefined) {
if(prevData === undefined) {
path.move(currX, currY, false, currData);
} else {
path.curve(
prevX + length,
prevY,
currX - length,
currY,
currX,
currY,
false,
currData
);
}
prevX = currX;
prevY = currY;
prevData = currData;
} else if(!options.fillHoles) {
prevX = currX = prevData = undefined;
}
}
return path;
};
};
Chartist.Interpolation.cardinal = function(options) {
var defaultOptions = {
tension: 1,
fillHoles: false
};
options = Chartist.extend({}, defaultOptions, options);
var t = Math.min(1, Math.max(0, options.tension)),
c = 1 - t;
return function cardinal(pathCoordinates, valueData) {
var segments = Chartist.splitIntoSegments(pathCoordinates, valueData, {
fillHoles: options.fillHoles
});
if(!segments.length) {
return Chartist.Interpolation.none()([]);
} else if(segments.length > 1) {
var paths = [];
segments.forEach(function(segment) {
paths.push(cardinal(segment.pathCoordinates, segment.valueData));
});
return Chartist.Svg.Path.join(paths);
} else {
pathCoordinates = segments[0].pathCoordinates;
valueData = segments[0].valueData;
if(pathCoordinates.length <= 4) {
return Chartist.Interpolation.none()(pathCoordinates, valueData);
}
var path = new Chartist.Svg.Path().move(pathCoordinates[0], pathCoordinates[1], false, valueData[0]),
z;
for (var i = 0, iLen = pathCoordinates.length; iLen - 2 * !z > i; i += 2) {
var p = [
{x: +pathCoordinates[i - 2], y: +pathCoordinates[i - 1]},
{x: +pathCoordinates[i], y: +pathCoordinates[i + 1]},
{x: +pathCoordinates[i + 2], y: +pathCoordinates[i + 3]},
{x: +pathCoordinates[i + 4], y: +pathCoordinates[i + 5]}
];
if (z) {
if (!i) {
p[0] = {x: +pathCoordinates[iLen - 2], y: +pathCoordinates[iLen - 1]};
} else if (iLen - 4 === i) {
p[3] = {x: +pathCoordinates[0], y: +pathCoordinates[1]};
} else if (iLen - 2 === i) {
p[2] = {x: +pathCoordinates[0], y: +pathCoordinates[1]};
p[3] = {x: +pathCoordinates[2], y: +pathCoordinates[3]};
}
} else {
if (iLen - 4 === i) {
p[3] = p[2];
} else if (!i) {
p[0] = {x: +pathCoordinates[i], y: +pathCoordinates[i + 1]};
}
}
path.curve(
(t * (-p[0].x + 6 * p[1].x + p[2].x) / 6) + (c * p[2].x),
(t * (-p[0].y + 6 * p[1].y + p[2].y) / 6) + (c * p[2].y),
(t * (p[1].x + 6 * p[2].x - p[3].x) / 6) + (c * p[2].x),
(t * (p[1].y + 6 * p[2].y - p[3].y) / 6) + (c * p[2].y),
p[2].x,
p[2].y,
false,
valueData[(i + 2) / 2]
);
}
return path;
}
};
};
Chartist.Interpolation.monotoneCubic = function(options) {
var defaultOptions = {
fillHoles: false
};
options = Chartist.extend({}, defaultOptions, options);
return function monotoneCubic(pathCoordinates, valueData) {
var segments = Chartist.splitIntoSegments(pathCoordinates, valueData, {
fillHoles: options.fillHoles,
increasingX: true
});
if(!segments.length) {
return Chartist.Interpolation.none()([]);
} else if(segments.length > 1) {
var paths = [];
segments.forEach(function(segment) {
paths.push(monotoneCubic(segment.pathCoordinates, segment.valueData));
});
return Chartist.Svg.Path.join(paths);
} else {
pathCoordinates = segments[0].pathCoordinates;
valueData = segments[0].valueData;
if(pathCoordinates.length <= 4) {
return Chartist.Interpolation.none()(pathCoordinates, valueData);
}
var xs = [],
ys = [],
i,
n = pathCoordinates.length / 2,
ms = [],
ds = [], dys = [], dxs = [],
path;
for(i = 0; i < n; i++) {
xs[i] = pathCoordinates[i * 2];
ys[i] = pathCoordinates[i * 2 + 1];
}
for(i = 0; i < n - 1; i++) {
dys[i] = ys[i + 1] - ys[i];
dxs[i] = xs[i + 1] - xs[i];
ds[i] = dys[i] / dxs[i];
}
ms[0] = ds[0];
ms[n - 1] = ds[n - 2];
for(i = 1; i < n - 1; i++) {
if(ds[i] === 0 || ds[i - 1] === 0 || (ds[i - 1] > 0) !== (ds[i] > 0)) {
ms[i] = 0;
} else {
ms[i] = 3 * (dxs[i - 1] + dxs[i]) / (
(2 * dxs[i] + dxs[i - 1]) / ds[i - 1] +
(dxs[i] + 2 * dxs[i - 1]) / ds[i]);
if(!isFinite(ms[i])) {
ms[i] = 0;
}
}
}
path = new Chartist.Svg.Path().move(xs[0], ys[0], false, valueData[0]);
for(i = 0; i < n - 1; i++) {
path.curve(
xs[i] + dxs[i] / 3,
ys[i] + ms[i] * dxs[i] / 3,
xs[i + 1] - dxs[i] / 3,
ys[i + 1] - ms[i + 1] * dxs[i] / 3,
xs[i + 1],
ys[i + 1],
false,
valueData[i + 1]
);
}
return path;
}
};
};
Chartist.Interpolation.step = function(options) {
var defaultOptions = {
postpone: true,
fillHoles: false
};
options = Chartist.extend({}, defaultOptions, options);
return function step(pathCoordinates, valueData) {
var path = new Chartist.Svg.Path();
var prevX, prevY, prevData;
for (var i = 0; i < pathCoordinates.length; i += 2) {
var currX = pathCoordinates[i];
var currY = pathCoordinates[i + 1];
var currData = valueData[i / 2];
if(currData.value !== undefined) {
if(prevData === undefined) {
path.move(currX, currY, false, currData);
} else {
if(options.postpone) {
path.line(currX, prevY, false, prevData);
} else {
path.line(prevX, currY, false, currData);
}
path.line(currX, currY, false, currData);
}
prevX = currX;
prevY = currY;
prevData = currData;
} else if(!options.fillHoles) {
prevX = prevY = prevData = undefined;
}
}
return path;
};
};
}(window, document, Chartist));
;
(function (window, document, Chartist) {
'use strict';
Chartist.EventEmitter = function () {
var handlers = [];
function addEventHandler(event, handler) {
handlers[event] = handlers[event] || [];
handlers[event].push(handler);
}
function removeEventHandler(event, handler) {
if(handlers[event]) {
if(handler) {
handlers[event].splice(handlers[event].indexOf(handler), 1);
if(handlers[event].length === 0) {
delete handlers[event];
}
} else {
delete handlers[event];
}
}
}
function emit(event, data) {
if(handlers[event]) {
handlers[event].forEach(function(handler) {
handler(data);
});
}
if(handlers['*']) {
handlers['*'].forEach(function(starHandler) {
starHandler(event, data);
});
}
}
return {
addEventHandler: addEventHandler,
removeEventHandler: removeEventHandler,
emit: emit
};
};
}(window, document, Chartist));
;
(function(window, document, Chartist) {
'use strict';
function listToArray(list) {
var arr = [];
if (list.length) {
for (var i = 0; i < list.length; i++) {
arr.push(list[i]);
}
}
return arr;
}
function extend(properties, superProtoOverride) {
var superProto = superProtoOverride || this.prototype || Chartist.Class;
var proto = Object.create(superProto);
Chartist.Class.cloneDefinitions(proto, properties);
var constr = function() {
var fn = proto.constructor || function () {},
instance;
instance = this === Chartist ? Object.create(proto) : this;
fn.apply(instance, Array.prototype.slice.call(arguments, 0));
return instance;
};
constr.prototype = proto;
constr.super = superProto;
constr.extend = this.extend;
return constr;
}
function cloneDefinitions() {
var args = listToArray(arguments);
var target = args[0];
args.splice(1, args.length - 1).forEach(function (source) {
Object.getOwnPropertyNames(source).forEach(function (propName) {
delete target[propName];
Object.defineProperty(target, propName,
Object.getOwnPropertyDescriptor(source, propName));
});
});
return target;
}
Chartist.Class = {
extend: extend,
cloneDefinitions: cloneDefinitions
};
}(window, document, Chartist));
;
(function(window, document, Chartist) {
'use strict';
function update(data, options, override) {
if(data) {
this.data = data || {};
this.data.labels = this.data.labels || [];
this.data.series = this.data.series || [];
this.eventEmitter.emit('data', {
type: 'update',
data: this.data
});
}
if(options) {
this.options = Chartist.extend({}, override ? this.options : this.defaultOptions, options);
if(!this.initializeTimeoutId) {
this.optionsProvider.removeMediaQueryListeners();
this.optionsProvider = Chartist.optionsProvider(this.options, this.responsiveOptions, this.eventEmitter);
}
}
if(!this.initializeTimeoutId) {
this.createChart(this.optionsProvider.getCurrentOptions());
}
return this;
}
function detach() {
if(!this.initializeTimeoutId) {
window.removeEventListener('resize', this.resizeListener);
this.optionsProvider.removeMediaQueryListeners();
} else {
window.clearTimeout(this.initializeTimeoutId);
}
return this;
}
function on(event, handler) {
this.eventEmitter.addEventHandler(event, handler);
return this;
}
function off(event, handler) {
this.eventEmitter.removeEventHandler(event, handler);
return this;
}
function initialize() {
window.addEventListener('resize', this.resizeListener);
this.optionsProvider = Chartist.optionsProvider(this.options, this.responsiveOptions, this.eventEmitter);
this.eventEmitter.addEventHandler('optionsChanged', function() {
this.update();
}.bind(this));
if(this.options.plugins) {
this.options.plugins.forEach(function(plugin) {
if(plugin instanceof Array) {
plugin[0](this, plugin[1]);
} else {
plugin(this);
}
}.bind(this));
}
this.eventEmitter.emit('data', {
type: 'initial',
data: this.data
});
this.createChart(this.optionsProvider.getCurrentOptions());
this.initializeTimeoutId = undefined;
}
function Base(query, data, defaultOptions, options, responsiveOptions) {
this.container = Chartist.querySelector(query);
this.data = data || {};
this.data.labels = this.data.labels || [];
this.data.series = this.data.series || [];
this.defaultOptions = defaultOptions;
this.options = options;
this.responsiveOptions = responsiveOptions;
this.eventEmitter = Chartist.EventEmitter();
this.supportsForeignObject = Chartist.Svg.isSupported('Extensibility');
this.supportsAnimations = Chartist.Svg.isSupported('AnimationEventsAttribute');
this.resizeListener = function resizeListener(){
this.update();
}.bind(this);
if(this.container) {
if(this.container.__chartist__) {
this.container.__chartist__.detach();
}
this.container.__chartist__ = this;
}
this.initializeTimeoutId = setTimeout(initialize.bind(this), 0);
}
Chartist.Base = Chartist.Class.extend({
constructor: Base,
optionsProvider: undefined,
container: undefined,
svg: undefined,
eventEmitter: undefined,
createChart: function() {
throw new Error('Base chart type can\'t be instantiated!');
},
update: update,
detach: detach,
on: on,
off: off,
version: Chartist.version,
supportsForeignObject: false
});
}(window, document, Chartist));
;
(function(window, document, Chartist) {
'use strict';
function Svg(name, attributes, className, parent, insertFirst) {
if(name instanceof Element) {
this._node = name;
} else {
this._node = document.createElementNS(Chartist.namespaces.svg, name);
if(name === 'svg') {
this.attr({
'xmlns:ct': Chartist.namespaces.ct
});
}
}
if(attributes) {
this.attr(attributes);
}
if(className) {
this.addClass(className);
}
if(parent) {
if (insertFirst && parent._node.firstChild) {
parent._node.insertBefore(this._node, parent._node.firstChild);
} else {
parent._node.appendChild(this._node);
}
}
}
function attr(attributes, ns) {
if(typeof attributes === 'string') {
if(ns) {
return this._node.getAttributeNS(ns, attributes);
} else {
return this._node.getAttribute(attributes);
}
}
Object.keys(attributes).forEach(function(key) {
if(attributes[key] === undefined) {
return;
}
if (key.indexOf(':') !== -1) {
var namespacedAttribute = key.split(':');
this._node.setAttributeNS(Chartist.namespaces[namespacedAttribute[0]], key, attributes[key]);
} else {
this._node.setAttribute(key, attributes[key]);
}
}.bind(this));
return this;
}
function elem(name, attributes, className, insertFirst) {
return new Chartist.Svg(name, attributes, className, this, insertFirst);
}
function parent() {
return this._node.parentNode instanceof SVGElement ? new Chartist.Svg(this._node.parentNode) : null;
}
function root() {
var node = this._node;
while(node.nodeName !== 'svg') {
node = node.parentNode;
}
return new Chartist.Svg(node);
}
function querySelector(selector) {
var foundNode = this._node.querySelector(selector);
return foundNode ? new Chartist.Svg(foundNode) : null;
}
function querySelectorAll(selector) {
var foundNodes = this._node.querySelectorAll(selector);
return foundNodes.length ? new Chartist.Svg.List(foundNodes) : null;
}
function getNode() {
return this._node;
}
function foreignObject(content, attributes, className, insertFirst) {
if(typeof content === 'string') {
var container = document.createElement('div');
container.innerHTML = content;
content = container.firstChild;
}
content.setAttribute('xmlns', Chartist.namespaces.xmlns);
var fnObj = this.elem('foreignObject', attributes, className, insertFirst);
fnObj._node.appendChild(content);
return fnObj;
}
function text(t) {
this._node.appendChild(document.createTextNode(t));
return this;
}
function empty() {
while (this._node.firstChild) {
this._node.removeChild(this._node.firstChild);
}
return this;
}
function remove() {
this._node.parentNode.removeChild(this._node);
return this.parent();
}
function replace(newElement) {
this._node.parentNode.replaceChild(newElement._node, this._node);
return newElement;
}
function append(element, insertFirst) {
if(insertFirst && this._node.firstChild) {
this._node.insertBefore(element._node, this._node.firstChild);
} else {
this._node.appendChild(element._node);
}
return this;
}
function classes() {
return this._node.getAttribute('class') ? this._node.getAttribute('class').trim().split(/\s+/) : [];
}
function addClass(names) {
this._node.setAttribute('class',
this.classes(this._node)
.concat(names.trim().split(/\s+/))
.filter(function(elem, pos, self) {
return self.indexOf(elem) === pos;
}).join(' ')
);
return this;
}
function removeClass(names) {
var removedClasses = names.trim().split(/\s+/);
this._node.setAttribute('class', this.classes(this._node).filter(function(name) {
return removedClasses.indexOf(name) === -1;
}).join(' '));
return this;
}
function removeAllClasses() {
this._node.setAttribute('class', '');
return this;
}
function height() {
return this._node.getBoundingClientRect().height;
}
function width() {
return this._node.getBoundingClientRect().width;
}
function animate(animations, guided, eventEmitter) {
if(guided === undefined) {
guided = true;
}
Object.keys(animations).forEach(function createAnimateForAttributes(attribute) {
function createAnimate(animationDefinition, guided) {
var attributeProperties = {},
animate,
timeout,
easing;
if(animationDefinition.easing) {
easing = animationDefinition.easing instanceof Array ?
animationDefinition.easing :
Chartist.Svg.Easing[animationDefinition.easing];
delete animationDefinition.easing;
}
animationDefinition.begin = Chartist.ensureUnit(animationDefinition.begin, 'ms');
animationDefinition.dur = Chartist.ensureUnit(animationDefinition.dur, 'ms');
if(easing) {
animationDefinition.calcMode = 'spline';
animationDefinition.keySplines = easing.join(' ');
animationDefinition.keyTimes = '0;1';
}
if(guided) {
animationDefinition.fill = 'freeze';
attributeProperties[attribute] = animationDefinition.from;
this.attr(attributeProperties);
timeout = Chartist.quantity(animationDefinition.begin || 0).value;
animationDefinition.begin = 'indefinite';
}
animate = this.elem('animate', Chartist.extend({
attributeName: attribute
}, animationDefinition));
if(guided) {
setTimeout(function() {
try {
animate._node.beginElement();
} catch(err) {
attributeProperties[attribute] = animationDefinition.to;
this.attr(attributeProperties);
animate.remove();
}
}.bind(this), timeout);
}
if(eventEmitter) {
animate._node.addEventListener('beginEvent', function handleBeginEvent() {
eventEmitter.emit('animationBegin', {
element: this,
animate: animate._node,
params: animationDefinition
});
}.bind(this));
}
animate._node.addEventListener('endEvent', function handleEndEvent() {
if(eventEmitter) {
eventEmitter.emit('animationEnd', {
element: this,
animate: animate._node,
params: animationDefinition
});
}
if(guided) {
attributeProperties[attribute] = animationDefinition.to;
this.attr(attributeProperties);
animate.remove();
}
}.bind(this));
}
if(animations[attribute] instanceof Array) {
animations[attribute].forEach(function(animationDefinition) {
createAnimate.bind(this)(animationDefinition, false);
}.bind(this));
} else {
createAnimate.bind(this)(animations[attribute], guided);
}
}.bind(this));
return this;
}
Chartist.Svg = Chartist.Class.extend({
constructor: Svg,
attr: attr,
elem: elem,
parent: parent,
root: root,
querySelector: querySelector,
querySelectorAll: querySelectorAll,
getNode: getNode,
foreignObject: foreignObject,
text: text,
empty: empty,
remove: remove,
replace: replace,
append: append,
classes: classes,
addClass: addClass,
removeClass: removeClass,
removeAllClasses: removeAllClasses,
height: height,
width: width,
animate: animate
});
Chartist.Svg.isSupported = function(feature) {
return document.implementation.hasFeature('http://www.w3.org/TR/SVG11/feature#' + feature, '1.1');
};
var easingCubicBeziers = {
easeInSine: [0.47, 0, 0.745, 0.715],
easeOutSine: [0.39, 0.575, 0.565, 1],
easeInOutSine: [0.445, 0.05, 0.55, 0.95],
easeInQuad: [0.55, 0.085, 0.68, 0.53],
easeOutQuad: [0.25, 0.46, 0.45, 0.94],
easeInOutQuad: [0.455, 0.03, 0.515, 0.955],
easeInCubic: [0.55, 0.055, 0.675, 0.19],
easeOutCubic: [0.215, 0.61, 0.355, 1],
easeInOutCubic: [0.645, 0.045, 0.355, 1],
easeInQuart: [0.895, 0.03, 0.685, 0.22],
easeOutQuart: [0.165, 0.84, 0.44, 1],
easeInOutQuart: [0.77, 0, 0.175, 1],
easeInQuint: [0.755, 0.05, 0.855, 0.06],
easeOutQuint: [0.23, 1, 0.32, 1],
easeInOutQuint: [0.86, 0, 0.07, 1],
easeInExpo: [0.95, 0.05, 0.795, 0.035],
easeOutExpo: [0.19, 1, 0.22, 1],
easeInOutExpo: [1, 0, 0, 1],
easeInCirc: [0.6, 0.04, 0.98, 0.335],
easeOutCirc: [0.075, 0.82, 0.165, 1],
easeInOutCirc: [0.785, 0.135, 0.15, 0.86],
easeInBack: [0.6, -0.28, 0.735, 0.045],
easeOutBack: [0.175, 0.885, 0.32, 1.275],
easeInOutBack: [0.68, -0.55, 0.265, 1.55]
};
Chartist.Svg.Easing = easingCubicBeziers;
function SvgList(nodeList) {
var list = this;
this.svgElements = [];
for(var i = 0; i < nodeList.length; i++) {
this.svgElements.push(new Chartist.Svg(nodeList[i]));
}
Object.keys(Chartist.Svg.prototype).filter(function(prototypeProperty) {
return ['constructor',
'parent',
'querySelector',
'querySelectorAll',
'replace',
'append',
'classes',
'height',
'width'].indexOf(prototypeProperty) === -1;
}).forEach(function(prototypeProperty) {
list[prototypeProperty] = function() {
var args = Array.prototype.slice.call(arguments, 0);
list.svgElements.forEach(function(element) {
Chartist.Svg.prototype[prototypeProperty].apply(element, args);
});
return list;
};
});
}
Chartist.Svg.List = Chartist.Class.extend({
constructor: SvgList
});
}(window, document, Chartist));
;
(function(window, document, Chartist) {
'use strict';
var elementDescriptions = {
m: ['x', 'y'],
l: ['x', 'y'],
c: ['x1', 'y1', 'x2', 'y2', 'x', 'y'],
a: ['rx', 'ry', 'xAr', 'lAf', 'sf', 'x', 'y']
};
var defaultOptions = {
accuracy: 3
};
function element(command, params, pathElements, pos, relative, data) {
var pathElement = Chartist.extend({
command: relative ? command.toLowerCase() : command.toUpperCase()
}, params, data ? { data: data } : {} );
pathElements.splice(pos, 0, pathElement);
}
function forEachParam(pathElements, cb) {
pathElements.forEach(function(pathElement, pathElementIndex) {
elementDescriptions[pathElement.command.toLowerCase()].forEach(function(paramName, paramIndex) {
cb(pathElement, paramName, pathElementIndex, paramIndex, pathElements);
});
});
}
function SvgPath(close, options) {
this.pathElements = [];
this.pos = 0;
this.close = close;
this.options = Chartist.extend({}, defaultOptions, options);
}
function position(pos) {
if(pos !== undefined) {
this.pos = Math.max(0, Math.min(this.pathElements.length, pos));
return this;
} else {
return this.pos;
}
}
function remove(count) {
this.pathElements.splice(this.pos, count);
return this;
}
function move(x, y, relative, data) {
element('M', {
x: +x,
y: +y
}, this.pathElements, this.pos++, relative, data);
return this;
}
function line(x, y, relative, data) {
element('L', {
x: +x,
y: +y
}, this.pathElements, this.pos++, relative, data);
return this;
}
function curve(x1, y1, x2, y2, x, y, relative, data) {
element('C', {
x1: +x1,
y1: +y1,
x2: +x2,
y2: +y2,
x: +x,
y: +y
}, this.pathElements, this.pos++, relative, data);
return this;
}
function arc(rx, ry, xAr, lAf, sf, x, y, relative, data) {
element('A', {
rx: +rx,
ry: +ry,
xAr: +xAr,
lAf: +lAf,
sf: +sf,
x: +x,
y: +y
}, this.pathElements, this.pos++, relative, data);
return this;
}
function parse(path) {
var chunks = path.replace(/([A-Za-z])([0-9])/g, '$1 $2')
.replace(/([0-9])([A-Za-z])/g, '$1 $2')
.split(/[\s,]+/)
.reduce(function(result, element) {
if(element.match(/[A-Za-z]/)) {
result.push([]);
}
result[result.length - 1].push(element);
return result;
}, []);
if(chunks[chunks.length - 1][0].toUpperCase() === 'Z') {
chunks.pop();
}
var elements = chunks.map(function(chunk) {
var command = chunk.shift(),
description = elementDescriptions[command.toLowerCase()];
return Chartist.extend({
command: command
}, description.reduce(function(result, paramName, index) {
result[paramName] = +chunk[index];
return result;
}, {}));
});
var spliceArgs = [this.pos, 0];
Array.prototype.push.apply(spliceArgs, elements);
Array.prototype.splice.apply(this.pathElements, spliceArgs);
this.pos += elements.length;
return this;
}
function stringify() {
var accuracyMultiplier = Math.pow(10, this.options.accuracy);
return this.pathElements.reduce(function(path, pathElement) {
var params = elementDescriptions[pathElement.command.toLowerCase()].map(function(paramName) {
return this.options.accuracy ?
(Math.round(pathElement[paramName] * accuracyMultiplier) / accuracyMultiplier) :
pathElement[paramName];
}.bind(this));
return path + pathElement.command + params.join(',');
}.bind(this), '') + (this.close ? 'Z' : '');
}
function scale(x, y) {
forEachParam(this.pathElements, function(pathElement, paramName) {
pathElement[paramName] *= paramName[0] === 'x' ? x : y;
});
return this;
}
function translate(x, y) {
forEachParam(this.pathElements, function(pathElement, paramName) {
pathElement[paramName] += paramName[0] === 'x' ? x : y;
});
return this;
}
function transform(transformFnc) {
forEachParam(this.pathElements, function(pathElement, paramName, pathElementIndex, paramIndex, pathElements) {
var transformed = transformFnc(pathElement, paramName, pathElementIndex, paramIndex, pathElements);
if(transformed || transformed === 0) {
pathElement[paramName] = transformed;
}
});
return this;
}
function clone(close) {
var c = new Chartist.Svg.Path(close || this.close);
c.pos = this.pos;
c.pathElements = this.pathElements.slice().map(function cloneElements(pathElement) {
return Chartist.extend({}, pathElement);
});
c.options = Chartist.extend({}, this.options);
return c;
}
function splitByCommand(command) {
var split = [
new Chartist.Svg.Path()
];
this.pathElements.forEach(function(pathElement) {
if(pathElement.command === command.toUpperCase() && split[split.length - 1].pathElements.length !== 0) {
split.push(new Chartist.Svg.Path());
}
split[split.length - 1].pathElements.push(pathElement);
});
return split;
}
function join(paths, close, options) {
var joinedPath = new Chartist.Svg.Path(close, options);
for(var i = 0; i < paths.length; i++) {
var path = paths[i];
for(var j = 0; j < path.pathElements.length; j++) {
joinedPath.pathElements.push(path.pathElements[j]);
}
}
return joinedPath;
}
Chartist.Svg.Path = Chartist.Class.extend({
constructor: SvgPath,
position: position,
remove: remove,
move: move,
line: line,
curve: curve,
arc: arc,
scale: scale,
translate: translate,
transform: transform,
parse: parse,
stringify: stringify,
clone: clone,
splitByCommand: splitByCommand
});
Chartist.Svg.Path.elementDescriptions = elementDescriptions;
Chartist.Svg.Path.join = join;
}(window, document, Chartist));
;
(function (window, document, Chartist) {
'use strict';
var axisUnits = {
x: {
pos: 'x',
len: 'width',
dir: 'horizontal',
rectStart: 'x1',
rectEnd: 'x2',
rectOffset: 'y2'
},
y: {
pos: 'y',
len: 'height',
dir: 'vertical',
rectStart: 'y2',
rectEnd: 'y1',
rectOffset: 'x1'
}
};
function Axis(units, chartRect, ticks, options) {
this.units = units;
this.counterUnits = units === axisUnits.x ? axisUnits.y : axisUnits.x;
this.chartRect = chartRect;
this.axisLength = chartRect[units.rectEnd] - chartRect[units.rectStart];
this.gridOffset = chartRect[units.rectOffset];
this.ticks = ticks;
this.options = options;
}
function createGridAndLabels(gridGroup, labelGroup, useForeignObject, chartOptions, eventEmitter) {
var axisOptions = chartOptions['axis' + this.units.pos.toUpperCase()];
var projectedValues = this.ticks.map(this.projectValue.bind(this));
var labelValues = this.ticks.map(axisOptions.labelInterpolationFnc);
projectedValues.forEach(function(projectedValue, index) {
var labelOffset = {
x: 0,
y: 0
};
var labelLength;
if(projectedValues[index + 1]) {
labelLength = projectedValues[index + 1] - projectedValue;
} else {
labelLength = Math.max(this.axisLength - projectedValue, 30);
}
if(Chartist.isFalseyButZero(labelValues[index]) && labelValues[index] !== '') {
return;
}
if(this.units.pos === 'x') {
projectedValue = this.chartRect.x1 + projectedValue;
labelOffset.x = chartOptions.axisX.labelOffset.x;
if(chartOptions.axisX.position === 'start') {
labelOffset.y = this.chartRect.padding.top + chartOptions.axisX.labelOffset.y + (useForeignObject ? 5 : 20);
} else {
labelOffset.y = this.chartRect.y1 + chartOptions.axisX.labelOffset.y + (useForeignObject ? 5 : 20);
}
} else {
projectedValue = this.chartRect.y1 - projectedValue;
labelOffset.y = chartOptions.axisY.labelOffset.y - (useForeignObject ? labelLength : 0);
if(chartOptions.axisY.position === 'start') {
labelOffset.x = useForeignObject ? this.chartRect.padding.left + chartOptions.axisY.labelOffset.x : this.chartRect.x1 - 10;
} else {
labelOffset.x = this.chartRect.x2 + chartOptions.axisY.labelOffset.x + 10;
}
}
if(axisOptions.showGrid) {
Chartist.createGrid(projectedValue, index, this, this.gridOffset, this.chartRect[this.counterUnits.len](), gridGroup, [
chartOptions.classNames.grid,
chartOptions.classNames[this.units.dir]
], eventEmitter);
}
if(axisOptions.showLabel) {
Chartist.createLabel(projectedValue, labelLength, index, labelValues, this, axisOptions.offset, labelOffset, labelGroup, [
chartOptions.classNames.label,
chartOptions.classNames[this.units.dir],
(axisOptions.position === 'start' ? chartOptions.classNames[axisOptions.position] : chartOptions.classNames['end'])
], useForeignObject, eventEmitter);
}
}.bind(this));
}
Chartist.Axis = Chartist.Class.extend({
constructor: Axis,
createGridAndLabels: createGridAndLabels,
projectValue: function(value, index, data) {
throw new Error('Base axis can\'t be instantiated!');
}
});
Chartist.Axis.units = axisUnits;
}(window, document, Chartist));
;
(function (window, document, Chartist) {
'use strict';
function AutoScaleAxis(axisUnit, data, chartRect, options) {
var highLow = options.highLow || Chartist.getHighLow(data, options, axisUnit.pos);
this.bounds = Chartist.getBounds(chartRect[axisUnit.rectEnd] - chartRect[axisUnit.rectStart], highLow, options.scaleMinSpace || 20, options.onlyInteger);
this.range = {
min: this.bounds.min,
max: this.bounds.max
};
Chartist.AutoScaleAxis.super.constructor.call(this,
axisUnit,
chartRect,
this.bounds.values,
options);
}
function projectValue(value) {
return this.axisLength * (+Chartist.getMultiValue(value, this.units.pos) - this.bounds.min) / this.bounds.range;
}
Chartist.AutoScaleAxis = Chartist.Axis.extend({
constructor: AutoScaleAxis,
projectValue: projectValue
});
}(window, document, Chartist));
;
(function (window, document, Chartist) {
'use strict';
function FixedScaleAxis(axisUnit, data, chartRect, options) {
var highLow = options.highLow || Chartist.getHighLow(data, options, axisUnit.pos);
this.divisor = options.divisor || 1;
this.ticks = options.ticks || Chartist.times(this.divisor).map(function(value, index) {
return highLow.low + (highLow.high - highLow.low) / this.divisor * index;
}.bind(this));
this.ticks.sort(function(a, b) {
return a - b;
});
this.range = {
min: highLow.low,
max: highLow.high
};
Chartist.FixedScaleAxis.super.constructor.call(this,
axisUnit,
chartRect,
this.ticks,
options);
this.stepLength = this.axisLength / this.divisor;
}
function projectValue(value) {
return this.axisLength * (+Chartist.getMultiValue(value, this.units.pos) - this.range.min) / (this.range.max - this.range.min);
}
Chartist.FixedScaleAxis = Chartist.Axis.extend({
constructor: FixedScaleAxis,
projectValue: projectValue
});
}(window, document, Chartist));
;
(function (window, document, Chartist) {
'use strict';
function StepAxis(axisUnit, data, chartRect, options) {
Chartist.StepAxis.super.constructor.call(this,
axisUnit,
chartRect,
options.ticks,
options);
var calc = Math.max(1, options.ticks.length - (options.stretch ? 1 : 0));
this.stepLength = this.axisLength / calc;
}
function projectValue(value, index) {
return this.stepLength * index;
}
Chartist.StepAxis = Chartist.Axis.extend({
constructor: StepAxis,
projectValue: projectValue
});
}(window, document, Chartist));
;
(function(window, document, Chartist){
'use strict';
var defaultOptions = {
axisX: {
offset: 30,
position: 'end',
labelOffset: {
x: 0,
y: 0
},
showLabel: true,
showGrid: true,
labelInterpolationFnc: Chartist.noop,
type: undefined
},
axisY: {
offset: 40,
position: 'start',
labelOffset: {
x: 0,
y: 0
},
showLabel: true,
showGrid: true,
labelInterpolationFnc: Chartist.noop,
type: undefined,
scaleMinSpace: 20,
onlyInteger: false
},
width: undefined,
height: undefined,
showLine: true,
showPoint: true,
showArea: false,
areaBase: 0,
lineSmooth: true,
showGridBackground: false,
low: undefined,
high: undefined,
chartPadding: {
top: 15,
right: 15,
bottom: 5,
left: 10
},
fullWidth: false,
reverseData: false,
classNames: {
chart: 'ct-chart-line',
label: 'ct-label',
labelGroup: 'ct-labels',
series: 'ct-series',
line: 'ct-line',
point: 'ct-point',
area: 'ct-area',
grid: 'ct-grid',
gridGroup: 'ct-grids',
gridBackground: 'ct-grid-background',
vertical: 'ct-vertical',
horizontal: 'ct-horizontal',
start: 'ct-start',
end: 'ct-end'
}
};
function createChart(options) {
var data = Chartist.normalizeData(this.data, options.reverseData, true);
this.svg = Chartist.createSvg(this.container, options.width, options.height, options.classNames.chart);
var gridGroup = this.svg.elem('g').addClass(options.classNames.gridGroup);
var seriesGroup = this.svg.elem('g');
var labelGroup = this.svg.elem('g').addClass(options.classNames.labelGroup);
var chartRect = Chartist.createChartRect(this.svg, options, defaultOptions.padding);
var axisX, axisY;
if(options.axisX.type === undefined) {
axisX = new Chartist.StepAxis(Chartist.Axis.units.x, data.normalized.series, chartRect, Chartist.extend({}, options.axisX, {
ticks: data.normalized.labels,
stretch: options.fullWidth
}));
} else {
axisX = options.axisX.type.call(Chartist, Chartist.Axis.units.x, data.normalized.series, chartRect, options.axisX);
}
if(options.axisY.type === undefined) {
axisY = new Chartist.AutoScaleAxis(Chartist.Axis.units.y, data.normalized.series, chartRect, Chartist.extend({}, options.axisY, {
high: Chartist.isNumeric(options.high) ? options.high : options.axisY.high,
low: Chartist.isNumeric(options.low) ? options.low : options.axisY.low
}));
} else {
axisY = options.axisY.type.call(Chartist, Chartist.Axis.units.y, data.normalized.series, chartRect, options.axisY);
}
axisX.createGridAndLabels(gridGroup, labelGroup, this.supportsForeignObject, options, this.eventEmitter);
axisY.createGridAndLabels(gridGroup, labelGroup, this.supportsForeignObject, options, this.eventEmitter);
if (options.showGridBackground) {
Chartist.createGridBackground(gridGroup, chartRect, options.classNames.gridBackground, this.eventEmitter);
}
data.raw.series.forEach(function(series, seriesIndex) {
var seriesElement = seriesGroup.elem('g');
seriesElement.attr({
'ct:series-name': series.name,
'ct:meta': Chartist.serialize(series.meta)
});
seriesElement.addClass([
options.classNames.series,
(series.className || options.classNames.series + '-' + Chartist.alphaNumerate(seriesIndex))
].join(' '));
var pathCoordinates = [],
pathData = [];
data.normalized.series[seriesIndex].forEach(function(value, valueIndex) {
var p = {
x: chartRect.x1 + axisX.projectValue(value, valueIndex, data.normalized.series[seriesIndex]),
y: chartRect.y1 - axisY.projectValue(value, valueIndex, data.normalized.series[seriesIndex])
};
pathCoordinates.push(p.x, p.y);
pathData.push({
value: value,
valueIndex: valueIndex,
meta: Chartist.getMetaData(series, valueIndex)
});
}.bind(this));
var seriesOptions = {
lineSmooth: Chartist.getSeriesOption(series, options, 'lineSmooth'),
showPoint: Chartist.getSeriesOption(series, options, 'showPoint'),
showLine: Chartist.getSeriesOption(series, options, 'showLine'),
showArea: Chartist.getSeriesOption(series, options, 'showArea'),
areaBase: Chartist.getSeriesOption(series, options, 'areaBase')
};
var smoothing = typeof seriesOptions.lineSmooth === 'function' ?
seriesOptions.lineSmooth : (seriesOptions.lineSmooth ? Chartist.Interpolation.monotoneCubic() : Chartist.Interpolation.none());
var path = smoothing(pathCoordinates, pathData);
if (seriesOptions.showPoint) {
path.pathElements.forEach(function(pathElement) {
var point = seriesElement.elem('line', {
x1: pathElement.x,
y1: pathElement.y,
x2: pathElement.x + 0.01,
y2: pathElement.y
}, options.classNames.point).attr({
'ct:value': [pathElement.data.value.x, pathElement.data.value.y].filter(Chartist.isNumeric).join(','),
'ct:meta': Chartist.serialize(pathElement.data.meta)
});
this.eventEmitter.emit('draw', {
type: 'point',
value: pathElement.data.value,
index: pathElement.data.valueIndex,
meta: pathElement.data.meta,
series: series,
seriesIndex: seriesIndex,
axisX: axisX,
axisY: axisY,
group: seriesElement,
element: point,
x: pathElement.x,
y: pathElement.y
});
}.bind(this));
}
if(seriesOptions.showLine) {
var line = seriesElement.elem('path', {
d: path.stringify()
}, options.classNames.line, true);
this.eventEmitter.emit('draw', {
type: 'line',
values: data.normalized.series[seriesIndex],
path: path.clone(),
chartRect: chartRect,
index: seriesIndex,
series: series,
seriesIndex: seriesIndex,
seriesMeta: series.meta,
axisX: axisX,
axisY: axisY,
group: seriesElement,
element: line
});
}
if(seriesOptions.showArea && axisY.range) {
var areaBase = Math.max(Math.min(seriesOptions.areaBase, axisY.range.max), axisY.range.min);
var areaBaseProjected = chartRect.y1 - axisY.projectValue(areaBase);
path.splitByCommand('M').filter(function onlySolidSegments(pathSegment) {
return pathSegment.pathElements.length > 1;
}).map(function convertToArea(solidPathSegments) {
var firstElement = solidPathSegments.pathElements[0];
var lastElement = solidPathSegments.pathElements[solidPathSegments.pathElements.length - 1];
return solidPathSegments.clone(true)
.position(0)
.remove(1)
.move(firstElement.x, areaBaseProjected)
.line(firstElement.x, firstElement.y)
.position(solidPathSegments.pathElements.length + 1)
.line(lastElement.x, areaBaseProjected);
}).forEach(function createArea(areaPath) {
var area = seriesElement.elem('path', {
d: areaPath.stringify()
}, options.classNames.area, true);
this.eventEmitter.emit('draw', {
type: 'area',
values: data.normalized.series[seriesIndex],
path: areaPath.clone(),
series: series,
seriesIndex: seriesIndex,
axisX: axisX,
axisY: axisY,
chartRect: chartRect,
index: seriesIndex,
group: seriesElement,
element: area
});
}.bind(this));
}
}.bind(this));
this.eventEmitter.emit('created', {
bounds: axisY.bounds,
chartRect: chartRect,
axisX: axisX,
axisY: axisY,
svg: this.svg,
options: options
});
}
function Line(query, data, options, responsiveOptions) {
Chartist.Line.super.constructor.call(this,
query,
data,
defaultOptions,
Chartist.extend({}, defaultOptions, options),
responsiveOptions);
}
Chartist.Line = Chartist.Base.extend({
constructor: Line,
createChart: createChart
});
}(window, document, Chartist));
;
(function(window, document, Chartist){
'use strict';
var defaultOptions = {
axisX: {
offset: 30,
position: 'end',
labelOffset: {
x: 0,
y: 0
},
showLabel: true,
showGrid: true,
labelInterpolationFnc: Chartist.noop,
scaleMinSpace: 30,
onlyInteger: false
},
axisY: {
offset: 40,
position: 'start',
labelOffset: {
x: 0,
y: 0
},
showLabel: true,
showGrid: true,
labelInterpolationFnc: Chartist.noop,
scaleMinSpace: 20,
onlyInteger: false
},
width: undefined,
height: undefined,
high: undefined,
low: undefined,
referenceValue: 0,
chartPadding: {
top: 15,
right: 15,
bottom: 5,
left: 10
},
seriesBarDistance: 15,
stackBars: false,
stackMode: 'accumulate',
horizontalBars: false,
distributeSeries: false,
reverseData: false,
showGridBackground: false,
classNames: {
chart: 'ct-chart-bar',
horizontalBars: 'ct-horizontal-bars',
label: 'ct-label',
labelGroup: 'ct-labels',
series: 'ct-series',
bar: 'ct-bar',
grid: 'ct-grid',
gridGroup: 'ct-grids',
gridBackground: 'ct-grid-background',
vertical: 'ct-vertical',
horizontal: 'ct-horizontal',
start: 'ct-start',
end: 'ct-end'
}
};
function createChart(options) {
var data;
var highLow;
if(options.distributeSeries) {
data = Chartist.normalizeData(this.data, options.reverseData, options.horizontalBars ? 'x' : 'y');
data.normalized.series = data.normalized.series.map(function(value) {
return [value];
});
} else {
data = Chartist.normalizeData(this.data, options.reverseData, options.horizontalBars ? 'x' : 'y');
}
this.svg = Chartist.createSvg(
this.container,
options.width,
options.height,
options.classNames.chart + (options.horizontalBars ? ' ' + options.classNames.horizontalBars : '')
);
var gridGroup = this.svg.elem('g').addClass(options.classNames.gridGroup);
var seriesGroup = this.svg.elem('g');
var labelGroup = this.svg.elem('g').addClass(options.classNames.labelGroup);
if(options.stackBars && data.normalized.series.length !== 0) {
var serialSums = Chartist.serialMap(data.normalized.series, function serialSums() {
return Array.prototype.slice.call(arguments).map(function(value) {
return value;
}).reduce(function(prev, curr) {
return {
x: prev.x + (curr && curr.x) || 0,
y: prev.y + (curr && curr.y) || 0
};
}, {x: 0, y: 0});
});
highLow = Chartist.getHighLow([serialSums], options, options.horizontalBars ? 'x' : 'y');
} else {
highLow = Chartist.getHighLow(data.normalized.series, options, options.horizontalBars ? 'x' : 'y');
}
highLow.high = +options.high || (options.high === 0 ? 0 : highLow.high);
highLow.low = +options.low || (options.low === 0 ? 0 : highLow.low);
var chartRect = Chartist.createChartRect(this.svg, options, defaultOptions.padding);
var valueAxis,
labelAxisTicks,
labelAxis,
axisX,
axisY;
if(options.distributeSeries && options.stackBars) {
labelAxisTicks = data.normalized.labels.slice(0, 1);
} else {
labelAxisTicks = data.normalized.labels;
}
if(options.horizontalBars) {
if(options.axisX.type === undefined) {
valueAxis = axisX = new Chartist.AutoScaleAxis(Chartist.Axis.units.x, data.normalized.series, chartRect, Chartist.extend({}, options.axisX, {
highLow: highLow,
referenceValue: 0
}));
} else {
valueAxis = axisX = options.axisX.type.call(Chartist, Chartist.Axis.units.x, data.normalized.series, chartRect, Chartist.extend({}, options.axisX, {
highLow: highLow,
referenceValue: 0
}));
}
if(options.axisY.type === undefined) {
labelAxis = axisY = new Chartist.StepAxis(Chartist.Axis.units.y, data.normalized.series, chartRect, {
ticks: labelAxisTicks
});
} else {
labelAxis = axisY = options.axisY.type.call(Chartist, Chartist.Axis.units.y, data.normalized.series, chartRect, options.axisY);
}
} else {
if(options.axisX.type === undefined) {
labelAxis = axisX = new Chartist.StepAxis(Chartist.Axis.units.x, data.normalized.series, chartRect, {
ticks: labelAxisTicks
});
} else {
labelAxis = axisX = options.axisX.type.call(Chartist, Chartist.Axis.units.x, data.normalized.series, chartRect, options.axisX);
}
if(options.axisY.type === undefined) {
valueAxis = axisY = new Chartist.AutoScaleAxis(Chartist.Axis.units.y, data.normalized.series, chartRect, Chartist.extend({}, options.axisY, {
highLow: highLow,
referenceValue: 0
}));
} else {
valueAxis = axisY = options.axisY.type.call(Chartist, Chartist.Axis.units.y, data.normalized.series, chartRect, Chartist.extend({}, options.axisY, {
highLow: highLow,
referenceValue: 0
}));
}
}
var zeroPoint = options.horizontalBars ? (chartRect.x1 + valueAxis.projectValue(0)) : (chartRect.y1 - valueAxis.projectValue(0));
var stackedBarValues = [];
labelAxis.createGridAndLabels(gridGroup, labelGroup, this.supportsForeignObject, options, this.eventEmitter);
valueAxis.createGridAndLabels(gridGroup, labelGroup, this.supportsForeignObject, options, this.eventEmitter);
if (options.showGridBackground) {
Chartist.createGridBackground(gridGroup, chartRect, options.classNames.gridBackground, this.eventEmitter);
}
data.raw.series.forEach(function(series, seriesIndex) {
var biPol = seriesIndex - (data.raw.series.length - 1) / 2;
var periodHalfLength;
var seriesElement;
if(options.distributeSeries && !options.stackBars) {
periodHalfLength = labelAxis.axisLength / data.normalized.series.length / 2;
} else if(options.distributeSeries && options.stackBars) {
periodHalfLength = labelAxis.axisLength / 2;
} else {
periodHalfLength = labelAxis.axisLength / data.normalized.series[seriesIndex].length / 2;
}
seriesElement = seriesGroup.elem('g');
seriesElement.attr({
'ct:series-name': series.name,
'ct:meta': Chartist.serialize(series.meta)
});
seriesElement.addClass([
options.classNames.series,
(series.className || options.classNames.series + '-' + Chartist.alphaNumerate(seriesIndex))
].join(' '));
data.normalized.series[seriesIndex].forEach(function(value, valueIndex) {
var projected,
bar,
previousStack,
labelAxisValueIndex;
if(options.distributeSeries && !options.stackBars) {
labelAxisValueIndex = seriesIndex;
} else if(options.distributeSeries && options.stackBars) {
labelAxisValueIndex = 0;
} else {
labelAxisValueIndex = valueIndex;
}
if(options.horizontalBars) {
projected = {
x: chartRect.x1 + valueAxis.projectValue(value && value.x ? value.x : 0, valueIndex, data.normalized.series[seriesIndex]),
y: chartRect.y1 - labelAxis.projectValue(value && value.y ? value.y : 0, labelAxisValueIndex, data.normalized.series[seriesIndex])
};
} else {
projected = {
x: chartRect.x1 + labelAxis.projectValue(value && value.x ? value.x : 0, labelAxisValueIndex, data.normalized.series[seriesIndex]),
y: chartRect.y1 - valueAxis.projectValue(value && value.y ? value.y : 0, valueIndex, data.normalized.series[seriesIndex])
}
}
if(labelAxis instanceof Chartist.StepAxis) {
if(!labelAxis.options.stretch) {
projected[labelAxis.units.pos] += periodHalfLength * (options.horizontalBars ? -1 : 1);
}
projected[labelAxis.units.pos] += (options.stackBars || options.distributeSeries) ? 0 : biPol * options.seriesBarDistance * (options.horizontalBars ? -1 : 1);
}
previousStack = stackedBarValues[valueIndex] || zeroPoint;
stackedBarValues[valueIndex] = previousStack - (zeroPoint - projected[labelAxis.counterUnits.pos]);
if(value === undefined) {
return;
}
var positions = {};
positions[labelAxis.units.pos + '1'] = projected[labelAxis.units.pos];
positions[labelAxis.units.pos + '2'] = projected[labelAxis.units.pos];
if(options.stackBars && (options.stackMode === 'accumulate' || !options.stackMode)) {
positions[labelAxis.counterUnits.pos + '1'] = previousStack;
positions[labelAxis.counterUnits.pos + '2'] = stackedBarValues[valueIndex];
} else {
positions[labelAxis.counterUnits.pos + '1'] = zeroPoint;
positions[labelAxis.counterUnits.pos + '2'] = projected[labelAxis.counterUnits.pos];
}
positions.x1 = Math.min(Math.max(positions.x1, chartRect.x1), chartRect.x2);
positions.x2 = Math.min(Math.max(positions.x2, chartRect.x1), chartRect.x2);
positions.y1 = Math.min(Math.max(positions.y1, chartRect.y2), chartRect.y1);
positions.y2 = Math.min(Math.max(positions.y2, chartRect.y2), chartRect.y1);
var metaData = Chartist.getMetaData(series, valueIndex);
bar = seriesElement.elem('line', positions, options.classNames.bar).attr({
'ct:value': [value.x, value.y].filter(Chartist.isNumeric).join(','),
'ct:meta': Chartist.serialize(metaData)
});
this.eventEmitter.emit('draw', Chartist.extend({
type: 'bar',
value: value,
index: valueIndex,
meta: metaData,
series: series,
seriesIndex: seriesIndex,
axisX: axisX,
axisY: axisY,
chartRect: chartRect,
group: seriesElement,
element: bar
}, positions));
}.bind(this));
}.bind(this));
this.eventEmitter.emit('created', {
bounds: valueAxis.bounds,
chartRect: chartRect,
axisX: axisX,
axisY: axisY,
svg: this.svg,
options: options
});
}
function Bar(query, data, options, responsiveOptions) {
Chartist.Bar.super.constructor.call(this,
query,
data,
defaultOptions,
Chartist.extend({}, defaultOptions, options),
responsiveOptions);
}
Chartist.Bar = Chartist.Base.extend({
constructor: Bar,
createChart: createChart
});
}(window, document, Chartist));
;
(function(window, document, Chartist) {
'use strict';
var defaultOptions = {
width: undefined,
height: undefined,
chartPadding: 5,
classNames: {
chartPie: 'ct-chart-pie',
chartDonut: 'ct-chart-donut',
series: 'ct-series',
slicePie: 'ct-slice-pie',
sliceDonut: 'ct-slice-donut',
sliceDonutSolid: 'ct-slice-donut-solid',
label: 'ct-label'
},
startAngle: 0,
total: undefined,
donut: false,
donutSolid: false,
donutWidth: 60,
showLabel: true,
labelOffset: 0,
labelPosition: 'inside',
labelInterpolationFnc: Chartist.noop,
labelDirection: 'neutral',
reverseData: false,
ignoreEmptyValues: false
};
function determineAnchorPosition(center, label, direction) {
var toTheRight = label.x > center.x;
if(toTheRight && direction === 'explode' ||
!toTheRight && direction === 'implode') {
return 'start';
} else if(toTheRight && direction === 'implode' ||
!toTheRight && direction === 'explode') {
return 'end';
} else {
return 'middle';
}
}
function createChart(options) {
var data = Chartist.normalizeData(this.data);
var seriesGroups = [],
labelsGroup,
chartRect,
radius,
labelRadius,
totalDataSum,
startAngle = options.startAngle;
this.svg = Chartist.createSvg(this.container, options.width, options.height,options.donut ? options.classNames.chartDonut : options.classNames.chartPie);
chartRect = Chartist.createChartRect(this.svg, options, defaultOptions.padding);
radius = Math.min(chartRect.width() / 2, chartRect.height() / 2);
totalDataSum = options.total || data.normalized.series.reduce(function(previousValue, currentValue) {
return previousValue + currentValue;
}, 0);
var donutWidth = Chartist.quantity(options.donutWidth);
if (donutWidth.unit === '%') {
donutWidth.value *= radius / 100;
}
radius -= options.donut && !options.donutSolid ? donutWidth.value / 2  : 0;
if(options.labelPosition === 'outside' || options.donut && !options.donutSolid) {
labelRadius = radius;
} else if(options.labelPosition === 'center') {
labelRadius = 0;
} else if(options.donutSolid) {
labelRadius = radius - donutWidth.value / 2;
} else {
labelRadius = radius / 2;
}
labelRadius += options.labelOffset;
var center = {
x: chartRect.x1 + chartRect.width() / 2,
y: chartRect.y2 + chartRect.height() / 2
};
var hasSingleValInSeries = data.raw.series.filter(function(val) {
return val.hasOwnProperty('value') ? val.value !== 0 : val !== 0;
}).length === 1;
data.raw.series.forEach(function(series, index) {
seriesGroups[index] = this.svg.elem('g', null, null);
}.bind(this));
if(options.showLabel) {
labelsGroup = this.svg.elem('g', null, null);
}
data.raw.series.forEach(function(series, index) {
if (data.normalized.series[index] === 0 && options.ignoreEmptyValues) return;
seriesGroups[index].attr({
'ct:series-name': series.name
});
seriesGroups[index].addClass([
options.classNames.series,
(series.className || options.classNames.series + '-' + Chartist.alphaNumerate(index))
].join(' '));
var endAngle = (totalDataSum > 0 ? startAngle + data.normalized.series[index] / totalDataSum * 360 : 0);
var overlappigStartAngle = Math.max(0, startAngle - (index === 0 || hasSingleValInSeries ? 0 : 0.2));
if(endAngle - overlappigStartAngle >= 359.99) {
endAngle = overlappigStartAngle + 359.99;
}
var start = Chartist.polarToCartesian(center.x, center.y, radius, overlappigStartAngle),
end = Chartist.polarToCartesian(center.x, center.y, radius, endAngle);
var innerStart,
innerEnd,
donutSolidRadius;
var path = new Chartist.Svg.Path(!options.donut || options.donutSolid)
.move(end.x, end.y)
.arc(radius, radius, 0, endAngle - startAngle > 180, 0, start.x, start.y);
if(!options.donut) {
path.line(center.x, center.y);
} else if (options.donutSolid) {
donutSolidRadius = radius - donutWidth.value;
innerStart = Chartist.polarToCartesian(center.x, center.y, donutSolidRadius, startAngle - (index === 0 || hasSingleValInSeries ? 0 : 0.2));
innerEnd = Chartist.polarToCartesian(center.x, center.y, donutSolidRadius, endAngle);
path.line(innerStart.x, innerStart.y);
path.arc(donutSolidRadius, donutSolidRadius, 0, endAngle - startAngle  > 180, 1, innerEnd.x, innerEnd.y);
}
var pathClassName = options.classNames.slicePie;
if (options.donut) {
pathClassName = options.classNames.sliceDonut;
if (options.donutSolid) {
pathClassName = options.classNames.sliceDonutSolid;
}
}
var pathElement = seriesGroups[index].elem('path', {
d: path.stringify()
}, pathClassName);
pathElement.attr({
'ct:value': data.normalized.series[index],
'ct:meta': Chartist.serialize(series.meta)
});
if(options.donut && !options.donutSolid) {
pathElement._node.style.strokeWidth = donutWidth.value + 'px';
}
this.eventEmitter.emit('draw', {
type: 'slice',
value: data.normalized.series[index],
totalDataSum: totalDataSum,
index: index,
meta: series.meta,
series: series,
group: seriesGroups[index],
element: pathElement,
path: path.clone(),
center: center,
radius: radius,
startAngle: startAngle,
endAngle: endAngle
});
if(options.showLabel) {
var labelPosition;
if(data.raw.series.length === 1) {
labelPosition = {
x: center.x,
y: center.y
};
} else {
labelPosition = Chartist.polarToCartesian(
center.x,
center.y,
labelRadius,
startAngle + (endAngle - startAngle) / 2
);
}
var rawValue;
if(data.normalized.labels && !Chartist.isFalseyButZero(data.normalized.labels[index])) {
rawValue = data.normalized.labels[index];
} else {
rawValue = data.normalized.series[index];
}
var interpolatedValue = options.labelInterpolationFnc(rawValue, index);
if(interpolatedValue || interpolatedValue === 0) {
var labelElement = labelsGroup.elem('text', {
dx: labelPosition.x,
dy: labelPosition.y,
'text-anchor': determineAnchorPosition(center, labelPosition, options.labelDirection)
}, options.classNames.label).text('' + interpolatedValue);
this.eventEmitter.emit('draw', {
type: 'label',
index: index,
group: labelsGroup,
element: labelElement,
text: '' + interpolatedValue,
x: labelPosition.x,
y: labelPosition.y
});
}
}
startAngle = endAngle;
}.bind(this));
this.eventEmitter.emit('created', {
chartRect: chartRect,
svg: this.svg,
options: options
});
}
function Pie(query, data, options, responsiveOptions) {
Chartist.Pie.super.constructor.call(this,
query,
data,
defaultOptions,
Chartist.extend({}, defaultOptions, options),
responsiveOptions);
}
Chartist.Pie = Chartist.Base.extend({
constructor: Pie,
createChart: createChart,
determineAnchorPosition: determineAnchorPosition
});
}(window, document, Chartist));
return Chartist;
}));
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.Chart = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var colorNames = require(5);
module.exports = {
getRgba: getRgba,
getHsla: getHsla,
getRgb: getRgb,
getHsl: getHsl,
getHwb: getHwb,
getAlpha: getAlpha,
hexString: hexString,
rgbString: rgbString,
rgbaString: rgbaString,
percentString: percentString,
percentaString: percentaString,
hslString: hslString,
hslaString: hslaString,
hwbString: hwbString,
keyword: keyword
}
function getRgba(string) {
if (!string) {
return;
}
var abbr =  /^#([a-fA-F0-9]{3})$/i,
hex =  /^#([a-fA-F0-9]{6})$/i,
rgba = /^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i,
per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i,
keyword = /(\w+)/;
var rgb = [0, 0, 0],
a = 1,
match = string.match(abbr);
if (match) {
match = match[1];
for (var i = 0; i < rgb.length; i++) {
rgb[i] = parseInt(match[i] + match[i], 16);
}
}
else if (match = string.match(hex)) {
match = match[1];
for (var i = 0; i < rgb.length; i++) {
rgb[i] = parseInt(match.slice(i * 2, i * 2 + 2), 16);
}
}
else if (match = string.match(rgba)) {
for (var i = 0; i < rgb.length; i++) {
rgb[i] = parseInt(match[i + 1]);
}
a = parseFloat(match[4]);
}
else if (match = string.match(per)) {
for (var i = 0; i < rgb.length; i++) {
rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
}
a = parseFloat(match[4]);
}
else if (match = string.match(keyword)) {
if (match[1] == "transparent") {
return [0, 0, 0, 0];
}
rgb = colorNames[match[1]];
if (!rgb) {
return;
}
}
for (var i = 0; i < rgb.length; i++) {
rgb[i] = scale(rgb[i], 0, 255);
}
if (!a && a != 0) {
a = 1;
}
else {
a = scale(a, 0, 1);
}
rgb[3] = a;
return rgb;
}
function getHsla(string) {
if (!string) {
return;
}
var hsl = /^hsla?\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
var match = string.match(hsl);
if (match) {
var alpha = parseFloat(match[4]);
var h = scale(parseInt(match[1]), 0, 360),
s = scale(parseFloat(match[2]), 0, 100),
l = scale(parseFloat(match[3]), 0, 100),
a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
return [h, s, l, a];
}
}
function getHwb(string) {
if (!string) {
return;
}
var hwb = /^hwb\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
var match = string.match(hwb);
if (match) {
var alpha = parseFloat(match[4]);
var h = scale(parseInt(match[1]), 0, 360),
w = scale(parseFloat(match[2]), 0, 100),
b = scale(parseFloat(match[3]), 0, 100),
a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
return [h, w, b, a];
}
}
function getRgb(string) {
var rgba = getRgba(string);
return rgba && rgba.slice(0, 3);
}
function getHsl(string) {
var hsla = getHsla(string);
return hsla && hsla.slice(0, 3);
}
function getAlpha(string) {
var vals = getRgba(string);
if (vals) {
return vals[3];
}
else if (vals = getHsla(string)) {
return vals[3];
}
else if (vals = getHwb(string)) {
return vals[3];
}
}
function hexString(rgb) {
return "#" + hexDouble(rgb[0]) + hexDouble(rgb[1])
+ hexDouble(rgb[2]);
}
function rgbString(rgba, alpha) {
if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {
return rgbaString(rgba, alpha);
}
return "rgb(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2] + ")";
}
function rgbaString(rgba, alpha) {
if (alpha === undefined) {
alpha = (rgba[3] !== undefined ? rgba[3] : 1);
}
return "rgba(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2]
+ ", " + alpha + ")";
}
function percentString(rgba, alpha) {
if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {
return percentaString(rgba, alpha);
}
var r = Math.round(rgba[0]/255 * 100),
g = Math.round(rgba[1]/255 * 100),
b = Math.round(rgba[2]/255 * 100);
return "rgb(" + r + "%, " + g + "%, " + b + "%)";
}
function percentaString(rgba, alpha) {
var r = Math.round(rgba[0]/255 * 100),
g = Math.round(rgba[1]/255 * 100),
b = Math.round(rgba[2]/255 * 100);
return "rgba(" + r + "%, " + g + "%, " + b + "%, " + (alpha || rgba[3] || 1) + ")";
}
function hslString(hsla, alpha) {
if (alpha < 1 || (hsla[3] && hsla[3] < 1)) {
return hslaString(hsla, alpha);
}
return "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)";
}
function hslaString(hsla, alpha) {
if (alpha === undefined) {
alpha = (hsla[3] !== undefined ? hsla[3] : 1);
}
return "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, "
+ alpha + ")";
}
function hwbString(hwb, alpha) {
if (alpha === undefined) {
alpha = (hwb[3] !== undefined ? hwb[3] : 1);
}
return "hwb(" + hwb[0] + ", " + hwb[1] + "%, " + hwb[2] + "%"
+ (alpha !== undefined && alpha !== 1 ? ", " + alpha : "") + ")";
}
function keyword(rgb) {
return reverseNames[rgb.slice(0, 3)];
}
function scale(num, min, max) {
return Math.min(Math.max(min, num), max);
}
function hexDouble(num) {
var str = num.toString(16).toUpperCase();
return (str.length < 2) ? "0" + str : str;
}
var reverseNames = {};
for (var name in colorNames) {
reverseNames[colorNames[name]] = name;
}
},{"5":5}],2:[function(require,module,exports){
var convert = require(4);
var string = require(1);
var Color = function (obj) {
if (obj instanceof Color) {
return obj;
}
if (!(this instanceof Color)) {
return new Color(obj);
}
this.valid = false;
this.values = {
rgb: [0, 0, 0],
hsl: [0, 0, 0],
hsv: [0, 0, 0],
hwb: [0, 0, 0],
cmyk: [0, 0, 0, 0],
alpha: 1
};
var vals;
if (typeof obj === 'string') {
vals = string.getRgba(obj);
if (vals) {
this.setValues('rgb', vals);
} else if (vals = string.getHsla(obj)) {
this.setValues('hsl', vals);
} else if (vals = string.getHwb(obj)) {
this.setValues('hwb', vals);
}
} else if (typeof obj === 'object') {
vals = obj;
if (vals.r !== undefined || vals.red !== undefined) {
this.setValues('rgb', vals);
} else if (vals.l !== undefined || vals.lightness !== undefined) {
this.setValues('hsl', vals);
} else if (vals.v !== undefined || vals.value !== undefined) {
this.setValues('hsv', vals);
} else if (vals.w !== undefined || vals.whiteness !== undefined) {
this.setValues('hwb', vals);
} else if (vals.c !== undefined || vals.cyan !== undefined) {
this.setValues('cmyk', vals);
}
}
};
Color.prototype = {
isValid: function () {
return this.valid;
},
rgb: function () {
return this.setSpace('rgb', arguments);
},
hsl: function () {
return this.setSpace('hsl', arguments);
},
hsv: function () {
return this.setSpace('hsv', arguments);
},
hwb: function () {
return this.setSpace('hwb', arguments);
},
cmyk: function () {
return this.setSpace('cmyk', arguments);
},
rgbArray: function () {
return this.values.rgb;
},
hslArray: function () {
return this.values.hsl;
},
hsvArray: function () {
return this.values.hsv;
},
hwbArray: function () {
var values = this.values;
if (values.alpha !== 1) {
return values.hwb.concat([values.alpha]);
}
return values.hwb;
},
cmykArray: function () {
return this.values.cmyk;
},
rgbaArray: function () {
var values = this.values;
return values.rgb.concat([values.alpha]);
},
hslaArray: function () {
var values = this.values;
return values.hsl.concat([values.alpha]);
},
alpha: function (val) {
if (val === undefined) {
return this.values.alpha;
}
this.setValues('alpha', val);
return this;
},
red: function (val) {
return this.setChannel('rgb', 0, val);
},
green: function (val) {
return this.setChannel('rgb', 1, val);
},
blue: function (val) {
return this.setChannel('rgb', 2, val);
},
hue: function (val) {
if (val) {
val %= 360;
val = val < 0 ? 360 + val : val;
}
return this.setChannel('hsl', 0, val);
},
saturation: function (val) {
return this.setChannel('hsl', 1, val);
},
lightness: function (val) {
return this.setChannel('hsl', 2, val);
},
saturationv: function (val) {
return this.setChannel('hsv', 1, val);
},
whiteness: function (val) {
return this.setChannel('hwb', 1, val);
},
blackness: function (val) {
return this.setChannel('hwb', 2, val);
},
value: function (val) {
return this.setChannel('hsv', 2, val);
},
cyan: function (val) {
return this.setChannel('cmyk', 0, val);
},
magenta: function (val) {
return this.setChannel('cmyk', 1, val);
},
yellow: function (val) {
return this.setChannel('cmyk', 2, val);
},
black: function (val) {
return this.setChannel('cmyk', 3, val);
},
hexString: function () {
return string.hexString(this.values.rgb);
},
rgbString: function () {
return string.rgbString(this.values.rgb, this.values.alpha);
},
rgbaString: function () {
return string.rgbaString(this.values.rgb, this.values.alpha);
},
percentString: function () {
return string.percentString(this.values.rgb, this.values.alpha);
},
hslString: function () {
return string.hslString(this.values.hsl, this.values.alpha);
},
hslaString: function () {
return string.hslaString(this.values.hsl, this.values.alpha);
},
hwbString: function () {
return string.hwbString(this.values.hwb, this.values.alpha);
},
keyword: function () {
return string.keyword(this.values.rgb, this.values.alpha);
},
rgbNumber: function () {
var rgb = this.values.rgb;
return (rgb[0] << 16) | (rgb[1] << 8) | rgb[2];
},
luminosity: function () {
var rgb = this.values.rgb;
var lum = [];
for (var i = 0; i < rgb.length; i++) {
var chan = rgb[i] / 255;
lum[i] = (chan <= 0.03928) ? chan / 12.92 : Math.pow(((chan + 0.055) / 1.055), 2.4);
}
return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
},
contrast: function (color2) {
var lum1 = this.luminosity();
var lum2 = color2.luminosity();
if (lum1 > lum2) {
return (lum1 + 0.05) / (lum2 + 0.05);
}
return (lum2 + 0.05) / (lum1 + 0.05);
},
level: function (color2) {
var contrastRatio = this.contrast(color2);
if (contrastRatio >= 7.1) {
return 'AAA';
}
return (contrastRatio >= 4.5) ? 'AA' : '';
},
dark: function () {
var rgb = this.values.rgb;
var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
return yiq < 128;
},
light: function () {
return !this.dark();
},
negate: function () {
var rgb = [];
for (var i = 0; i < 3; i++) {
rgb[i] = 255 - this.values.rgb[i];
}
this.setValues('rgb', rgb);
return this;
},
lighten: function (ratio) {
var hsl = this.values.hsl;
hsl[2] += hsl[2] * ratio;
this.setValues('hsl', hsl);
return this;
},
darken: function (ratio) {
var hsl = this.values.hsl;
hsl[2] -= hsl[2] * ratio;
this.setValues('hsl', hsl);
return this;
},
saturate: function (ratio) {
var hsl = this.values.hsl;
hsl[1] += hsl[1] * ratio;
this.setValues('hsl', hsl);
return this;
},
desaturate: function (ratio) {
var hsl = this.values.hsl;
hsl[1] -= hsl[1] * ratio;
this.setValues('hsl', hsl);
return this;
},
whiten: function (ratio) {
var hwb = this.values.hwb;
hwb[1] += hwb[1] * ratio;
this.setValues('hwb', hwb);
return this;
},
blacken: function (ratio) {
var hwb = this.values.hwb;
hwb[2] += hwb[2] * ratio;
this.setValues('hwb', hwb);
return this;
},
greyscale: function () {
var rgb = this.values.rgb;
var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
this.setValues('rgb', [val, val, val]);
return this;
},
clearer: function (ratio) {
var alpha = this.values.alpha;
this.setValues('alpha', alpha - (alpha * ratio));
return this;
},
opaquer: function (ratio) {
var alpha = this.values.alpha;
this.setValues('alpha', alpha + (alpha * ratio));
return this;
},
rotate: function (degrees) {
var hsl = this.values.hsl;
var hue = (hsl[0] + degrees) % 360;
hsl[0] = hue < 0 ? 360 + hue : hue;
this.setValues('hsl', hsl);
return this;
},
mix: function (mixinColor, weight) {
var color1 = this;
var color2 = mixinColor;
var p = weight === undefined ? 0.5 : weight;
var w = 2 * p - 1;
var a = color1.alpha() - color2.alpha();
var w1 = (((w * a === -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
var w2 = 1 - w1;
return this
.rgb(
w1 * color1.red() + w2 * color2.red(),
w1 * color1.green() + w2 * color2.green(),
w1 * color1.blue() + w2 * color2.blue()
)
.alpha(color1.alpha() * p + color2.alpha() * (1 - p));
},
toJSON: function () {
return this.rgb();
},
clone: function () {
var result = new Color();
var source = this.values;
var target = result.values;
var value, type;
for (var prop in source) {
if (source.hasOwnProperty(prop)) {
value = source[prop];
type = ({}).toString.call(value);
if (type === '[object Array]') {
target[prop] = value.slice(0);
} else if (type === '[object Number]') {
target[prop] = value;
} else {
console.error('unexpected color value:', value);
}
}
}
return result;
}
};
Color.prototype.spaces = {
rgb: ['red', 'green', 'blue'],
hsl: ['hue', 'saturation', 'lightness'],
hsv: ['hue', 'saturation', 'value'],
hwb: ['hue', 'whiteness', 'blackness'],
cmyk: ['cyan', 'magenta', 'yellow', 'black']
};
Color.prototype.maxes = {
rgb: [255, 255, 255],
hsl: [360, 100, 100],
hsv: [360, 100, 100],
hwb: [360, 100, 100],
cmyk: [100, 100, 100, 100]
};
Color.prototype.getValues = function (space) {
var values = this.values;
var vals = {};
for (var i = 0; i < space.length; i++) {
vals[space.charAt(i)] = values[space][i];
}
if (values.alpha !== 1) {
vals.a = values.alpha;
}
return vals;
};
Color.prototype.setValues = function (space, vals) {
var values = this.values;
var spaces = this.spaces;
var maxes = this.maxes;
var alpha = 1;
var i;
this.valid = true;
if (space === 'alpha') {
alpha = vals;
} else if (vals.length) {
values[space] = vals.slice(0, space.length);
alpha = vals[space.length];
} else if (vals[space.charAt(0)] !== undefined) {
for (i = 0; i < space.length; i++) {
values[space][i] = vals[space.charAt(i)];
}
alpha = vals.a;
} else if (vals[spaces[space][0]] !== undefined) {
var chans = spaces[space];
for (i = 0; i < space.length; i++) {
values[space][i] = vals[chans[i]];
}
alpha = vals.alpha;
}
values.alpha = Math.max(0, Math.min(1, (alpha === undefined ? values.alpha : alpha)));
if (space === 'alpha') {
return false;
}
var capped;
for (i = 0; i < space.length; i++) {
capped = Math.max(0, Math.min(maxes[space][i], values[space][i]));
values[space][i] = Math.round(capped);
}
for (var sname in spaces) {
if (sname !== space) {
values[sname] = convert[space][sname](values[space]);
}
}
return true;
};
Color.prototype.setSpace = function (space, args) {
var vals = args[0];
if (vals === undefined) {
return this.getValues(space);
}
if (typeof vals === 'number') {
vals = Array.prototype.slice.call(args);
}
this.setValues(space, vals);
return this;
};
Color.prototype.setChannel = function (space, index, val) {
var svalues = this.values[space];
if (val === undefined) {
return svalues[index];
} else if (val === svalues[index]) {
return this;
}
svalues[index] = val;
this.setValues(space, svalues);
return this;
};
if (typeof window !== 'undefined') {
window.Color = Color;
}
module.exports = Color;
},{"1":1,"4":4}],3:[function(require,module,exports){
module.exports = {
rgb2hsl: rgb2hsl,
rgb2hsv: rgb2hsv,
rgb2hwb: rgb2hwb,
rgb2cmyk: rgb2cmyk,
rgb2keyword: rgb2keyword,
rgb2xyz: rgb2xyz,
rgb2lab: rgb2lab,
rgb2lch: rgb2lch,
hsl2rgb: hsl2rgb,
hsl2hsv: hsl2hsv,
hsl2hwb: hsl2hwb,
hsl2cmyk: hsl2cmyk,
hsl2keyword: hsl2keyword,
hsv2rgb: hsv2rgb,
hsv2hsl: hsv2hsl,
hsv2hwb: hsv2hwb,
hsv2cmyk: hsv2cmyk,
hsv2keyword: hsv2keyword,
hwb2rgb: hwb2rgb,
hwb2hsl: hwb2hsl,
hwb2hsv: hwb2hsv,
hwb2cmyk: hwb2cmyk,
hwb2keyword: hwb2keyword,
cmyk2rgb: cmyk2rgb,
cmyk2hsl: cmyk2hsl,
cmyk2hsv: cmyk2hsv,
cmyk2hwb: cmyk2hwb,
cmyk2keyword: cmyk2keyword,
keyword2rgb: keyword2rgb,
keyword2hsl: keyword2hsl,
keyword2hsv: keyword2hsv,
keyword2hwb: keyword2hwb,
keyword2cmyk: keyword2cmyk,
keyword2lab: keyword2lab,
keyword2xyz: keyword2xyz,
xyz2rgb: xyz2rgb,
xyz2lab: xyz2lab,
xyz2lch: xyz2lch,
lab2xyz: lab2xyz,
lab2rgb: lab2rgb,
lab2lch: lab2lch,
lch2lab: lch2lab,
lch2xyz: lch2xyz,
lch2rgb: lch2rgb
}
function rgb2hsl(rgb) {
var r = rgb[0]/255,
g = rgb[1]/255,
b = rgb[2]/255,
min = Math.min(r, g, b),
max = Math.max(r, g, b),
delta = max - min,
h, s, l;
if (max == min)
h = 0;
else if (r == max)
h = (g - b) / delta;
else if (g == max)
h = 2 + (b - r) / delta;
else if (b == max)
h = 4 + (r - g)/ delta;
h = Math.min(h * 60, 360);
if (h < 0)
h += 360;
l = (min + max) / 2;
if (max == min)
s = 0;
else if (l <= 0.5)
s = delta / (max + min);
else
s = delta / (2 - max - min);
return [h, s * 100, l * 100];
}
function rgb2hsv(rgb) {
var r = rgb[0],
g = rgb[1],
b = rgb[2],
min = Math.min(r, g, b),
max = Math.max(r, g, b),
delta = max - min,
h, s, v;
if (max == 0)
s = 0;
else
s = (delta/max * 1000)/10;
if (max == min)
h = 0;
else if (r == max)
h = (g - b) / delta;
else if (g == max)
h = 2 + (b - r) / delta;
else if (b == max)
h = 4 + (r - g) / delta;
h = Math.min(h * 60, 360);
if (h < 0)
h += 360;
v = ((max / 255) * 1000) / 10;
return [h, s, v];
}
function rgb2hwb(rgb) {
var r = rgb[0],
g = rgb[1],
b = rgb[2],
h = rgb2hsl(rgb)[0],
w = 1/255 * Math.min(r, Math.min(g, b)),
b = 1 - 1/255 * Math.max(r, Math.max(g, b));
return [h, w * 100, b * 100];
}
function rgb2cmyk(rgb) {
var r = rgb[0] / 255,
g = rgb[1] / 255,
b = rgb[2] / 255,
c, m, y, k;
k = Math.min(1 - r, 1 - g, 1 - b);
c = (1 - r - k) / (1 - k) || 0;
m = (1 - g - k) / (1 - k) || 0;
y = (1 - b - k) / (1 - k) || 0;
return [c * 100, m * 100, y * 100, k * 100];
}
function rgb2keyword(rgb) {
return reverseKeywords[JSON.stringify(rgb)];
}
function rgb2xyz(rgb) {
var r = rgb[0] / 255,
g = rgb[1] / 255,
b = rgb[2] / 255;
r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);
g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);
b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);
var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);
return [x * 100, y *100, z * 100];
}
function rgb2lab(rgb) {
var xyz = rgb2xyz(rgb),
x = xyz[0],
y = xyz[1],
z = xyz[2],
l, a, b;
x /= 95.047;
y /= 100;
z /= 108.883;
x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);
y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);
z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);
l = (116 * y) - 16;
a = 500 * (x - y);
b = 200 * (y - z);
return [l, a, b];
}
function rgb2lch(args) {
return lab2lch(rgb2lab(args));
}
function hsl2rgb(hsl) {
var h = hsl[0] / 360,
s = hsl[1] / 100,
l = hsl[2] / 100,
t1, t2, t3, rgb, val;
if (s == 0) {
val = l * 255;
return [val, val, val];
}
if (l < 0.5)
t2 = l * (1 + s);
else
t2 = l + s - l * s;
t1 = 2 * l - t2;
rgb = [0, 0, 0];
for (var i = 0; i < 3; i++) {
t3 = h + 1 / 3 * - (i - 1);
t3 < 0 && t3++;
t3 > 1 && t3--;
if (6 * t3 < 1)
val = t1 + (t2 - t1) * 6 * t3;
else if (2 * t3 < 1)
val = t2;
else if (3 * t3 < 2)
val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
else
val = t1;
rgb[i] = val * 255;
}
return rgb;
}
function hsl2hsv(hsl) {
var h = hsl[0],
s = hsl[1] / 100,
l = hsl[2] / 100,
sv, v;
if(l === 0) {
return [0, 0, 0];
}
l *= 2;
s *= (l <= 1) ? l : 2 - l;
v = (l + s) / 2;
sv = (2 * s) / (l + s);
return [h, sv * 100, v * 100];
}
function hsl2hwb(args) {
return rgb2hwb(hsl2rgb(args));
}
function hsl2cmyk(args) {
return rgb2cmyk(hsl2rgb(args));
}
function hsl2keyword(args) {
return rgb2keyword(hsl2rgb(args));
}
function hsv2rgb(hsv) {
var h = hsv[0] / 60,
s = hsv[1] / 100,
v = hsv[2] / 100,
hi = Math.floor(h) % 6;
var f = h - Math.floor(h),
p = 255 * v * (1 - s),
q = 255 * v * (1 - (s * f)),
t = 255 * v * (1 - (s * (1 - f))),
v = 255 * v;
switch(hi) {
case 0:
return [v, t, p];
case 1:
return [q, v, p];
case 2:
return [p, v, t];
case 3:
return [p, q, v];
case 4:
return [t, p, v];
case 5:
return [v, p, q];
}
}
function hsv2hsl(hsv) {
var h = hsv[0],
s = hsv[1] / 100,
v = hsv[2] / 100,
sl, l;
l = (2 - s) * v;
sl = s * v;
sl /= (l <= 1) ? l : 2 - l;
sl = sl || 0;
l /= 2;
return [h, sl * 100, l * 100];
}
function hsv2hwb(args) {
return rgb2hwb(hsv2rgb(args))
}
function hsv2cmyk(args) {
return rgb2cmyk(hsv2rgb(args));
}
function hsv2keyword(args) {
return rgb2keyword(hsv2rgb(args));
}
function hwb2rgb(hwb) {
var h = hwb[0] / 360,
wh = hwb[1] / 100,
bl = hwb[2] / 100,
ratio = wh + bl,
i, v, f, n;
if (ratio > 1) {
wh /= ratio;
bl /= ratio;
}
i = Math.floor(6 * h);
v = 1 - bl;
f = 6 * h - i;
if ((i & 0x01) != 0) {
f = 1 - f;
}
n = wh + f * (v - wh);  // linear interpolation
switch (i) {
default:
case 6:
case 0: r = v; g = n; b = wh; break;
case 1: r = n; g = v; b = wh; break;
case 2: r = wh; g = v; b = n; break;
case 3: r = wh; g = n; b = v; break;
case 4: r = n; g = wh; b = v; break;
case 5: r = v; g = wh; b = n; break;
}
return [r * 255, g * 255, b * 255];
}
function hwb2hsl(args) {
return rgb2hsl(hwb2rgb(args));
}
function hwb2hsv(args) {
return rgb2hsv(hwb2rgb(args));
}
function hwb2cmyk(args) {
return rgb2cmyk(hwb2rgb(args));
}
function hwb2keyword(args) {
return rgb2keyword(hwb2rgb(args));
}
function cmyk2rgb(cmyk) {
var c = cmyk[0] / 100,
m = cmyk[1] / 100,
y = cmyk[2] / 100,
k = cmyk[3] / 100,
r, g, b;
r = 1 - Math.min(1, c * (1 - k) + k);
g = 1 - Math.min(1, m * (1 - k) + k);
b = 1 - Math.min(1, y * (1 - k) + k);
return [r * 255, g * 255, b * 255];
}
function cmyk2hsl(args) {
return rgb2hsl(cmyk2rgb(args));
}
function cmyk2hsv(args) {
return rgb2hsv(cmyk2rgb(args));
}
function cmyk2hwb(args) {
return rgb2hwb(cmyk2rgb(args));
}
function cmyk2keyword(args) {
return rgb2keyword(cmyk2rgb(args));
}
function xyz2rgb(xyz) {
var x = xyz[0] / 100,
y = xyz[1] / 100,
z = xyz[2] / 100,
r, g, b;
r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);
r = r > 0.0031308 ? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)
: r = (r * 12.92);
g = g > 0.0031308 ? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)
: g = (g * 12.92);
b = b > 0.0031308 ? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)
: b = (b * 12.92);
r = Math.min(Math.max(0, r), 1);
g = Math.min(Math.max(0, g), 1);
b = Math.min(Math.max(0, b), 1);
return [r * 255, g * 255, b * 255];
}
function xyz2lab(xyz) {
var x = xyz[0],
y = xyz[1],
z = xyz[2],
l, a, b;
x /= 95.047;
y /= 100;
z /= 108.883;
x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);
y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);
z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);
l = (116 * y) - 16;
a = 500 * (x - y);
b = 200 * (y - z);
return [l, a, b];
}
function xyz2lch(args) {
return lab2lch(xyz2lab(args));
}
function lab2xyz(lab) {
var l = lab[0],
a = lab[1],
b = lab[2],
x, y, z, y2;
if (l <= 8) {
y = (l * 100) / 903.3;
y2 = (7.787 * (y / 100)) + (16 / 116);
} else {
y = 100 * Math.pow((l + 16) / 116, 3);
y2 = Math.pow(y / 100, 1/3);
}
x = x / 95.047 <= 0.008856 ? x = (95.047 * ((a / 500) + y2 - (16 / 116))) / 7.787 : 95.047 * Math.pow((a / 500) + y2, 3);
z = z / 108.883 <= 0.008859 ? z = (108.883 * (y2 - (b / 200) - (16 / 116))) / 7.787 : 108.883 * Math.pow(y2 - (b / 200), 3);
return [x, y, z];
}
function lab2lch(lab) {
var l = lab[0],
a = lab[1],
b = lab[2],
hr, h, c;
hr = Math.atan2(b, a);
h = hr * 360 / 2 / Math.PI;
if (h < 0) {
h += 360;
}
c = Math.sqrt(a * a + b * b);
return [l, c, h];
}
function lab2rgb(args) {
return xyz2rgb(lab2xyz(args));
}
function lch2lab(lch) {
var l = lch[0],
c = lch[1],
h = lch[2],
a, b, hr;
hr = h / 360 * 2 * Math.PI;
a = c * Math.cos(hr);
b = c * Math.sin(hr);
return [l, a, b];
}
function lch2xyz(args) {
return lab2xyz(lch2lab(args));
}
function lch2rgb(args) {
return lab2rgb(lch2lab(args));
}
function keyword2rgb(keyword) {
return cssKeywords[keyword];
}
function keyword2hsl(args) {
return rgb2hsl(keyword2rgb(args));
}
function keyword2hsv(args) {
return rgb2hsv(keyword2rgb(args));
}
function keyword2hwb(args) {
return rgb2hwb(keyword2rgb(args));
}
function keyword2cmyk(args) {
return rgb2cmyk(keyword2rgb(args));
}
function keyword2lab(args) {
return rgb2lab(keyword2rgb(args));
}
function keyword2xyz(args) {
return rgb2xyz(keyword2rgb(args));
}
var cssKeywords = {
aliceblue:  [240,248,255],
antiquewhite: [250,235,215],
aqua: [0,255,255],
aquamarine: [127,255,212],
azure:  [240,255,255],
beige:  [245,245,220],
bisque: [255,228,196],
black:  [0,0,0],
blanchedalmond: [255,235,205],
blue: [0,0,255],
blueviolet: [138,43,226],
brown:  [165,42,42],
burlywood:  [222,184,135],
cadetblue:  [95,158,160],
chartreuse: [127,255,0],
chocolate:  [210,105,30],
coral:  [255,127,80],
cornflowerblue: [100,149,237],
cornsilk: [255,248,220],
crimson:  [220,20,60],
cyan: [0,255,255],
darkblue: [0,0,139],
darkcyan: [0,139,139],
darkgoldenrod:  [184,134,11],
darkgray: [169,169,169],
darkgreen:  [0,100,0],
darkgrey: [169,169,169],
darkkhaki:  [189,183,107],
darkmagenta:  [139,0,139],
darkolivegreen: [85,107,47],
darkorange: [255,140,0],
darkorchid: [153,50,204],
darkred:  [139,0,0],
darksalmon: [233,150,122],
darkseagreen: [143,188,143],
darkslateblue:  [72,61,139],
darkslategray:  [47,79,79],
darkslategrey:  [47,79,79],
darkturquoise:  [0,206,209],
darkviolet: [148,0,211],
deeppink: [255,20,147],
deepskyblue:  [0,191,255],
dimgray:  [105,105,105],
dimgrey:  [105,105,105],
dodgerblue: [30,144,255],
firebrick:  [178,34,34],
floralwhite:  [255,250,240],
forestgreen:  [34,139,34],
fuchsia:  [255,0,255],
gainsboro:  [220,220,220],
ghostwhite: [248,248,255],
gold: [255,215,0],
goldenrod:  [218,165,32],
gray: [128,128,128],
green:  [0,128,0],
greenyellow:  [173,255,47],
grey: [128,128,128],
honeydew: [240,255,240],
hotpink:  [255,105,180],
indianred:  [205,92,92],
indigo: [75,0,130],
ivory:  [255,255,240],
khaki:  [240,230,140],
lavender: [230,230,250],
lavenderblush:  [255,240,245],
lawngreen:  [124,252,0],
lemonchiffon: [255,250,205],
lightblue:  [173,216,230],
lightcoral: [240,128,128],
lightcyan:  [224,255,255],
lightgoldenrodyellow: [250,250,210],
lightgray:  [211,211,211],
lightgreen: [144,238,144],
lightgrey:  [211,211,211],
lightpink:  [255,182,193],
lightsalmon:  [255,160,122],
lightseagreen:  [32,178,170],
lightskyblue: [135,206,250],
lightslategray: [119,136,153],
lightslategrey: [119,136,153],
lightsteelblue: [176,196,222],
lightyellow:  [255,255,224],
lime: [0,255,0],
limegreen:  [50,205,50],
linen:  [250,240,230],
magenta:  [255,0,255],
maroon: [128,0,0],
mediumaquamarine: [102,205,170],
mediumblue: [0,0,205],
mediumorchid: [186,85,211],
mediumpurple: [147,112,219],
mediumseagreen: [60,179,113],
mediumslateblue:  [123,104,238],
mediumspringgreen:  [0,250,154],
mediumturquoise:  [72,209,204],
mediumvioletred:  [199,21,133],
midnightblue: [25,25,112],
mintcream:  [245,255,250],
mistyrose:  [255,228,225],
moccasin: [255,228,181],
navajowhite:  [255,222,173],
navy: [0,0,128],
oldlace:  [253,245,230],
olive:  [128,128,0],
olivedrab:  [107,142,35],
orange: [255,165,0],
orangered:  [255,69,0],
orchid: [218,112,214],
palegoldenrod:  [238,232,170],
palegreen:  [152,251,152],
paleturquoise:  [175,238,238],
palevioletred:  [219,112,147],
papayawhip: [255,239,213],
peachpuff:  [255,218,185],
peru: [205,133,63],
pink: [255,192,203],
plum: [221,160,221],
powderblue: [176,224,230],
purple: [128,0,128],
rebeccapurple: [102, 51, 153],
red:  [255,0,0],
rosybrown:  [188,143,143],
royalblue:  [65,105,225],
saddlebrown:  [139,69,19],
salmon: [250,128,114],
sandybrown: [244,164,96],
seagreen: [46,139,87],
seashell: [255,245,238],
sienna: [160,82,45],
silver: [192,192,192],
skyblue:  [135,206,235],
slateblue:  [106,90,205],
slategray:  [112,128,144],
slategrey:  [112,128,144],
snow: [255,250,250],
springgreen:  [0,255,127],
steelblue:  [70,130,180],
tan:  [210,180,140],
teal: [0,128,128],
thistle:  [216,191,216],
tomato: [255,99,71],
turquoise:  [64,224,208],
violet: [238,130,238],
wheat:  [245,222,179],
white:  [255,255,255],
whitesmoke: [245,245,245],
yellow: [255,255,0],
yellowgreen:  [154,205,50]
};
var reverseKeywords = {};
for (var key in cssKeywords) {
reverseKeywords[JSON.stringify(cssKeywords[key])] = key;
}
},{}],4:[function(require,module,exports){
var conversions = require(3);
var convert = function() {
return new Converter();
}
for (var func in conversions) {
convert[func + "Raw"] =  (function(func) {
return function(arg) {
if (typeof arg == "number")
arg = Array.prototype.slice.call(arguments);
return conversions[func](arg);
}
})(func);
var pair = /(\w+)2(\w+)/.exec(func),
from = pair[1],
to = pair[2];
convert[from] = convert[from] || {};
convert[from][to] = convert[func] = (function(func) {
return function(arg) {
if (typeof arg == "number")
arg = Array.prototype.slice.call(arguments);
var val = conversions[func](arg);
if (typeof val == "string" || val === undefined)
return val; // keyword
for (var i = 0; i < val.length; i++)
val[i] = Math.round(val[i]);
return val;
}
})(func);
}
var Converter = function() {
this.convs = {};
};
Converter.prototype.routeSpace = function(space, args) {
var values = args[0];
if (values === undefined) {
return this.getValues(space);
}
if (typeof values == "number") {
values = Array.prototype.slice.call(args);
}
return this.setValues(space, values);
};
Converter.prototype.setValues = function(space, values) {
this.space = space;
this.convs = {};
this.convs[space] = values;
return this;
};
Converter.prototype.getValues = function(space) {
var vals = this.convs[space];
if (!vals) {
var fspace = this.space,
from = this.convs[fspace];
vals = convert[fspace][space](from);
this.convs[space] = vals;
}
return vals;
};
["rgb", "hsl", "hsv", "cmyk", "keyword"].forEach(function(space) {
Converter.prototype[space] = function(vals) {
return this.routeSpace(space, arguments);
}
});
module.exports = convert;
},{"3":3}],5:[function(require,module,exports){
'use strict'
module.exports = {
"aliceblue": [240, 248, 255],
"antiquewhite": [250, 235, 215],
"aqua": [0, 255, 255],
"aquamarine": [127, 255, 212],
"azure": [240, 255, 255],
"beige": [245, 245, 220],
"bisque": [255, 228, 196],
"black": [0, 0, 0],
"blanchedalmond": [255, 235, 205],
"blue": [0, 0, 255],
"blueviolet": [138, 43, 226],
"brown": [165, 42, 42],
"burlywood": [222, 184, 135],
"cadetblue": [95, 158, 160],
"chartreuse": [127, 255, 0],
"chocolate": [210, 105, 30],
"coral": [255, 127, 80],
"cornflowerblue": [100, 149, 237],
"cornsilk": [255, 248, 220],
"crimson": [220, 20, 60],
"cyan": [0, 255, 255],
"darkblue": [0, 0, 139],
"darkcyan": [0, 139, 139],
"darkgoldenrod": [184, 134, 11],
"darkgray": [169, 169, 169],
"darkgreen": [0, 100, 0],
"darkgrey": [169, 169, 169],
"darkkhaki": [189, 183, 107],
"darkmagenta": [139, 0, 139],
"darkolivegreen": [85, 107, 47],
"darkorange": [255, 140, 0],
"darkorchid": [153, 50, 204],
"darkred": [139, 0, 0],
"darksalmon": [233, 150, 122],
"darkseagreen": [143, 188, 143],
"darkslateblue": [72, 61, 139],
"darkslategray": [47, 79, 79],
"darkslategrey": [47, 79, 79],
"darkturquoise": [0, 206, 209],
"darkviolet": [148, 0, 211],
"deeppink": [255, 20, 147],
"deepskyblue": [0, 191, 255],
"dimgray": [105, 105, 105],
"dimgrey": [105, 105, 105],
"dodgerblue": [30, 144, 255],
"firebrick": [178, 34, 34],
"floralwhite": [255, 250, 240],
"forestgreen": [34, 139, 34],
"fuchsia": [255, 0, 255],
"gainsboro": [220, 220, 220],
"ghostwhite": [248, 248, 255],
"gold": [255, 215, 0],
"goldenrod": [218, 165, 32],
"gray": [128, 128, 128],
"green": [0, 128, 0],
"greenyellow": [173, 255, 47],
"grey": [128, 128, 128],
"honeydew": [240, 255, 240],
"hotpink": [255, 105, 180],
"indianred": [205, 92, 92],
"indigo": [75, 0, 130],
"ivory": [255, 255, 240],
"khaki": [240, 230, 140],
"lavender": [230, 230, 250],
"lavenderblush": [255, 240, 245],
"lawngreen": [124, 252, 0],
"lemonchiffon": [255, 250, 205],
"lightblue": [173, 216, 230],
"lightcoral": [240, 128, 128],
"lightcyan": [224, 255, 255],
"lightgoldenrodyellow": [250, 250, 210],
"lightgray": [211, 211, 211],
"lightgreen": [144, 238, 144],
"lightgrey": [211, 211, 211],
"lightpink": [255, 182, 193],
"lightsalmon": [255, 160, 122],
"lightseagreen": [32, 178, 170],
"lightskyblue": [135, 206, 250],
"lightslategray": [119, 136, 153],
"lightslategrey": [119, 136, 153],
"lightsteelblue": [176, 196, 222],
"lightyellow": [255, 255, 224],
"lime": [0, 255, 0],
"limegreen": [50, 205, 50],
"linen": [250, 240, 230],
"magenta": [255, 0, 255],
"maroon": [128, 0, 0],
"mediumaquamarine": [102, 205, 170],
"mediumblue": [0, 0, 205],
"mediumorchid": [186, 85, 211],
"mediumpurple": [147, 112, 219],
"mediumseagreen": [60, 179, 113],
"mediumslateblue": [123, 104, 238],
"mediumspringgreen": [0, 250, 154],
"mediumturquoise": [72, 209, 204],
"mediumvioletred": [199, 21, 133],
"midnightblue": [25, 25, 112],
"mintcream": [245, 255, 250],
"mistyrose": [255, 228, 225],
"moccasin": [255, 228, 181],
"navajowhite": [255, 222, 173],
"navy": [0, 0, 128],
"oldlace": [253, 245, 230],
"olive": [128, 128, 0],
"olivedrab": [107, 142, 35],
"orange": [255, 165, 0],
"orangered": [255, 69, 0],
"orchid": [218, 112, 214],
"palegoldenrod": [238, 232, 170],
"palegreen": [152, 251, 152],
"paleturquoise": [175, 238, 238],
"palevioletred": [219, 112, 147],
"papayawhip": [255, 239, 213],
"peachpuff": [255, 218, 185],
"peru": [205, 133, 63],
"pink": [255, 192, 203],
"plum": [221, 160, 221],
"powderblue": [176, 224, 230],
"purple": [128, 0, 128],
"rebeccapurple": [102, 51, 153],
"red": [255, 0, 0],
"rosybrown": [188, 143, 143],
"royalblue": [65, 105, 225],
"saddlebrown": [139, 69, 19],
"salmon": [250, 128, 114],
"sandybrown": [244, 164, 96],
"seagreen": [46, 139, 87],
"seashell": [255, 245, 238],
"sienna": [160, 82, 45],
"silver": [192, 192, 192],
"skyblue": [135, 206, 235],
"slateblue": [106, 90, 205],
"slategray": [112, 128, 144],
"slategrey": [112, 128, 144],
"snow": [255, 250, 250],
"springgreen": [0, 255, 127],
"steelblue": [70, 130, 180],
"tan": [210, 180, 140],
"teal": [0, 128, 128],
"thistle": [216, 191, 216],
"tomato": [255, 99, 71],
"turquoise": [64, 224, 208],
"violet": [238, 130, 238],
"wheat": [245, 222, 179],
"white": [255, 255, 255],
"whitesmoke": [245, 245, 245],
"yellow": [255, 255, 0],
"yellowgreen": [154, 205, 50]
};
},{}],6:[function(require,module,exports){
;(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
typeof define === 'function' && define.amd ? define(factory) :
global.moment = factory()
}(this, (function () { 'use strict';
var hookCallback;
function hooks () {
return hookCallback.apply(null, arguments);
}
function setHookCallback (callback) {
hookCallback = callback;
}
function isArray(input) {
return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
}
function isObject(input) {
return input != null && Object.prototype.toString.call(input) === '[object Object]';
}
function isObjectEmpty(obj) {
var k;
for (k in obj) {
return false;
}
return true;
}
function isUndefined(input) {
return input === void 0;
}
function isNumber(input) {
return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
}
function isDate(input) {
return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
}
function map(arr, fn) {
var res = [], i;
for (i = 0; i < arr.length; ++i) {
res.push(fn(arr[i], i));
}
return res;
}
function hasOwnProp(a, b) {
return Object.prototype.hasOwnProperty.call(a, b);
}
function extend(a, b) {
for (var i in b) {
if (hasOwnProp(b, i)) {
a[i] = b[i];
}
}
if (hasOwnProp(b, 'toString')) {
a.toString = b.toString;
}
if (hasOwnProp(b, 'valueOf')) {
a.valueOf = b.valueOf;
}
return a;
}
function createUTC (input, format, locale, strict) {
return createLocalOrUTC(input, format, locale, strict, true).utc();
}
function defaultParsingFlags() {
return {
empty           : false,
unusedTokens    : [],
unusedInput     : [],
overflow        : -2,
charsLeftOver   : 0,
nullInput       : false,
invalidMonth    : null,
invalidFormat   : false,
userInvalidated : false,
iso             : false,
parsedDateParts : [],
meridiem        : null,
rfc2822         : false,
weekdayMismatch : false
};
}
function getParsingFlags(m) {
if (m._pf == null) {
m._pf = defaultParsingFlags();
}
return m._pf;
}
var some;
if (Array.prototype.some) {
some = Array.prototype.some;
} else {
some = function (fun) {
var t = Object(this);
var len = t.length >>> 0;
for (var i = 0; i < len; i++) {
if (i in t && fun.call(this, t[i], i, t)) {
return true;
}
}
return false;
};
}
var some$1 = some;
function isValid(m) {
if (m._isValid == null) {
var flags = getParsingFlags(m);
var parsedParts = some$1.call(flags.parsedDateParts, function (i) {
return i != null;
});
var isNowValid = !isNaN(m._d.getTime()) &&
flags.overflow < 0 &&
!flags.empty &&
!flags.invalidMonth &&
!flags.invalidWeekday &&
!flags.nullInput &&
!flags.invalidFormat &&
!flags.userInvalidated &&
(!flags.meridiem || (flags.meridiem && parsedParts));
if (m._strict) {
isNowValid = isNowValid &&
flags.charsLeftOver === 0 &&
flags.unusedTokens.length === 0 &&
flags.bigHour === undefined;
}
if (Object.isFrozen == null || !Object.isFrozen(m)) {
m._isValid = isNowValid;
}
else {
return isNowValid;
}
}
return m._isValid;
}
function createInvalid (flags) {
var m = createUTC(NaN);
if (flags != null) {
extend(getParsingFlags(m), flags);
}
else {
getParsingFlags(m).userInvalidated = true;
}
return m;
}
var momentProperties = hooks.momentProperties = [];
function copyConfig(to, from) {
var i, prop, val;
if (!isUndefined(from._isAMomentObject)) {
to._isAMomentObject = from._isAMomentObject;
}
if (!isUndefined(from._i)) {
to._i = from._i;
}
if (!isUndefined(from._f)) {
to._f = from._f;
}
if (!isUndefined(from._l)) {
to._l = from._l;
}
if (!isUndefined(from._strict)) {
to._strict = from._strict;
}
if (!isUndefined(from._tzm)) {
to._tzm = from._tzm;
}
if (!isUndefined(from._isUTC)) {
to._isUTC = from._isUTC;
}
if (!isUndefined(from._offset)) {
to._offset = from._offset;
}
if (!isUndefined(from._pf)) {
to._pf = getParsingFlags(from);
}
if (!isUndefined(from._locale)) {
to._locale = from._locale;
}
if (momentProperties.length > 0) {
for (i = 0; i < momentProperties.length; i++) {
prop = momentProperties[i];
val = from[prop];
if (!isUndefined(val)) {
to[prop] = val;
}
}
}
return to;
}
var updateInProgress = false;
function Moment(config) {
copyConfig(this, config);
this._d = new Date(config._d != null ? config._d.getTime() : NaN);
if (!this.isValid()) {
this._d = new Date(NaN);
}
if (updateInProgress === false) {
updateInProgress = true;
hooks.updateOffset(this);
updateInProgress = false;
}
}
function isMoment (obj) {
return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
}
function absFloor (number) {
if (number < 0) {
return Math.ceil(number) || 0;
} else {
return Math.floor(number);
}
}
function toInt(argumentForCoercion) {
var coercedNumber = +argumentForCoercion,
value = 0;
if (coercedNumber !== 0 && isFinite(coercedNumber)) {
value = absFloor(coercedNumber);
}
return value;
}
function compareArrays(array1, array2, dontConvert) {
var len = Math.min(array1.length, array2.length),
lengthDiff = Math.abs(array1.length - array2.length),
diffs = 0,
i;
for (i = 0; i < len; i++) {
if ((dontConvert && array1[i] !== array2[i]) ||
(!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
diffs++;
}
}
return diffs + lengthDiff;
}
function warn(msg) {
if (hooks.suppressDeprecationWarnings === false &&
(typeof console !==  'undefined') && console.warn) {
console.warn('Deprecation warning: ' + msg);
}
}
function deprecate(msg, fn) {
var firstTime = true;
return extend(function () {
if (hooks.deprecationHandler != null) {
hooks.deprecationHandler(null, msg);
}
if (firstTime) {
var args = [];
var arg;
for (var i = 0; i < arguments.length; i++) {
arg = '';
if (typeof arguments[i] === 'object') {
arg += '\n[' + i + '] ';
for (var key in arguments[0]) {
arg += key + ': ' + arguments[0][key] + ', ';
}
arg = arg.slice(0, -2); // Remove trailing comma and space
} else {
arg = arguments[i];
}
args.push(arg);
}
warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + (new Error()).stack);
firstTime = false;
}
return fn.apply(this, arguments);
}, fn);
}
var deprecations = {};
function deprecateSimple(name, msg) {
if (hooks.deprecationHandler != null) {
hooks.deprecationHandler(name, msg);
}
if (!deprecations[name]) {
warn(msg);
deprecations[name] = true;
}
}
hooks.suppressDeprecationWarnings = false;
hooks.deprecationHandler = null;
function isFunction(input) {
return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
}
function set (config) {
var prop, i;
for (i in config) {
prop = config[i];
if (isFunction(prop)) {
this[i] = prop;
} else {
this['_' + i] = prop;
}
}
this._config = config;
this._dayOfMonthOrdinalParseLenient = new RegExp(
(this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
'|' + (/\d{1,2}/).source);
}
function mergeConfigs(parentConfig, childConfig) {
var res = extend({}, parentConfig), prop;
for (prop in childConfig) {
if (hasOwnProp(childConfig, prop)) {
if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
res[prop] = {};
extend(res[prop], parentConfig[prop]);
extend(res[prop], childConfig[prop]);
} else if (childConfig[prop] != null) {
res[prop] = childConfig[prop];
} else {
delete res[prop];
}
}
}
for (prop in parentConfig) {
if (hasOwnProp(parentConfig, prop) &&
!hasOwnProp(childConfig, prop) &&
isObject(parentConfig[prop])) {
res[prop] = extend({}, res[prop]);
}
}
return res;
}
function Locale(config) {
if (config != null) {
this.set(config);
}
}
var keys;
if (Object.keys) {
keys = Object.keys;
} else {
keys = function (obj) {
var i, res = [];
for (i in obj) {
if (hasOwnProp(obj, i)) {
res.push(i);
}
}
return res;
};
}
var keys$1 = keys;
var defaultCalendar = {
sameDay : '[Today at] LT',
nextDay : '[Tomorrow at] LT',
nextWeek : 'dddd [at] LT',
lastDay : '[Yesterday at] LT',
lastWeek : '[Last] dddd [at] LT',
sameElse : 'L'
};
function calendar (key, mom, now) {
var output = this._calendar[key] || this._calendar['sameElse'];
return isFunction(output) ? output.call(mom, now) : output;
}
var defaultLongDateFormat = {
LTS  : 'h:mm:ss A',
LT   : 'h:mm A',
L    : 'MM/DD/YYYY',
LL   : 'MMMM D, YYYY',
LLL  : 'MMMM D, YYYY h:mm A',
LLLL : 'dddd, MMMM D, YYYY h:mm A'
};
function longDateFormat (key) {
var format = this._longDateFormat[key],
formatUpper = this._longDateFormat[key.toUpperCase()];
if (format || !formatUpper) {
return format;
}
this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
return val.slice(1);
});
return this._longDateFormat[key];
}
var defaultInvalidDate = 'Invalid date';
function invalidDate () {
return this._invalidDate;
}
var defaultOrdinal = '%d';
var defaultDayOfMonthOrdinalParse = /\d{1,2}/;
function ordinal (number) {
return this._ordinal.replace('%d', number);
}
var defaultRelativeTime = {
future : 'in %s',
past   : '%s ago',
s  : 'a few seconds',
ss : '%d seconds',
m  : 'a minute',
mm : '%d minutes',
h  : 'an hour',
hh : '%d hours',
d  : 'a day',
dd : '%d days',
M  : 'a month',
MM : '%d months',
y  : 'a year',
yy : '%d years'
};
function relativeTime (number, withoutSuffix, string, isFuture) {
var output = this._relativeTime[string];
return (isFunction(output)) ?
output(number, withoutSuffix, string, isFuture) :
output.replace(/%d/i, number);
}
function pastFuture (diff, output) {
var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
return isFunction(format) ? format(output) : format.replace(/%s/i, output);
}
var aliases = {};
function addUnitAlias (unit, shorthand) {
var lowerCase = unit.toLowerCase();
aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
}
function normalizeUnits(units) {
return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
}
function normalizeObjectUnits(inputObject) {
var normalizedInput = {},
normalizedProp,
prop;
for (prop in inputObject) {
if (hasOwnProp(inputObject, prop)) {
normalizedProp = normalizeUnits(prop);
if (normalizedProp) {
normalizedInput[normalizedProp] = inputObject[prop];
}
}
}
return normalizedInput;
}
var priorities = {};
function addUnitPriority(unit, priority) {
priorities[unit] = priority;
}
function getPrioritizedUnits(unitsObj) {
var units = [];
for (var u in unitsObj) {
units.push({unit: u, priority: priorities[u]});
}
units.sort(function (a, b) {
return a.priority - b.priority;
});
return units;
}
function makeGetSet (unit, keepTime) {
return function (value) {
if (value != null) {
set$1(this, unit, value);
hooks.updateOffset(this, keepTime);
return this;
} else {
return get(this, unit);
}
};
}
function get (mom, unit) {
return mom.isValid() ?
mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
}
function set$1 (mom, unit, value) {
if (mom.isValid()) {
mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
}
}
function stringGet (units) {
units = normalizeUnits(units);
if (isFunction(this[units])) {
return this[units]();
}
return this;
}
function stringSet (units, value) {
if (typeof units === 'object') {
units = normalizeObjectUnits(units);
var prioritized = getPrioritizedUnits(units);
for (var i = 0; i < prioritized.length; i++) {
this[prioritized[i].unit](units[prioritized[i].unit]);
}
} else {
units = normalizeUnits(units);
if (isFunction(this[units])) {
return this[units](value);
}
}
return this;
}
function zeroFill(number, targetLength, forceSign) {
var absNumber = '' + Math.abs(number),
zerosToFill = targetLength - absNumber.length,
sign = number >= 0;
return (sign ? (forceSign ? '+' : '') : '-') +
Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
}
var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;
var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;
var formatFunctions = {};
var formatTokenFunctions = {};
function addFormatToken (token, padded, ordinal, callback) {
var func = callback;
if (typeof callback === 'string') {
func = function () {
return this[callback]();
};
}
if (token) {
formatTokenFunctions[token] = func;
}
if (padded) {
formatTokenFunctions[padded[0]] = function () {
return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
};
}
if (ordinal) {
formatTokenFunctions[ordinal] = function () {
return this.localeData().ordinal(func.apply(this, arguments), token);
};
}
}
function removeFormattingTokens(input) {
if (input.match(/\[[\s\S]/)) {
return input.replace(/^\[|\]$/g, '');
}
return input.replace(/\\/g, '');
}
function makeFormatFunction(format) {
var array = format.match(formattingTokens), i, length;
for (i = 0, length = array.length; i < length; i++) {
if (formatTokenFunctions[array[i]]) {
array[i] = formatTokenFunctions[array[i]];
} else {
array[i] = removeFormattingTokens(array[i]);
}
}
return function (mom) {
var output = '', i;
for (i = 0; i < length; i++) {
output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
}
return output;
};
}
function formatMoment(m, format) {
if (!m.isValid()) {
return m.localeData().invalidDate();
}
format = expandFormat(format, m.localeData());
formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);
return formatFunctions[format](m);
}
function expandFormat(format, locale) {
var i = 5;
function replaceLongDateFormatTokens(input) {
return locale.longDateFormat(input) || input;
}
localFormattingTokens.lastIndex = 0;
while (i >= 0 && localFormattingTokens.test(format)) {
format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
localFormattingTokens.lastIndex = 0;
i -= 1;
}
return format;
}
var match1         = /\d/;            //       0 - 9
var match2         = /\d\d/;          //      00 - 99
var match3         = /\d{3}/;         //     000 - 999
var match4         = /\d{4}/;         //    0000 - 9999
var match6         = /[+-]?\d{6}/;    // -999999 - 999999
var match1to2      = /\d\d?/;         //       0 - 99
var match3to4      = /\d\d\d\d?/;     //     999 - 9999
var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
var match1to3      = /\d{1,3}/;       //       0 - 999
var match1to4      = /\d{1,4}/;       //       0 - 9999
var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999
var matchUnsigned  = /\d+/;           //       0 - inf
var matchSigned    = /[+-]?\d+/;      //    -inf - inf
var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z
var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123
var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;
var regexes = {};
function addRegexToken (token, regex, strictRegex) {
regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
return (isStrict && strictRegex) ? strictRegex : regex;
};
}
function getParseRegexForToken (token, config) {
if (!hasOwnProp(regexes, token)) {
return new RegExp(unescapeFormat(token));
}
return regexes[token](config._strict, config._locale);
}
function unescapeFormat(s) {
return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
return p1 || p2 || p3 || p4;
}));
}
function regexEscape(s) {
return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
}
var tokens = {};
function addParseToken (token, callback) {
var i, func = callback;
if (typeof token === 'string') {
token = [token];
}
if (isNumber(callback)) {
func = function (input, array) {
array[callback] = toInt(input);
};
}
for (i = 0; i < token.length; i++) {
tokens[token[i]] = func;
}
}
function addWeekParseToken (token, callback) {
addParseToken(token, function (input, array, config, token) {
config._w = config._w || {};
callback(input, config._w, config, token);
});
}
function addTimeToArrayFromToken(token, input, config) {
if (input != null && hasOwnProp(tokens, token)) {
tokens[token](input, config._a, config, token);
}
}
var YEAR = 0;
var MONTH = 1;
var DATE = 2;
var HOUR = 3;
var MINUTE = 4;
var SECOND = 5;
var MILLISECOND = 6;
var WEEK = 7;
var WEEKDAY = 8;
var indexOf;
if (Array.prototype.indexOf) {
indexOf = Array.prototype.indexOf;
} else {
indexOf = function (o) {
var i;
for (i = 0; i < this.length; ++i) {
if (this[i] === o) {
return i;
}
}
return -1;
};
}
var indexOf$1 = indexOf;
function daysInMonth(year, month) {
return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
}
addFormatToken('M', ['MM', 2], 'Mo', function () {
return this.month() + 1;
});
addFormatToken('MMM', 0, 0, function (format) {
return this.localeData().monthsShort(this, format);
});
addFormatToken('MMMM', 0, 0, function (format) {
return this.localeData().months(this, format);
});
addUnitAlias('month', 'M');
addUnitPriority('month', 8);
addRegexToken('M',    match1to2);
addRegexToken('MM',   match1to2, match2);
addRegexToken('MMM',  function (isStrict, locale) {
return locale.monthsShortRegex(isStrict);
});
addRegexToken('MMMM', function (isStrict, locale) {
return locale.monthsRegex(isStrict);
});
addParseToken(['M', 'MM'], function (input, array) {
array[MONTH] = toInt(input) - 1;
});
addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
var month = config._locale.monthsParse(input, token, config._strict);
if (month != null) {
array[MONTH] = month;
} else {
getParsingFlags(config).invalidMonth = input;
}
});
var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
function localeMonths (m, format) {
if (!m) {
return isArray(this._months) ? this._months :
this._months['standalone'];
}
return isArray(this._months) ? this._months[m.month()] :
this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
}
var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
function localeMonthsShort (m, format) {
if (!m) {
return isArray(this._monthsShort) ? this._monthsShort :
this._monthsShort['standalone'];
}
return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
}
function handleStrictParse(monthName, format, strict) {
var i, ii, mom, llc = monthName.toLocaleLowerCase();
if (!this._monthsParse) {
this._monthsParse = [];
this._longMonthsParse = [];
this._shortMonthsParse = [];
for (i = 0; i < 12; ++i) {
mom = createUTC([2000, i]);
this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
}
}
if (strict) {
if (format === 'MMM') {
ii = indexOf$1.call(this._shortMonthsParse, llc);
return ii !== -1 ? ii : null;
} else {
ii = indexOf$1.call(this._longMonthsParse, llc);
return ii !== -1 ? ii : null;
}
} else {
if (format === 'MMM') {
ii = indexOf$1.call(this._shortMonthsParse, llc);
if (ii !== -1) {
return ii;
}
ii = indexOf$1.call(this._longMonthsParse, llc);
return ii !== -1 ? ii : null;
} else {
ii = indexOf$1.call(this._longMonthsParse, llc);
if (ii !== -1) {
return ii;
}
ii = indexOf$1.call(this._shortMonthsParse, llc);
return ii !== -1 ? ii : null;
}
}
}
function localeMonthsParse (monthName, format, strict) {
var i, mom, regex;
if (this._monthsParseExact) {
return handleStrictParse.call(this, monthName, format, strict);
}
if (!this._monthsParse) {
this._monthsParse = [];
this._longMonthsParse = [];
this._shortMonthsParse = [];
}
for (i = 0; i < 12; i++) {
mom = createUTC([2000, i]);
if (strict && !this._longMonthsParse[i]) {
this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
}
if (!strict && !this._monthsParse[i]) {
regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
}
if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
return i;
} else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
return i;
} else if (!strict && this._monthsParse[i].test(monthName)) {
return i;
}
}
}
function setMonth (mom, value) {
var dayOfMonth;
if (!mom.isValid()) {
return mom;
}
if (typeof value === 'string') {
if (/^\d+$/.test(value)) {
value = toInt(value);
} else {
value = mom.localeData().monthsParse(value);
if (!isNumber(value)) {
return mom;
}
}
}
dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
return mom;
}
function getSetMonth (value) {
if (value != null) {
setMonth(this, value);
hooks.updateOffset(this, true);
return this;
} else {
return get(this, 'Month');
}
}
function getDaysInMonth () {
return daysInMonth(this.year(), this.month());
}
var defaultMonthsShortRegex = matchWord;
function monthsShortRegex (isStrict) {
if (this._monthsParseExact) {
if (!hasOwnProp(this, '_monthsRegex')) {
computeMonthsParse.call(this);
}
if (isStrict) {
return this._monthsShortStrictRegex;
} else {
return this._monthsShortRegex;
}
} else {
if (!hasOwnProp(this, '_monthsShortRegex')) {
this._monthsShortRegex = defaultMonthsShortRegex;
}
return this._monthsShortStrictRegex && isStrict ?
this._monthsShortStrictRegex : this._monthsShortRegex;
}
}
var defaultMonthsRegex = matchWord;
function monthsRegex (isStrict) {
if (this._monthsParseExact) {
if (!hasOwnProp(this, '_monthsRegex')) {
computeMonthsParse.call(this);
}
if (isStrict) {
return this._monthsStrictRegex;
} else {
return this._monthsRegex;
}
} else {
if (!hasOwnProp(this, '_monthsRegex')) {
this._monthsRegex = defaultMonthsRegex;
}
return this._monthsStrictRegex && isStrict ?
this._monthsStrictRegex : this._monthsRegex;
}
}
function computeMonthsParse () {
function cmpLenRev(a, b) {
return b.length - a.length;
}
var shortPieces = [], longPieces = [], mixedPieces = [],
i, mom;
for (i = 0; i < 12; i++) {
mom = createUTC([2000, i]);
shortPieces.push(this.monthsShort(mom, ''));
longPieces.push(this.months(mom, ''));
mixedPieces.push(this.months(mom, ''));
mixedPieces.push(this.monthsShort(mom, ''));
}
shortPieces.sort(cmpLenRev);
longPieces.sort(cmpLenRev);
mixedPieces.sort(cmpLenRev);
for (i = 0; i < 12; i++) {
shortPieces[i] = regexEscape(shortPieces[i]);
longPieces[i] = regexEscape(longPieces[i]);
}
for (i = 0; i < 24; i++) {
mixedPieces[i] = regexEscape(mixedPieces[i]);
}
this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
this._monthsShortRegex = this._monthsRegex;
this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
}
addFormatToken('Y', 0, 0, function () {
var y = this.year();
return y <= 9999 ? '' + y : '+' + y;
});
addFormatToken(0, ['YY', 2], 0, function () {
return this.year() % 100;
});
addFormatToken(0, ['YYYY',   4],       0, 'year');
addFormatToken(0, ['YYYYY',  5],       0, 'year');
addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');
addUnitAlias('year', 'y');
addUnitPriority('year', 1);
addRegexToken('Y',      matchSigned);
addRegexToken('YY',     match1to2, match2);
addRegexToken('YYYY',   match1to4, match4);
addRegexToken('YYYYY',  match1to6, match6);
addRegexToken('YYYYYY', match1to6, match6);
addParseToken(['YYYYY', 'YYYYYY'], YEAR);
addParseToken('YYYY', function (input, array) {
array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
});
addParseToken('YY', function (input, array) {
array[YEAR] = hooks.parseTwoDigitYear(input);
});
addParseToken('Y', function (input, array) {
array[YEAR] = parseInt(input, 10);
});
function daysInYear(year) {
return isLeapYear(year) ? 366 : 365;
}
function isLeapYear(year) {
return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
}
hooks.parseTwoDigitYear = function (input) {
return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
};
var getSetYear = makeGetSet('FullYear', true);
function getIsLeapYear () {
return isLeapYear(this.year());
}
function createDate (y, m, d, h, M, s, ms) {
var date = new Date(y, m, d, h, M, s, ms);
if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
date.setFullYear(y);
}
return date;
}
function createUTCDate (y) {
var date = new Date(Date.UTC.apply(null, arguments));
if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
date.setUTCFullYear(y);
}
return date;
}
function firstWeekOffset(year, dow, doy) {
var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
fwd = 7 + dow - doy,
fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
return -fwdlw + fwd - 1;
}
function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
var localWeekday = (7 + weekday - dow) % 7,
weekOffset = firstWeekOffset(year, dow, doy),
dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
resYear, resDayOfYear;
if (dayOfYear <= 0) {
resYear = year - 1;
resDayOfYear = daysInYear(resYear) + dayOfYear;
} else if (dayOfYear > daysInYear(year)) {
resYear = year + 1;
resDayOfYear = dayOfYear - daysInYear(year);
} else {
resYear = year;
resDayOfYear = dayOfYear;
}
return {
year: resYear,
dayOfYear: resDayOfYear
};
}
function weekOfYear(mom, dow, doy) {
var weekOffset = firstWeekOffset(mom.year(), dow, doy),
week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
resWeek, resYear;
if (week < 1) {
resYear = mom.year() - 1;
resWeek = week + weeksInYear(resYear, dow, doy);
} else if (week > weeksInYear(mom.year(), dow, doy)) {
resWeek = week - weeksInYear(mom.year(), dow, doy);
resYear = mom.year() + 1;
} else {
resYear = mom.year();
resWeek = week;
}
return {
week: resWeek,
year: resYear
};
}
function weeksInYear(year, dow, doy) {
var weekOffset = firstWeekOffset(year, dow, doy),
weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
}
addFormatToken('w', ['ww', 2], 'wo', 'week');
addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');
addUnitAlias('week', 'w');
addUnitAlias('isoWeek', 'W');
addUnitPriority('week', 5);
addUnitPriority('isoWeek', 5);
addRegexToken('w',  match1to2);
addRegexToken('ww', match1to2, match2);
addRegexToken('W',  match1to2);
addRegexToken('WW', match1to2, match2);
addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
week[token.substr(0, 1)] = toInt(input);
});
function localeWeek (mom) {
return weekOfYear(mom, this._week.dow, this._week.doy).week;
}
var defaultLocaleWeek = {
dow : 0, // Sunday is the first day of the week.
doy : 6  // The week that contains Jan 1st is the first week of the year.
};
function localeFirstDayOfWeek () {
return this._week.dow;
}
function localeFirstDayOfYear () {
return this._week.doy;
}
function getSetWeek (input) {
var week = this.localeData().week(this);
return input == null ? week : this.add((input - week) * 7, 'd');
}
function getSetISOWeek (input) {
var week = weekOfYear(this, 1, 4).week;
return input == null ? week : this.add((input - week) * 7, 'd');
}
addFormatToken('d', 0, 'do', 'day');
addFormatToken('dd', 0, 0, function (format) {
return this.localeData().weekdaysMin(this, format);
});
addFormatToken('ddd', 0, 0, function (format) {
return this.localeData().weekdaysShort(this, format);
});
addFormatToken('dddd', 0, 0, function (format) {
return this.localeData().weekdays(this, format);
});
addFormatToken('e', 0, 0, 'weekday');
addFormatToken('E', 0, 0, 'isoWeekday');
addUnitAlias('day', 'd');
addUnitAlias('weekday', 'e');
addUnitAlias('isoWeekday', 'E');
addUnitPriority('day', 11);
addUnitPriority('weekday', 11);
addUnitPriority('isoWeekday', 11);
addRegexToken('d',    match1to2);
addRegexToken('e',    match1to2);
addRegexToken('E',    match1to2);
addRegexToken('dd',   function (isStrict, locale) {
return locale.weekdaysMinRegex(isStrict);
});
addRegexToken('ddd',   function (isStrict, locale) {
return locale.weekdaysShortRegex(isStrict);
});
addRegexToken('dddd',   function (isStrict, locale) {
return locale.weekdaysRegex(isStrict);
});
addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
var weekday = config._locale.weekdaysParse(input, token, config._strict);
if (weekday != null) {
week.d = weekday;
} else {
getParsingFlags(config).invalidWeekday = input;
}
});
addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
week[token] = toInt(input);
});
function parseWeekday(input, locale) {
if (typeof input !== 'string') {
return input;
}
if (!isNaN(input)) {
return parseInt(input, 10);
}
input = locale.weekdaysParse(input);
if (typeof input === 'number') {
return input;
}
return null;
}
function parseIsoWeekday(input, locale) {
if (typeof input === 'string') {
return locale.weekdaysParse(input) % 7 || 7;
}
return isNaN(input) ? null : input;
}
var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
function localeWeekdays (m, format) {
if (!m) {
return isArray(this._weekdays) ? this._weekdays :
this._weekdays['standalone'];
}
return isArray(this._weekdays) ? this._weekdays[m.day()] :
this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
}
var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
function localeWeekdaysShort (m) {
return (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
}
var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
function localeWeekdaysMin (m) {
return (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
}
function handleStrictParse$1(weekdayName, format, strict) {
var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
if (!this._weekdaysParse) {
this._weekdaysParse = [];
this._shortWeekdaysParse = [];
this._minWeekdaysParse = [];
for (i = 0; i < 7; ++i) {
mom = createUTC([2000, 1]).day(i);
this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
}
}
if (strict) {
if (format === 'dddd') {
ii = indexOf$1.call(this._weekdaysParse, llc);
return ii !== -1 ? ii : null;
} else if (format === 'ddd') {
ii = indexOf$1.call(this._shortWeekdaysParse, llc);
return ii !== -1 ? ii : null;
} else {
ii = indexOf$1.call(this._minWeekdaysParse, llc);
return ii !== -1 ? ii : null;
}
} else {
if (format === 'dddd') {
ii = indexOf$1.call(this._weekdaysParse, llc);
if (ii !== -1) {
return ii;
}
ii = indexOf$1.call(this._shortWeekdaysParse, llc);
if (ii !== -1) {
return ii;
}
ii = indexOf$1.call(this._minWeekdaysParse, llc);
return ii !== -1 ? ii : null;
} else if (format === 'ddd') {
ii = indexOf$1.call(this._shortWeekdaysParse, llc);
if (ii !== -1) {
return ii;
}
ii = indexOf$1.call(this._weekdaysParse, llc);
if (ii !== -1) {
return ii;
}
ii = indexOf$1.call(this._minWeekdaysParse, llc);
return ii !== -1 ? ii : null;
} else {
ii = indexOf$1.call(this._minWeekdaysParse, llc);
if (ii !== -1) {
return ii;
}
ii = indexOf$1.call(this._weekdaysParse, llc);
if (ii !== -1) {
return ii;
}
ii = indexOf$1.call(this._shortWeekdaysParse, llc);
return ii !== -1 ? ii : null;
}
}
}
function localeWeekdaysParse (weekdayName, format, strict) {
var i, mom, regex;
if (this._weekdaysParseExact) {
return handleStrictParse$1.call(this, weekdayName, format, strict);
}
if (!this._weekdaysParse) {
this._weekdaysParse = [];
this._minWeekdaysParse = [];
this._shortWeekdaysParse = [];
this._fullWeekdaysParse = [];
}
for (i = 0; i < 7; i++) {
mom = createUTC([2000, 1]).day(i);
if (strict && !this._fullWeekdaysParse[i]) {
this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\.?') + '$', 'i');
this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\.?') + '$', 'i');
this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\.?') + '$', 'i');
}
if (!this._weekdaysParse[i]) {
regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
}
if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
return i;
} else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
return i;
} else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
return i;
} else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
return i;
}
}
}
function getSetDayOfWeek (input) {
if (!this.isValid()) {
return input != null ? this : NaN;
}
var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
if (input != null) {
input = parseWeekday(input, this.localeData());
return this.add(input - day, 'd');
} else {
return day;
}
}
function getSetLocaleDayOfWeek (input) {
if (!this.isValid()) {
return input != null ? this : NaN;
}
var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
return input == null ? weekday : this.add(input - weekday, 'd');
}
function getSetISODayOfWeek (input) {
if (!this.isValid()) {
return input != null ? this : NaN;
}
if (input != null) {
var weekday = parseIsoWeekday(input, this.localeData());
return this.day(this.day() % 7 ? weekday : weekday - 7);
} else {
return this.day() || 7;
}
}
var defaultWeekdaysRegex = matchWord;
function weekdaysRegex (isStrict) {
if (this._weekdaysParseExact) {
if (!hasOwnProp(this, '_weekdaysRegex')) {
computeWeekdaysParse.call(this);
}
if (isStrict) {
return this._weekdaysStrictRegex;
} else {
return this._weekdaysRegex;
}
} else {
if (!hasOwnProp(this, '_weekdaysRegex')) {
this._weekdaysRegex = defaultWeekdaysRegex;
}
return this._weekdaysStrictRegex && isStrict ?
this._weekdaysStrictRegex : this._weekdaysRegex;
}
}
var defaultWeekdaysShortRegex = matchWord;
function weekdaysShortRegex (isStrict) {
if (this._weekdaysParseExact) {
if (!hasOwnProp(this, '_weekdaysRegex')) {
computeWeekdaysParse.call(this);
}
if (isStrict) {
return this._weekdaysShortStrictRegex;
} else {
return this._weekdaysShortRegex;
}
} else {
if (!hasOwnProp(this, '_weekdaysShortRegex')) {
this._weekdaysShortRegex = defaultWeekdaysShortRegex;
}
return this._weekdaysShortStrictRegex && isStrict ?
this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
}
}
var defaultWeekdaysMinRegex = matchWord;
function weekdaysMinRegex (isStrict) {
if (this._weekdaysParseExact) {
if (!hasOwnProp(this, '_weekdaysRegex')) {
computeWeekdaysParse.call(this);
}
if (isStrict) {
return this._weekdaysMinStrictRegex;
} else {
return this._weekdaysMinRegex;
}
} else {
if (!hasOwnProp(this, '_weekdaysMinRegex')) {
this._weekdaysMinRegex = defaultWeekdaysMinRegex;
}
return this._weekdaysMinStrictRegex && isStrict ?
this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
}
}
function computeWeekdaysParse () {
function cmpLenRev(a, b) {
return b.length - a.length;
}
var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
i, mom, minp, shortp, longp;
for (i = 0; i < 7; i++) {
mom = createUTC([2000, 1]).day(i);
minp = this.weekdaysMin(mom, '');
shortp = this.weekdaysShort(mom, '');
longp = this.weekdays(mom, '');
minPieces.push(minp);
shortPieces.push(shortp);
longPieces.push(longp);
mixedPieces.push(minp);
mixedPieces.push(shortp);
mixedPieces.push(longp);
}
minPieces.sort(cmpLenRev);
shortPieces.sort(cmpLenRev);
longPieces.sort(cmpLenRev);
mixedPieces.sort(cmpLenRev);
for (i = 0; i < 7; i++) {
shortPieces[i] = regexEscape(shortPieces[i]);
longPieces[i] = regexEscape(longPieces[i]);
mixedPieces[i] = regexEscape(mixedPieces[i]);
}
this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
this._weekdaysShortRegex = this._weekdaysRegex;
this._weekdaysMinRegex = this._weekdaysRegex;
this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
}
function hFormat() {
return this.hours() % 12 || 12;
}
function kFormat() {
return this.hours() || 24;
}
addFormatToken('H', ['HH', 2], 0, 'hour');
addFormatToken('h', ['hh', 2], 0, hFormat);
addFormatToken('k', ['kk', 2], 0, kFormat);
addFormatToken('hmm', 0, 0, function () {
return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
});
addFormatToken('hmmss', 0, 0, function () {
return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
zeroFill(this.seconds(), 2);
});
addFormatToken('Hmm', 0, 0, function () {
return '' + this.hours() + zeroFill(this.minutes(), 2);
});
addFormatToken('Hmmss', 0, 0, function () {
return '' + this.hours() + zeroFill(this.minutes(), 2) +
zeroFill(this.seconds(), 2);
});
function meridiem (token, lowercase) {
addFormatToken(token, 0, 0, function () {
return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
});
}
meridiem('a', true);
meridiem('A', false);
addUnitAlias('hour', 'h');
addUnitPriority('hour', 13);
function matchMeridiem (isStrict, locale) {
return locale._meridiemParse;
}
addRegexToken('a',  matchMeridiem);
addRegexToken('A',  matchMeridiem);
addRegexToken('H',  match1to2);
addRegexToken('h',  match1to2);
addRegexToken('k',  match1to2);
addRegexToken('HH', match1to2, match2);
addRegexToken('hh', match1to2, match2);
addRegexToken('kk', match1to2, match2);
addRegexToken('hmm', match3to4);
addRegexToken('hmmss', match5to6);
addRegexToken('Hmm', match3to4);
addRegexToken('Hmmss', match5to6);
addParseToken(['H', 'HH'], HOUR);
addParseToken(['k', 'kk'], function (input, array, config) {
var kInput = toInt(input);
array[HOUR] = kInput === 24 ? 0 : kInput;
});
addParseToken(['a', 'A'], function (input, array, config) {
config._isPm = config._locale.isPM(input);
config._meridiem = input;
});
addParseToken(['h', 'hh'], function (input, array, config) {
array[HOUR] = toInt(input);
getParsingFlags(config).bigHour = true;
});
addParseToken('hmm', function (input, array, config) {
var pos = input.length - 2;
array[HOUR] = toInt(input.substr(0, pos));
array[MINUTE] = toInt(input.substr(pos));
getParsingFlags(config).bigHour = true;
});
addParseToken('hmmss', function (input, array, config) {
var pos1 = input.length - 4;
var pos2 = input.length - 2;
array[HOUR] = toInt(input.substr(0, pos1));
array[MINUTE] = toInt(input.substr(pos1, 2));
array[SECOND] = toInt(input.substr(pos2));
getParsingFlags(config).bigHour = true;
});
addParseToken('Hmm', function (input, array, config) {
var pos = input.length - 2;
array[HOUR] = toInt(input.substr(0, pos));
array[MINUTE] = toInt(input.substr(pos));
});
addParseToken('Hmmss', function (input, array, config) {
var pos1 = input.length - 4;
var pos2 = input.length - 2;
array[HOUR] = toInt(input.substr(0, pos1));
array[MINUTE] = toInt(input.substr(pos1, 2));
array[SECOND] = toInt(input.substr(pos2));
});
function localeIsPM (input) {
return ((input + '').toLowerCase().charAt(0) === 'p');
}
var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
function localeMeridiem (hours, minutes, isLower) {
if (hours > 11) {
return isLower ? 'pm' : 'PM';
} else {
return isLower ? 'am' : 'AM';
}
}
var getSetHour = makeGetSet('Hours', true);
var baseConfig = {
calendar: defaultCalendar,
longDateFormat: defaultLongDateFormat,
invalidDate: defaultInvalidDate,
ordinal: defaultOrdinal,
dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
relativeTime: defaultRelativeTime,
months: defaultLocaleMonths,
monthsShort: defaultLocaleMonthsShort,
week: defaultLocaleWeek,
weekdays: defaultLocaleWeekdays,
weekdaysMin: defaultLocaleWeekdaysMin,
weekdaysShort: defaultLocaleWeekdaysShort,
meridiemParse: defaultLocaleMeridiemParse
};
var locales = {};
var localeFamilies = {};
var globalLocale;
function normalizeLocale(key) {
return key ? key.toLowerCase().replace('_', '-') : key;
}
function chooseLocale(names) {
var i = 0, j, next, locale, split;
while (i < names.length) {
split = normalizeLocale(names[i]).split('-');
j = split.length;
next = normalizeLocale(names[i + 1]);
next = next ? next.split('-') : null;
while (j > 0) {
locale = loadLocale(split.slice(0, j).join('-'));
if (locale) {
return locale;
}
if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
break;
}
j--;
}
i++;
}
return null;
}
function loadLocale(name) {
var oldLocale = null;
if (!locales[name] && (typeof module !== 'undefined') &&
module && module.exports) {
try {
oldLocale = globalLocale._abbr;
require('./locale/' + name);
getSetGlobalLocale(oldLocale);
} catch (e) { }
}
return locales[name];
}
function getSetGlobalLocale (key, values) {
var data;
if (key) {
if (isUndefined(values)) {
data = getLocale(key);
}
else {
data = defineLocale(key, values);
}
if (data) {
globalLocale = data;
}
}
return globalLocale._abbr;
}
function defineLocale (name, config) {
if (config !== null) {
var parentConfig = baseConfig;
config.abbr = name;
if (locales[name] != null) {
deprecateSimple('defineLocaleOverride',
'use moment.updateLocale(localeName, config) to change ' +
'an existing locale. moment.defineLocale(localeName, ' +
'config) should only be used for creating a new locale ' +
'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
parentConfig = locales[name]._config;
} else if (config.parentLocale != null) {
if (locales[config.parentLocale] != null) {
parentConfig = locales[config.parentLocale]._config;
} else {
if (!localeFamilies[config.parentLocale]) {
localeFamilies[config.parentLocale] = [];
}
localeFamilies[config.parentLocale].push({
name: name,
config: config
});
return null;
}
}
locales[name] = new Locale(mergeConfigs(parentConfig, config));
if (localeFamilies[name]) {
localeFamilies[name].forEach(function (x) {
defineLocale(x.name, x.config);
});
}
getSetGlobalLocale(name);
return locales[name];
} else {
delete locales[name];
return null;
}
}
function updateLocale(name, config) {
if (config != null) {
var locale, parentConfig = baseConfig;
if (locales[name] != null) {
parentConfig = locales[name]._config;
}
config = mergeConfigs(parentConfig, config);
locale = new Locale(config);
locale.parentLocale = locales[name];
locales[name] = locale;
getSetGlobalLocale(name);
} else {
if (locales[name] != null) {
if (locales[name].parentLocale != null) {
locales[name] = locales[name].parentLocale;
} else if (locales[name] != null) {
delete locales[name];
}
}
}
return locales[name];
}
function getLocale (key) {
var locale;
if (key && key._locale && key._locale._abbr) {
key = key._locale._abbr;
}
if (!key) {
return globalLocale;
}
if (!isArray(key)) {
locale = loadLocale(key);
if (locale) {
return locale;
}
key = [key];
}
return chooseLocale(key);
}
function listLocales() {
return keys$1(locales);
}
function checkOverflow (m) {
var overflow;
var a = m._a;
if (a && getParsingFlags(m).overflow === -2) {
overflow =
a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
-1;
if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
overflow = DATE;
}
if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
overflow = WEEK;
}
if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
overflow = WEEKDAY;
}
getParsingFlags(m).overflow = overflow;
}
return m;
}
var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;
var isoDates = [
['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
['GGGG-[W]WW', /\d{4}-W\d\d/, false],
['YYYY-DDD', /\d{4}-\d{3}/],
['YYYY-MM', /\d{4}-\d\d/, false],
['YYYYYYMMDD', /[+-]\d{10}/],
['YYYYMMDD', /\d{8}/],
['GGGG[W]WWE', /\d{4}W\d{3}/],
['GGGG[W]WW', /\d{4}W\d{2}/, false],
['YYYYDDD', /\d{7}/]
];
var isoTimes = [
['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
['HH:mm:ss', /\d\d:\d\d:\d\d/],
['HH:mm', /\d\d:\d\d/],
['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
['HHmmss', /\d\d\d\d\d\d/],
['HHmm', /\d\d\d\d/],
['HH', /\d\d/]
];
var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;
function configFromISO(config) {
var i, l,
string = config._i,
match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
allowTime, dateFormat, timeFormat, tzFormat;
if (match) {
getParsingFlags(config).iso = true;
for (i = 0, l = isoDates.length; i < l; i++) {
if (isoDates[i][1].exec(match[1])) {
dateFormat = isoDates[i][0];
allowTime = isoDates[i][2] !== false;
break;
}
}
if (dateFormat == null) {
config._isValid = false;
return;
}
if (match[3]) {
for (i = 0, l = isoTimes.length; i < l; i++) {
if (isoTimes[i][1].exec(match[3])) {
timeFormat = (match[2] || ' ') + isoTimes[i][0];
break;
}
}
if (timeFormat == null) {
config._isValid = false;
return;
}
}
if (!allowTime && timeFormat != null) {
config._isValid = false;
return;
}
if (match[4]) {
if (tzRegex.exec(match[4])) {
tzFormat = 'Z';
} else {
config._isValid = false;
return;
}
}
config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
configFromStringAndFormat(config);
} else {
config._isValid = false;
}
}
var basicRfcRegex = /^((?:Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d?\d\s(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(?:\d\d)?\d\d\s)(\d\d:\d\d)(\:\d\d)?(\s(?:UT|GMT|[ECMP][SD]T|[A-IK-Za-ik-z]|[+-]\d{4}))$/;
function configFromRFC2822(config) {
var string, match, dayFormat,
dateFormat, timeFormat, tzFormat;
var timezones = {
' GMT': ' +0000',
' EDT': ' -0400',
' EST': ' -0500',
' CDT': ' -0500',
' CST': ' -0600',
' MDT': ' -0600',
' MST': ' -0700',
' PDT': ' -0700',
' PST': ' -0800'
};
var military = 'YXWVUTSRQPONZABCDEFGHIKLM';
var timezone, timezoneIndex;
string = config._i
.replace(/\([^\)]*\)|[\n\t]/g, ' ') // Remove comments and folding whitespace
.replace(/(\s\s+)/g, ' ') // Replace multiple-spaces with a single space
.replace(/^\s|\s$/g, ''); // Remove leading and trailing spaces
match = basicRfcRegex.exec(string);
if (match) {
dayFormat = match[1] ? 'ddd' + ((match[1].length === 5) ? ', ' : ' ') : '';
dateFormat = 'D MMM ' + ((match[2].length > 10) ? 'YYYY ' : 'YY ');
timeFormat = 'HH:mm' + (match[4] ? ':ss' : '');
if (match[1]) { // day of week given
var momentDate = new Date(match[2]);
var momentDay = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'][momentDate.getDay()];
if (match[1].substr(0,3) !== momentDay) {
getParsingFlags(config).weekdayMismatch = true;
config._isValid = false;
return;
}
}
switch (match[5].length) {
case 2: // military
if (timezoneIndex === 0) {
timezone = ' +0000';
} else {
timezoneIndex = military.indexOf(match[5][1].toUpperCase()) - 12;
timezone = ((timezoneIndex < 0) ? ' -' : ' +') +
(('' + timezoneIndex).replace(/^-?/, '0')).match(/..$/)[0] + '00';
}
break;
case 4: // Zone
timezone = timezones[match[5]];
break;
default: // UT or +/-9999
timezone = timezones[' GMT'];
}
match[5] = timezone;
config._i = match.splice(1).join('');
tzFormat = ' ZZ';
config._f = dayFormat + dateFormat + timeFormat + tzFormat;
configFromStringAndFormat(config);
getParsingFlags(config).rfc2822 = true;
} else {
config._isValid = false;
}
}
function configFromString(config) {
var matched = aspNetJsonRegex.exec(config._i);
if (matched !== null) {
config._d = new Date(+matched[1]);
return;
}
configFromISO(config);
if (config._isValid === false) {
delete config._isValid;
} else {
return;
}
configFromRFC2822(config);
if (config._isValid === false) {
delete config._isValid;
} else {
return;
}
hooks.createFromInputFallback(config);
}
hooks.createFromInputFallback = deprecate(
'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
'discouraged and will be removed in an upcoming major release. Please refer to ' +
'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
function (config) {
config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
}
);
function defaults(a, b, c) {
if (a != null) {
return a;
}
if (b != null) {
return b;
}
return c;
}
function currentDateArray(config) {
var nowValue = new Date(hooks.now());
if (config._useUTC) {
return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
}
return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
}
function configFromArray (config) {
var i, date, input = [], currentDate, yearToUse;
if (config._d) {
return;
}
currentDate = currentDateArray(config);
if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
dayOfYearFromWeekInfo(config);
}
if (config._dayOfYear != null) {
yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
getParsingFlags(config)._overflowDayOfYear = true;
}
date = createUTCDate(yearToUse, 0, config._dayOfYear);
config._a[MONTH] = date.getUTCMonth();
config._a[DATE] = date.getUTCDate();
}
for (i = 0; i < 3 && config._a[i] == null; ++i) {
config._a[i] = input[i] = currentDate[i];
}
for (; i < 7; i++) {
config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
}
if (config._a[HOUR] === 24 &&
config._a[MINUTE] === 0 &&
config._a[SECOND] === 0 &&
config._a[MILLISECOND] === 0) {
config._nextDay = true;
config._a[HOUR] = 0;
}
config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
if (config._tzm != null) {
config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
}
if (config._nextDay) {
config._a[HOUR] = 24;
}
}
function dayOfYearFromWeekInfo(config) {
var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;
w = config._w;
if (w.GG != null || w.W != null || w.E != null) {
dow = 1;
doy = 4;
weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
week = defaults(w.W, 1);
weekday = defaults(w.E, 1);
if (weekday < 1 || weekday > 7) {
weekdayOverflow = true;
}
} else {
dow = config._locale._week.dow;
doy = config._locale._week.doy;
var curWeek = weekOfYear(createLocal(), dow, doy);
weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);
week = defaults(w.w, curWeek.week);
if (w.d != null) {
weekday = w.d;
if (weekday < 0 || weekday > 6) {
weekdayOverflow = true;
}
} else if (w.e != null) {
weekday = w.e + dow;
if (w.e < 0 || w.e > 6) {
weekdayOverflow = true;
}
} else {
weekday = dow;
}
}
if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
getParsingFlags(config)._overflowWeeks = true;
} else if (weekdayOverflow != null) {
getParsingFlags(config)._overflowWeekday = true;
} else {
temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
config._a[YEAR] = temp.year;
config._dayOfYear = temp.dayOfYear;
}
}
hooks.ISO_8601 = function () {};
hooks.RFC_2822 = function () {};
function configFromStringAndFormat(config) {
if (config._f === hooks.ISO_8601) {
configFromISO(config);
return;
}
if (config._f === hooks.RFC_2822) {
configFromRFC2822(config);
return;
}
config._a = [];
getParsingFlags(config).empty = true;
var string = '' + config._i,
i, parsedInput, tokens, token, skipped,
stringLength = string.length,
totalParsedInputLength = 0;
tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];
for (i = 0; i < tokens.length; i++) {
token = tokens[i];
parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
if (parsedInput) {
skipped = string.substr(0, string.indexOf(parsedInput));
if (skipped.length > 0) {
getParsingFlags(config).unusedInput.push(skipped);
}
string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
totalParsedInputLength += parsedInput.length;
}
if (formatTokenFunctions[token]) {
if (parsedInput) {
getParsingFlags(config).empty = false;
}
else {
getParsingFlags(config).unusedTokens.push(token);
}
addTimeToArrayFromToken(token, parsedInput, config);
}
else if (config._strict && !parsedInput) {
getParsingFlags(config).unusedTokens.push(token);
}
}
getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
if (string.length > 0) {
getParsingFlags(config).unusedInput.push(string);
}
if (config._a[HOUR] <= 12 &&
getParsingFlags(config).bigHour === true &&
config._a[HOUR] > 0) {
getParsingFlags(config).bigHour = undefined;
}
getParsingFlags(config).parsedDateParts = config._a.slice(0);
getParsingFlags(config).meridiem = config._meridiem;
config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);
configFromArray(config);
checkOverflow(config);
}
function meridiemFixWrap (locale, hour, meridiem) {
var isPm;
if (meridiem == null) {
return hour;
}
if (locale.meridiemHour != null) {
return locale.meridiemHour(hour, meridiem);
} else if (locale.isPM != null) {
isPm = locale.isPM(meridiem);
if (isPm && hour < 12) {
hour += 12;
}
if (!isPm && hour === 12) {
hour = 0;
}
return hour;
} else {
return hour;
}
}
function configFromStringAndArray(config) {
var tempConfig,
bestMoment,
scoreToBeat,
i,
currentScore;
if (config._f.length === 0) {
getParsingFlags(config).invalidFormat = true;
config._d = new Date(NaN);
return;
}
for (i = 0; i < config._f.length; i++) {
currentScore = 0;
tempConfig = copyConfig({}, config);
if (config._useUTC != null) {
tempConfig._useUTC = config._useUTC;
}
tempConfig._f = config._f[i];
configFromStringAndFormat(tempConfig);
if (!isValid(tempConfig)) {
continue;
}
currentScore += getParsingFlags(tempConfig).charsLeftOver;
currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
getParsingFlags(tempConfig).score = currentScore;
if (scoreToBeat == null || currentScore < scoreToBeat) {
scoreToBeat = currentScore;
bestMoment = tempConfig;
}
}
extend(config, bestMoment || tempConfig);
}
function configFromObject(config) {
if (config._d) {
return;
}
var i = normalizeObjectUnits(config._i);
config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
return obj && parseInt(obj, 10);
});
configFromArray(config);
}
function createFromConfig (config) {
var res = new Moment(checkOverflow(prepareConfig(config)));
if (res._nextDay) {
res.add(1, 'd');
res._nextDay = undefined;
}
return res;
}
function prepareConfig (config) {
var input = config._i,
format = config._f;
config._locale = config._locale || getLocale(config._l);
if (input === null || (format === undefined && input === '')) {
return createInvalid({nullInput: true});
}
if (typeof input === 'string') {
config._i = input = config._locale.preparse(input);
}
if (isMoment(input)) {
return new Moment(checkOverflow(input));
} else if (isDate(input)) {
config._d = input;
} else if (isArray(format)) {
configFromStringAndArray(config);
} else if (format) {
configFromStringAndFormat(config);
}  else {
configFromInput(config);
}
if (!isValid(config)) {
config._d = null;
}
return config;
}
function configFromInput(config) {
var input = config._i;
if (isUndefined(input)) {
config._d = new Date(hooks.now());
} else if (isDate(input)) {
config._d = new Date(input.valueOf());
} else if (typeof input === 'string') {
configFromString(config);
} else if (isArray(input)) {
config._a = map(input.slice(0), function (obj) {
return parseInt(obj, 10);
});
configFromArray(config);
} else if (isObject(input)) {
configFromObject(config);
} else if (isNumber(input)) {
config._d = new Date(input);
} else {
hooks.createFromInputFallback(config);
}
}
function createLocalOrUTC (input, format, locale, strict, isUTC) {
var c = {};
if (locale === true || locale === false) {
strict = locale;
locale = undefined;
}
if ((isObject(input) && isObjectEmpty(input)) ||
(isArray(input) && input.length === 0)) {
input = undefined;
}
c._isAMomentObject = true;
c._useUTC = c._isUTC = isUTC;
c._l = locale;
c._i = input;
c._f = format;
c._strict = strict;
return createFromConfig(c);
}
function createLocal (input, format, locale, strict) {
return createLocalOrUTC(input, format, locale, strict, false);
}
var prototypeMin = deprecate(
'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
function () {
var other = createLocal.apply(null, arguments);
if (this.isValid() && other.isValid()) {
return other < this ? this : other;
} else {
return createInvalid();
}
}
);
var prototypeMax = deprecate(
'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
function () {
var other = createLocal.apply(null, arguments);
if (this.isValid() && other.isValid()) {
return other > this ? this : other;
} else {
return createInvalid();
}
}
);
function pickBy(fn, moments) {
var res, i;
if (moments.length === 1 && isArray(moments[0])) {
moments = moments[0];
}
if (!moments.length) {
return createLocal();
}
res = moments[0];
for (i = 1; i < moments.length; ++i) {
if (!moments[i].isValid() || moments[i][fn](res)) {
res = moments[i];
}
}
return res;
}
function min () {
var args = [].slice.call(arguments, 0);
return pickBy('isBefore', args);
}
function max () {
var args = [].slice.call(arguments, 0);
return pickBy('isAfter', args);
}
var now = function () {
return Date.now ? Date.now() : +(new Date());
};
var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];
function isDurationValid(m) {
for (var key in m) {
if (!(ordering.indexOf(key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
return false;
}
}
var unitHasDecimal = false;
for (var i = 0; i < ordering.length; ++i) {
if (m[ordering[i]]) {
if (unitHasDecimal) {
return false; // only allow non-integers for smallest unit
}
if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
unitHasDecimal = true;
}
}
}
return true;
}
function isValid$1() {
return this._isValid;
}
function createInvalid$1() {
return createDuration(NaN);
}
function Duration (duration) {
var normalizedInput = normalizeObjectUnits(duration),
years = normalizedInput.year || 0,
quarters = normalizedInput.quarter || 0,
months = normalizedInput.month || 0,
weeks = normalizedInput.week || 0,
days = normalizedInput.day || 0,
hours = normalizedInput.hour || 0,
minutes = normalizedInput.minute || 0,
seconds = normalizedInput.second || 0,
milliseconds = normalizedInput.millisecond || 0;
this._isValid = isDurationValid(normalizedInput);
this._milliseconds = +milliseconds +
seconds * 1e3 + // 1000
minutes * 6e4 + // 1000 * 60
hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
this._days = +days +
weeks * 7;
this._months = +months +
quarters * 3 +
years * 12;
this._data = {};
this._locale = getLocale();
this._bubble();
}
function isDuration (obj) {
return obj instanceof Duration;
}
function absRound (number) {
if (number < 0) {
return Math.round(-1 * number) * -1;
} else {
return Math.round(number);
}
}
function offset (token, separator) {
addFormatToken(token, 0, 0, function () {
var offset = this.utcOffset();
var sign = '+';
if (offset < 0) {
offset = -offset;
sign = '-';
}
return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
});
}
offset('Z', ':');
offset('ZZ', '');
addRegexToken('Z',  matchShortOffset);
addRegexToken('ZZ', matchShortOffset);
addParseToken(['Z', 'ZZ'], function (input, array, config) {
config._useUTC = true;
config._tzm = offsetFromString(matchShortOffset, input);
});
var chunkOffset = /([\+\-]|\d\d)/gi;
function offsetFromString(matcher, string) {
var matches = (string || '').match(matcher);
if (matches === null) {
return null;
}
var chunk   = matches[matches.length - 1] || [];
var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
var minutes = +(parts[1] * 60) + toInt(parts[2]);
return minutes === 0 ?
0 :
parts[0] === '+' ? minutes : -minutes;
}
function cloneWithOffset(input, model) {
var res, diff;
if (model._isUTC) {
res = model.clone();
diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
res._d.setTime(res._d.valueOf() + diff);
hooks.updateOffset(res, false);
return res;
} else {
return createLocal(input).local();
}
}
function getDateOffset (m) {
return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
}
hooks.updateOffset = function () {};
function getSetOffset (input, keepLocalTime, keepMinutes) {
var offset = this._offset || 0,
localAdjust;
if (!this.isValid()) {
return input != null ? this : NaN;
}
if (input != null) {
if (typeof input === 'string') {
input = offsetFromString(matchShortOffset, input);
if (input === null) {
return this;
}
} else if (Math.abs(input) < 16 && !keepMinutes) {
input = input * 60;
}
if (!this._isUTC && keepLocalTime) {
localAdjust = getDateOffset(this);
}
this._offset = input;
this._isUTC = true;
if (localAdjust != null) {
this.add(localAdjust, 'm');
}
if (offset !== input) {
if (!keepLocalTime || this._changeInProgress) {
addSubtract(this, createDuration(input - offset, 'm'), 1, false);
} else if (!this._changeInProgress) {
this._changeInProgress = true;
hooks.updateOffset(this, true);
this._changeInProgress = null;
}
}
return this;
} else {
return this._isUTC ? offset : getDateOffset(this);
}
}
function getSetZone (input, keepLocalTime) {
if (input != null) {
if (typeof input !== 'string') {
input = -input;
}
this.utcOffset(input, keepLocalTime);
return this;
} else {
return -this.utcOffset();
}
}
function setOffsetToUTC (keepLocalTime) {
return this.utcOffset(0, keepLocalTime);
}
function setOffsetToLocal (keepLocalTime) {
if (this._isUTC) {
this.utcOffset(0, keepLocalTime);
this._isUTC = false;
if (keepLocalTime) {
this.subtract(getDateOffset(this), 'm');
}
}
return this;
}
function setOffsetToParsedOffset () {
if (this._tzm != null) {
this.utcOffset(this._tzm, false, true);
} else if (typeof this._i === 'string') {
var tZone = offsetFromString(matchOffset, this._i);
if (tZone != null) {
this.utcOffset(tZone);
}
else {
this.utcOffset(0, true);
}
}
return this;
}
function hasAlignedHourOffset (input) {
if (!this.isValid()) {
return false;
}
input = input ? createLocal(input).utcOffset() : 0;
return (this.utcOffset() - input) % 60 === 0;
}
function isDaylightSavingTime () {
return (
this.utcOffset() > this.clone().month(0).utcOffset() ||
this.utcOffset() > this.clone().month(5).utcOffset()
);
}
function isDaylightSavingTimeShifted () {
if (!isUndefined(this._isDSTShifted)) {
return this._isDSTShifted;
}
var c = {};
copyConfig(c, this);
c = prepareConfig(c);
if (c._a) {
var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
this._isDSTShifted = this.isValid() &&
compareArrays(c._a, other.toArray()) > 0;
} else {
this._isDSTShifted = false;
}
return this._isDSTShifted;
}
function isLocal () {
return this.isValid() ? !this._isUTC : false;
}
function isUtcOffset () {
return this.isValid() ? this._isUTC : false;
}
function isUtc () {
return this.isValid() ? this._isUTC && this._offset === 0 : false;
}
var aspNetRegex = /^(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;
var isoRegex = /^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/;
function createDuration (input, key) {
var duration = input,
match = null,
sign,
ret,
diffRes;
if (isDuration(input)) {
duration = {
ms : input._milliseconds,
d  : input._days,
M  : input._months
};
} else if (isNumber(input)) {
duration = {};
if (key) {
duration[key] = input;
} else {
duration.milliseconds = input;
}
} else if (!!(match = aspNetRegex.exec(input))) {
sign = (match[1] === '-') ? -1 : 1;
duration = {
y  : 0,
d  : toInt(match[DATE])                         * sign,
h  : toInt(match[HOUR])                         * sign,
m  : toInt(match[MINUTE])                       * sign,
s  : toInt(match[SECOND])                       * sign,
ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
};
} else if (!!(match = isoRegex.exec(input))) {
sign = (match[1] === '-') ? -1 : 1;
duration = {
y : parseIso(match[2], sign),
M : parseIso(match[3], sign),
w : parseIso(match[4], sign),
d : parseIso(match[5], sign),
h : parseIso(match[6], sign),
m : parseIso(match[7], sign),
s : parseIso(match[8], sign)
};
} else if (duration == null) {// checks for null or undefined
duration = {};
} else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));
duration = {};
duration.ms = diffRes.milliseconds;
duration.M = diffRes.months;
}
ret = new Duration(duration);
if (isDuration(input) && hasOwnProp(input, '_locale')) {
ret._locale = input._locale;
}
return ret;
}
createDuration.fn = Duration.prototype;
createDuration.invalid = createInvalid$1;
function parseIso (inp, sign) {
var res = inp && parseFloat(inp.replace(',', '.'));
return (isNaN(res) ? 0 : res) * sign;
}
function positiveMomentsDifference(base, other) {
var res = {milliseconds: 0, months: 0};
res.months = other.month() - base.month() +
(other.year() - base.year()) * 12;
if (base.clone().add(res.months, 'M').isAfter(other)) {
--res.months;
}
res.milliseconds = +other - +(base.clone().add(res.months, 'M'));
return res;
}
function momentsDifference(base, other) {
var res;
if (!(base.isValid() && other.isValid())) {
return {milliseconds: 0, months: 0};
}
other = cloneWithOffset(other, base);
if (base.isBefore(other)) {
res = positiveMomentsDifference(base, other);
} else {
res = positiveMomentsDifference(other, base);
res.milliseconds = -res.milliseconds;
res.months = -res.months;
}
return res;
}
function createAdder(direction, name) {
return function (val, period) {
var dur, tmp;
if (period !== null && !isNaN(+period)) {
deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
tmp = val; val = period; period = tmp;
}
val = typeof val === 'string' ? +val : val;
dur = createDuration(val, period);
addSubtract(this, dur, direction);
return this;
};
}
function addSubtract (mom, duration, isAdding, updateOffset) {
var milliseconds = duration._milliseconds,
days = absRound(duration._days),
months = absRound(duration._months);
if (!mom.isValid()) {
return;
}
updateOffset = updateOffset == null ? true : updateOffset;
if (milliseconds) {
mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
}
if (days) {
set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
}
if (months) {
setMonth(mom, get(mom, 'Month') + months * isAdding);
}
if (updateOffset) {
hooks.updateOffset(mom, days || months);
}
}
var add      = createAdder(1, 'add');
var subtract = createAdder(-1, 'subtract');
function getCalendarFormat(myMoment, now) {
var diff = myMoment.diff(now, 'days', true);
return diff < -6 ? 'sameElse' :
diff < -1 ? 'lastWeek' :
diff < 0 ? 'lastDay' :
diff < 1 ? 'sameDay' :
diff < 2 ? 'nextDay' :
diff < 7 ? 'nextWeek' : 'sameElse';
}
function calendar$1 (time, formats) {
var now = time || createLocal(),
sod = cloneWithOffset(now, this).startOf('day'),
format = hooks.calendarFormat(this, sod) || 'sameElse';
var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);
return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
}
function clone () {
return new Moment(this);
}
function isAfter (input, units) {
var localInput = isMoment(input) ? input : createLocal(input);
if (!(this.isValid() && localInput.isValid())) {
return false;
}
units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
if (units === 'millisecond') {
return this.valueOf() > localInput.valueOf();
} else {
return localInput.valueOf() < this.clone().startOf(units).valueOf();
}
}
function isBefore (input, units) {
var localInput = isMoment(input) ? input : createLocal(input);
if (!(this.isValid() && localInput.isValid())) {
return false;
}
units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
if (units === 'millisecond') {
return this.valueOf() < localInput.valueOf();
} else {
return this.clone().endOf(units).valueOf() < localInput.valueOf();
}
}
function isBetween (from, to, units, inclusivity) {
inclusivity = inclusivity || '()';
return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&
(inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
}
function isSame (input, units) {
var localInput = isMoment(input) ? input : createLocal(input),
inputMs;
if (!(this.isValid() && localInput.isValid())) {
return false;
}
units = normalizeUnits(units || 'millisecond');
if (units === 'millisecond') {
return this.valueOf() === localInput.valueOf();
} else {
inputMs = localInput.valueOf();
return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
}
}
function isSameOrAfter (input, units) {
return this.isSame(input, units) || this.isAfter(input,units);
}
function isSameOrBefore (input, units) {
return this.isSame(input, units) || this.isBefore(input,units);
}
function diff (input, units, asFloat) {
var that,
zoneDelta,
delta, output;
if (!this.isValid()) {
return NaN;
}
that = cloneWithOffset(input, this);
if (!that.isValid()) {
return NaN;
}
zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
units = normalizeUnits(units);
if (units === 'year' || units === 'month' || units === 'quarter') {
output = monthDiff(this, that);
if (units === 'quarter') {
output = output / 3;
} else if (units === 'year') {
output = output / 12;
}
} else {
delta = this - that;
output = units === 'second' ? delta / 1e3 : // 1000
units === 'minute' ? delta / 6e4 : // 1000 * 60
units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60
units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
delta;
}
return asFloat ? output : absFloor(output);
}
function monthDiff (a, b) {
var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
anchor = a.clone().add(wholeMonthDiff, 'months'),
anchor2, adjust;
if (b - anchor < 0) {
anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
adjust = (b - anchor) / (anchor - anchor2);
} else {
anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
adjust = (b - anchor) / (anchor2 - anchor);
}
return -(wholeMonthDiff + adjust) || 0;
}
hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';
function toString () {
return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
}
function toISOString() {
if (!this.isValid()) {
return null;
}
var m = this.clone().utc();
if (m.year() < 0 || m.year() > 9999) {
return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
}
if (isFunction(Date.prototype.toISOString)) {
return this.toDate().toISOString();
}
return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
}
function inspect () {
if (!this.isValid()) {
return 'moment.invalid(/* ' + this._i + ' */)';
}
var func = 'moment';
var zone = '';
if (!this.isLocal()) {
func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
zone = 'Z';
}
var prefix = '[' + func + '("]';
var year = (0 <= this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';
var datetime = '-MM-DD[T]HH:mm:ss.SSS';
var suffix = zone + '[")]';
return this.format(prefix + year + datetime + suffix);
}
function format (inputString) {
if (!inputString) {
inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
}
var output = formatMoment(this, inputString);
return this.localeData().postformat(output);
}
function from (time, withoutSuffix) {
if (this.isValid() &&
((isMoment(time) && time.isValid()) ||
createLocal(time).isValid())) {
return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
} else {
return this.localeData().invalidDate();
}
}
function fromNow (withoutSuffix) {
return this.from(createLocal(), withoutSuffix);
}
function to (time, withoutSuffix) {
if (this.isValid() &&
((isMoment(time) && time.isValid()) ||
createLocal(time).isValid())) {
return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
} else {
return this.localeData().invalidDate();
}
}
function toNow (withoutSuffix) {
return this.to(createLocal(), withoutSuffix);
}
function locale (key) {
var newLocaleData;
if (key === undefined) {
return this._locale._abbr;
} else {
newLocaleData = getLocale(key);
if (newLocaleData != null) {
this._locale = newLocaleData;
}
return this;
}
}
var lang = deprecate(
'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
function (key) {
if (key === undefined) {
return this.localeData();
} else {
return this.locale(key);
}
}
);
function localeData () {
return this._locale;
}
function startOf (units) {
units = normalizeUnits(units);
switch (units) {
case 'year':
this.month(0);
case 'quarter':
case 'month':
this.date(1);
case 'week':
case 'isoWeek':
case 'day':
case 'date':
this.hours(0);
case 'hour':
this.minutes(0);
case 'minute':
this.seconds(0);
case 'second':
this.milliseconds(0);
}
if (units === 'week') {
this.weekday(0);
}
if (units === 'isoWeek') {
this.isoWeekday(1);
}
if (units === 'quarter') {
this.month(Math.floor(this.month() / 3) * 3);
}
return this;
}
function endOf (units) {
units = normalizeUnits(units);
if (units === undefined || units === 'millisecond') {
return this;
}
if (units === 'date') {
units = 'day';
}
return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
}
function valueOf () {
return this._d.valueOf() - ((this._offset || 0) * 60000);
}
function unix () {
return Math.floor(this.valueOf() / 1000);
}
function toDate () {
return new Date(this.valueOf());
}
function toArray () {
var m = this;
return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
}
function toObject () {
var m = this;
return {
years: m.year(),
months: m.month(),
date: m.date(),
hours: m.hours(),
minutes: m.minutes(),
seconds: m.seconds(),
milliseconds: m.milliseconds()
};
}
function toJSON () {
return this.isValid() ? this.toISOString() : null;
}
function isValid$2 () {
return isValid(this);
}
function parsingFlags () {
return extend({}, getParsingFlags(this));
}
function invalidAt () {
return getParsingFlags(this).overflow;
}
function creationData() {
return {
input: this._i,
format: this._f,
locale: this._locale,
isUTC: this._isUTC,
strict: this._strict
};
}
addFormatToken(0, ['gg', 2], 0, function () {
return this.weekYear() % 100;
});
addFormatToken(0, ['GG', 2], 0, function () {
return this.isoWeekYear() % 100;
});
function addWeekYearFormatToken (token, getter) {
addFormatToken(0, [token, token.length], 0, getter);
}
addWeekYearFormatToken('gggg',     'weekYear');
addWeekYearFormatToken('ggggg',    'weekYear');
addWeekYearFormatToken('GGGG',  'isoWeekYear');
addWeekYearFormatToken('GGGGG', 'isoWeekYear');
addUnitAlias('weekYear', 'gg');
addUnitAlias('isoWeekYear', 'GG');
addUnitPriority('weekYear', 1);
addUnitPriority('isoWeekYear', 1);
addRegexToken('G',      matchSigned);
addRegexToken('g',      matchSigned);
addRegexToken('GG',     match1to2, match2);
addRegexToken('gg',     match1to2, match2);
addRegexToken('GGGG',   match1to4, match4);
addRegexToken('gggg',   match1to4, match4);
addRegexToken('GGGGG',  match1to6, match6);
addRegexToken('ggggg',  match1to6, match6);
addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
week[token.substr(0, 2)] = toInt(input);
});
addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
week[token] = hooks.parseTwoDigitYear(input);
});
function getSetWeekYear (input) {
return getSetWeekYearHelper.call(this,
input,
this.week(),
this.weekday(),
this.localeData()._week.dow,
this.localeData()._week.doy);
}
function getSetISOWeekYear (input) {
return getSetWeekYearHelper.call(this,
input, this.isoWeek(), this.isoWeekday(), 1, 4);
}
function getISOWeeksInYear () {
return weeksInYear(this.year(), 1, 4);
}
function getWeeksInYear () {
var weekInfo = this.localeData()._week;
return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
}
function getSetWeekYearHelper(input, week, weekday, dow, doy) {
var weeksTarget;
if (input == null) {
return weekOfYear(this, dow, doy).year;
} else {
weeksTarget = weeksInYear(input, dow, doy);
if (week > weeksTarget) {
week = weeksTarget;
}
return setWeekAll.call(this, input, week, weekday, dow, doy);
}
}
function setWeekAll(weekYear, week, weekday, dow, doy) {
var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
this.year(date.getUTCFullYear());
this.month(date.getUTCMonth());
this.date(date.getUTCDate());
return this;
}
addFormatToken('Q', 0, 'Qo', 'quarter');
addUnitAlias('quarter', 'Q');
addUnitPriority('quarter', 7);
addRegexToken('Q', match1);
addParseToken('Q', function (input, array) {
array[MONTH] = (toInt(input) - 1) * 3;
});
function getSetQuarter (input) {
return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
}
addFormatToken('D', ['DD', 2], 'Do', 'date');
addUnitAlias('date', 'D');
addUnitPriority('date', 9);
addRegexToken('D',  match1to2);
addRegexToken('DD', match1to2, match2);
addRegexToken('Do', function (isStrict, locale) {
return isStrict ?
(locale._dayOfMonthOrdinalParse || locale._ordinalParse) :
locale._dayOfMonthOrdinalParseLenient;
});
addParseToken(['D', 'DD'], DATE);
addParseToken('Do', function (input, array) {
array[DATE] = toInt(input.match(match1to2)[0], 10);
});
var getSetDayOfMonth = makeGetSet('Date', true);
addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');
addUnitAlias('dayOfYear', 'DDD');
addUnitPriority('dayOfYear', 4);
addRegexToken('DDD',  match1to3);
addRegexToken('DDDD', match3);
addParseToken(['DDD', 'DDDD'], function (input, array, config) {
config._dayOfYear = toInt(input);
});
function getSetDayOfYear (input) {
var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
}
addFormatToken('m', ['mm', 2], 0, 'minute');
addUnitAlias('minute', 'm');
addUnitPriority('minute', 14);
addRegexToken('m',  match1to2);
addRegexToken('mm', match1to2, match2);
addParseToken(['m', 'mm'], MINUTE);
var getSetMinute = makeGetSet('Minutes', false);
addFormatToken('s', ['ss', 2], 0, 'second');
addUnitAlias('second', 's');
addUnitPriority('second', 15);
addRegexToken('s',  match1to2);
addRegexToken('ss', match1to2, match2);
addParseToken(['s', 'ss'], SECOND);
var getSetSecond = makeGetSet('Seconds', false);
addFormatToken('S', 0, 0, function () {
return ~~(this.millisecond() / 100);
});
addFormatToken(0, ['SS', 2], 0, function () {
return ~~(this.millisecond() / 10);
});
addFormatToken(0, ['SSS', 3], 0, 'millisecond');
addFormatToken(0, ['SSSS', 4], 0, function () {
return this.millisecond() * 10;
});
addFormatToken(0, ['SSSSS', 5], 0, function () {
return this.millisecond() * 100;
});
addFormatToken(0, ['SSSSSS', 6], 0, function () {
return this.millisecond() * 1000;
});
addFormatToken(0, ['SSSSSSS', 7], 0, function () {
return this.millisecond() * 10000;
});
addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
return this.millisecond() * 100000;
});
addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
return this.millisecond() * 1000000;
});
addUnitAlias('millisecond', 'ms');
addUnitPriority('millisecond', 16);
addRegexToken('S',    match1to3, match1);
addRegexToken('SS',   match1to3, match2);
addRegexToken('SSS',  match1to3, match3);
var token;
for (token = 'SSSS'; token.length <= 9; token += 'S') {
addRegexToken(token, matchUnsigned);
}
function parseMs(input, array) {
array[MILLISECOND] = toInt(('0.' + input) * 1000);
}
for (token = 'S'; token.length <= 9; token += 'S') {
addParseToken(token, parseMs);
}
var getSetMillisecond = makeGetSet('Milliseconds', false);
addFormatToken('z',  0, 0, 'zoneAbbr');
addFormatToken('zz', 0, 0, 'zoneName');
function getZoneAbbr () {
return this._isUTC ? 'UTC' : '';
}
function getZoneName () {
return this._isUTC ? 'Coordinated Universal Time' : '';
}
var proto = Moment.prototype;
proto.add               = add;
proto.calendar          = calendar$1;
proto.clone             = clone;
proto.diff              = diff;
proto.endOf             = endOf;
proto.format            = format;
proto.from              = from;
proto.fromNow           = fromNow;
proto.to                = to;
proto.toNow             = toNow;
proto.get               = stringGet;
proto.invalidAt         = invalidAt;
proto.isAfter           = isAfter;
proto.isBefore          = isBefore;
proto.isBetween         = isBetween;
proto.isSame            = isSame;
proto.isSameOrAfter     = isSameOrAfter;
proto.isSameOrBefore    = isSameOrBefore;
proto.isValid           = isValid$2;
proto.lang              = lang;
proto.locale            = locale;
proto.localeData        = localeData;
proto.max               = prototypeMax;
proto.min               = prototypeMin;
proto.parsingFlags      = parsingFlags;
proto.set               = stringSet;
proto.startOf           = startOf;
proto.subtract          = subtract;
proto.toArray           = toArray;
proto.toObject          = toObject;
proto.toDate            = toDate;
proto.toISOString       = toISOString;
proto.inspect           = inspect;
proto.toJSON            = toJSON;
proto.toString          = toString;
proto.unix              = unix;
proto.valueOf           = valueOf;
proto.creationData      = creationData;
proto.year       = getSetYear;
proto.isLeapYear = getIsLeapYear;
proto.weekYear    = getSetWeekYear;
proto.isoWeekYear = getSetISOWeekYear;
proto.quarter = proto.quarters = getSetQuarter;
proto.month       = getSetMonth;
proto.daysInMonth = getDaysInMonth;
proto.week           = proto.weeks        = getSetWeek;
proto.isoWeek        = proto.isoWeeks     = getSetISOWeek;
proto.weeksInYear    = getWeeksInYear;
proto.isoWeeksInYear = getISOWeeksInYear;
proto.date       = getSetDayOfMonth;
proto.day        = proto.days             = getSetDayOfWeek;
proto.weekday    = getSetLocaleDayOfWeek;
proto.isoWeekday = getSetISODayOfWeek;
proto.dayOfYear  = getSetDayOfYear;
proto.hour = proto.hours = getSetHour;
proto.minute = proto.minutes = getSetMinute;
proto.second = proto.seconds = getSetSecond;
proto.millisecond = proto.milliseconds = getSetMillisecond;
proto.utcOffset            = getSetOffset;
proto.utc                  = setOffsetToUTC;
proto.local                = setOffsetToLocal;
proto.parseZone            = setOffsetToParsedOffset;
proto.hasAlignedHourOffset = hasAlignedHourOffset;
proto.isDST                = isDaylightSavingTime;
proto.isLocal              = isLocal;
proto.isUtcOffset          = isUtcOffset;
proto.isUtc                = isUtc;
proto.isUTC                = isUtc;
proto.zoneAbbr = getZoneAbbr;
proto.zoneName = getZoneName;
proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);
function createUnix (input) {
return createLocal(input * 1000);
}
function createInZone () {
return createLocal.apply(null, arguments).parseZone();
}
function preParsePostFormat (string) {
return string;
}
var proto$1 = Locale.prototype;
proto$1.calendar        = calendar;
proto$1.longDateFormat  = longDateFormat;
proto$1.invalidDate     = invalidDate;
proto$1.ordinal         = ordinal;
proto$1.preparse        = preParsePostFormat;
proto$1.postformat      = preParsePostFormat;
proto$1.relativeTime    = relativeTime;
proto$1.pastFuture      = pastFuture;
proto$1.set             = set;
proto$1.months            =        localeMonths;
proto$1.monthsShort       =        localeMonthsShort;
proto$1.monthsParse       =        localeMonthsParse;
proto$1.monthsRegex       = monthsRegex;
proto$1.monthsShortRegex  = monthsShortRegex;
proto$1.week = localeWeek;
proto$1.firstDayOfYear = localeFirstDayOfYear;
proto$1.firstDayOfWeek = localeFirstDayOfWeek;
proto$1.weekdays       =        localeWeekdays;
proto$1.weekdaysMin    =        localeWeekdaysMin;
proto$1.weekdaysShort  =        localeWeekdaysShort;
proto$1.weekdaysParse  =        localeWeekdaysParse;
proto$1.weekdaysRegex       =        weekdaysRegex;
proto$1.weekdaysShortRegex  =        weekdaysShortRegex;
proto$1.weekdaysMinRegex    =        weekdaysMinRegex;
proto$1.isPM = localeIsPM;
proto$1.meridiem = localeMeridiem;
function get$1 (format, index, field, setter) {
var locale = getLocale();
var utc = createUTC().set(setter, index);
return locale[field](utc, format);
}
function listMonthsImpl (format, index, field) {
if (isNumber(format)) {
index = format;
format = undefined;
}
format = format || '';
if (index != null) {
return get$1(format, index, field, 'month');
}
var i;
var out = [];
for (i = 0; i < 12; i++) {
out[i] = get$1(format, i, field, 'month');
}
return out;
}
function listWeekdaysImpl (localeSorted, format, index, field) {
if (typeof localeSorted === 'boolean') {
if (isNumber(format)) {
index = format;
format = undefined;
}
format = format || '';
} else {
format = localeSorted;
index = format;
localeSorted = false;
if (isNumber(format)) {
index = format;
format = undefined;
}
format = format || '';
}
var locale = getLocale(),
shift = localeSorted ? locale._week.dow : 0;
if (index != null) {
return get$1(format, (index + shift) % 7, field, 'day');
}
var i;
var out = [];
for (i = 0; i < 7; i++) {
out[i] = get$1(format, (i + shift) % 7, field, 'day');
}
return out;
}
function listMonths (format, index) {
return listMonthsImpl(format, index, 'months');
}
function listMonthsShort (format, index) {
return listMonthsImpl(format, index, 'monthsShort');
}
function listWeekdays (localeSorted, format, index) {
return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
}
function listWeekdaysShort (localeSorted, format, index) {
return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
}
function listWeekdaysMin (localeSorted, format, index) {
return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
}
getSetGlobalLocale('en', {
dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
ordinal : function (number) {
var b = number % 10,
output = (toInt(number % 100 / 10) === 1) ? 'th' :
(b === 1) ? 'st' :
(b === 2) ? 'nd' :
(b === 3) ? 'rd' : 'th';
return number + output;
}
});
hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);
var mathAbs = Math.abs;
function abs () {
var data           = this._data;
this._milliseconds = mathAbs(this._milliseconds);
this._days         = mathAbs(this._days);
this._months       = mathAbs(this._months);
data.milliseconds  = mathAbs(data.milliseconds);
data.seconds       = mathAbs(data.seconds);
data.minutes       = mathAbs(data.minutes);
data.hours         = mathAbs(data.hours);
data.months        = mathAbs(data.months);
data.years         = mathAbs(data.years);
return this;
}
function addSubtract$1 (duration, input, value, direction) {
var other = createDuration(input, value);
duration._milliseconds += direction * other._milliseconds;
duration._days         += direction * other._days;
duration._months       += direction * other._months;
return duration._bubble();
}
function add$1 (input, value) {
return addSubtract$1(this, input, value, 1);
}
function subtract$1 (input, value) {
return addSubtract$1(this, input, value, -1);
}
function absCeil (number) {
if (number < 0) {
return Math.floor(number);
} else {
return Math.ceil(number);
}
}
function bubble () {
var milliseconds = this._milliseconds;
var days         = this._days;
var months       = this._months;
var data         = this._data;
var seconds, minutes, hours, years, monthsFromDays;
if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
(milliseconds <= 0 && days <= 0 && months <= 0))) {
milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
days = 0;
months = 0;
}
data.milliseconds = milliseconds % 1000;
seconds           = absFloor(milliseconds / 1000);
data.seconds      = seconds % 60;
minutes           = absFloor(seconds / 60);
data.minutes      = minutes % 60;
hours             = absFloor(minutes / 60);
data.hours        = hours % 24;
days += absFloor(hours / 24);
monthsFromDays = absFloor(daysToMonths(days));
months += monthsFromDays;
days -= absCeil(monthsToDays(monthsFromDays));
years = absFloor(months / 12);
months %= 12;
data.days   = days;
data.months = months;
data.years  = years;
return this;
}
function daysToMonths (days) {
return days * 4800 / 146097;
}
function monthsToDays (months) {
return months * 146097 / 4800;
}
function as (units) {
if (!this.isValid()) {
return NaN;
}
var days;
var months;
var milliseconds = this._milliseconds;
units = normalizeUnits(units);
if (units === 'month' || units === 'year') {
days   = this._days   + milliseconds / 864e5;
months = this._months + daysToMonths(days);
return units === 'month' ? months : months / 12;
} else {
days = this._days + Math.round(monthsToDays(this._months));
switch (units) {
case 'week'   : return days / 7     + milliseconds / 6048e5;
case 'day'    : return days         + milliseconds / 864e5;
case 'hour'   : return days * 24    + milliseconds / 36e5;
case 'minute' : return days * 1440  + milliseconds / 6e4;
case 'second' : return days * 86400 + milliseconds / 1000;
case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
default: throw new Error('Unknown unit ' + units);
}
}
}
function valueOf$1 () {
if (!this.isValid()) {
return NaN;
}
return (
this._milliseconds +
this._days * 864e5 +
(this._months % 12) * 2592e6 +
toInt(this._months / 12) * 31536e6
);
}
function makeAs (alias) {
return function () {
return this.as(alias);
};
}
var asMilliseconds = makeAs('ms');
var asSeconds      = makeAs('s');
var asMinutes      = makeAs('m');
var asHours        = makeAs('h');
var asDays         = makeAs('d');
var asWeeks        = makeAs('w');
var asMonths       = makeAs('M');
var asYears        = makeAs('y');
function get$2 (units) {
units = normalizeUnits(units);
return this.isValid() ? this[units + 's']() : NaN;
}
function makeGetter(name) {
return function () {
return this.isValid() ? this._data[name] : NaN;
};
}
var milliseconds = makeGetter('milliseconds');
var seconds      = makeGetter('seconds');
var minutes      = makeGetter('minutes');
var hours        = makeGetter('hours');
var days         = makeGetter('days');
var months       = makeGetter('months');
var years        = makeGetter('years');
function weeks () {
return absFloor(this.days() / 7);
}
var round = Math.round;
var thresholds = {
ss: 44,         // a few seconds to seconds
s : 45,         // seconds to minute
m : 45,         // minutes to hour
h : 22,         // hours to day
d : 26,         // days to month
M : 11          // months to year
};
function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
}
function relativeTime$1 (posNegDuration, withoutSuffix, locale) {
var duration = createDuration(posNegDuration).abs();
var seconds  = round(duration.as('s'));
var minutes  = round(duration.as('m'));
var hours    = round(duration.as('h'));
var days     = round(duration.as('d'));
var months   = round(duration.as('M'));
var years    = round(duration.as('y'));
var a = seconds <= thresholds.ss && ['s', seconds]  ||
seconds < thresholds.s   && ['ss', seconds] ||
minutes <= 1             && ['m']           ||
minutes < thresholds.m   && ['mm', minutes] ||
hours   <= 1             && ['h']           ||
hours   < thresholds.h   && ['hh', hours]   ||
days    <= 1             && ['d']           ||
days    < thresholds.d   && ['dd', days]    ||
months  <= 1             && ['M']           ||
months  < thresholds.M   && ['MM', months]  ||
years   <= 1             && ['y']           || ['yy', years];
a[2] = withoutSuffix;
a[3] = +posNegDuration > 0;
a[4] = locale;
return substituteTimeAgo.apply(null, a);
}
function getSetRelativeTimeRounding (roundingFunction) {
if (roundingFunction === undefined) {
return round;
}
if (typeof(roundingFunction) === 'function') {
round = roundingFunction;
return true;
}
return false;
}
function getSetRelativeTimeThreshold (threshold, limit) {
if (thresholds[threshold] === undefined) {
return false;
}
if (limit === undefined) {
return thresholds[threshold];
}
thresholds[threshold] = limit;
if (threshold === 's') {
thresholds.ss = limit - 1;
}
return true;
}
function humanize (withSuffix) {
if (!this.isValid()) {
return this.localeData().invalidDate();
}
var locale = this.localeData();
var output = relativeTime$1(this, !withSuffix, locale);
if (withSuffix) {
output = locale.pastFuture(+this, output);
}
return locale.postformat(output);
}
var abs$1 = Math.abs;
function toISOString$1() {
if (!this.isValid()) {
return this.localeData().invalidDate();
}
var seconds = abs$1(this._milliseconds) / 1000;
var days         = abs$1(this._days);
var months       = abs$1(this._months);
var minutes, hours, years;
minutes           = absFloor(seconds / 60);
hours             = absFloor(minutes / 60);
seconds %= 60;
minutes %= 60;
years  = absFloor(months / 12);
months %= 12;
var Y = years;
var M = months;
var D = days;
var h = hours;
var m = minutes;
var s = seconds;
var total = this.asSeconds();
if (!total) {
return 'P0D';
}
return (total < 0 ? '-' : '') +
'P' +
(Y ? Y + 'Y' : '') +
(M ? M + 'M' : '') +
(D ? D + 'D' : '') +
((h || m || s) ? 'T' : '') +
(h ? h + 'H' : '') +
(m ? m + 'M' : '') +
(s ? s + 'S' : '');
}
var proto$2 = Duration.prototype;
proto$2.isValid        = isValid$1;
proto$2.abs            = abs;
proto$2.add            = add$1;
proto$2.subtract       = subtract$1;
proto$2.as             = as;
proto$2.asMilliseconds = asMilliseconds;
proto$2.asSeconds      = asSeconds;
proto$2.asMinutes      = asMinutes;
proto$2.asHours        = asHours;
proto$2.asDays         = asDays;
proto$2.asWeeks        = asWeeks;
proto$2.asMonths       = asMonths;
proto$2.asYears        = asYears;
proto$2.valueOf        = valueOf$1;
proto$2._bubble        = bubble;
proto$2.get            = get$2;
proto$2.milliseconds   = milliseconds;
proto$2.seconds        = seconds;
proto$2.minutes        = minutes;
proto$2.hours          = hours;
proto$2.days           = days;
proto$2.weeks          = weeks;
proto$2.months         = months;
proto$2.years          = years;
proto$2.humanize       = humanize;
proto$2.toISOString    = toISOString$1;
proto$2.toString       = toISOString$1;
proto$2.toJSON         = toISOString$1;
proto$2.locale         = locale;
proto$2.localeData     = localeData;
proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
proto$2.lang = lang;
addFormatToken('X', 0, 0, 'unix');
addFormatToken('x', 0, 0, 'valueOf');
addRegexToken('x', matchSigned);
addRegexToken('X', matchTimestamp);
addParseToken('X', function (input, array, config) {
config._d = new Date(parseFloat(input, 10) * 1000);
});
addParseToken('x', function (input, array, config) {
config._d = new Date(toInt(input));
});
hooks.version = '2.18.1';
setHookCallback(createLocal);
hooks.fn                    = proto;
hooks.min                   = min;
hooks.max                   = max;
hooks.now                   = now;
hooks.utc                   = createUTC;
hooks.unix                  = createUnix;
hooks.months                = listMonths;
hooks.isDate                = isDate;
hooks.locale                = getSetGlobalLocale;
hooks.invalid               = createInvalid;
hooks.duration              = createDuration;
hooks.isMoment              = isMoment;
hooks.weekdays              = listWeekdays;
hooks.parseZone             = createInZone;
hooks.localeData            = getLocale;
hooks.isDuration            = isDuration;
hooks.monthsShort           = listMonthsShort;
hooks.weekdaysMin           = listWeekdaysMin;
hooks.defineLocale          = defineLocale;
hooks.updateLocale          = updateLocale;
hooks.locales               = listLocales;
hooks.weekdaysShort         = listWeekdaysShort;
hooks.normalizeUnits        = normalizeUnits;
hooks.relativeTimeRounding = getSetRelativeTimeRounding;
hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
hooks.calendarFormat        = getCalendarFormat;
hooks.prototype             = proto;
return hooks;
})));
},{}],7:[function(require,module,exports){
var Chart = require(29)();
Chart.helpers = require(45);
require(27)(Chart);
Chart.defaults = require(25);
Chart.Element = require(26);
Chart.elements = require(40);
Chart.Interaction = require(28);
Chart.platform = require(48);
require(31)(Chart);
require(22)(Chart);
require(23)(Chart);
require(24)(Chart);
require(30)(Chart);
require(33)(Chart);
require(32)(Chart);
require(35)(Chart);
require(54)(Chart);
require(52)(Chart);
require(53)(Chart);
require(55)(Chart);
require(56)(Chart);
require(57)(Chart);
require(15)(Chart);
require(16)(Chart);
require(17)(Chart);
require(18)(Chart);
require(19)(Chart);
require(20)(Chart);
require(21)(Chart);
require(8)(Chart);
require(9)(Chart);
require(10)(Chart);
require(11)(Chart);
require(12)(Chart);
require(13)(Chart);
require(14)(Chart);
var plugins = [];
plugins.push(
require(49)(Chart),
require(50)(Chart),
require(51)(Chart)
);
Chart.plugins.register(plugins);
Chart.platform.initialize();
module.exports = Chart;
if (typeof window !== 'undefined') {
window.Chart = Chart;
}
Chart.canvasHelpers = Chart.helpers.canvas;
},{"10":10,"11":11,"12":12,"13":13,"14":14,"15":15,"16":16,"17":17,"18":18,"19":19,"20":20,"21":21,"22":22,"23":23,"24":24,"25":25,"26":26,"27":27,"28":28,"29":29,"30":30,"31":31,"32":32,"33":33,"35":35,"40":40,"45":45,"48":48,"49":49,"50":50,"51":51,"52":52,"53":53,"54":54,"55":55,"56":56,"57":57,"8":8,"9":9}],8:[function(require,module,exports){
'use strict';
module.exports = function(Chart) {
Chart.Bar = function(context, config) {
config.type = 'bar';
return new Chart(context, config);
};
};
},{}],9:[function(require,module,exports){
'use strict';
module.exports = function(Chart) {
Chart.Bubble = function(context, config) {
config.type = 'bubble';
return new Chart(context, config);
};
};
},{}],10:[function(require,module,exports){
'use strict';
module.exports = function(Chart) {
Chart.Doughnut = function(context, config) {
config.type = 'doughnut';
return new Chart(context, config);
};
};
},{}],11:[function(require,module,exports){
'use strict';
module.exports = function(Chart) {
Chart.Line = function(context, config) {
config.type = 'line';
return new Chart(context, config);
};
};
},{}],12:[function(require,module,exports){
'use strict';
module.exports = function(Chart) {
Chart.PolarArea = function(context, config) {
config.type = 'polarArea';
return new Chart(context, config);
};
};
},{}],13:[function(require,module,exports){
'use strict';
module.exports = function(Chart) {
Chart.Radar = function(context, config) {
config.type = 'radar';
return new Chart(context, config);
};
};
},{}],14:[function(require,module,exports){
'use strict';
module.exports = function(Chart) {
Chart.Scatter = function(context, config) {
config.type = 'scatter';
return new Chart(context, config);
};
};
},{}],15:[function(require,module,exports){
'use strict';
var defaults = require(25);
var elements = require(40);
var helpers = require(45);
defaults._set('bar', {
hover: {
mode: 'label'
},
scales: {
xAxes: [{
type: 'category',
categoryPercentage: 0.8,
barPercentage: 0.9,
offset: true,
gridLines: {
offsetGridLines: true
}
}],
yAxes: [{
type: 'linear'
}]
}
});
defaults._set('horizontalBar', {
hover: {
mode: 'index',
axis: 'y'
},
scales: {
xAxes: [{
type: 'linear',
position: 'bottom'
}],
yAxes: [{
position: 'left',
type: 'category',
categoryPercentage: 0.8,
barPercentage: 0.9,
offset: true,
gridLines: {
offsetGridLines: true
}
}]
},
elements: {
rectangle: {
borderSkipped: 'left'
}
},
tooltips: {
callbacks: {
title: function(item, data) {
var title = '';
if (item.length > 0) {
if (item[0].yLabel) {
title = item[0].yLabel;
} else if (data.labels.length > 0 && item[0].index < data.labels.length) {
title = data.labels[item[0].index];
}
}
return title;
},
label: function(item, data) {
var datasetLabel = data.datasets[item.datasetIndex].label || '';
return datasetLabel + ': ' + item.xLabel;
}
},
mode: 'index',
axis: 'y'
}
});
module.exports = function(Chart) {
Chart.controllers.bar = Chart.DatasetController.extend({
dataElementType: elements.Rectangle,
initialize: function() {
var me = this;
var meta;
Chart.DatasetController.prototype.initialize.apply(me, arguments);
meta = me.getMeta();
meta.stack = me.getDataset().stack;
meta.bar = true;
},
update: function(reset) {
var me = this;
var rects = me.getMeta().data;
var i, ilen;
me._ruler = me.getRuler();
for (i = 0, ilen = rects.length; i < ilen; ++i) {
me.updateElement(rects[i], i, reset);
}
},
updateElement: function(rectangle, index, reset) {
var me = this;
var chart = me.chart;
var meta = me.getMeta();
var dataset = me.getDataset();
var custom = rectangle.custom || {};
var rectangleOptions = chart.options.elements.rectangle;
rectangle._xScale = me.getScaleForId(meta.xAxisID);
rectangle._yScale = me.getScaleForId(meta.yAxisID);
rectangle._datasetIndex = me.index;
rectangle._index = index;
rectangle._model = {
datasetLabel: dataset.label,
label: chart.data.labels[index],
borderSkipped: custom.borderSkipped ? custom.borderSkipped : rectangleOptions.borderSkipped,
backgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.backgroundColor, index, rectangleOptions.backgroundColor),
borderColor: custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.borderColor, index, rectangleOptions.borderColor),
borderWidth: custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.borderWidth, index, rectangleOptions.borderWidth)
};
me.updateElementGeometry(rectangle, index, reset);
rectangle.pivot();
},
updateElementGeometry: function(rectangle, index, reset) {
var me = this;
var model = rectangle._model;
var vscale = me.getValueScale();
var base = vscale.getBasePixel();
var horizontal = vscale.isHorizontal();
var ruler = me._ruler || me.getRuler();
var vpixels = me.calculateBarValuePixels(me.index, index);
var ipixels = me.calculateBarIndexPixels(me.index, index, ruler);
model.horizontal = horizontal;
model.base = reset ? base : vpixels.base;
model.x = horizontal ? reset ? base : vpixels.head : ipixels.center;
model.y = horizontal ? ipixels.center : reset ? base : vpixels.head;
model.height = horizontal ? ipixels.size : undefined;
model.width = horizontal ? undefined : ipixels.size;
},
getValueScaleId: function() {
return this.getMeta().yAxisID;
},
getIndexScaleId: function() {
return this.getMeta().xAxisID;
},
getValueScale: function() {
return this.getScaleForId(this.getValueScaleId());
},
getIndexScale: function() {
return this.getScaleForId(this.getIndexScaleId());
},
getStackCount: function(last) {
var me = this;
var chart = me.chart;
var scale = me.getIndexScale();
var stacked = scale.options.stacked;
var ilen = last === undefined ? chart.data.datasets.length : last + 1;
var stacks = [];
var i, meta;
for (i = 0; i < ilen; ++i) {
meta = chart.getDatasetMeta(i);
if (meta.bar && chart.isDatasetVisible(i) &&
(stacked === false ||
(stacked === true && stacks.indexOf(meta.stack) === -1) ||
(stacked === undefined && (meta.stack === undefined || stacks.indexOf(meta.stack) === -1)))) {
stacks.push(meta.stack);
}
}
return stacks.length;
},
getStackIndex: function(datasetIndex) {
return this.getStackCount(datasetIndex) - 1;
},
getRuler: function() {
var me = this;
var scale = me.getIndexScale();
var stackCount = me.getStackCount();
var datasetIndex = me.index;
var pixels = [];
var isHorizontal = scale.isHorizontal();
var start = isHorizontal ? scale.left : scale.top;
var end = start + (isHorizontal ? scale.width : scale.height);
var i, ilen;
for (i = 0, ilen = me.getMeta().data.length; i < ilen; ++i) {
pixels.push(scale.getPixelForValue(null, i, datasetIndex));
}
return {
pixels: pixels,
start: start,
end: end,
stackCount: stackCount,
scale: scale
};
},
calculateBarValuePixels: function(datasetIndex, index) {
var me = this;
var chart = me.chart;
var meta = me.getMeta();
var scale = me.getValueScale();
var datasets = chart.data.datasets;
var value = scale.getRightValue(datasets[datasetIndex].data[index]);
var stacked = scale.options.stacked;
var stack = meta.stack;
var start = 0;
var i, imeta, ivalue, base, head, size;
if (stacked || (stacked === undefined && stack !== undefined)) {
for (i = 0; i < datasetIndex; ++i) {
imeta = chart.getDatasetMeta(i);
if (imeta.bar &&
imeta.stack === stack &&
imeta.controller.getValueScaleId() === scale.id &&
chart.isDatasetVisible(i)) {
ivalue = scale.getRightValue(datasets[i].data[index]);
if ((value < 0 && ivalue < 0) || (value >= 0 && ivalue > 0)) {
start += ivalue;
}
}
}
}
base = scale.getPixelForValue(start);
head = scale.getPixelForValue(start + value);
size = (head - base) / 2;
return {
size: size,
base: base,
head: head,
center: head + size / 2
};
},
calculateBarIndexPixels: function(datasetIndex, index, ruler) {
var me = this;
var options = ruler.scale.options;
var stackIndex = me.getStackIndex(datasetIndex);
var pixels = ruler.pixels;
var base = pixels[index];
var length = pixels.length;
var start = ruler.start;
var end = ruler.end;
var leftSampleSize, rightSampleSize, leftCategorySize, rightCategorySize, fullBarSize, size;
if (length === 1) {
leftSampleSize = base > start ? base - start : end - base;
rightSampleSize = base < end ? end - base : base - start;
} else {
if (index > 0) {
leftSampleSize = (base - pixels[index - 1]) / 2;
if (index === length - 1) {
rightSampleSize = leftSampleSize;
}
}
if (index < length - 1) {
rightSampleSize = (pixels[index + 1] - base) / 2;
if (index === 0) {
leftSampleSize = rightSampleSize;
}
}
}
leftCategorySize = leftSampleSize * options.categoryPercentage;
rightCategorySize = rightSampleSize * options.categoryPercentage;
fullBarSize = (leftCategorySize + rightCategorySize) / ruler.stackCount;
size = fullBarSize * options.barPercentage;
size = Math.min(
helpers.valueOrDefault(options.barThickness, size),
helpers.valueOrDefault(options.maxBarThickness, Infinity));
base -= leftCategorySize;
base += fullBarSize * stackIndex;
base += (fullBarSize - size) / 2;
return {
size: size,
base: base,
head: base + size,
center: base + size / 2
};
},
draw: function() {
var me = this;
var chart = me.chart;
var scale = me.getValueScale();
var rects = me.getMeta().data;
var dataset = me.getDataset();
var ilen = rects.length;
var i = 0;
helpers.canvas.clipArea(chart.ctx, chart.chartArea);
for (; i < ilen; ++i) {
if (!isNaN(scale.getRightValue(dataset.data[i]))) {
rects[i].draw();
}
}
helpers.canvas.unclipArea(chart.ctx);
},
setHoverStyle: function(rectangle) {
var dataset = this.chart.data.datasets[rectangle._datasetIndex];
var index = rectangle._index;
var custom = rectangle.custom || {};
var model = rectangle._model;
model.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : helpers.valueAtIndexOrDefault(dataset.hoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));
model.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : helpers.valueAtIndexOrDefault(dataset.hoverBorderColor, index, helpers.getHoverColor(model.borderColor));
model.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : helpers.valueAtIndexOrDefault(dataset.hoverBorderWidth, index, model.borderWidth);
},
removeHoverStyle: function(rectangle) {
var dataset = this.chart.data.datasets[rectangle._datasetIndex];
var index = rectangle._index;
var custom = rectangle.custom || {};
var model = rectangle._model;
var rectangleElementOptions = this.chart.options.elements.rectangle;
model.backgroundColor = custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.backgroundColor, index, rectangleElementOptions.backgroundColor);
model.borderColor = custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.borderColor, index, rectangleElementOptions.borderColor);
model.borderWidth = custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.borderWidth, index, rectangleElementOptions.borderWidth);
}
});
Chart.controllers.horizontalBar = Chart.controllers.bar.extend({
getValueScaleId: function() {
return this.getMeta().xAxisID;
},
getIndexScaleId: function() {
return this.getMeta().yAxisID;
}
});
};
},{"25":25,"40":40,"45":45}],16:[function(require,module,exports){
'use strict';
var defaults = require(25);
var elements = require(40);
var helpers = require(45);
defaults._set('bubble', {
hover: {
mode: 'single'
},
scales: {
xAxes: [{
type: 'linear', // bubble should probably use a linear scale by default
position: 'bottom',
id: 'x-axis-0' // need an ID so datasets can reference the scale
}],
yAxes: [{
type: 'linear',
position: 'left',
id: 'y-axis-0'
}]
},
tooltips: {
callbacks: {
title: function() {
return '';
},
label: function(item, data) {
var datasetLabel = data.datasets[item.datasetIndex].label || '';
var dataPoint = data.datasets[item.datasetIndex].data[item.index];
return datasetLabel + ': (' + item.xLabel + ', ' + item.yLabel + ', ' + dataPoint.r + ')';
}
}
}
});
module.exports = function(Chart) {
Chart.controllers.bubble = Chart.DatasetController.extend({
dataElementType: elements.Point,
update: function(reset) {
var me = this;
var meta = me.getMeta();
var points = meta.data;
helpers.each(points, function(point, index) {
me.updateElement(point, index, reset);
});
},
updateElement: function(point, index, reset) {
var me = this;
var meta = me.getMeta();
var custom = point.custom || {};
var xScale = me.getScaleForId(meta.xAxisID);
var yScale = me.getScaleForId(meta.yAxisID);
var options = me._resolveElementOptions(point, index);
var data = me.getDataset().data[index];
var dsIndex = me.index;
var x = reset ? xScale.getPixelForDecimal(0.5) : xScale.getPixelForValue(typeof data === 'object' ? data : NaN, index, dsIndex);
var y = reset ? yScale.getBasePixel() : yScale.getPixelForValue(data, index, dsIndex);
point._xScale = xScale;
point._yScale = yScale;
point._options = options;
point._datasetIndex = dsIndex;
point._index = index;
point._model = {
backgroundColor: options.backgroundColor,
borderColor: options.borderColor,
borderWidth: options.borderWidth,
hitRadius: options.hitRadius,
pointStyle: options.pointStyle,
radius: reset ? 0 : options.radius,
skip: custom.skip || isNaN(x) || isNaN(y),
x: x,
y: y,
};
point.pivot();
},
setHoverStyle: function(point) {
var model = point._model;
var options = point._options;
model.backgroundColor = helpers.valueOrDefault(options.hoverBackgroundColor, helpers.getHoverColor(options.backgroundColor));
model.borderColor = helpers.valueOrDefault(options.hoverBorderColor, helpers.getHoverColor(options.borderColor));
model.borderWidth = helpers.valueOrDefault(options.hoverBorderWidth, options.borderWidth);
model.radius = options.radius + options.hoverRadius;
},
removeHoverStyle: function(point) {
var model = point._model;
var options = point._options;
model.backgroundColor = options.backgroundColor;
model.borderColor = options.borderColor;
model.borderWidth = options.borderWidth;
model.radius = options.radius;
},
_resolveElementOptions: function(point, index) {
var me = this;
var chart = me.chart;
var datasets = chart.data.datasets;
var dataset = datasets[me.index];
var custom = point.custom || {};
var options = chart.options.elements.point;
var resolve = helpers.options.resolve;
var data = dataset.data[index];
var values = {};
var i, ilen, key;
var context = {
chart: chart,
dataIndex: index,
dataset: dataset,
datasetIndex: me.index
};
var keys = [
'backgroundColor',
'borderColor',
'borderWidth',
'hoverBackgroundColor',
'hoverBorderColor',
'hoverBorderWidth',
'hoverRadius',
'hitRadius',
'pointStyle'
];
for (i = 0, ilen = keys.length; i < ilen; ++i) {
key = keys[i];
values[key] = resolve([
custom[key],
dataset[key],
options[key]
], context, index);
}
values.radius = resolve([
custom.radius,
data ? data.r : undefined,
dataset.radius,
options.radius
], context, index);
return values;
}
});
};
},{"25":25,"40":40,"45":45}],17:[function(require,module,exports){
'use strict';
var defaults = require(25);
var elements = require(40);
var helpers = require(45);
defaults._set('doughnut', {
animation: {
animateRotate: true,
animateScale: false
},
hover: {
mode: 'single'
},
legendCallback: function(chart) {
var text = [];
text.push('<ul class="' + chart.id + '-legend">');
var data = chart.data;
var datasets = data.datasets;
var labels = data.labels;
if (datasets.length) {
for (var i = 0; i < datasets[0].data.length; ++i) {
text.push('<li><span style="background-color:' + datasets[0].backgroundColor[i] + '"></span>');
if (labels[i]) {
text.push(labels[i]);
}
text.push('</li>');
}
}
text.push('</ul>');
return text.join('');
},
legend: {
labels: {
generateLabels: function(chart) {
var data = chart.data;
if (data.labels.length && data.datasets.length) {
return data.labels.map(function(label, i) {
var meta = chart.getDatasetMeta(0);
var ds = data.datasets[0];
var arc = meta.data[i];
var custom = arc && arc.custom || {};
var valueAtIndexOrDefault = helpers.valueAtIndexOrDefault;
var arcOpts = chart.options.elements.arc;
var fill = custom.backgroundColor ? custom.backgroundColor : valueAtIndexOrDefault(ds.backgroundColor, i, arcOpts.backgroundColor);
var stroke = custom.borderColor ? custom.borderColor : valueAtIndexOrDefault(ds.borderColor, i, arcOpts.borderColor);
var bw = custom.borderWidth ? custom.borderWidth : valueAtIndexOrDefault(ds.borderWidth, i, arcOpts.borderWidth);
return {
text: label,
fillStyle: fill,
strokeStyle: stroke,
lineWidth: bw,
hidden: isNaN(ds.data[i]) || meta.data[i].hidden,
index: i
};
});
}
return [];
}
},
onClick: function(e, legendItem) {
var index = legendItem.index;
var chart = this.chart;
var i, ilen, meta;
for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
meta = chart.getDatasetMeta(i);
if (meta.data[index]) {
meta.data[index].hidden = !meta.data[index].hidden;
}
}
chart.update();
}
},
cutoutPercentage: 50,
rotation: Math.PI * -0.5,
circumference: Math.PI * 2.0,
tooltips: {
callbacks: {
title: function() {
return '';
},
label: function(tooltipItem, data) {
var dataLabel = data.labels[tooltipItem.index];
var value = ': ' + data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];
if (helpers.isArray(dataLabel)) {
dataLabel = dataLabel.slice();
dataLabel[0] += value;
} else {
dataLabel += value;
}
return dataLabel;
}
}
}
});
defaults._set('pie', helpers.clone(defaults.doughnut));
defaults._set('pie', {
cutoutPercentage: 0
});
module.exports = function(Chart) {
Chart.controllers.doughnut = Chart.controllers.pie = Chart.DatasetController.extend({
dataElementType: elements.Arc,
linkScales: helpers.noop,
getRingIndex: function(datasetIndex) {
var ringIndex = 0;
for (var j = 0; j < datasetIndex; ++j) {
if (this.chart.isDatasetVisible(j)) {
++ringIndex;
}
}
return ringIndex;
},
update: function(reset) {
var me = this;
var chart = me.chart;
var chartArea = chart.chartArea;
var opts = chart.options;
var arcOpts = opts.elements.arc;
var availableWidth = chartArea.right - chartArea.left - arcOpts.borderWidth;
var availableHeight = chartArea.bottom - chartArea.top - arcOpts.borderWidth;
var minSize = Math.min(availableWidth, availableHeight);
var offset = {x: 0, y: 0};
var meta = me.getMeta();
var cutoutPercentage = opts.cutoutPercentage;
var circumference = opts.circumference;
if (circumference < Math.PI * 2.0) {
var startAngle = opts.rotation % (Math.PI * 2.0);
startAngle += Math.PI * 2.0 * (startAngle >= Math.PI ? -1 : startAngle < -Math.PI ? 1 : 0);
var endAngle = startAngle + circumference;
var start = {x: Math.cos(startAngle), y: Math.sin(startAngle)};
var end = {x: Math.cos(endAngle), y: Math.sin(endAngle)};
var contains0 = (startAngle <= 0 && endAngle >= 0) || (startAngle <= Math.PI * 2.0 && Math.PI * 2.0 <= endAngle);
var contains90 = (startAngle <= Math.PI * 0.5 && Math.PI * 0.5 <= endAngle) || (startAngle <= Math.PI * 2.5 && Math.PI * 2.5 <= endAngle);
var contains180 = (startAngle <= -Math.PI && -Math.PI <= endAngle) || (startAngle <= Math.PI && Math.PI <= endAngle);
var contains270 = (startAngle <= -Math.PI * 0.5 && -Math.PI * 0.5 <= endAngle) || (startAngle <= Math.PI * 1.5 && Math.PI * 1.5 <= endAngle);
var cutout = cutoutPercentage / 100.0;
var min = {x: contains180 ? -1 : Math.min(start.x * (start.x < 0 ? 1 : cutout), end.x * (end.x < 0 ? 1 : cutout)), y: contains270 ? -1 : Math.min(start.y * (start.y < 0 ? 1 : cutout), end.y * (end.y < 0 ? 1 : cutout))};
var max = {x: contains0 ? 1 : Math.max(start.x * (start.x > 0 ? 1 : cutout), end.x * (end.x > 0 ? 1 : cutout)), y: contains90 ? 1 : Math.max(start.y * (start.y > 0 ? 1 : cutout), end.y * (end.y > 0 ? 1 : cutout))};
var size = {width: (max.x - min.x) * 0.5, height: (max.y - min.y) * 0.5};
minSize = Math.min(availableWidth / size.width, availableHeight / size.height);
offset = {x: (max.x + min.x) * -0.5, y: (max.y + min.y) * -0.5};
}
chart.borderWidth = me.getMaxBorderWidth(meta.data);
chart.outerRadius = Math.max((minSize - chart.borderWidth) / 2, 0);
chart.innerRadius = Math.max(cutoutPercentage ? (chart.outerRadius / 100) * (cutoutPercentage) : 0, 0);
chart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();
chart.offsetX = offset.x * chart.outerRadius;
chart.offsetY = offset.y * chart.outerRadius;
meta.total = me.calculateTotal();
me.outerRadius = chart.outerRadius - (chart.radiusLength * me.getRingIndex(me.index));
me.innerRadius = Math.max(me.outerRadius - chart.radiusLength, 0);
helpers.each(meta.data, function(arc, index) {
me.updateElement(arc, index, reset);
});
},
updateElement: function(arc, index, reset) {
var me = this;
var chart = me.chart;
var chartArea = chart.chartArea;
var opts = chart.options;
var animationOpts = opts.animation;
var centerX = (chartArea.left + chartArea.right) / 2;
var centerY = (chartArea.top + chartArea.bottom) / 2;
var startAngle = opts.rotation; // non reset case handled later
var endAngle = opts.rotation; // non reset case handled later
var dataset = me.getDataset();
var circumference = reset && animationOpts.animateRotate ? 0 : arc.hidden ? 0 : me.calculateCircumference(dataset.data[index]) * (opts.circumference / (2.0 * Math.PI));
var innerRadius = reset && animationOpts.animateScale ? 0 : me.innerRadius;
var outerRadius = reset && animationOpts.animateScale ? 0 : me.outerRadius;
var valueAtIndexOrDefault = helpers.valueAtIndexOrDefault;
helpers.extend(arc, {
_datasetIndex: me.index,
_index: index,
_model: {
x: centerX + chart.offsetX,
y: centerY + chart.offsetY,
startAngle: startAngle,
endAngle: endAngle,
circumference: circumference,
outerRadius: outerRadius,
innerRadius: innerRadius,
label: valueAtIndexOrDefault(dataset.label, index, chart.data.labels[index])
}
});
var model = arc._model;
this.removeHoverStyle(arc);
if (!reset || !animationOpts.animateRotate) {
if (index === 0) {
model.startAngle = opts.rotation;
} else {
model.startAngle = me.getMeta().data[index - 1]._model.endAngle;
}
model.endAngle = model.startAngle + model.circumference;
}
arc.pivot();
},
removeHoverStyle: function(arc) {
Chart.DatasetController.prototype.removeHoverStyle.call(this, arc, this.chart.options.elements.arc);
},
calculateTotal: function() {
var dataset = this.getDataset();
var meta = this.getMeta();
var total = 0;
var value;
helpers.each(meta.data, function(element, index) {
value = dataset.data[index];
if (!isNaN(value) && !element.hidden) {
total += Math.abs(value);
}
});
return total;
},
calculateCircumference: function(value) {
var total = this.getMeta().total;
if (total > 0 && !isNaN(value)) {
return (Math.PI * 2.0) * (value / total);
}
return 0;
},
getMaxBorderWidth: function(arcs) {
var max = 0;
var index = this.index;
var length = arcs.length;
var borderWidth;
var hoverWidth;
for (var i = 0; i < length; i++) {
borderWidth = arcs[i]._model ? arcs[i]._model.borderWidth : 0;
hoverWidth = arcs[i]._chart ? arcs[i]._chart.config.data.datasets[index].hoverBorderWidth : 0;
max = borderWidth > max ? borderWidth : max;
max = hoverWidth > max ? hoverWidth : max;
}
return max;
}
});
};
},{"25":25,"40":40,"45":45}],18:[function(require,module,exports){
'use strict';
var defaults = require(25);
var elements = require(40);
var helpers = require(45);
defaults._set('line', {
showLines: true,
spanGaps: false,
hover: {
mode: 'label'
},
scales: {
xAxes: [{
type: 'category',
id: 'x-axis-0'
}],
yAxes: [{
type: 'linear',
id: 'y-axis-0'
}]
}
});
module.exports = function(Chart) {
function lineEnabled(dataset, options) {
return helpers.valueOrDefault(dataset.showLine, options.showLines);
}
Chart.controllers.line = Chart.DatasetController.extend({
datasetElementType: elements.Line,
dataElementType: elements.Point,
update: function(reset) {
var me = this;
var meta = me.getMeta();
var line = meta.dataset;
var points = meta.data || [];
var options = me.chart.options;
var lineElementOptions = options.elements.line;
var scale = me.getScaleForId(meta.yAxisID);
var i, ilen, custom;
var dataset = me.getDataset();
var showLine = lineEnabled(dataset, options);
if (showLine) {
custom = line.custom || {};
if ((dataset.tension !== undefined) && (dataset.lineTension === undefined)) {
dataset.lineTension = dataset.tension;
}
line._scale = scale;
line._datasetIndex = me.index;
line._children = points;
line._model = {
spanGaps: dataset.spanGaps ? dataset.spanGaps : options.spanGaps,
tension: custom.tension ? custom.tension : helpers.valueOrDefault(dataset.lineTension, lineElementOptions.tension),
backgroundColor: custom.backgroundColor ? custom.backgroundColor : (dataset.backgroundColor || lineElementOptions.backgroundColor),
borderWidth: custom.borderWidth ? custom.borderWidth : (dataset.borderWidth || lineElementOptions.borderWidth),
borderColor: custom.borderColor ? custom.borderColor : (dataset.borderColor || lineElementOptions.borderColor),
borderCapStyle: custom.borderCapStyle ? custom.borderCapStyle : (dataset.borderCapStyle || lineElementOptions.borderCapStyle),
borderDash: custom.borderDash ? custom.borderDash : (dataset.borderDash || lineElementOptions.borderDash),
borderDashOffset: custom.borderDashOffset ? custom.borderDashOffset : (dataset.borderDashOffset || lineElementOptions.borderDashOffset),
borderJoinStyle: custom.borderJoinStyle ? custom.borderJoinStyle : (dataset.borderJoinStyle || lineElementOptions.borderJoinStyle),
fill: custom.fill ? custom.fill : (dataset.fill !== undefined ? dataset.fill : lineElementOptions.fill),
steppedLine: custom.steppedLine ? custom.steppedLine : helpers.valueOrDefault(dataset.steppedLine, lineElementOptions.stepped),
cubicInterpolationMode: custom.cubicInterpolationMode ? custom.cubicInterpolationMode : helpers.valueOrDefault(dataset.cubicInterpolationMode, lineElementOptions.cubicInterpolationMode),
};
line.pivot();
}
for (i = 0, ilen = points.length; i < ilen; ++i) {
me.updateElement(points[i], i, reset);
}
if (showLine && line._model.tension !== 0) {
me.updateBezierControlPoints();
}
for (i = 0, ilen = points.length; i < ilen; ++i) {
points[i].pivot();
}
},
getPointBackgroundColor: function(point, index) {
var backgroundColor = this.chart.options.elements.point.backgroundColor;
var dataset = this.getDataset();
var custom = point.custom || {};
if (custom.backgroundColor) {
backgroundColor = custom.backgroundColor;
} else if (dataset.pointBackgroundColor) {
backgroundColor = helpers.valueAtIndexOrDefault(dataset.pointBackgroundColor, index, backgroundColor);
} else if (dataset.backgroundColor) {
backgroundColor = dataset.backgroundColor;
}
return backgroundColor;
},
getPointBorderColor: function(point, index) {
var borderColor = this.chart.options.elements.point.borderColor;
var dataset = this.getDataset();
var custom = point.custom || {};
if (custom.borderColor) {
borderColor = custom.borderColor;
} else if (dataset.pointBorderColor) {
borderColor = helpers.valueAtIndexOrDefault(dataset.pointBorderColor, index, borderColor);
} else if (dataset.borderColor) {
borderColor = dataset.borderColor;
}
return borderColor;
},
getPointBorderWidth: function(point, index) {
var borderWidth = this.chart.options.elements.point.borderWidth;
var dataset = this.getDataset();
var custom = point.custom || {};
if (!isNaN(custom.borderWidth)) {
borderWidth = custom.borderWidth;
} else if (!isNaN(dataset.pointBorderWidth) || helpers.isArray(dataset.pointBorderWidth)) {
borderWidth = helpers.valueAtIndexOrDefault(dataset.pointBorderWidth, index, borderWidth);
} else if (!isNaN(dataset.borderWidth)) {
borderWidth = dataset.borderWidth;
}
return borderWidth;
},
updateElement: function(point, index, reset) {
var me = this;
var meta = me.getMeta();
var custom = point.custom || {};
var dataset = me.getDataset();
var datasetIndex = me.index;
var value = dataset.data[index];
var yScale = me.getScaleForId(meta.yAxisID);
var xScale = me.getScaleForId(meta.xAxisID);
var pointOptions = me.chart.options.elements.point;
var x, y;
if ((dataset.radius !== undefined) && (dataset.pointRadius === undefined)) {
dataset.pointRadius = dataset.radius;
}
if ((dataset.hitRadius !== undefined) && (dataset.pointHitRadius === undefined)) {
dataset.pointHitRadius = dataset.hitRadius;
}
x = xScale.getPixelForValue(typeof value === 'object' ? value : NaN, index, datasetIndex);
y = reset ? yScale.getBasePixel() : me.calculatePointY(value, index, datasetIndex);
point._xScale = xScale;
point._yScale = yScale;
point._datasetIndex = datasetIndex;
point._index = index;
point._model = {
x: x,
y: y,
skip: custom.skip || isNaN(x) || isNaN(y),
radius: custom.radius || helpers.valueAtIndexOrDefault(dataset.pointRadius, index, pointOptions.radius),
pointStyle: custom.pointStyle || helpers.valueAtIndexOrDefault(dataset.pointStyle, index, pointOptions.pointStyle),
backgroundColor: me.getPointBackgroundColor(point, index),
borderColor: me.getPointBorderColor(point, index),
borderWidth: me.getPointBorderWidth(point, index),
tension: meta.dataset._model ? meta.dataset._model.tension : 0,
steppedLine: meta.dataset._model ? meta.dataset._model.steppedLine : false,
hitRadius: custom.hitRadius || helpers.valueAtIndexOrDefault(dataset.pointHitRadius, index, pointOptions.hitRadius)
};
},
calculatePointY: function(value, index, datasetIndex) {
var me = this;
var chart = me.chart;
var meta = me.getMeta();
var yScale = me.getScaleForId(meta.yAxisID);
var sumPos = 0;
var sumNeg = 0;
var i, ds, dsMeta;
if (yScale.options.stacked) {
for (i = 0; i < datasetIndex; i++) {
ds = chart.data.datasets[i];
dsMeta = chart.getDatasetMeta(i);
if (dsMeta.type === 'line' && dsMeta.yAxisID === yScale.id && chart.isDatasetVisible(i)) {
var stackedRightValue = Number(yScale.getRightValue(ds.data[index]));
if (stackedRightValue < 0) {
sumNeg += stackedRightValue || 0;
} else {
sumPos += stackedRightValue || 0;
}
}
}
var rightValue = Number(yScale.getRightValue(value));
if (rightValue < 0) {
return yScale.getPixelForValue(sumNeg + rightValue);
}
return yScale.getPixelForValue(sumPos + rightValue);
}
return yScale.getPixelForValue(value);
},
updateBezierControlPoints: function() {
var me = this;
var meta = me.getMeta();
var area = me.chart.chartArea;
var points = (meta.data || []);
var i, ilen, point, model, controlPoints;
if (meta.dataset._model.spanGaps) {
points = points.filter(function(pt) {
return !pt._model.skip;
});
}
function capControlPoint(pt, min, max) {
return Math.max(Math.min(pt, max), min);
}
if (meta.dataset._model.cubicInterpolationMode === 'monotone') {
helpers.splineCurveMonotone(points);
} else {
for (i = 0, ilen = points.length; i < ilen; ++i) {
point = points[i];
model = point._model;
controlPoints = helpers.splineCurve(
helpers.previousItem(points, i)._model,
model,
helpers.nextItem(points, i)._model,
meta.dataset._model.tension
);
model.controlPointPreviousX = controlPoints.previous.x;
model.controlPointPreviousY = controlPoints.previous.y;
model.controlPointNextX = controlPoints.next.x;
model.controlPointNextY = controlPoints.next.y;
}
}
if (me.chart.options.elements.line.capBezierPoints) {
for (i = 0, ilen = points.length; i < ilen; ++i) {
model = points[i]._model;
model.controlPointPreviousX = capControlPoint(model.controlPointPreviousX, area.left, area.right);
model.controlPointPreviousY = capControlPoint(model.controlPointPreviousY, area.top, area.bottom);
model.controlPointNextX = capControlPoint(model.controlPointNextX, area.left, area.right);
model.controlPointNextY = capControlPoint(model.controlPointNextY, area.top, area.bottom);
}
}
},
draw: function() {
var me = this;
var chart = me.chart;
var meta = me.getMeta();
var points = meta.data || [];
var area = chart.chartArea;
var ilen = points.length;
var i = 0;
helpers.canvas.clipArea(chart.ctx, area);
if (lineEnabled(me.getDataset(), chart.options)) {
meta.dataset.draw();
}
helpers.canvas.unclipArea(chart.ctx);
for (; i < ilen; ++i) {
points[i].draw(area);
}
},
setHoverStyle: function(point) {
var dataset = this.chart.data.datasets[point._datasetIndex];
var index = point._index;
var custom = point.custom || {};
var model = point._model;
model.radius = custom.hoverRadius || helpers.valueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);
model.backgroundColor = custom.hoverBackgroundColor || helpers.valueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));
model.borderColor = custom.hoverBorderColor || helpers.valueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(model.borderColor));
model.borderWidth = custom.hoverBorderWidth || helpers.valueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, model.borderWidth);
},
removeHoverStyle: function(point) {
var me = this;
var dataset = me.chart.data.datasets[point._datasetIndex];
var index = point._index;
var custom = point.custom || {};
var model = point._model;
if ((dataset.radius !== undefined) && (dataset.pointRadius === undefined)) {
dataset.pointRadius = dataset.radius;
}
model.radius = custom.radius || helpers.valueAtIndexOrDefault(dataset.pointRadius, index, me.chart.options.elements.point.radius);
model.backgroundColor = me.getPointBackgroundColor(point, index);
model.borderColor = me.getPointBorderColor(point, index);
model.borderWidth = me.getPointBorderWidth(point, index);
}
});
};
},{"25":25,"40":40,"45":45}],19:[function(require,module,exports){
'use strict';
var defaults = require(25);
var elements = require(40);
var helpers = require(45);
defaults._set('polarArea', {
scale: {
type: 'radialLinear',
angleLines: {
display: false
},
gridLines: {
circular: true
},
pointLabels: {
display: false
},
ticks: {
beginAtZero: true
}
},
animation: {
animateRotate: true,
animateScale: true
},
startAngle: -0.5 * Math.PI,
legendCallback: function(chart) {
var text = [];
text.push('<ul class="' + chart.id + '-legend">');
var data = chart.data;
var datasets = data.datasets;
var labels = data.labels;
if (datasets.length) {
for (var i = 0; i < datasets[0].data.length; ++i) {
text.push('<li><span style="background-color:' + datasets[0].backgroundColor[i] + '"></span>');
if (labels[i]) {
text.push(labels[i]);
}
text.push('</li>');
}
}
text.push('</ul>');
return text.join('');
},
legend: {
labels: {
generateLabels: function(chart) {
var data = chart.data;
if (data.labels.length && data.datasets.length) {
return data.labels.map(function(label, i) {
var meta = chart.getDatasetMeta(0);
var ds = data.datasets[0];
var arc = meta.data[i];
var custom = arc.custom || {};
var valueAtIndexOrDefault = helpers.valueAtIndexOrDefault;
var arcOpts = chart.options.elements.arc;
var fill = custom.backgroundColor ? custom.backgroundColor : valueAtIndexOrDefault(ds.backgroundColor, i, arcOpts.backgroundColor);
var stroke = custom.borderColor ? custom.borderColor : valueAtIndexOrDefault(ds.borderColor, i, arcOpts.borderColor);
var bw = custom.borderWidth ? custom.borderWidth : valueAtIndexOrDefault(ds.borderWidth, i, arcOpts.borderWidth);
return {
text: label,
fillStyle: fill,
strokeStyle: stroke,
lineWidth: bw,
hidden: isNaN(ds.data[i]) || meta.data[i].hidden,
index: i
};
});
}
return [];
}
},
onClick: function(e, legendItem) {
var index = legendItem.index;
var chart = this.chart;
var i, ilen, meta;
for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
meta = chart.getDatasetMeta(i);
meta.data[index].hidden = !meta.data[index].hidden;
}
chart.update();
}
},
tooltips: {
callbacks: {
title: function() {
return '';
},
label: function(item, data) {
return data.labels[item.index] + ': ' + item.yLabel;
}
}
}
});
module.exports = function(Chart) {
Chart.controllers.polarArea = Chart.DatasetController.extend({
dataElementType: elements.Arc,
linkScales: helpers.noop,
update: function(reset) {
var me = this;
var chart = me.chart;
var chartArea = chart.chartArea;
var meta = me.getMeta();
var opts = chart.options;
var arcOpts = opts.elements.arc;
var minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
chart.outerRadius = Math.max((minSize - arcOpts.borderWidth / 2) / 2, 0);
chart.innerRadius = Math.max(opts.cutoutPercentage ? (chart.outerRadius / 100) * (opts.cutoutPercentage) : 1, 0);
chart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();
me.outerRadius = chart.outerRadius - (chart.radiusLength * me.index);
me.innerRadius = me.outerRadius - chart.radiusLength;
meta.count = me.countVisibleElements();
helpers.each(meta.data, function(arc, index) {
me.updateElement(arc, index, reset);
});
},
updateElement: function(arc, index, reset) {
var me = this;
var chart = me.chart;
var dataset = me.getDataset();
var opts = chart.options;
var animationOpts = opts.animation;
var scale = chart.scale;
var labels = chart.data.labels;
var circumference = me.calculateCircumference(dataset.data[index]);
var centerX = scale.xCenter;
var centerY = scale.yCenter;
var visibleCount = 0;
var meta = me.getMeta();
for (var i = 0; i < index; ++i) {
if (!isNaN(dataset.data[i]) && !meta.data[i].hidden) {
++visibleCount;
}
}
var datasetStartAngle = opts.startAngle;
var distance = arc.hidden ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);
var startAngle = datasetStartAngle + (circumference * visibleCount);
var endAngle = startAngle + (arc.hidden ? 0 : circumference);
var resetRadius = animationOpts.animateScale ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);
helpers.extend(arc, {
_datasetIndex: me.index,
_index: index,
_scale: scale,
_model: {
x: centerX,
y: centerY,
innerRadius: 0,
outerRadius: reset ? resetRadius : distance,
startAngle: reset && animationOpts.animateRotate ? datasetStartAngle : startAngle,
endAngle: reset && animationOpts.animateRotate ? datasetStartAngle : endAngle,
label: helpers.valueAtIndexOrDefault(labels, index, labels[index])
}
});
me.removeHoverStyle(arc);
arc.pivot();
},
removeHoverStyle: function(arc) {
Chart.DatasetController.prototype.removeHoverStyle.call(this, arc, this.chart.options.elements.arc);
},
countVisibleElements: function() {
var dataset = this.getDataset();
var meta = this.getMeta();
var count = 0;
helpers.each(meta.data, function(element, index) {
if (!isNaN(dataset.data[index]) && !element.hidden) {
count++;
}
});
return count;
},
calculateCircumference: function(value) {
var count = this.getMeta().count;
if (count > 0 && !isNaN(value)) {
return (2 * Math.PI) / count;
}
return 0;
}
});
};
},{"25":25,"40":40,"45":45}],20:[function(require,module,exports){
'use strict';
var defaults = require(25);
var elements = require(40);
var helpers = require(45);
defaults._set('radar', {
scale: {
type: 'radialLinear'
},
elements: {
line: {
tension: 0 // no bezier in radar
}
}
});
module.exports = function(Chart) {
Chart.controllers.radar = Chart.DatasetController.extend({
datasetElementType: elements.Line,
dataElementType: elements.Point,
linkScales: helpers.noop,
update: function(reset) {
var me = this;
var meta = me.getMeta();
var line = meta.dataset;
var points = meta.data;
var custom = line.custom || {};
var dataset = me.getDataset();
var lineElementOptions = me.chart.options.elements.line;
var scale = me.chart.scale;
if ((dataset.tension !== undefined) && (dataset.lineTension === undefined)) {
dataset.lineTension = dataset.tension;
}
helpers.extend(meta.dataset, {
_datasetIndex: me.index,
_scale: scale,
_children: points,
_loop: true,
_model: {
tension: custom.tension ? custom.tension : helpers.valueOrDefault(dataset.lineTension, lineElementOptions.tension),
backgroundColor: custom.backgroundColor ? custom.backgroundColor : (dataset.backgroundColor || lineElementOptions.backgroundColor),
borderWidth: custom.borderWidth ? custom.borderWidth : (dataset.borderWidth || lineElementOptions.borderWidth),
borderColor: custom.borderColor ? custom.borderColor : (dataset.borderColor || lineElementOptions.borderColor),
fill: custom.fill ? custom.fill : (dataset.fill !== undefined ? dataset.fill : lineElementOptions.fill),
borderCapStyle: custom.borderCapStyle ? custom.borderCapStyle : (dataset.borderCapStyle || lineElementOptions.borderCapStyle),
borderDash: custom.borderDash ? custom.borderDash : (dataset.borderDash || lineElementOptions.borderDash),
borderDashOffset: custom.borderDashOffset ? custom.borderDashOffset : (dataset.borderDashOffset || lineElementOptions.borderDashOffset),
borderJoinStyle: custom.borderJoinStyle ? custom.borderJoinStyle : (dataset.borderJoinStyle || lineElementOptions.borderJoinStyle),
}
});
meta.dataset.pivot();
helpers.each(points, function(point, index) {
me.updateElement(point, index, reset);
}, me);
me.updateBezierControlPoints();
},
updateElement: function(point, index, reset) {
var me = this;
var custom = point.custom || {};
var dataset = me.getDataset();
var scale = me.chart.scale;
var pointElementOptions = me.chart.options.elements.point;
var pointPosition = scale.getPointPositionForValue(index, dataset.data[index]);
if ((dataset.radius !== undefined) && (dataset.pointRadius === undefined)) {
dataset.pointRadius = dataset.radius;
}
if ((dataset.hitRadius !== undefined) && (dataset.pointHitRadius === undefined)) {
dataset.pointHitRadius = dataset.hitRadius;
}
helpers.extend(point, {
_datasetIndex: me.index,
_index: index,
_scale: scale,
_model: {
x: reset ? scale.xCenter : pointPosition.x, // value not used in dataset scale, but we want a consistent API between scales
y: reset ? scale.yCenter : pointPosition.y,
tension: custom.tension ? custom.tension : helpers.valueOrDefault(dataset.lineTension, me.chart.options.elements.line.tension),
radius: custom.radius ? custom.radius : helpers.valueAtIndexOrDefault(dataset.pointRadius, index, pointElementOptions.radius),
backgroundColor: custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.pointBackgroundColor, index, pointElementOptions.backgroundColor),
borderColor: custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.pointBorderColor, index, pointElementOptions.borderColor),
borderWidth: custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.pointBorderWidth, index, pointElementOptions.borderWidth),
pointStyle: custom.pointStyle ? custom.pointStyle : helpers.valueAtIndexOrDefault(dataset.pointStyle, index, pointElementOptions.pointStyle),
hitRadius: custom.hitRadius ? custom.hitRadius : helpers.valueAtIndexOrDefault(dataset.pointHitRadius, index, pointElementOptions.hitRadius)
}
});
point._model.skip = custom.skip ? custom.skip : (isNaN(point._model.x) || isNaN(point._model.y));
},
updateBezierControlPoints: function() {
var chartArea = this.chart.chartArea;
var meta = this.getMeta();
helpers.each(meta.data, function(point, index) {
var model = point._model;
var controlPoints = helpers.splineCurve(
helpers.previousItem(meta.data, index, true)._model,
model,
helpers.nextItem(meta.data, index, true)._model,
model.tension
);
model.controlPointPreviousX = Math.max(Math.min(controlPoints.previous.x, chartArea.right), chartArea.left);
model.controlPointPreviousY = Math.max(Math.min(controlPoints.previous.y, chartArea.bottom), chartArea.top);
model.controlPointNextX = Math.max(Math.min(controlPoints.next.x, chartArea.right), chartArea.left);
model.controlPointNextY = Math.max(Math.min(controlPoints.next.y, chartArea.bottom), chartArea.top);
point.pivot();
});
},
setHoverStyle: function(point) {
var dataset = this.chart.data.datasets[point._datasetIndex];
var custom = point.custom || {};
var index = point._index;
var model = point._model;
model.radius = custom.hoverRadius ? custom.hoverRadius : helpers.valueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);
model.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : helpers.valueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));
model.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : helpers.valueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(model.borderColor));
model.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : helpers.valueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, model.borderWidth);
},
removeHoverStyle: function(point) {
var dataset = this.chart.data.datasets[point._datasetIndex];
var custom = point.custom || {};
var index = point._index;
var model = point._model;
var pointElementOptions = this.chart.options.elements.point;
model.radius = custom.radius ? custom.radius : helpers.valueAtIndexOrDefault(dataset.pointRadius, index, pointElementOptions.radius);
model.backgroundColor = custom.backgroundColor ? custom.backgroundColor : helpers.valueAtIndexOrDefault(dataset.pointBackgroundColor, index, pointElementOptions.backgroundColor);
model.borderColor = custom.borderColor ? custom.borderColor : helpers.valueAtIndexOrDefault(dataset.pointBorderColor, index, pointElementOptions.borderColor);
model.borderWidth = custom.borderWidth ? custom.borderWidth : helpers.valueAtIndexOrDefault(dataset.pointBorderWidth, index, pointElementOptions.borderWidth);
}
});
};
},{"25":25,"40":40,"45":45}],21:[function(require,module,exports){
'use strict';
var defaults = require(25);
defaults._set('scatter', {
hover: {
mode: 'single'
},
scales: {
xAxes: [{
id: 'x-axis-1',    // need an ID so datasets can reference the scale
type: 'linear',    // scatter should not use a category axis
position: 'bottom'
}],
yAxes: [{
id: 'y-axis-1',
type: 'linear',
position: 'left'
}]
},
showLines: false,
tooltips: {
callbacks: {
title: function() {
return '';     // doesn't make sense for scatter since data are formatted as a point
},
label: function(item) {
return '(' + item.xLabel + ', ' + item.yLabel + ')';
}
}
}
});
module.exports = function(Chart) {
Chart.controllers.scatter = Chart.controllers.line;
};
},{"25":25}],22:[function(require,module,exports){
'use strict';
var defaults = require(25);
var Element = require(26);
var helpers = require(45);
defaults._set('global', {
animation: {
duration: 1000,
easing: 'easeOutQuart',
onProgress: helpers.noop,
onComplete: helpers.noop
}
});
module.exports = function(Chart) {
Chart.Animation = Element.extend({
chart: null, // the animation associated chart instance
currentStep: 0, // the current animation step
numSteps: 60, // default number of steps
easing: '', // the easing to use for this animation
render: null, // render function used by the animation service
onAnimationProgress: null, // user specified callback to fire on each step of the animation
onAnimationComplete: null, // user specified callback to fire when the animation finishes
});
Chart.animationService = {
frameDuration: 17,
animations: [],
dropFrames: 0,
request: null,
addAnimation: function(chart, animation, duration, lazy) {
var animations = this.animations;
var i, ilen;
animation.chart = chart;
if (!lazy) {
chart.animating = true;
}
for (i = 0, ilen = animations.length; i < ilen; ++i) {
if (animations[i].chart === chart) {
animations[i] = animation;
return;
}
}
animations.push(animation);
if (animations.length === 1) {
this.requestAnimationFrame();
}
},
cancelAnimation: function(chart) {
var index = helpers.findIndex(this.animations, function(animation) {
return animation.chart === chart;
});
if (index !== -1) {
this.animations.splice(index, 1);
chart.animating = false;
}
},
requestAnimationFrame: function() {
var me = this;
if (me.request === null) {
me.request = helpers.requestAnimFrame.call(window, function() {
me.request = null;
me.startDigest();
});
}
},
startDigest: function() {
var me = this;
var startTime = Date.now();
var framesToDrop = 0;
if (me.dropFrames > 1) {
framesToDrop = Math.floor(me.dropFrames);
me.dropFrames = me.dropFrames % 1;
}
me.advance(1 + framesToDrop);
var endTime = Date.now();
me.dropFrames += (endTime - startTime) / me.frameDuration;
if (me.animations.length > 0) {
me.requestAnimationFrame();
}
},
advance: function(count) {
var animations = this.animations;
var animation, chart;
var i = 0;
while (i < animations.length) {
animation = animations[i];
chart = animation.chart;
animation.currentStep = (animation.currentStep || 0) + count;
animation.currentStep = Math.min(animation.currentStep, animation.numSteps);
helpers.callback(animation.render, [chart, animation], chart);
helpers.callback(animation.onAnimationProgress, [animation], chart);
if (animation.currentStep >= animation.numSteps) {
helpers.callback(animation.onAnimationComplete, [animation], chart);
chart.animating = false;
animations.splice(i, 1);
} else {
++i;
}
}
}
};
Object.defineProperty(Chart.Animation.prototype, 'animationObject', {
get: function() {
return this;
}
});
Object.defineProperty(Chart.Animation.prototype, 'chartInstance', {
get: function() {
return this.chart;
},
set: function(value) {
this.chart = value;
}
});
};
},{"25":25,"26":26,"45":45}],23:[function(require,module,exports){
'use strict';
var defaults = require(25);
var helpers = require(45);
var Interaction = require(28);
var platform = require(48);
module.exports = function(Chart) {
var plugins = Chart.plugins;
Chart.types = {};
Chart.instances = {};
Chart.controllers = {};
function initConfig(config) {
config = config || {};
var data = config.data = config.data || {};
data.datasets = data.datasets || [];
data.labels = data.labels || [];
config.options = helpers.configMerge(
defaults.global,
defaults[config.type],
config.options || {});
return config;
}
function updateConfig(chart) {
var newOptions = chart.options;
if (newOptions.scale) {
chart.scale.options = newOptions.scale;
} else if (newOptions.scales) {
newOptions.scales.xAxes.concat(newOptions.scales.yAxes).forEach(function(scaleOptions) {
chart.scales[scaleOptions.id].options = scaleOptions;
});
}
chart.tooltip._options = newOptions.tooltips;
}
function positionIsHorizontal(position) {
return position === 'top' || position === 'bottom';
}
helpers.extend(Chart.prototype, {
construct: function(item, config) {
var me = this;
config = initConfig(config);
var context = platform.acquireContext(item, config);
var canvas = context && context.canvas;
var height = canvas && canvas.height;
var width = canvas && canvas.width;
me.id = helpers.uid();
me.ctx = context;
me.canvas = canvas;
me.config = config;
me.width = width;
me.height = height;
me.aspectRatio = height ? width / height : null;
me.options = config.options;
me._bufferedRender = false;
me.chart = me;
me.controller = me; // chart.chart.controller #inception
Chart.instances[me.id] = me;
Object.defineProperty(me, 'data', {
get: function() {
return me.config.data;
},
set: function(value) {
me.config.data = value;
}
});
if (!context || !canvas) {
console.error("Failed to create chart: can't acquire context from the given item");
return;
}
me.initialize();
me.update();
},
initialize: function() {
var me = this;
plugins.notify(me, 'beforeInit');
helpers.retinaScale(me, me.options.devicePixelRatio);
me.bindEvents();
if (me.options.responsive) {
me.resize(true);
}
me.ensureScalesHaveIDs();
me.buildScales();
me.initToolTip();
plugins.notify(me, 'afterInit');
return me;
},
clear: function() {
helpers.canvas.clear(this);
return this;
},
stop: function() {
Chart.animationService.cancelAnimation(this);
return this;
},
resize: function(silent) {
var me = this;
var options = me.options;
var canvas = me.canvas;
var aspectRatio = (options.maintainAspectRatio && me.aspectRatio) || null;
var newWidth = Math.max(0, Math.floor(helpers.getMaximumWidth(canvas)));
var newHeight = Math.max(0, Math.floor(aspectRatio ? newWidth / aspectRatio : helpers.getMaximumHeight(canvas)));
if (me.width === newWidth && me.height === newHeight) {
return;
}
canvas.width = me.width = newWidth;
canvas.height = me.height = newHeight;
canvas.style.width = newWidth + 'px';
canvas.style.height = newHeight + 'px';
helpers.retinaScale(me, options.devicePixelRatio);
if (!silent) {
var newSize = {width: newWidth, height: newHeight};
plugins.notify(me, 'resize', [newSize]);
if (me.options.onResize) {
me.options.onResize(me, newSize);
}
me.stop();
me.update(me.options.responsiveAnimationDuration);
}
},
ensureScalesHaveIDs: function() {
var options = this.options;
var scalesOptions = options.scales || {};
var scaleOptions = options.scale;
helpers.each(scalesOptions.xAxes, function(xAxisOptions, index) {
xAxisOptions.id = xAxisOptions.id || ('x-axis-' + index);
});
helpers.each(scalesOptions.yAxes, function(yAxisOptions, index) {
yAxisOptions.id = yAxisOptions.id || ('y-axis-' + index);
});
if (scaleOptions) {
scaleOptions.id = scaleOptions.id || 'scale';
}
},
buildScales: function() {
var me = this;
var options = me.options;
var scales = me.scales = {};
var items = [];
if (options.scales) {
items = items.concat(
(options.scales.xAxes || []).map(function(xAxisOptions) {
return {options: xAxisOptions, dtype: 'category', dposition: 'bottom'};
}),
(options.scales.yAxes || []).map(function(yAxisOptions) {
return {options: yAxisOptions, dtype: 'linear', dposition: 'left'};
})
);
}
if (options.scale) {
items.push({
options: options.scale,
dtype: 'radialLinear',
isDefault: true,
dposition: 'chartArea'
});
}
helpers.each(items, function(item) {
var scaleOptions = item.options;
var scaleType = helpers.valueOrDefault(scaleOptions.type, item.dtype);
var scaleClass = Chart.scaleService.getScaleConstructor(scaleType);
if (!scaleClass) {
return;
}
if (positionIsHorizontal(scaleOptions.position) !== positionIsHorizontal(item.dposition)) {
scaleOptions.position = item.dposition;
}
var scale = new scaleClass({
id: scaleOptions.id,
options: scaleOptions,
ctx: me.ctx,
chart: me
});
scales[scale.id] = scale;
scale.mergeTicksOptions();
if (item.isDefault) {
me.scale = scale;
}
});
Chart.scaleService.addScalesToLayout(this);
},
buildOrUpdateControllers: function() {
var me = this;
var types = [];
var newControllers = [];
helpers.each(me.data.datasets, function(dataset, datasetIndex) {
var meta = me.getDatasetMeta(datasetIndex);
var type = dataset.type || me.config.type;
if (meta.type && meta.type !== type) {
me.destroyDatasetMeta(datasetIndex);
meta = me.getDatasetMeta(datasetIndex);
}
meta.type = type;
types.push(meta.type);
if (meta.controller) {
meta.controller.updateIndex(datasetIndex);
} else {
var ControllerClass = Chart.controllers[meta.type];
if (ControllerClass === undefined) {
throw new Error('"' + meta.type + '" is not a chart type.');
}
meta.controller = new ControllerClass(me, datasetIndex);
newControllers.push(meta.controller);
}
}, me);
return newControllers;
},
resetElements: function() {
var me = this;
helpers.each(me.data.datasets, function(dataset, datasetIndex) {
me.getDatasetMeta(datasetIndex).controller.reset();
}, me);
},
reset: function() {
this.resetElements();
this.tooltip.initialize();
},
update: function(config) {
var me = this;
if (!config || typeof config !== 'object') {
config = {
duration: config,
lazy: arguments[1]
};
}
updateConfig(me);
if (plugins.notify(me, 'beforeUpdate') === false) {
return;
}
me.tooltip._data = me.data;
var newControllers = me.buildOrUpdateControllers();
helpers.each(me.data.datasets, function(dataset, datasetIndex) {
me.getDatasetMeta(datasetIndex).controller.buildOrUpdateElements();
}, me);
me.updateLayout();
helpers.each(newControllers, function(controller) {
controller.reset();
});
me.updateDatasets();
me.tooltip.initialize();
me.lastActive = [];
plugins.notify(me, 'afterUpdate');
if (me._bufferedRender) {
me._bufferedRequest = {
duration: config.duration,
easing: config.easing,
lazy: config.lazy
};
} else {
me.render(config);
}
},
updateLayout: function() {
var me = this;
if (plugins.notify(me, 'beforeLayout') === false) {
return;
}
Chart.layoutService.update(this, this.width, this.height);
plugins.notify(me, 'afterScaleUpdate');
plugins.notify(me, 'afterLayout');
},
updateDatasets: function() {
var me = this;
if (plugins.notify(me, 'beforeDatasetsUpdate') === false) {
return;
}
for (var i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {
me.updateDataset(i);
}
plugins.notify(me, 'afterDatasetsUpdate');
},
updateDataset: function(index) {
var me = this;
var meta = me.getDatasetMeta(index);
var args = {
meta: meta,
index: index
};
if (plugins.notify(me, 'beforeDatasetUpdate', [args]) === false) {
return;
}
meta.controller.update();
plugins.notify(me, 'afterDatasetUpdate', [args]);
},
render: function(config) {
var me = this;
if (!config || typeof config !== 'object') {
config = {
duration: config,
lazy: arguments[1]
};
}
var duration = config.duration;
var lazy = config.lazy;
if (plugins.notify(me, 'beforeRender') === false) {
return;
}
var animationOptions = me.options.animation;
var onComplete = function(animation) {
plugins.notify(me, 'afterRender');
helpers.callback(animationOptions && animationOptions.onComplete, [animation], me);
};
if (animationOptions && ((typeof duration !== 'undefined' && duration !== 0) || (typeof duration === 'undefined' && animationOptions.duration !== 0))) {
var animation = new Chart.Animation({
numSteps: (duration || animationOptions.duration) / 16.66, // 60 fps
easing: config.easing || animationOptions.easing,
render: function(chart, animationObject) {
var easingFunction = helpers.easing.effects[animationObject.easing];
var currentStep = animationObject.currentStep;
var stepDecimal = currentStep / animationObject.numSteps;
chart.draw(easingFunction(stepDecimal), stepDecimal, currentStep);
},
onAnimationProgress: animationOptions.onProgress,
onAnimationComplete: onComplete
});
Chart.animationService.addAnimation(me, animation, duration, lazy);
} else {
me.draw();
onComplete(new Chart.Animation({numSteps: 0, chart: me}));
}
return me;
},
draw: function(easingValue) {
var me = this;
me.clear();
if (helpers.isNullOrUndef(easingValue)) {
easingValue = 1;
}
me.transition(easingValue);
if (plugins.notify(me, 'beforeDraw', [easingValue]) === false) {
return;
}
helpers.each(me.boxes, function(box) {
box.draw(me.chartArea);
}, me);
if (me.scale) {
me.scale.draw();
}
me.drawDatasets(easingValue);
me._drawTooltip(easingValue);
plugins.notify(me, 'afterDraw', [easingValue]);
},
transition: function(easingValue) {
var me = this;
for (var i = 0, ilen = (me.data.datasets || []).length; i < ilen; ++i) {
if (me.isDatasetVisible(i)) {
me.getDatasetMeta(i).controller.transition(easingValue);
}
}
me.tooltip.transition(easingValue);
},
drawDatasets: function(easingValue) {
var me = this;
if (plugins.notify(me, 'beforeDatasetsDraw', [easingValue]) === false) {
return;
}
for (var i = (me.data.datasets || []).length - 1; i >= 0; --i) {
if (me.isDatasetVisible(i)) {
me.drawDataset(i, easingValue);
}
}
plugins.notify(me, 'afterDatasetsDraw', [easingValue]);
},
drawDataset: function(index, easingValue) {
var me = this;
var meta = me.getDatasetMeta(index);
var args = {
meta: meta,
index: index,
easingValue: easingValue
};
if (plugins.notify(me, 'beforeDatasetDraw', [args]) === false) {
return;
}
meta.controller.draw(easingValue);
plugins.notify(me, 'afterDatasetDraw', [args]);
},
_drawTooltip: function(easingValue) {
var me = this;
var tooltip = me.tooltip;
var args = {
tooltip: tooltip,
easingValue: easingValue
};
if (plugins.notify(me, 'beforeTooltipDraw', [args]) === false) {
return;
}
tooltip.draw();
plugins.notify(me, 'afterTooltipDraw', [args]);
},
getElementAtEvent: function(e) {
return Interaction.modes.single(this, e);
},
getElementsAtEvent: function(e) {
return Interaction.modes.label(this, e, {intersect: true});
},
getElementsAtXAxis: function(e) {
return Interaction.modes['x-axis'](this, e, {intersect: true});
},
getElementsAtEventForMode: function(e, mode, options) {
var method = Interaction.modes[mode];
if (typeof method === 'function') {
return method(this, e, options);
}
return [];
},
getDatasetAtEvent: function(e) {
return Interaction.modes.dataset(this, e, {intersect: true});
},
getDatasetMeta: function(datasetIndex) {
var me = this;
var dataset = me.data.datasets[datasetIndex];
if (!dataset._meta) {
dataset._meta = {};
}
var meta = dataset._meta[me.id];
if (!meta) {
meta = dataset._meta[me.id] = {
type: null,
data: [],
dataset: null,
controller: null,
hidden: null,			// See isDatasetVisible() comment
xAxisID: null,
yAxisID: null
};
}
return meta;
},
getVisibleDatasetCount: function() {
var count = 0;
for (var i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
if (this.isDatasetVisible(i)) {
count++;
}
}
return count;
},
isDatasetVisible: function(datasetIndex) {
var meta = this.getDatasetMeta(datasetIndex);
return typeof meta.hidden === 'boolean' ? !meta.hidden : !this.data.datasets[datasetIndex].hidden;
},
generateLegend: function() {
return this.options.legendCallback(this);
},
destroyDatasetMeta: function(datasetIndex) {
var id = this.id;
var dataset = this.data.datasets[datasetIndex];
var meta = dataset._meta && dataset._meta[id];
if (meta) {
meta.controller.destroy();
delete dataset._meta[id];
}
},
destroy: function() {
var me = this;
var canvas = me.canvas;
var i, ilen;
me.stop();
for (i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {
me.destroyDatasetMeta(i);
}
if (canvas) {
me.unbindEvents();
helpers.canvas.clear(me);
platform.releaseContext(me.ctx);
me.canvas = null;
me.ctx = null;
}
plugins.notify(me, 'destroy');
delete Chart.instances[me.id];
},
toBase64Image: function() {
return this.canvas.toDataURL.apply(this.canvas, arguments);
},
initToolTip: function() {
var me = this;
me.tooltip = new Chart.Tooltip({
_chart: me,
_chartInstance: me, // deprecated, backward compatibility
_data: me.data,
_options: me.options.tooltips
}, me);
},
bindEvents: function() {
var me = this;
var listeners = me._listeners = {};
var listener = function() {
me.eventHandler.apply(me, arguments);
};
helpers.each(me.options.events, function(type) {
platform.addEventListener(me, type, listener);
listeners[type] = listener;
});
if (me.options.responsive) {
listener = function() {
me.resize();
};
platform.addEventListener(me, 'resize', listener);
listeners.resize = listener;
}
},
unbindEvents: function() {
var me = this;
var listeners = me._listeners;
if (!listeners) {
return;
}
delete me._listeners;
helpers.each(listeners, function(listener, type) {
platform.removeEventListener(me, type, listener);
});
},
updateHoverStyle: function(elements, mode, enabled) {
var method = enabled ? 'setHoverStyle' : 'removeHoverStyle';
var element, i, ilen;
for (i = 0, ilen = elements.length; i < ilen; ++i) {
element = elements[i];
if (element) {
this.getDatasetMeta(element._datasetIndex).controller[method](element);
}
}
},
eventHandler: function(e) {
var me = this;
var tooltip = me.tooltip;
if (plugins.notify(me, 'beforeEvent', [e]) === false) {
return;
}
me._bufferedRender = true;
me._bufferedRequest = null;
var changed = me.handleEvent(e);
changed |= tooltip && tooltip.handleEvent(e);
plugins.notify(me, 'afterEvent', [e]);
var bufferedRequest = me._bufferedRequest;
if (bufferedRequest) {
me.render(bufferedRequest);
} else if (changed && !me.animating) {
me.stop();
me.render(me.options.hover.animationDuration, true);
}
me._bufferedRender = false;
me._bufferedRequest = null;
return me;
},
handleEvent: function(e) {
var me = this;
var options = me.options || {};
var hoverOptions = options.hover;
var changed = false;
me.lastActive = me.lastActive || [];
if (e.type === 'mouseout') {
me.active = [];
} else {
me.active = me.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions);
}
helpers.callback(options.onHover || options.hover.onHover, [e.native, me.active], me);
if (e.type === 'mouseup' || e.type === 'click') {
if (options.onClick) {
options.onClick.call(me, e.native, me.active);
}
}
if (me.lastActive.length) {
me.updateHoverStyle(me.lastActive, hoverOptions.mode, false);
}
if (me.active.length && hoverOptions.mode) {
me.updateHoverStyle(me.active, hoverOptions.mode, true);
}
changed = !helpers.arrayEquals(me.active, me.lastActive);
me.lastActive = me.active;
return changed;
}
});
Chart.Controller = Chart;
};
},{"25":25,"28":28,"45":45,"48":48}],24:[function(require,module,exports){
'use strict';
var helpers = require(45);
module.exports = function(Chart) {
var arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'];
function listenArrayEvents(array, listener) {
if (array._chartjs) {
array._chartjs.listeners.push(listener);
return;
}
Object.defineProperty(array, '_chartjs', {
configurable: true,
enumerable: false,
value: {
listeners: [listener]
}
});
arrayEvents.forEach(function(key) {
var method = 'onData' + key.charAt(0).toUpperCase() + key.slice(1);
var base = array[key];
Object.defineProperty(array, key, {
configurable: true,
enumerable: false,
value: function() {
var args = Array.prototype.slice.call(arguments);
var res = base.apply(this, args);
helpers.each(array._chartjs.listeners, function(object) {
if (typeof object[method] === 'function') {
object[method].apply(object, args);
}
});
return res;
}
});
});
}
function unlistenArrayEvents(array, listener) {
var stub = array._chartjs;
if (!stub) {
return;
}
var listeners = stub.listeners;
var index = listeners.indexOf(listener);
if (index !== -1) {
listeners.splice(index, 1);
}
if (listeners.length > 0) {
return;
}
arrayEvents.forEach(function(key) {
delete array[key];
});
delete array._chartjs;
}
Chart.DatasetController = function(chart, datasetIndex) {
this.initialize(chart, datasetIndex);
};
helpers.extend(Chart.DatasetController.prototype, {
datasetElementType: null,
dataElementType: null,
initialize: function(chart, datasetIndex) {
var me = this;
me.chart = chart;
me.index = datasetIndex;
me.linkScales();
me.addElements();
},
updateIndex: function(datasetIndex) {
this.index = datasetIndex;
},
linkScales: function() {
var me = this;
var meta = me.getMeta();
var dataset = me.getDataset();
if (meta.xAxisID === null) {
meta.xAxisID = dataset.xAxisID || me.chart.options.scales.xAxes[0].id;
}
if (meta.yAxisID === null) {
meta.yAxisID = dataset.yAxisID || me.chart.options.scales.yAxes[0].id;
}
},
getDataset: function() {
return this.chart.data.datasets[this.index];
},
getMeta: function() {
return this.chart.getDatasetMeta(this.index);
},
getScaleForId: function(scaleID) {
return this.chart.scales[scaleID];
},
reset: function() {
this.update(true);
},
destroy: function() {
if (this._data) {
unlistenArrayEvents(this._data, this);
}
},
createMetaDataset: function() {
var me = this;
var type = me.datasetElementType;
return type && new type({
_chart: me.chart,
_datasetIndex: me.index
});
},
createMetaData: function(index) {
var me = this;
var type = me.dataElementType;
return type && new type({
_chart: me.chart,
_datasetIndex: me.index,
_index: index
});
},
addElements: function() {
var me = this;
var meta = me.getMeta();
var data = me.getDataset().data || [];
var metaData = meta.data;
var i, ilen;
for (i = 0, ilen = data.length; i < ilen; ++i) {
metaData[i] = metaData[i] || me.createMetaData(i);
}
meta.dataset = meta.dataset || me.createMetaDataset();
},
addElementAndReset: function(index) {
var element = this.createMetaData(index);
this.getMeta().data.splice(index, 0, element);
this.updateElement(element, index, true);
},
buildOrUpdateElements: function() {
var me = this;
var dataset = me.getDataset();
var data = dataset.data || (dataset.data = []);
if (me._data !== data) {
if (me._data) {
unlistenArrayEvents(me._data, me);
}
listenArrayEvents(data, me);
me._data = data;
}
me.resyncElements();
},
update: helpers.noop,
transition: function(easingValue) {
var meta = this.getMeta();
var elements = meta.data || [];
var ilen = elements.length;
var i = 0;
for (; i < ilen; ++i) {
elements[i].transition(easingValue);
}
if (meta.dataset) {
meta.dataset.transition(easingValue);
}
},
draw: function() {
var meta = this.getMeta();
var elements = meta.data || [];
var ilen = elements.length;
var i = 0;
if (meta.dataset) {
meta.dataset.draw();
}
for (; i < ilen; ++i) {
elements[i].draw();
}
},
removeHoverStyle: function(element, elementOpts) {
var dataset = this.chart.data.datasets[element._datasetIndex];
var index = element._index;
var custom = element.custom || {};
var valueOrDefault = helpers.valueAtIndexOrDefault;
var model = element._model;
model.backgroundColor = custom.backgroundColor ? custom.backgroundColor : valueOrDefault(dataset.backgroundColor, index, elementOpts.backgroundColor);
model.borderColor = custom.borderColor ? custom.borderColor : valueOrDefault(dataset.borderColor, index, elementOpts.borderColor);
model.borderWidth = custom.borderWidth ? custom.borderWidth : valueOrDefault(dataset.borderWidth, index, elementOpts.borderWidth);
},
setHoverStyle: function(element) {
var dataset = this.chart.data.datasets[element._datasetIndex];
var index = element._index;
var custom = element.custom || {};
var valueOrDefault = helpers.valueAtIndexOrDefault;
var getHoverColor = helpers.getHoverColor;
var model = element._model;
model.backgroundColor = custom.hoverBackgroundColor ? custom.hoverBackgroundColor : valueOrDefault(dataset.hoverBackgroundColor, index, getHoverColor(model.backgroundColor));
model.borderColor = custom.hoverBorderColor ? custom.hoverBorderColor : valueOrDefault(dataset.hoverBorderColor, index, getHoverColor(model.borderColor));
model.borderWidth = custom.hoverBorderWidth ? custom.hoverBorderWidth : valueOrDefault(dataset.hoverBorderWidth, index, model.borderWidth);
},
resyncElements: function() {
var me = this;
var meta = me.getMeta();
var data = me.getDataset().data;
var numMeta = meta.data.length;
var numData = data.length;
if (numData < numMeta) {
meta.data.splice(numData, numMeta - numData);
} else if (numData > numMeta) {
me.insertElements(numMeta, numData - numMeta);
}
},
insertElements: function(start, count) {
for (var i = 0; i < count; ++i) {
this.addElementAndReset(start + i);
}
},
onDataPush: function() {
this.insertElements(this.getDataset().data.length - 1, arguments.length);
},
onDataPop: function() {
this.getMeta().data.pop();
},
onDataShift: function() {
this.getMeta().data.shift();
},
onDataSplice: function(start, count) {
this.getMeta().data.splice(start, count);
this.insertElements(start, arguments.length - 2);
},
onDataUnshift: function() {
this.insertElements(0, arguments.length);
}
});
Chart.DatasetController.extend = helpers.inherits;
};
},{"45":45}],25:[function(require,module,exports){
'use strict';
var helpers = require(45);
module.exports = {
_set: function(scope, values) {
return helpers.merge(this[scope] || (this[scope] = {}), values);
}
};
},{"45":45}],26:[function(require,module,exports){
'use strict';
var color = require(2);
var helpers = require(45);
function interpolate(start, view, model, ease) {
var keys = Object.keys(model);
var i, ilen, key, actual, origin, target, type, c0, c1;
for (i = 0, ilen = keys.length; i < ilen; ++i) {
key = keys[i];
target = model[key];
if (!view.hasOwnProperty(key)) {
view[key] = target;
}
actual = view[key];
if (actual === target || key[0] === '_') {
continue;
}
if (!start.hasOwnProperty(key)) {
start[key] = actual;
}
origin = start[key];
type = typeof target;
if (type === typeof origin) {
if (type === 'string') {
c0 = color(origin);
if (c0.valid) {
c1 = color(target);
if (c1.valid) {
view[key] = c1.mix(c0, ease).rgbString();
continue;
}
}
} else if (type === 'number' && isFinite(origin) && isFinite(target)) {
view[key] = origin + (target - origin) * ease;
continue;
}
}
view[key] = target;
}
}
var Element = function(configuration) {
helpers.extend(this, configuration);
this.initialize.apply(this, arguments);
};
helpers.extend(Element.prototype, {
initialize: function() {
this.hidden = false;
},
pivot: function() {
var me = this;
if (!me._view) {
me._view = helpers.clone(me._model);
}
me._start = {};
return me;
},
transition: function(ease) {
var me = this;
var model = me._model;
var start = me._start;
var view = me._view;
if (!model || ease === 1) {
me._view = model;
me._start = null;
return me;
}
if (!view) {
view = me._view = {};
}
if (!start) {
start = me._start = {};
}
interpolate(start, view, model, ease);
return me;
},
tooltipPosition: function() {
return {
x: this._model.x,
y: this._model.y
};
},
hasValue: function() {
return helpers.isNumber(this._model.x) && helpers.isNumber(this._model.y);
}
});
Element.extend = helpers.inherits;
module.exports = Element;
},{"2":2,"45":45}],27:[function(require,module,exports){
'use strict';
var color = require(2);
var defaults = require(25);
var helpers = require(45);
module.exports = function(Chart) {
helpers.configMerge = function(/* objects ... */) {
return helpers.merge(helpers.clone(arguments[0]), [].slice.call(arguments, 1), {
merger: function(key, target, source, options) {
var tval = target[key] || {};
var sval = source[key];
if (key === 'scales') {
target[key] = helpers.scaleMerge(tval, sval);
} else if (key === 'scale') {
target[key] = helpers.merge(tval, [Chart.scaleService.getScaleDefaults(sval.type), sval]);
} else {
helpers._merger(key, target, source, options);
}
}
});
};
helpers.scaleMerge = function(/* objects ... */) {
return helpers.merge(helpers.clone(arguments[0]), [].slice.call(arguments, 1), {
merger: function(key, target, source, options) {
if (key === 'xAxes' || key === 'yAxes') {
var slen = source[key].length;
var i, type, scale;
if (!target[key]) {
target[key] = [];
}
for (i = 0; i < slen; ++i) {
scale = source[key][i];
type = helpers.valueOrDefault(scale.type, key === 'xAxes' ? 'category' : 'linear');
if (i >= target[key].length) {
target[key].push({});
}
if (!target[key][i].type || (scale.type && scale.type !== target[key][i].type)) {
helpers.merge(target[key][i], [Chart.scaleService.getScaleDefaults(type), scale]);
} else {
helpers.merge(target[key][i], scale);
}
}
} else {
helpers._merger(key, target, source, options);
}
}
});
};
helpers.where = function(collection, filterCallback) {
if (helpers.isArray(collection) && Array.prototype.filter) {
return collection.filter(filterCallback);
}
var filtered = [];
helpers.each(collection, function(item) {
if (filterCallback(item)) {
filtered.push(item);
}
});
return filtered;
};
helpers.findIndex = Array.prototype.findIndex ?
function(array, callback, scope) {
return array.findIndex(callback, scope);
} :
function(array, callback, scope) {
scope = scope === undefined ? array : scope;
for (var i = 0, ilen = array.length; i < ilen; ++i) {
if (callback.call(scope, array[i], i, array)) {
return i;
}
}
return -1;
};
helpers.findNextWhere = function(arrayToSearch, filterCallback, startIndex) {
if (helpers.isNullOrUndef(startIndex)) {
startIndex = -1;
}
for (var i = startIndex + 1; i < arrayToSearch.length; i++) {
var currentItem = arrayToSearch[i];
if (filterCallback(currentItem)) {
return currentItem;
}
}
};
helpers.findPreviousWhere = function(arrayToSearch, filterCallback, startIndex) {
if (helpers.isNullOrUndef(startIndex)) {
startIndex = arrayToSearch.length;
}
for (var i = startIndex - 1; i >= 0; i--) {
var currentItem = arrayToSearch[i];
if (filterCallback(currentItem)) {
return currentItem;
}
}
};
helpers.isNumber = function(n) {
return !isNaN(parseFloat(n)) && isFinite(n);
};
helpers.almostEquals = function(x, y, epsilon) {
return Math.abs(x - y) < epsilon;
};
helpers.almostWhole = function(x, epsilon) {
var rounded = Math.round(x);
return (((rounded - epsilon) < x) && ((rounded + epsilon) > x));
};
helpers.max = function(array) {
return array.reduce(function(max, value) {
if (!isNaN(value)) {
return Math.max(max, value);
}
return max;
}, Number.NEGATIVE_INFINITY);
};
helpers.min = function(array) {
return array.reduce(function(min, value) {
if (!isNaN(value)) {
return Math.min(min, value);
}
return min;
}, Number.POSITIVE_INFINITY);
};
helpers.sign = Math.sign ?
function(x) {
return Math.sign(x);
} :
function(x) {
x = +x; // convert to a number
if (x === 0 || isNaN(x)) {
return x;
}
return x > 0 ? 1 : -1;
};
helpers.log10 = Math.log10 ?
function(x) {
return Math.log10(x);
} :
function(x) {
return Math.log(x) / Math.LN10;
};
helpers.toRadians = function(degrees) {
return degrees * (Math.PI / 180);
};
helpers.toDegrees = function(radians) {
return radians * (180 / Math.PI);
};
helpers.getAngleFromPoint = function(centrePoint, anglePoint) {
var distanceFromXCenter = anglePoint.x - centrePoint.x;
var distanceFromYCenter = anglePoint.y - centrePoint.y;
var radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
var angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
if (angle < (-0.5 * Math.PI)) {
angle += 2.0 * Math.PI; // make sure the returned angle is in the range of (-PI/2, 3PI/2]
}
return {
angle: angle,
distance: radialDistanceFromCenter
};
};
helpers.distanceBetweenPoints = function(pt1, pt2) {
return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
};
helpers.aliasPixel = function(pixelWidth) {
return (pixelWidth % 2 === 0) ? 0 : 0.5;
};
helpers.splineCurve = function(firstPoint, middlePoint, afterPoint, t) {
var previous = firstPoint.skip ? middlePoint : firstPoint;
var current = middlePoint;
var next = afterPoint.skip ? middlePoint : afterPoint;
var d01 = Math.sqrt(Math.pow(current.x - previous.x, 2) + Math.pow(current.y - previous.y, 2));
var d12 = Math.sqrt(Math.pow(next.x - current.x, 2) + Math.pow(next.y - current.y, 2));
var s01 = d01 / (d01 + d12);
var s12 = d12 / (d01 + d12);
s01 = isNaN(s01) ? 0 : s01;
s12 = isNaN(s12) ? 0 : s12;
var fa = t * s01; // scaling factor for triangle Ta
var fb = t * s12;
return {
previous: {
x: current.x - fa * (next.x - previous.x),
y: current.y - fa * (next.y - previous.y)
},
next: {
x: current.x + fb * (next.x - previous.x),
y: current.y + fb * (next.y - previous.y)
}
};
};
helpers.EPSILON = Number.EPSILON || 1e-14;
helpers.splineCurveMonotone = function(points) {
var pointsWithTangents = (points || []).map(function(point) {
return {
model: point._model,
deltaK: 0,
mK: 0
};
});
var pointsLen = pointsWithTangents.length;
var i, pointBefore, pointCurrent, pointAfter;
for (i = 0; i < pointsLen; ++i) {
pointCurrent = pointsWithTangents[i];
if (pointCurrent.model.skip) {
continue;
}
pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;
pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;
if (pointAfter && !pointAfter.model.skip) {
var slopeDeltaX = (pointAfter.model.x - pointCurrent.model.x);
pointCurrent.deltaK = slopeDeltaX !== 0 ? (pointAfter.model.y - pointCurrent.model.y) / slopeDeltaX : 0;
}
if (!pointBefore || pointBefore.model.skip) {
pointCurrent.mK = pointCurrent.deltaK;
} else if (!pointAfter || pointAfter.model.skip) {
pointCurrent.mK = pointBefore.deltaK;
} else if (this.sign(pointBefore.deltaK) !== this.sign(pointCurrent.deltaK)) {
pointCurrent.mK = 0;
} else {
pointCurrent.mK = (pointBefore.deltaK + pointCurrent.deltaK) / 2;
}
}
var alphaK, betaK, tauK, squaredMagnitude;
for (i = 0; i < pointsLen - 1; ++i) {
pointCurrent = pointsWithTangents[i];
pointAfter = pointsWithTangents[i + 1];
if (pointCurrent.model.skip || pointAfter.model.skip) {
continue;
}
if (helpers.almostEquals(pointCurrent.deltaK, 0, this.EPSILON)) {
pointCurrent.mK = pointAfter.mK = 0;
continue;
}
alphaK = pointCurrent.mK / pointCurrent.deltaK;
betaK = pointAfter.mK / pointCurrent.deltaK;
squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
if (squaredMagnitude <= 9) {
continue;
}
tauK = 3 / Math.sqrt(squaredMagnitude);
pointCurrent.mK = alphaK * tauK * pointCurrent.deltaK;
pointAfter.mK = betaK * tauK * pointCurrent.deltaK;
}
var deltaX;
for (i = 0; i < pointsLen; ++i) {
pointCurrent = pointsWithTangents[i];
if (pointCurrent.model.skip) {
continue;
}
pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;
pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;
if (pointBefore && !pointBefore.model.skip) {
deltaX = (pointCurrent.model.x - pointBefore.model.x) / 3;
pointCurrent.model.controlPointPreviousX = pointCurrent.model.x - deltaX;
pointCurrent.model.controlPointPreviousY = pointCurrent.model.y - deltaX * pointCurrent.mK;
}
if (pointAfter && !pointAfter.model.skip) {
deltaX = (pointAfter.model.x - pointCurrent.model.x) / 3;
pointCurrent.model.controlPointNextX = pointCurrent.model.x + deltaX;
pointCurrent.model.controlPointNextY = pointCurrent.model.y + deltaX * pointCurrent.mK;
}
}
};
helpers.nextItem = function(collection, index, loop) {
if (loop) {
return index >= collection.length - 1 ? collection[0] : collection[index + 1];
}
return index >= collection.length - 1 ? collection[collection.length - 1] : collection[index + 1];
};
helpers.previousItem = function(collection, index, loop) {
if (loop) {
return index <= 0 ? collection[collection.length - 1] : collection[index - 1];
}
return index <= 0 ? collection[0] : collection[index - 1];
};
helpers.niceNum = function(range, round) {
var exponent = Math.floor(helpers.log10(range));
var fraction = range / Math.pow(10, exponent);
var niceFraction;
if (round) {
if (fraction < 1.5) {
niceFraction = 1;
} else if (fraction < 3) {
niceFraction = 2;
} else if (fraction < 7) {
niceFraction = 5;
} else {
niceFraction = 10;
}
} else if (fraction <= 1.0) {
niceFraction = 1;
} else if (fraction <= 2) {
niceFraction = 2;
} else if (fraction <= 5) {
niceFraction = 5;
} else {
niceFraction = 10;
}
return niceFraction * Math.pow(10, exponent);
};
helpers.requestAnimFrame = (function() {
if (typeof window === 'undefined') {
return function(callback) {
callback();
};
}
return window.requestAnimationFrame ||
window.webkitRequestAnimationFrame ||
window.mozRequestAnimationFrame ||
window.oRequestAnimationFrame ||
window.msRequestAnimationFrame ||
function(callback) {
return window.setTimeout(callback, 1000 / 60);
};
}());
helpers.getRelativePosition = function(evt, chart) {
var mouseX, mouseY;
var e = evt.originalEvent || evt;
var canvas = evt.currentTarget || evt.srcElement;
var boundingRect = canvas.getBoundingClientRect();
var touches = e.touches;
if (touches && touches.length > 0) {
mouseX = touches[0].clientX;
mouseY = touches[0].clientY;
} else {
mouseX = e.clientX;
mouseY = e.clientY;
}
var paddingLeft = parseFloat(helpers.getStyle(canvas, 'padding-left'));
var paddingTop = parseFloat(helpers.getStyle(canvas, 'padding-top'));
var paddingRight = parseFloat(helpers.getStyle(canvas, 'padding-right'));
var paddingBottom = parseFloat(helpers.getStyle(canvas, 'padding-bottom'));
var width = boundingRect.right - boundingRect.left - paddingLeft - paddingRight;
var height = boundingRect.bottom - boundingRect.top - paddingTop - paddingBottom;
mouseX = Math.round((mouseX - boundingRect.left - paddingLeft) / (width) * canvas.width / chart.currentDevicePixelRatio);
mouseY = Math.round((mouseY - boundingRect.top - paddingTop) / (height) * canvas.height / chart.currentDevicePixelRatio);
return {
x: mouseX,
y: mouseY
};
};
function parseMaxStyle(styleValue, node, parentProperty) {
var valueInPixels;
if (typeof styleValue === 'string') {
valueInPixels = parseInt(styleValue, 10);
if (styleValue.indexOf('%') !== -1) {
valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
}
} else {
valueInPixels = styleValue;
}
return valueInPixels;
}
function isConstrainedValue(value) {
return value !== undefined && value !== null && value !== 'none';
}
function getConstraintDimension(domNode, maxStyle, percentageProperty) {
var view = document.defaultView;
var parentNode = domNode.parentNode;
var constrainedNode = view.getComputedStyle(domNode)[maxStyle];
var constrainedContainer = view.getComputedStyle(parentNode)[maxStyle];
var hasCNode = isConstrainedValue(constrainedNode);
var hasCContainer = isConstrainedValue(constrainedContainer);
var infinity = Number.POSITIVE_INFINITY;
if (hasCNode || hasCContainer) {
return Math.min(
hasCNode ? parseMaxStyle(constrainedNode, domNode, percentageProperty) : infinity,
hasCContainer ? parseMaxStyle(constrainedContainer, parentNode, percentageProperty) : infinity);
}
return 'none';
}
helpers.getConstraintWidth = function(domNode) {
return getConstraintDimension(domNode, 'max-width', 'clientWidth');
};
helpers.getConstraintHeight = function(domNode) {
return getConstraintDimension(domNode, 'max-height', 'clientHeight');
};
helpers.getMaximumWidth = function(domNode) {
var container = domNode.parentNode;
if (!container) {
return domNode.clientWidth;
}
var paddingLeft = parseInt(helpers.getStyle(container, 'padding-left'), 10);
var paddingRight = parseInt(helpers.getStyle(container, 'padding-right'), 10);
var w = container.clientWidth - paddingLeft - paddingRight;
var cw = helpers.getConstraintWidth(domNode);
return isNaN(cw) ? w : Math.min(w, cw);
};
helpers.getMaximumHeight = function(domNode) {
var container = domNode.parentNode;
if (!container) {
return domNode.clientHeight;
}
var paddingTop = parseInt(helpers.getStyle(container, 'padding-top'), 10);
var paddingBottom = parseInt(helpers.getStyle(container, 'padding-bottom'), 10);
var h = container.clientHeight - paddingTop - paddingBottom;
var ch = helpers.getConstraintHeight(domNode);
return isNaN(ch) ? h : Math.min(h, ch);
};
helpers.getStyle = function(el, property) {
return el.currentStyle ?
el.currentStyle[property] :
document.defaultView.getComputedStyle(el, null).getPropertyValue(property);
};
helpers.retinaScale = function(chart, forceRatio) {
var pixelRatio = chart.currentDevicePixelRatio = forceRatio || window.devicePixelRatio || 1;
if (pixelRatio === 1) {
return;
}
var canvas = chart.canvas;
var height = chart.height;
var width = chart.width;
canvas.height = height * pixelRatio;
canvas.width = width * pixelRatio;
chart.ctx.scale(pixelRatio, pixelRatio);
canvas.style.height = height + 'px';
canvas.style.width = width + 'px';
};
helpers.fontString = function(pixelSize, fontStyle, fontFamily) {
return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;
};
helpers.longestText = function(ctx, font, arrayOfThings, cache) {
cache = cache || {};
var data = cache.data = cache.data || {};
var gc = cache.garbageCollect = cache.garbageCollect || [];
if (cache.font !== font) {
data = cache.data = {};
gc = cache.garbageCollect = [];
cache.font = font;
}
ctx.font = font;
var longest = 0;
helpers.each(arrayOfThings, function(thing) {
if (thing !== undefined && thing !== null && helpers.isArray(thing) !== true) {
longest = helpers.measureText(ctx, data, gc, longest, thing);
} else if (helpers.isArray(thing)) {
helpers.each(thing, function(nestedThing) {
if (nestedThing !== undefined && nestedThing !== null && !helpers.isArray(nestedThing)) {
longest = helpers.measureText(ctx, data, gc, longest, nestedThing);
}
});
}
});
var gcLen = gc.length / 2;
if (gcLen > arrayOfThings.length) {
for (var i = 0; i < gcLen; i++) {
delete data[gc[i]];
}
gc.splice(0, gcLen);
}
return longest;
};
helpers.measureText = function(ctx, data, gc, longest, string) {
var textWidth = data[string];
if (!textWidth) {
textWidth = data[string] = ctx.measureText(string).width;
gc.push(string);
}
if (textWidth > longest) {
longest = textWidth;
}
return longest;
};
helpers.numberOfLabelLines = function(arrayOfThings) {
var numberOfLines = 1;
helpers.each(arrayOfThings, function(thing) {
if (helpers.isArray(thing)) {
if (thing.length > numberOfLines) {
numberOfLines = thing.length;
}
}
});
return numberOfLines;
};
helpers.color = !color ?
function(value) {
console.error('Color.js not found!');
return value;
} :
function(value) {
if (value instanceof CanvasGradient) {
value = defaults.global.defaultColor;
}
return color(value);
};
helpers.getHoverColor = function(colorValue) {
return (colorValue instanceof CanvasPattern) ?
colorValue :
helpers.color(colorValue).saturate(0.5).darken(0.1).rgbString();
};
};
},{"2":2,"25":25,"45":45}],28:[function(require,module,exports){
'use strict';
var helpers = require(45);
function getRelativePosition(e, chart) {
if (e.native) {
return {
x: e.x,
y: e.y
};
}
return helpers.getRelativePosition(e, chart);
}
function parseVisibleItems(chart, handler) {
var datasets = chart.data.datasets;
var meta, i, j, ilen, jlen;
for (i = 0, ilen = datasets.length; i < ilen; ++i) {
if (!chart.isDatasetVisible(i)) {
continue;
}
meta = chart.getDatasetMeta(i);
for (j = 0, jlen = meta.data.length; j < jlen; ++j) {
var element = meta.data[j];
if (!element._view.skip) {
handler(element);
}
}
}
}
function getIntersectItems(chart, position) {
var elements = [];
parseVisibleItems(chart, function(element) {
if (element.inRange(position.x, position.y)) {
elements.push(element);
}
});
return elements;
}
function getNearestItems(chart, position, intersect, distanceMetric) {
var minDistance = Number.POSITIVE_INFINITY;
var nearestItems = [];
parseVisibleItems(chart, function(element) {
if (intersect && !element.inRange(position.x, position.y)) {
return;
}
var center = element.getCenterPoint();
var distance = distanceMetric(position, center);
if (distance < minDistance) {
nearestItems = [element];
minDistance = distance;
} else if (distance === minDistance) {
nearestItems.push(element);
}
});
return nearestItems;
}
function getDistanceMetricForAxis(axis) {
var useX = axis.indexOf('x') !== -1;
var useY = axis.indexOf('y') !== -1;
return function(pt1, pt2) {
var deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
var deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
};
}
function indexMode(chart, e, options) {
var position = getRelativePosition(e, chart);
options.axis = options.axis || 'x';
var distanceMetric = getDistanceMetricForAxis(options.axis);
var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);
var elements = [];
if (!items.length) {
return [];
}
chart.data.datasets.forEach(function(dataset, datasetIndex) {
if (chart.isDatasetVisible(datasetIndex)) {
var meta = chart.getDatasetMeta(datasetIndex);
var element = meta.data[items[0]._index];
if (element && !element._view.skip) {
elements.push(element);
}
}
});
return elements;
}
module.exports = {
modes: {
single: function(chart, e) {
var position = getRelativePosition(e, chart);
var elements = [];
parseVisibleItems(chart, function(element) {
if (element.inRange(position.x, position.y)) {
elements.push(element);
return elements;
}
});
return elements.slice(0, 1);
},
label: indexMode,
index: indexMode,
dataset: function(chart, e, options) {
var position = getRelativePosition(e, chart);
options.axis = options.axis || 'xy';
var distanceMetric = getDistanceMetricForAxis(options.axis);
var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);
if (items.length > 0) {
items = chart.getDatasetMeta(items[0]._datasetIndex).data;
}
return items;
},
'x-axis': function(chart, e) {
return indexMode(chart, e, {intersect: false});
},
point: function(chart, e) {
var position = getRelativePosition(e, chart);
return getIntersectItems(chart, position);
},
nearest: function(chart, e, options) {
var position = getRelativePosition(e, chart);
options.axis = options.axis || 'xy';
var distanceMetric = getDistanceMetricForAxis(options.axis);
var nearestItems = getNearestItems(chart, position, options.intersect, distanceMetric);
if (nearestItems.length > 1) {
nearestItems.sort(function(a, b) {
var sizeA = a.getArea();
var sizeB = b.getArea();
var ret = sizeA - sizeB;
if (ret === 0) {
ret = a._datasetIndex - b._datasetIndex;
}
return ret;
});
}
return nearestItems.slice(0, 1);
},
x: function(chart, e, options) {
var position = getRelativePosition(e, chart);
var items = [];
var intersectsItem = false;
parseVisibleItems(chart, function(element) {
if (element.inXRange(position.x)) {
items.push(element);
}
if (element.inRange(position.x, position.y)) {
intersectsItem = true;
}
});
if (options.intersect && !intersectsItem) {
items = [];
}
return items;
},
y: function(chart, e, options) {
var position = getRelativePosition(e, chart);
var items = [];
var intersectsItem = false;
parseVisibleItems(chart, function(element) {
if (element.inYRange(position.y)) {
items.push(element);
}
if (element.inRange(position.x, position.y)) {
intersectsItem = true;
}
});
if (options.intersect && !intersectsItem) {
items = [];
}
return items;
}
}
};
},{"45":45}],29:[function(require,module,exports){
'use strict';
var defaults = require(25);
defaults._set('global', {
responsive: true,
responsiveAnimationDuration: 0,
maintainAspectRatio: true,
events: ['mousemove', 'mouseout', 'click', 'touchstart', 'touchmove'],
hover: {
onHover: null,
mode: 'nearest',
intersect: true,
animationDuration: 400
},
onClick: null,
defaultColor: 'rgba(0,0,0,0.1)',
defaultFontColor: '#666',
defaultFontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
defaultFontSize: 12,
defaultFontStyle: 'normal',
showLines: true,
elements: {},
layout: {
padding: {
top: 0,
right: 0,
bottom: 0,
left: 0
}
}
});
module.exports = function() {
var Chart = function(item, config) {
this.construct(item, config);
return this;
};
Chart.Chart = Chart;
return Chart;
};
},{"25":25}],30:[function(require,module,exports){
'use strict';
var helpers = require(45);
module.exports = function(Chart) {
function filterByPosition(array, position) {
return helpers.where(array, function(v) {
return v.position === position;
});
}
function sortByWeight(array, reverse) {
array.forEach(function(v, i) {
v._tmpIndex_ = i;
return v;
});
array.sort(function(a, b) {
var v0 = reverse ? b : a;
var v1 = reverse ? a : b;
return v0.weight === v1.weight ?
v0._tmpIndex_ - v1._tmpIndex_ :
v0.weight - v1.weight;
});
array.forEach(function(v) {
delete v._tmpIndex_;
});
}
Chart.layoutService = {
defaults: {},
addBox: function(chart, item) {
if (!chart.boxes) {
chart.boxes = [];
}
item.fullWidth = item.fullWidth || false;
item.position = item.position || 'top';
item.weight = item.weight || 0;
chart.boxes.push(item);
},
removeBox: function(chart, layoutItem) {
var index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
if (index !== -1) {
chart.boxes.splice(index, 1);
}
},
configure: function(chart, item, options) {
var props = ['fullWidth', 'position', 'weight'];
var ilen = props.length;
var i = 0;
var prop;
for (; i < ilen; ++i) {
prop = props[i];
if (options.hasOwnProperty(prop)) {
item[prop] = options[prop];
}
}
},
update: function(chart, width, height) {
if (!chart) {
return;
}
var layoutOptions = chart.options.layout || {};
var padding = helpers.options.toPadding(layoutOptions.padding);
var leftPadding = padding.left;
var rightPadding = padding.right;
var topPadding = padding.top;
var bottomPadding = padding.bottom;
var leftBoxes = filterByPosition(chart.boxes, 'left');
var rightBoxes = filterByPosition(chart.boxes, 'right');
var topBoxes = filterByPosition(chart.boxes, 'top');
var bottomBoxes = filterByPosition(chart.boxes, 'bottom');
var chartAreaBoxes = filterByPosition(chart.boxes, 'chartArea');
sortByWeight(leftBoxes, true);
sortByWeight(rightBoxes, false);
sortByWeight(topBoxes, true);
sortByWeight(bottomBoxes, false);
var chartWidth = width - leftPadding - rightPadding;
var chartHeight = height - topPadding - bottomPadding;
var chartAreaWidth = chartWidth / 2; // min 50%
var chartAreaHeight = chartHeight / 2; // min 50%
var verticalBoxWidth = (width - chartAreaWidth) / (leftBoxes.length + rightBoxes.length);
var horizontalBoxHeight = (height - chartAreaHeight) / (topBoxes.length + bottomBoxes.length);
var maxChartAreaWidth = chartWidth;
var maxChartAreaHeight = chartHeight;
var minBoxSizes = [];
function getMinimumBoxSize(box) {
var minSize;
var isHorizontal = box.isHorizontal();
if (isHorizontal) {
minSize = box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, horizontalBoxHeight);
maxChartAreaHeight -= minSize.height;
} else {
minSize = box.update(verticalBoxWidth, chartAreaHeight);
maxChartAreaWidth -= minSize.width;
}
minBoxSizes.push({
horizontal: isHorizontal,
minSize: minSize,
box: box,
});
}
helpers.each(leftBoxes.concat(rightBoxes, topBoxes, bottomBoxes), getMinimumBoxSize);
var maxHorizontalLeftPadding = 0;
var maxHorizontalRightPadding = 0;
var maxVerticalTopPadding = 0;
var maxVerticalBottomPadding = 0;
helpers.each(topBoxes.concat(bottomBoxes), function(horizontalBox) {
if (horizontalBox.getPadding) {
var boxPadding = horizontalBox.getPadding();
maxHorizontalLeftPadding = Math.max(maxHorizontalLeftPadding, boxPadding.left);
maxHorizontalRightPadding = Math.max(maxHorizontalRightPadding, boxPadding.right);
}
});
helpers.each(leftBoxes.concat(rightBoxes), function(verticalBox) {
if (verticalBox.getPadding) {
var boxPadding = verticalBox.getPadding();
maxVerticalTopPadding = Math.max(maxVerticalTopPadding, boxPadding.top);
maxVerticalBottomPadding = Math.max(maxVerticalBottomPadding, boxPadding.bottom);
}
});
var totalLeftBoxesWidth = leftPadding;
var totalRightBoxesWidth = rightPadding;
var totalTopBoxesHeight = topPadding;
var totalBottomBoxesHeight = bottomPadding;
function fitBox(box) {
var minBoxSize = helpers.findNextWhere(minBoxSizes, function(minBox) {
return minBox.box === box;
});
if (minBoxSize) {
if (box.isHorizontal()) {
var scaleMargin = {
left: Math.max(totalLeftBoxesWidth, maxHorizontalLeftPadding),
right: Math.max(totalRightBoxesWidth, maxHorizontalRightPadding),
top: 0,
bottom: 0
};
box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2, scaleMargin);
} else {
box.update(minBoxSize.minSize.width, maxChartAreaHeight);
}
}
}
helpers.each(leftBoxes.concat(rightBoxes), fitBox);
helpers.each(leftBoxes, function(box) {
totalLeftBoxesWidth += box.width;
});
helpers.each(rightBoxes, function(box) {
totalRightBoxesWidth += box.width;
});
helpers.each(topBoxes.concat(bottomBoxes), fitBox);
helpers.each(topBoxes, function(box) {
totalTopBoxesHeight += box.height;
});
helpers.each(bottomBoxes, function(box) {
totalBottomBoxesHeight += box.height;
});
function finalFitVerticalBox(box) {
var minBoxSize = helpers.findNextWhere(minBoxSizes, function(minSize) {
return minSize.box === box;
});
var scaleMargin = {
left: 0,
right: 0,
top: totalTopBoxesHeight,
bottom: totalBottomBoxesHeight
};
if (minBoxSize) {
box.update(minBoxSize.minSize.width, maxChartAreaHeight, scaleMargin);
}
}
helpers.each(leftBoxes.concat(rightBoxes), finalFitVerticalBox);
totalLeftBoxesWidth = leftPadding;
totalRightBoxesWidth = rightPadding;
totalTopBoxesHeight = topPadding;
totalBottomBoxesHeight = bottomPadding;
helpers.each(leftBoxes, function(box) {
totalLeftBoxesWidth += box.width;
});
helpers.each(rightBoxes, function(box) {
totalRightBoxesWidth += box.width;
});
helpers.each(topBoxes, function(box) {
totalTopBoxesHeight += box.height;
});
helpers.each(bottomBoxes, function(box) {
totalBottomBoxesHeight += box.height;
});
var leftPaddingAddition = Math.max(maxHorizontalLeftPadding - totalLeftBoxesWidth, 0);
totalLeftBoxesWidth += leftPaddingAddition;
totalRightBoxesWidth += Math.max(maxHorizontalRightPadding - totalRightBoxesWidth, 0);
var topPaddingAddition = Math.max(maxVerticalTopPadding - totalTopBoxesHeight, 0);
totalTopBoxesHeight += topPaddingAddition;
totalBottomBoxesHeight += Math.max(maxVerticalBottomPadding - totalBottomBoxesHeight, 0);
var newMaxChartAreaHeight = height - totalTopBoxesHeight - totalBottomBoxesHeight;
var newMaxChartAreaWidth = width - totalLeftBoxesWidth - totalRightBoxesWidth;
if (newMaxChartAreaWidth !== maxChartAreaWidth || newMaxChartAreaHeight !== maxChartAreaHeight) {
helpers.each(leftBoxes, function(box) {
box.height = newMaxChartAreaHeight;
});
helpers.each(rightBoxes, function(box) {
box.height = newMaxChartAreaHeight;
});
helpers.each(topBoxes, function(box) {
if (!box.fullWidth) {
box.width = newMaxChartAreaWidth;
}
});
helpers.each(bottomBoxes, function(box) {
if (!box.fullWidth) {
box.width = newMaxChartAreaWidth;
}
});
maxChartAreaHeight = newMaxChartAreaHeight;
maxChartAreaWidth = newMaxChartAreaWidth;
}
var left = leftPadding + leftPaddingAddition;
var top = topPadding + topPaddingAddition;
function placeBox(box) {
if (box.isHorizontal()) {
box.left = box.fullWidth ? leftPadding : totalLeftBoxesWidth;
box.right = box.fullWidth ? width - rightPadding : totalLeftBoxesWidth + maxChartAreaWidth;
box.top = top;
box.bottom = top + box.height;
top = box.bottom;
} else {
box.left = left;
box.right = left + box.width;
box.top = totalTopBoxesHeight;
box.bottom = totalTopBoxesHeight + maxChartAreaHeight;
left = box.right;
}
}
helpers.each(leftBoxes.concat(topBoxes), placeBox);
left += maxChartAreaWidth;
top += maxChartAreaHeight;
helpers.each(rightBoxes, placeBox);
helpers.each(bottomBoxes, placeBox);
chart.chartArea = {
left: totalLeftBoxesWidth,
top: totalTopBoxesHeight,
right: totalLeftBoxesWidth + maxChartAreaWidth,
bottom: totalTopBoxesHeight + maxChartAreaHeight
};
helpers.each(chartAreaBoxes, function(box) {
box.left = chart.chartArea.left;
box.top = chart.chartArea.top;
box.right = chart.chartArea.right;
box.bottom = chart.chartArea.bottom;
box.update(maxChartAreaWidth, maxChartAreaHeight);
});
}
};
};
},{"45":45}],31:[function(require,module,exports){
'use strict';
var defaults = require(25);
var Element = require(26);
var helpers = require(45);
defaults._set('global', {
plugins: {}
});
module.exports = function(Chart) {
Chart.plugins = {
_plugins: [],
_cacheId: 0,
register: function(plugins) {
var p = this._plugins;
([]).concat(plugins).forEach(function(plugin) {
if (p.indexOf(plugin) === -1) {
p.push(plugin);
}
});
this._cacheId++;
},
unregister: function(plugins) {
var p = this._plugins;
([]).concat(plugins).forEach(function(plugin) {
var idx = p.indexOf(plugin);
if (idx !== -1) {
p.splice(idx, 1);
}
});
this._cacheId++;
},
clear: function() {
this._plugins = [];
this._cacheId++;
},
count: function() {
return this._plugins.length;
},
getAll: function() {
return this._plugins;
},
notify: function(chart, hook, args) {
var descriptors = this.descriptors(chart);
var ilen = descriptors.length;
var i, descriptor, plugin, params, method;
for (i = 0; i < ilen; ++i) {
descriptor = descriptors[i];
plugin = descriptor.plugin;
method = plugin[hook];
if (typeof method === 'function') {
params = [chart].concat(args || []);
params.push(descriptor.options);
if (method.apply(plugin, params) === false) {
return false;
}
}
}
return true;
},
descriptors: function(chart) {
var cache = chart._plugins || (chart._plugins = {});
if (cache.id === this._cacheId) {
return cache.descriptors;
}
var plugins = [];
var descriptors = [];
var config = (chart && chart.config) || {};
var options = (config.options && config.options.plugins) || {};
this._plugins.concat(config.plugins || []).forEach(function(plugin) {
var idx = plugins.indexOf(plugin);
if (idx !== -1) {
return;
}
var id = plugin.id;
var opts = options[id];
if (opts === false) {
return;
}
if (opts === true) {
opts = helpers.clone(defaults.global.plugins[id]);
}
plugins.push(plugin);
descriptors.push({
plugin: plugin,
options: opts || {}
});
});
cache.descriptors = descriptors;
cache.id = this._cacheId;
return descriptors;
}
};
Chart.pluginService = Chart.plugins;
Chart.PluginBase = Element.extend({});
};
},{"25":25,"26":26,"45":45}],32:[function(require,module,exports){
'use strict';
var defaults = require(25);
var Element = require(26);
var helpers = require(45);
var Ticks = require(34);
defaults._set('scale', {
display: true,
position: 'left',
offset: false,
gridLines: {
display: true,
color: 'rgba(0, 0, 0, 0.1)',
lineWidth: 1,
drawBorder: true,
drawOnChartArea: true,
drawTicks: true,
tickMarkLength: 10,
zeroLineWidth: 1,
zeroLineColor: 'rgba(0,0,0,0.25)',
zeroLineBorderDash: [],
zeroLineBorderDashOffset: 0.0,
offsetGridLines: false,
borderDash: [],
borderDashOffset: 0.0
},
scaleLabel: {
display: false,
labelString: '',
lineHeight: 1.2,
padding: {
top: 4,
bottom: 4
}
},
ticks: {
beginAtZero: false,
minRotation: 0,
maxRotation: 50,
mirror: false,
padding: 0,
reverse: false,
display: true,
autoSkip: true,
autoSkipPadding: 0,
labelOffset: 0,
callback: Ticks.formatters.values,
minor: {},
major: {}
}
});
function labelsFromTicks(ticks) {
var labels = [];
var i, ilen;
for (i = 0, ilen = ticks.length; i < ilen; ++i) {
labels.push(ticks[i].label);
}
return labels;
}
function getLineValue(scale, index, offsetGridLines) {
var lineValue = scale.getPixelForTick(index);
if (offsetGridLines) {
if (index === 0) {
lineValue -= (scale.getPixelForTick(1) - lineValue) / 2;
} else {
lineValue -= (lineValue - scale.getPixelForTick(index - 1)) / 2;
}
}
return lineValue;
}
module.exports = function(Chart) {
function computeTextSize(context, tick, font) {
return helpers.isArray(tick) ?
helpers.longestText(context, font, tick) :
context.measureText(tick).width;
}
function parseFontOptions(options) {
var valueOrDefault = helpers.valueOrDefault;
var globalDefaults = defaults.global;
var size = valueOrDefault(options.fontSize, globalDefaults.defaultFontSize);
var style = valueOrDefault(options.fontStyle, globalDefaults.defaultFontStyle);
var family = valueOrDefault(options.fontFamily, globalDefaults.defaultFontFamily);
return {
size: size,
style: style,
family: family,
font: helpers.fontString(size, style, family)
};
}
function parseLineHeight(options) {
return helpers.options.toLineHeight(
helpers.valueOrDefault(options.lineHeight, 1.2),
helpers.valueOrDefault(options.fontSize, defaults.global.defaultFontSize));
}
Chart.Scale = Element.extend({
getPadding: function() {
var me = this;
return {
left: me.paddingLeft || 0,
top: me.paddingTop || 0,
right: me.paddingRight || 0,
bottom: me.paddingBottom || 0
};
},
getTicks: function() {
return this._ticks;
},
mergeTicksOptions: function() {
var ticks = this.options.ticks;
if (ticks.minor === false) {
ticks.minor = {
display: false
};
}
if (ticks.major === false) {
ticks.major = {
display: false
};
}
for (var key in ticks) {
if (key !== 'major' && key !== 'minor') {
if (typeof ticks.minor[key] === 'undefined') {
ticks.minor[key] = ticks[key];
}
if (typeof ticks.major[key] === 'undefined') {
ticks.major[key] = ticks[key];
}
}
}
},
beforeUpdate: function() {
helpers.callback(this.options.beforeUpdate, [this]);
},
update: function(maxWidth, maxHeight, margins) {
var me = this;
var i, ilen, labels, label, ticks, tick;
me.beforeUpdate();
me.maxWidth = maxWidth;
me.maxHeight = maxHeight;
me.margins = helpers.extend({
left: 0,
right: 0,
top: 0,
bottom: 0
}, margins);
me.longestTextCache = me.longestTextCache || {};
me.beforeSetDimensions();
me.setDimensions();
me.afterSetDimensions();
me.beforeDataLimits();
me.determineDataLimits();
me.afterDataLimits();
me.beforeBuildTicks();
ticks = me.buildTicks() || [];
me.afterBuildTicks();
me.beforeTickToLabelConversion();
labels = me.convertTicksToLabels(ticks) || me.ticks;
me.afterTickToLabelConversion();
me.ticks = labels;   // BACKWARD COMPATIBILITY
for (i = 0, ilen = labels.length; i < ilen; ++i) {
label = labels[i];
tick = ticks[i];
if (!tick) {
ticks.push(tick = {
label: label,
major: false
});
} else {
tick.label = label;
}
}
me._ticks = ticks;
me.beforeCalculateTickRotation();
me.calculateTickRotation();
me.afterCalculateTickRotation();
me.beforeFit();
me.fit();
me.afterFit();
me.afterUpdate();
return me.minSize;
},
afterUpdate: function() {
helpers.callback(this.options.afterUpdate, [this]);
},
beforeSetDimensions: function() {
helpers.callback(this.options.beforeSetDimensions, [this]);
},
setDimensions: function() {
var me = this;
if (me.isHorizontal()) {
me.width = me.maxWidth;
me.left = 0;
me.right = me.width;
} else {
me.height = me.maxHeight;
me.top = 0;
me.bottom = me.height;
}
me.paddingLeft = 0;
me.paddingTop = 0;
me.paddingRight = 0;
me.paddingBottom = 0;
},
afterSetDimensions: function() {
helpers.callback(this.options.afterSetDimensions, [this]);
},
beforeDataLimits: function() {
helpers.callback(this.options.beforeDataLimits, [this]);
},
determineDataLimits: helpers.noop,
afterDataLimits: function() {
helpers.callback(this.options.afterDataLimits, [this]);
},
beforeBuildTicks: function() {
helpers.callback(this.options.beforeBuildTicks, [this]);
},
buildTicks: helpers.noop,
afterBuildTicks: function() {
helpers.callback(this.options.afterBuildTicks, [this]);
},
beforeTickToLabelConversion: function() {
helpers.callback(this.options.beforeTickToLabelConversion, [this]);
},
convertTicksToLabels: function() {
var me = this;
var tickOpts = me.options.ticks;
me.ticks = me.ticks.map(tickOpts.userCallback || tickOpts.callback, this);
},
afterTickToLabelConversion: function() {
helpers.callback(this.options.afterTickToLabelConversion, [this]);
},
beforeCalculateTickRotation: function() {
helpers.callback(this.options.beforeCalculateTickRotation, [this]);
},
calculateTickRotation: function() {
var me = this;
var context = me.ctx;
var tickOpts = me.options.ticks;
var labels = labelsFromTicks(me._ticks);
var tickFont = parseFontOptions(tickOpts);
context.font = tickFont.font;
var labelRotation = tickOpts.minRotation || 0;
if (labels.length && me.options.display && me.isHorizontal()) {
var originalLabelWidth = helpers.longestText(context, tickFont.font, labels, me.longestTextCache);
var labelWidth = originalLabelWidth;
var cosRotation, sinRotation;
var tickWidth = me.getPixelForTick(1) - me.getPixelForTick(0) - 6;
while (labelWidth > tickWidth && labelRotation < tickOpts.maxRotation) {
var angleRadians = helpers.toRadians(labelRotation);
cosRotation = Math.cos(angleRadians);
sinRotation = Math.sin(angleRadians);
if (sinRotation * originalLabelWidth > me.maxHeight) {
labelRotation--;
break;
}
labelRotation++;
labelWidth = cosRotation * originalLabelWidth;
}
}
me.labelRotation = labelRotation;
},
afterCalculateTickRotation: function() {
helpers.callback(this.options.afterCalculateTickRotation, [this]);
},
beforeFit: function() {
helpers.callback(this.options.beforeFit, [this]);
},
fit: function() {
var me = this;
var minSize = me.minSize = {
width: 0,
height: 0
};
var labels = labelsFromTicks(me._ticks);
var opts = me.options;
var tickOpts = opts.ticks;
var scaleLabelOpts = opts.scaleLabel;
var gridLineOpts = opts.gridLines;
var display = opts.display;
var isHorizontal = me.isHorizontal();
var tickFont = parseFontOptions(tickOpts);
var tickMarkLength = opts.gridLines.tickMarkLength;
if (isHorizontal) {
minSize.width = me.isFullWidth() ? me.maxWidth - me.margins.left - me.margins.right : me.maxWidth;
} else {
minSize.width = display && gridLineOpts.drawTicks ? tickMarkLength : 0;
}
if (isHorizontal) {
minSize.height = display && gridLineOpts.drawTicks ? tickMarkLength : 0;
} else {
minSize.height = me.maxHeight; // fill all the height
}
if (scaleLabelOpts.display && display) {
var scaleLabelLineHeight = parseLineHeight(scaleLabelOpts);
var scaleLabelPadding = helpers.options.toPadding(scaleLabelOpts.padding);
var deltaHeight = scaleLabelLineHeight + scaleLabelPadding.height;
if (isHorizontal) {
minSize.height += deltaHeight;
} else {
minSize.width += deltaHeight;
}
}
if (tickOpts.display && display) {
var largestTextWidth = helpers.longestText(me.ctx, tickFont.font, labels, me.longestTextCache);
var tallestLabelHeightInLines = helpers.numberOfLabelLines(labels);
var lineSpace = tickFont.size * 0.5;
var tickPadding = me.options.ticks.padding;
if (isHorizontal) {
me.longestLabelWidth = largestTextWidth;
var angleRadians = helpers.toRadians(me.labelRotation);
var cosRotation = Math.cos(angleRadians);
var sinRotation = Math.sin(angleRadians);
var labelHeight = (sinRotation * largestTextWidth)
+ (tickFont.size * tallestLabelHeightInLines)
+ (lineSpace * (tallestLabelHeightInLines - 1))
+ lineSpace; // padding
minSize.height = Math.min(me.maxHeight, minSize.height + labelHeight + tickPadding);
me.ctx.font = tickFont.font;
var firstLabelWidth = computeTextSize(me.ctx, labels[0], tickFont.font);
var lastLabelWidth = computeTextSize(me.ctx, labels[labels.length - 1], tickFont.font);
if (me.labelRotation !== 0) {
me.paddingLeft = opts.position === 'bottom' ? (cosRotation * firstLabelWidth) + 3 : (cosRotation * lineSpace) + 3; // add 3 px to move away from canvas edges
me.paddingRight = opts.position === 'bottom' ? (cosRotation * lineSpace) + 3 : (cosRotation * lastLabelWidth) + 3;
} else {
me.paddingLeft = firstLabelWidth / 2 + 3; // add 3 px to move away from canvas edges
me.paddingRight = lastLabelWidth / 2 + 3;
}
} else {
if (tickOpts.mirror) {
largestTextWidth = 0;
} else {
largestTextWidth += tickPadding + lineSpace;
}
minSize.width = Math.min(me.maxWidth, minSize.width + largestTextWidth);
me.paddingTop = tickFont.size / 2;
me.paddingBottom = tickFont.size / 2;
}
}
me.handleMargins();
me.width = minSize.width;
me.height = minSize.height;
},
handleMargins: function() {
var me = this;
if (me.margins) {
me.paddingLeft = Math.max(me.paddingLeft - me.margins.left, 0);
me.paddingTop = Math.max(me.paddingTop - me.margins.top, 0);
me.paddingRight = Math.max(me.paddingRight - me.margins.right, 0);
me.paddingBottom = Math.max(me.paddingBottom - me.margins.bottom, 0);
}
},
afterFit: function() {
helpers.callback(this.options.afterFit, [this]);
},
isHorizontal: function() {
return this.options.position === 'top' || this.options.position === 'bottom';
},
isFullWidth: function() {
return (this.options.fullWidth);
},
getRightValue: function(rawValue) {
if (helpers.isNullOrUndef(rawValue)) {
return NaN;
}
if (typeof rawValue === 'number' && !isFinite(rawValue)) {
return NaN;
}
if (rawValue) {
if (this.isHorizontal()) {
if (rawValue.x !== undefined) {
return this.getRightValue(rawValue.x);
}
} else if (rawValue.y !== undefined) {
return this.getRightValue(rawValue.y);
}
}
return rawValue;
},
getLabelForIndex: helpers.noop,
getPixelForValue: helpers.noop,
getValueForPixel: helpers.noop,
getPixelForTick: function(index) {
var me = this;
var offset = me.options.offset;
if (me.isHorizontal()) {
var innerWidth = me.width - (me.paddingLeft + me.paddingRight);
var tickWidth = innerWidth / Math.max((me._ticks.length - (offset ? 0 : 1)), 1);
var pixel = (tickWidth * index) + me.paddingLeft;
if (offset) {
pixel += tickWidth / 2;
}
var finalVal = me.left + Math.round(pixel);
finalVal += me.isFullWidth() ? me.margins.left : 0;
return finalVal;
}
var innerHeight = me.height - (me.paddingTop + me.paddingBottom);
return me.top + (index * (innerHeight / (me._ticks.length - 1)));
},
getPixelForDecimal: function(decimal) {
var me = this;
if (me.isHorizontal()) {
var innerWidth = me.width - (me.paddingLeft + me.paddingRight);
var valueOffset = (innerWidth * decimal) + me.paddingLeft;
var finalVal = me.left + Math.round(valueOffset);
finalVal += me.isFullWidth() ? me.margins.left : 0;
return finalVal;
}
return me.top + (decimal * me.height);
},
getBasePixel: function() {
return this.getPixelForValue(this.getBaseValue());
},
getBaseValue: function() {
var me = this;
var min = me.min;
var max = me.max;
return me.beginAtZero ? 0 :
min < 0 && max < 0 ? max :
min > 0 && max > 0 ? min :
0;
},
_autoSkip: function(ticks) {
var skipRatio;
var me = this;
var isHorizontal = me.isHorizontal();
var optionTicks = me.options.ticks.minor;
var tickCount = ticks.length;
var labelRotationRadians = helpers.toRadians(me.labelRotation);
var cosRotation = Math.cos(labelRotationRadians);
var longestRotatedLabel = me.longestLabelWidth * cosRotation;
var result = [];
var i, tick, shouldSkip;
var maxTicks;
if (optionTicks.maxTicksLimit) {
maxTicks = optionTicks.maxTicksLimit;
}
if (isHorizontal) {
skipRatio = false;
if ((longestRotatedLabel + optionTicks.autoSkipPadding) * tickCount > (me.width - (me.paddingLeft + me.paddingRight))) {
skipRatio = 1 + Math.floor(((longestRotatedLabel + optionTicks.autoSkipPadding) * tickCount) / (me.width - (me.paddingLeft + me.paddingRight)));
}
if (maxTicks && tickCount > maxTicks) {
skipRatio = Math.max(skipRatio, Math.floor(tickCount / maxTicks));
}
}
for (i = 0; i < tickCount; i++) {
tick = ticks[i];
shouldSkip = (skipRatio > 1 && i % skipRatio > 0) || (i % skipRatio === 0 && i + skipRatio >= tickCount);
if (shouldSkip && i !== tickCount - 1) {
delete tick.label;
}
result.push(tick);
}
return result;
},
draw: function(chartArea) {
var me = this;
var options = me.options;
if (!options.display) {
return;
}
var context = me.ctx;
var globalDefaults = defaults.global;
var optionTicks = options.ticks.minor;
var optionMajorTicks = options.ticks.major || optionTicks;
var gridLines = options.gridLines;
var scaleLabel = options.scaleLabel;
var isRotated = me.labelRotation !== 0;
var isHorizontal = me.isHorizontal();
var ticks = optionTicks.autoSkip ? me._autoSkip(me.getTicks()) : me.getTicks();
var tickFontColor = helpers.valueOrDefault(optionTicks.fontColor, globalDefaults.defaultFontColor);
var tickFont = parseFontOptions(optionTicks);
var majorTickFontColor = helpers.valueOrDefault(optionMajorTicks.fontColor, globalDefaults.defaultFontColor);
var majorTickFont = parseFontOptions(optionMajorTicks);
var tl = gridLines.drawTicks ? gridLines.tickMarkLength : 0;
var scaleLabelFontColor = helpers.valueOrDefault(scaleLabel.fontColor, globalDefaults.defaultFontColor);
var scaleLabelFont = parseFontOptions(scaleLabel);
var scaleLabelPadding = helpers.options.toPadding(scaleLabel.padding);
var labelRotationRadians = helpers.toRadians(me.labelRotation);
var itemsToDraw = [];
var xTickStart = options.position === 'right' ? me.left : me.right - tl;
var xTickEnd = options.position === 'right' ? me.left + tl : me.right;
var yTickStart = options.position === 'bottom' ? me.top : me.bottom - tl;
var yTickEnd = options.position === 'bottom' ? me.top + tl : me.bottom;
helpers.each(ticks, function(tick, index) {
if (helpers.isNullOrUndef(tick.label)) {
return;
}
var label = tick.label;
var lineWidth, lineColor, borderDash, borderDashOffset;
if (index === me.zeroLineIndex && options.offset === gridLines.offsetGridLines) {
lineWidth = gridLines.zeroLineWidth;
lineColor = gridLines.zeroLineColor;
borderDash = gridLines.zeroLineBorderDash;
borderDashOffset = gridLines.zeroLineBorderDashOffset;
} else {
lineWidth = helpers.valueAtIndexOrDefault(gridLines.lineWidth, index);
lineColor = helpers.valueAtIndexOrDefault(gridLines.color, index);
borderDash = helpers.valueOrDefault(gridLines.borderDash, globalDefaults.borderDash);
borderDashOffset = helpers.valueOrDefault(gridLines.borderDashOffset, globalDefaults.borderDashOffset);
}
var tx1, ty1, tx2, ty2, x1, y1, x2, y2, labelX, labelY;
var textAlign = 'middle';
var textBaseline = 'middle';
var tickPadding = optionTicks.padding;
if (isHorizontal) {
var labelYOffset = tl + tickPadding;
if (options.position === 'bottom') {
textBaseline = !isRotated ? 'top' : 'middle';
textAlign = !isRotated ? 'center' : 'right';
labelY = me.top + labelYOffset;
} else {
textBaseline = !isRotated ? 'bottom' : 'middle';
textAlign = !isRotated ? 'center' : 'left';
labelY = me.bottom - labelYOffset;
}
var xLineValue = getLineValue(me, index, gridLines.offsetGridLines && ticks.length > 1);
if (xLineValue < me.left) {
lineColor = 'rgba(0,0,0,0)';
}
xLineValue += helpers.aliasPixel(lineWidth);
labelX = me.getPixelForTick(index) + optionTicks.labelOffset; // x values for optionTicks (need to consider offsetLabel option)
tx1 = tx2 = x1 = x2 = xLineValue;
ty1 = yTickStart;
ty2 = yTickEnd;
y1 = chartArea.top;
y2 = chartArea.bottom;
} else {
var isLeft = options.position === 'left';
var labelXOffset;
if (optionTicks.mirror) {
textAlign = isLeft ? 'left' : 'right';
labelXOffset = tickPadding;
} else {
textAlign = isLeft ? 'right' : 'left';
labelXOffset = tl + tickPadding;
}
labelX = isLeft ? me.right - labelXOffset : me.left + labelXOffset;
var yLineValue = getLineValue(me, index, gridLines.offsetGridLines && ticks.length > 1);
if (yLineValue < me.top) {
lineColor = 'rgba(0,0,0,0)';
}
yLineValue += helpers.aliasPixel(lineWidth);
labelY = me.getPixelForTick(index) + optionTicks.labelOffset;
tx1 = xTickStart;
tx2 = xTickEnd;
x1 = chartArea.left;
x2 = chartArea.right;
ty1 = ty2 = y1 = y2 = yLineValue;
}
itemsToDraw.push({
tx1: tx1,
ty1: ty1,
tx2: tx2,
ty2: ty2,
x1: x1,
y1: y1,
x2: x2,
y2: y2,
labelX: labelX,
labelY: labelY,
glWidth: lineWidth,
glColor: lineColor,
glBorderDash: borderDash,
glBorderDashOffset: borderDashOffset,
rotation: -1 * labelRotationRadians,
label: label,
major: tick.major,
textBaseline: textBaseline,
textAlign: textAlign
});
});
helpers.each(itemsToDraw, function(itemToDraw) {
if (gridLines.display) {
context.save();
context.lineWidth = itemToDraw.glWidth;
context.strokeStyle = itemToDraw.glColor;
if (context.setLineDash) {
context.setLineDash(itemToDraw.glBorderDash);
context.lineDashOffset = itemToDraw.glBorderDashOffset;
}
context.beginPath();
if (gridLines.drawTicks) {
context.moveTo(itemToDraw.tx1, itemToDraw.ty1);
context.lineTo(itemToDraw.tx2, itemToDraw.ty2);
}
if (gridLines.drawOnChartArea) {
context.moveTo(itemToDraw.x1, itemToDraw.y1);
context.lineTo(itemToDraw.x2, itemToDraw.y2);
}
context.stroke();
context.restore();
}
if (optionTicks.display) {
context.save();
context.translate(itemToDraw.labelX, itemToDraw.labelY);
context.rotate(itemToDraw.rotation);
context.font = itemToDraw.major ? majorTickFont.font : tickFont.font;
context.fillStyle = itemToDraw.major ? majorTickFontColor : tickFontColor;
context.textBaseline = itemToDraw.textBaseline;
context.textAlign = itemToDraw.textAlign;
var label = itemToDraw.label;
if (helpers.isArray(label)) {
for (var i = 0, y = 0; i < label.length; ++i) {
context.fillText('' + label[i], 0, y);
y += (tickFont.size * 1.5);
}
} else {
context.fillText(label, 0, 0);
}
context.restore();
}
});
if (scaleLabel.display) {
var scaleLabelX;
var scaleLabelY;
var rotation = 0;
var halfLineHeight = parseLineHeight(scaleLabel) / 2;
if (isHorizontal) {
scaleLabelX = me.left + ((me.right - me.left) / 2); // midpoint of the width
scaleLabelY = options.position === 'bottom'
? me.bottom - halfLineHeight - scaleLabelPadding.bottom
: me.top + halfLineHeight + scaleLabelPadding.top;
} else {
var isLeft = options.position === 'left';
scaleLabelX = isLeft
? me.left + halfLineHeight + scaleLabelPadding.top
: me.right - halfLineHeight - scaleLabelPadding.top;
scaleLabelY = me.top + ((me.bottom - me.top) / 2);
rotation = isLeft ? -0.5 * Math.PI : 0.5 * Math.PI;
}
context.save();
context.translate(scaleLabelX, scaleLabelY);
context.rotate(rotation);
context.textAlign = 'center';
context.textBaseline = 'middle';
context.fillStyle = scaleLabelFontColor; // render in correct colour
context.font = scaleLabelFont.font;
context.fillText(scaleLabel.labelString, 0, 0);
context.restore();
}
if (gridLines.drawBorder) {
context.lineWidth = helpers.valueAtIndexOrDefault(gridLines.lineWidth, 0);
context.strokeStyle = helpers.valueAtIndexOrDefault(gridLines.color, 0);
var x1 = me.left;
var x2 = me.right;
var y1 = me.top;
var y2 = me.bottom;
var aliasPixel = helpers.aliasPixel(context.lineWidth);
if (isHorizontal) {
y1 = y2 = options.position === 'top' ? me.bottom : me.top;
y1 += aliasPixel;
y2 += aliasPixel;
} else {
x1 = x2 = options.position === 'left' ? me.right : me.left;
x1 += aliasPixel;
x2 += aliasPixel;
}
context.beginPath();
context.moveTo(x1, y1);
context.lineTo(x2, y2);
context.stroke();
}
}
});
};
},{"25":25,"26":26,"34":34,"45":45}],33:[function(require,module,exports){
'use strict';
var defaults = require(25);
var helpers = require(45);
module.exports = function(Chart) {
Chart.scaleService = {
constructors: {},
defaults: {},
registerScaleType: function(type, scaleConstructor, scaleDefaults) {
this.constructors[type] = scaleConstructor;
this.defaults[type] = helpers.clone(scaleDefaults);
},
getScaleConstructor: function(type) {
return this.constructors.hasOwnProperty(type) ? this.constructors[type] : undefined;
},
getScaleDefaults: function(type) {
return this.defaults.hasOwnProperty(type) ? helpers.merge({}, [defaults.scale, this.defaults[type]]) : {};
},
updateScaleDefaults: function(type, additions) {
var me = this;
if (me.defaults.hasOwnProperty(type)) {
me.defaults[type] = helpers.extend(me.defaults[type], additions);
}
},
addScalesToLayout: function(chart) {
helpers.each(chart.scales, function(scale) {
scale.fullWidth = scale.options.fullWidth;
scale.position = scale.options.position;
scale.weight = scale.options.weight;
Chart.layoutService.addBox(chart, scale);
});
}
};
};
},{"25":25,"45":45}],34:[function(require,module,exports){
'use strict';
var helpers = require(45);
module.exports = {
generators: {
linear: function(generationOptions, dataRange) {
var ticks = [];
var spacing;
if (generationOptions.stepSize && generationOptions.stepSize > 0) {
spacing = generationOptions.stepSize;
} else {
var niceRange = helpers.niceNum(dataRange.max - dataRange.min, false);
spacing = helpers.niceNum(niceRange / (generationOptions.maxTicks - 1), true);
}
var niceMin = Math.floor(dataRange.min / spacing) * spacing;
var niceMax = Math.ceil(dataRange.max / spacing) * spacing;
if (generationOptions.min && generationOptions.max && generationOptions.stepSize) {
if (helpers.almostWhole((generationOptions.max - generationOptions.min) / generationOptions.stepSize, spacing / 1000)) {
niceMin = generationOptions.min;
niceMax = generationOptions.max;
}
}
var numSpaces = (niceMax - niceMin) / spacing;
if (helpers.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {
numSpaces = Math.round(numSpaces);
} else {
numSpaces = Math.ceil(numSpaces);
}
ticks.push(generationOptions.min !== undefined ? generationOptions.min : niceMin);
for (var j = 1; j < numSpaces; ++j) {
ticks.push(niceMin + (j * spacing));
}
ticks.push(generationOptions.max !== undefined ? generationOptions.max : niceMax);
return ticks;
},
logarithmic: function(generationOptions, dataRange) {
var ticks = [];
var valueOrDefault = helpers.valueOrDefault;
var tickVal = valueOrDefault(generationOptions.min, Math.pow(10, Math.floor(helpers.log10(dataRange.min))));
var endExp = Math.floor(helpers.log10(dataRange.max));
var endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));
var exp, significand;
if (tickVal === 0) {
exp = Math.floor(helpers.log10(dataRange.minNotZero));
significand = Math.floor(dataRange.minNotZero / Math.pow(10, exp));
ticks.push(tickVal);
tickVal = significand * Math.pow(10, exp);
} else {
exp = Math.floor(helpers.log10(tickVal));
significand = Math.floor(tickVal / Math.pow(10, exp));
}
do {
ticks.push(tickVal);
++significand;
if (significand === 10) {
significand = 1;
++exp;
}
tickVal = significand * Math.pow(10, exp);
} while (exp < endExp || (exp === endExp && significand < endSignificand));
var lastTick = valueOrDefault(generationOptions.max, tickVal);
ticks.push(lastTick);
return ticks;
}
},
formatters: {
values: function(value) {
return helpers.isArray(value) ? value : '' + value;
},
linear: function(tickValue, index, ticks) {
var delta = ticks.length > 3 ? ticks[2] - ticks[1] : ticks[1] - ticks[0];
if (Math.abs(delta) > 1) {
if (tickValue !== Math.floor(tickValue)) {
delta = tickValue - Math.floor(tickValue);
}
}
var logDelta = helpers.log10(Math.abs(delta));
var tickString = '';
if (tickValue !== 0) {
var numDecimal = -1 * Math.floor(logDelta);
numDecimal = Math.max(Math.min(numDecimal, 20), 0); // toFixed has a max of 20 decimal places
tickString = tickValue.toFixed(numDecimal);
} else {
tickString = '0'; // never show decimal places for 0
}
return tickString;
},
logarithmic: function(tickValue, index, ticks) {
var remain = tickValue / (Math.pow(10, Math.floor(helpers.log10(tickValue))));
if (tickValue === 0) {
return '0';
} else if (remain === 1 || remain === 2 || remain === 5 || index === 0 || index === ticks.length - 1) {
return tickValue.toExponential();
}
return '';
}
}
};
},{"45":45}],35:[function(require,module,exports){
'use strict';
var defaults = require(25);
var Element = require(26);
var helpers = require(45);
defaults._set('global', {
tooltips: {
enabled: true,
custom: null,
mode: 'nearest',
position: 'average',
intersect: true,
backgroundColor: 'rgba(0,0,0,0.8)',
titleFontStyle: 'bold',
titleSpacing: 2,
titleMarginBottom: 6,
titleFontColor: '#fff',
titleAlign: 'left',
bodySpacing: 2,
bodyFontColor: '#fff',
bodyAlign: 'left',
footerFontStyle: 'bold',
footerSpacing: 2,
footerMarginTop: 6,
footerFontColor: '#fff',
footerAlign: 'left',
yPadding: 6,
xPadding: 6,
caretPadding: 2,
caretSize: 5,
cornerRadius: 6,
multiKeyBackground: '#fff',
displayColors: true,
borderColor: 'rgba(0,0,0,0)',
borderWidth: 0,
callbacks: {
beforeTitle: helpers.noop,
title: function(tooltipItems, data) {
var title = '';
var labels = data.labels;
var labelCount = labels ? labels.length : 0;
if (tooltipItems.length > 0) {
var item = tooltipItems[0];
if (item.xLabel) {
title = item.xLabel;
} else if (labelCount > 0 && item.index < labelCount) {
title = labels[item.index];
}
}
return title;
},
afterTitle: helpers.noop,
beforeBody: helpers.noop,
beforeLabel: helpers.noop,
label: function(tooltipItem, data) {
var label = data.datasets[tooltipItem.datasetIndex].label || '';
if (label) {
label += ': ';
}
label += tooltipItem.yLabel;
return label;
},
labelColor: function(tooltipItem, chart) {
var meta = chart.getDatasetMeta(tooltipItem.datasetIndex);
var activeElement = meta.data[tooltipItem.index];
var view = activeElement._view;
return {
borderColor: view.borderColor,
backgroundColor: view.backgroundColor
};
},
labelTextColor: function() {
return this._options.bodyFontColor;
},
afterLabel: helpers.noop,
afterBody: helpers.noop,
beforeFooter: helpers.noop,
footer: helpers.noop,
afterFooter: helpers.noop
}
}
});
module.exports = function(Chart) {
function mergeOpacity(colorString, opacity) {
var color = helpers.color(colorString);
return color.alpha(opacity * color.alpha()).rgbaString();
}
function pushOrConcat(base, toPush) {
if (toPush) {
if (helpers.isArray(toPush)) {
Array.prototype.push.apply(base, toPush);
} else {
base.push(toPush);
}
}
return base;
}
function createTooltipItem(element) {
var xScale = element._xScale;
var yScale = element._yScale || element._scale; // handle radar || polarArea charts
var index = element._index;
var datasetIndex = element._datasetIndex;
return {
xLabel: xScale ? xScale.getLabelForIndex(index, datasetIndex) : '',
yLabel: yScale ? yScale.getLabelForIndex(index, datasetIndex) : '',
index: index,
datasetIndex: datasetIndex,
x: element._model.x,
y: element._model.y
};
}
function getBaseModel(tooltipOpts) {
var globalDefaults = defaults.global;
var valueOrDefault = helpers.valueOrDefault;
return {
xPadding: tooltipOpts.xPadding,
yPadding: tooltipOpts.yPadding,
xAlign: tooltipOpts.xAlign,
yAlign: tooltipOpts.yAlign,
bodyFontColor: tooltipOpts.bodyFontColor,
_bodyFontFamily: valueOrDefault(tooltipOpts.bodyFontFamily, globalDefaults.defaultFontFamily),
_bodyFontStyle: valueOrDefault(tooltipOpts.bodyFontStyle, globalDefaults.defaultFontStyle),
_bodyAlign: tooltipOpts.bodyAlign,
bodyFontSize: valueOrDefault(tooltipOpts.bodyFontSize, globalDefaults.defaultFontSize),
bodySpacing: tooltipOpts.bodySpacing,
titleFontColor: tooltipOpts.titleFontColor,
_titleFontFamily: valueOrDefault(tooltipOpts.titleFontFamily, globalDefaults.defaultFontFamily),
_titleFontStyle: valueOrDefault(tooltipOpts.titleFontStyle, globalDefaults.defaultFontStyle),
titleFontSize: valueOrDefault(tooltipOpts.titleFontSize, globalDefaults.defaultFontSize),
_titleAlign: tooltipOpts.titleAlign,
titleSpacing: tooltipOpts.titleSpacing,
titleMarginBottom: tooltipOpts.titleMarginBottom,
footerFontColor: tooltipOpts.footerFontColor,
_footerFontFamily: valueOrDefault(tooltipOpts.footerFontFamily, globalDefaults.defaultFontFamily),
_footerFontStyle: valueOrDefault(tooltipOpts.footerFontStyle, globalDefaults.defaultFontStyle),
footerFontSize: valueOrDefault(tooltipOpts.footerFontSize, globalDefaults.defaultFontSize),
_footerAlign: tooltipOpts.footerAlign,
footerSpacing: tooltipOpts.footerSpacing,
footerMarginTop: tooltipOpts.footerMarginTop,
caretSize: tooltipOpts.caretSize,
cornerRadius: tooltipOpts.cornerRadius,
backgroundColor: tooltipOpts.backgroundColor,
opacity: 0,
legendColorBackground: tooltipOpts.multiKeyBackground,
displayColors: tooltipOpts.displayColors,
borderColor: tooltipOpts.borderColor,
borderWidth: tooltipOpts.borderWidth
};
}
function getTooltipSize(tooltip, model) {
var ctx = tooltip._chart.ctx;
var height = model.yPadding * 2; // Tooltip Padding
var width = 0;
var body = model.body;
var combinedBodyLength = body.reduce(function(count, bodyItem) {
return count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length;
}, 0);
combinedBodyLength += model.beforeBody.length + model.afterBody.length;
var titleLineCount = model.title.length;
var footerLineCount = model.footer.length;
var titleFontSize = model.titleFontSize;
var bodyFontSize = model.bodyFontSize;
var footerFontSize = model.footerFontSize;
height += titleLineCount * titleFontSize; // Title Lines
height += titleLineCount ? (titleLineCount - 1) * model.titleSpacing : 0; // Title Line Spacing
height += titleLineCount ? model.titleMarginBottom : 0; // Title's bottom Margin
height += combinedBodyLength * bodyFontSize; // Body Lines
height += combinedBodyLength ? (combinedBodyLength - 1) * model.bodySpacing : 0; // Body Line Spacing
height += footerLineCount ? model.footerMarginTop : 0; // Footer Margin
height += footerLineCount * (footerFontSize); // Footer Lines
height += footerLineCount ? (footerLineCount - 1) * model.footerSpacing : 0; // Footer Line Spacing
var widthPadding = 0;
var maxLineWidth = function(line) {
width = Math.max(width, ctx.measureText(line).width + widthPadding);
};
ctx.font = helpers.fontString(titleFontSize, model._titleFontStyle, model._titleFontFamily);
helpers.each(model.title, maxLineWidth);
ctx.font = helpers.fontString(bodyFontSize, model._bodyFontStyle, model._bodyFontFamily);
helpers.each(model.beforeBody.concat(model.afterBody), maxLineWidth);
widthPadding = model.displayColors ? (bodyFontSize + 2) : 0;
helpers.each(body, function(bodyItem) {
helpers.each(bodyItem.before, maxLineWidth);
helpers.each(bodyItem.lines, maxLineWidth);
helpers.each(bodyItem.after, maxLineWidth);
});
widthPadding = 0;
ctx.font = helpers.fontString(footerFontSize, model._footerFontStyle, model._footerFontFamily);
helpers.each(model.footer, maxLineWidth);
width += 2 * model.xPadding;
return {
width: width,
height: height
};
}
function determineAlignment(tooltip, size) {
var model = tooltip._model;
var chart = tooltip._chart;
var chartArea = tooltip._chart.chartArea;
var xAlign = 'center';
var yAlign = 'center';
if (model.y < size.height) {
yAlign = 'top';
} else if (model.y > (chart.height - size.height)) {
yAlign = 'bottom';
}
var lf, rf; // functions to determine left, right alignment
var olf, orf; // functions to determine if left/right alignment causes tooltip to go outside chart
var yf; // function to get the y alignment if the tooltip goes outside of the left or right edges
var midX = (chartArea.left + chartArea.right) / 2;
var midY = (chartArea.top + chartArea.bottom) / 2;
if (yAlign === 'center') {
lf = function(x) {
return x <= midX;
};
rf = function(x) {
return x > midX;
};
} else {
lf = function(x) {
return x <= (size.width / 2);
};
rf = function(x) {
return x >= (chart.width - (size.width / 2));
};
}
olf = function(x) {
return x + size.width > chart.width;
};
orf = function(x) {
return x - size.width < 0;
};
yf = function(y) {
return y <= midY ? 'top' : 'bottom';
};
if (lf(model.x)) {
xAlign = 'left';
if (olf(model.x)) {
xAlign = 'center';
yAlign = yf(model.y);
}
} else if (rf(model.x)) {
xAlign = 'right';
if (orf(model.x)) {
xAlign = 'center';
yAlign = yf(model.y);
}
}
var opts = tooltip._options;
return {
xAlign: opts.xAlign ? opts.xAlign : xAlign,
yAlign: opts.yAlign ? opts.yAlign : yAlign
};
}
function getBackgroundPoint(vm, size, alignment) {
var x = vm.x;
var y = vm.y;
var caretSize = vm.caretSize;
var caretPadding = vm.caretPadding;
var cornerRadius = vm.cornerRadius;
var xAlign = alignment.xAlign;
var yAlign = alignment.yAlign;
var paddingAndSize = caretSize + caretPadding;
var radiusAndPadding = cornerRadius + caretPadding;
if (xAlign === 'right') {
x -= size.width;
} else if (xAlign === 'center') {
x -= (size.width / 2);
}
if (yAlign === 'top') {
y += paddingAndSize;
} else if (yAlign === 'bottom') {
y -= size.height + paddingAndSize;
} else {
y -= (size.height / 2);
}
if (yAlign === 'center') {
if (xAlign === 'left') {
x += paddingAndSize;
} else if (xAlign === 'right') {
x -= paddingAndSize;
}
} else if (xAlign === 'left') {
x -= radiusAndPadding;
} else if (xAlign === 'right') {
x += radiusAndPadding;
}
return {
x: x,
y: y
};
}
Chart.Tooltip = Element.extend({
initialize: function() {
this._model = getBaseModel(this._options);
this._lastActive = [];
},
getTitle: function() {
var me = this;
var opts = me._options;
var callbacks = opts.callbacks;
var beforeTitle = callbacks.beforeTitle.apply(me, arguments);
var title = callbacks.title.apply(me, arguments);
var afterTitle = callbacks.afterTitle.apply(me, arguments);
var lines = [];
lines = pushOrConcat(lines, beforeTitle);
lines = pushOrConcat(lines, title);
lines = pushOrConcat(lines, afterTitle);
return lines;
},
getBeforeBody: function() {
var lines = this._options.callbacks.beforeBody.apply(this, arguments);
return helpers.isArray(lines) ? lines : lines !== undefined ? [lines] : [];
},
getBody: function(tooltipItems, data) {
var me = this;
var callbacks = me._options.callbacks;
var bodyItems = [];
helpers.each(tooltipItems, function(tooltipItem) {
var bodyItem = {
before: [],
lines: [],
after: []
};
pushOrConcat(bodyItem.before, callbacks.beforeLabel.call(me, tooltipItem, data));
pushOrConcat(bodyItem.lines, callbacks.label.call(me, tooltipItem, data));
pushOrConcat(bodyItem.after, callbacks.afterLabel.call(me, tooltipItem, data));
bodyItems.push(bodyItem);
});
return bodyItems;
},
getAfterBody: function() {
var lines = this._options.callbacks.afterBody.apply(this, arguments);
return helpers.isArray(lines) ? lines : lines !== undefined ? [lines] : [];
},
getFooter: function() {
var me = this;
var callbacks = me._options.callbacks;
var beforeFooter = callbacks.beforeFooter.apply(me, arguments);
var footer = callbacks.footer.apply(me, arguments);
var afterFooter = callbacks.afterFooter.apply(me, arguments);
var lines = [];
lines = pushOrConcat(lines, beforeFooter);
lines = pushOrConcat(lines, footer);
lines = pushOrConcat(lines, afterFooter);
return lines;
},
update: function(changed) {
var me = this;
var opts = me._options;
var existingModel = me._model;
var model = me._model = getBaseModel(opts);
var active = me._active;
var data = me._data;
var alignment = {
xAlign: existingModel.xAlign,
yAlign: existingModel.yAlign
};
var backgroundPoint = {
x: existingModel.x,
y: existingModel.y
};
var tooltipSize = {
width: existingModel.width,
height: existingModel.height
};
var tooltipPosition = {
x: existingModel.caretX,
y: existingModel.caretY
};
var i, len;
if (active.length) {
model.opacity = 1;
var labelColors = [];
var labelTextColors = [];
tooltipPosition = Chart.Tooltip.positioners[opts.position].call(me, active, me._eventPosition);
var tooltipItems = [];
for (i = 0, len = active.length; i < len; ++i) {
tooltipItems.push(createTooltipItem(active[i]));
}
if (opts.filter) {
tooltipItems = tooltipItems.filter(function(a) {
return opts.filter(a, data);
});
}
if (opts.itemSort) {
tooltipItems = tooltipItems.sort(function(a, b) {
return opts.itemSort(a, b, data);
});
}
helpers.each(tooltipItems, function(tooltipItem) {
labelColors.push(opts.callbacks.labelColor.call(me, tooltipItem, me._chart));
labelTextColors.push(opts.callbacks.labelTextColor.call(me, tooltipItem, me._chart));
});
model.title = me.getTitle(tooltipItems, data);
model.beforeBody = me.getBeforeBody(tooltipItems, data);
model.body = me.getBody(tooltipItems, data);
model.afterBody = me.getAfterBody(tooltipItems, data);
model.footer = me.getFooter(tooltipItems, data);
model.x = Math.round(tooltipPosition.x);
model.y = Math.round(tooltipPosition.y);
model.caretPadding = opts.caretPadding;
model.labelColors = labelColors;
model.labelTextColors = labelTextColors;
model.dataPoints = tooltipItems;
tooltipSize = getTooltipSize(this, model);
alignment = determineAlignment(this, tooltipSize);
backgroundPoint = getBackgroundPoint(model, tooltipSize, alignment);
} else {
model.opacity = 0;
}
model.xAlign = alignment.xAlign;
model.yAlign = alignment.yAlign;
model.x = backgroundPoint.x;
model.y = backgroundPoint.y;
model.width = tooltipSize.width;
model.height = tooltipSize.height;
model.caretX = tooltipPosition.x;
model.caretY = tooltipPosition.y;
me._model = model;
if (changed && opts.custom) {
opts.custom.call(me, model);
}
return me;
},
drawCaret: function(tooltipPoint, size) {
var ctx = this._chart.ctx;
var vm = this._view;
var caretPosition = this.getCaretPosition(tooltipPoint, size, vm);
ctx.lineTo(caretPosition.x1, caretPosition.y1);
ctx.lineTo(caretPosition.x2, caretPosition.y2);
ctx.lineTo(caretPosition.x3, caretPosition.y3);
},
getCaretPosition: function(tooltipPoint, size, vm) {
var x1, x2, x3, y1, y2, y3;
var caretSize = vm.caretSize;
var cornerRadius = vm.cornerRadius;
var xAlign = vm.xAlign;
var yAlign = vm.yAlign;
var ptX = tooltipPoint.x;
var ptY = tooltipPoint.y;
var width = size.width;
var height = size.height;
if (yAlign === 'center') {
y2 = ptY + (height / 2);
if (xAlign === 'left') {
x1 = ptX;
x2 = x1 - caretSize;
x3 = x1;
y1 = y2 + caretSize;
y3 = y2 - caretSize;
} else {
x1 = ptX + width;
x2 = x1 + caretSize;
x3 = x1;
y1 = y2 - caretSize;
y3 = y2 + caretSize;
}
} else {
if (xAlign === 'left') {
x2 = ptX + cornerRadius + (caretSize);
x1 = x2 - caretSize;
x3 = x2 + caretSize;
} else if (xAlign === 'right') {
x2 = ptX + width - cornerRadius - caretSize;
x1 = x2 - caretSize;
x3 = x2 + caretSize;
} else {
x2 = ptX + (width / 2);
x1 = x2 - caretSize;
x3 = x2 + caretSize;
}
if (yAlign === 'top') {
y1 = ptY;
y2 = y1 - caretSize;
y3 = y1;
} else {
y1 = ptY + height;
y2 = y1 + caretSize;
y3 = y1;
var tmp = x3;
x3 = x1;
x1 = tmp;
}
}
return {x1: x1, x2: x2, x3: x3, y1: y1, y2: y2, y3: y3};
},
drawTitle: function(pt, vm, ctx, opacity) {
var title = vm.title;
if (title.length) {
ctx.textAlign = vm._titleAlign;
ctx.textBaseline = 'top';
var titleFontSize = vm.titleFontSize;
var titleSpacing = vm.titleSpacing;
ctx.fillStyle = mergeOpacity(vm.titleFontColor, opacity);
ctx.font = helpers.fontString(titleFontSize, vm._titleFontStyle, vm._titleFontFamily);
var i, len;
for (i = 0, len = title.length; i < len; ++i) {
ctx.fillText(title[i], pt.x, pt.y);
pt.y += titleFontSize + titleSpacing; // Line Height and spacing
if (i + 1 === title.length) {
pt.y += vm.titleMarginBottom - titleSpacing; // If Last, add margin, remove spacing
}
}
}
},
drawBody: function(pt, vm, ctx, opacity) {
var bodyFontSize = vm.bodyFontSize;
var bodySpacing = vm.bodySpacing;
var body = vm.body;
ctx.textAlign = vm._bodyAlign;
ctx.textBaseline = 'top';
ctx.font = helpers.fontString(bodyFontSize, vm._bodyFontStyle, vm._bodyFontFamily);
var xLinePadding = 0;
var fillLineOfText = function(line) {
ctx.fillText(line, pt.x + xLinePadding, pt.y);
pt.y += bodyFontSize + bodySpacing;
};
ctx.fillStyle = mergeOpacity(vm.bodyFontColor, opacity);
helpers.each(vm.beforeBody, fillLineOfText);
var drawColorBoxes = vm.displayColors;
xLinePadding = drawColorBoxes ? (bodyFontSize + 2) : 0;
helpers.each(body, function(bodyItem, i) {
var textColor = mergeOpacity(vm.labelTextColors[i], opacity);
ctx.fillStyle = textColor;
helpers.each(bodyItem.before, fillLineOfText);
helpers.each(bodyItem.lines, function(line) {
if (drawColorBoxes) {
ctx.fillStyle = mergeOpacity(vm.legendColorBackground, opacity);
ctx.fillRect(pt.x, pt.y, bodyFontSize, bodyFontSize);
ctx.lineWidth = 1;
ctx.strokeStyle = mergeOpacity(vm.labelColors[i].borderColor, opacity);
ctx.strokeRect(pt.x, pt.y, bodyFontSize, bodyFontSize);
ctx.fillStyle = mergeOpacity(vm.labelColors[i].backgroundColor, opacity);
ctx.fillRect(pt.x + 1, pt.y + 1, bodyFontSize - 2, bodyFontSize - 2);
ctx.fillStyle = textColor;
}
fillLineOfText(line);
});
helpers.each(bodyItem.after, fillLineOfText);
});
xLinePadding = 0;
helpers.each(vm.afterBody, fillLineOfText);
pt.y -= bodySpacing; // Remove last body spacing
},
drawFooter: function(pt, vm, ctx, opacity) {
var footer = vm.footer;
if (footer.length) {
pt.y += vm.footerMarginTop;
ctx.textAlign = vm._footerAlign;
ctx.textBaseline = 'top';
ctx.fillStyle = mergeOpacity(vm.footerFontColor, opacity);
ctx.font = helpers.fontString(vm.footerFontSize, vm._footerFontStyle, vm._footerFontFamily);
helpers.each(footer, function(line) {
ctx.fillText(line, pt.x, pt.y);
pt.y += vm.footerFontSize + vm.footerSpacing;
});
}
},
drawBackground: function(pt, vm, ctx, tooltipSize, opacity) {
ctx.fillStyle = mergeOpacity(vm.backgroundColor, opacity);
ctx.strokeStyle = mergeOpacity(vm.borderColor, opacity);
ctx.lineWidth = vm.borderWidth;
var xAlign = vm.xAlign;
var yAlign = vm.yAlign;
var x = pt.x;
var y = pt.y;
var width = tooltipSize.width;
var height = tooltipSize.height;
var radius = vm.cornerRadius;
ctx.beginPath();
ctx.moveTo(x + radius, y);
if (yAlign === 'top') {
this.drawCaret(pt, tooltipSize);
}
ctx.lineTo(x + width - radius, y);
ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
if (yAlign === 'center' && xAlign === 'right') {
this.drawCaret(pt, tooltipSize);
}
ctx.lineTo(x + width, y + height - radius);
ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
if (yAlign === 'bottom') {
this.drawCaret(pt, tooltipSize);
}
ctx.lineTo(x + radius, y + height);
ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
if (yAlign === 'center' && xAlign === 'left') {
this.drawCaret(pt, tooltipSize);
}
ctx.lineTo(x, y + radius);
ctx.quadraticCurveTo(x, y, x + radius, y);
ctx.closePath();
ctx.fill();
if (vm.borderWidth > 0) {
ctx.stroke();
}
},
draw: function() {
var ctx = this._chart.ctx;
var vm = this._view;
if (vm.opacity === 0) {
return;
}
var tooltipSize = {
width: vm.width,
height: vm.height
};
var pt = {
x: vm.x,
y: vm.y
};
var opacity = Math.abs(vm.opacity < 1e-3) ? 0 : vm.opacity;
var hasTooltipContent = vm.title.length || vm.beforeBody.length || vm.body.length || vm.afterBody.length || vm.footer.length;
if (this._options.enabled && hasTooltipContent) {
this.drawBackground(pt, vm, ctx, tooltipSize, opacity);
pt.x += vm.xPadding;
pt.y += vm.yPadding;
this.drawTitle(pt, vm, ctx, opacity);
this.drawBody(pt, vm, ctx, opacity);
this.drawFooter(pt, vm, ctx, opacity);
}
},
handleEvent: function(e) {
var me = this;
var options = me._options;
var changed = false;
me._lastActive = me._lastActive || [];
if (e.type === 'mouseout') {
me._active = [];
} else {
me._active = me._chart.getElementsAtEventForMode(e, options.mode, options);
}
changed = !helpers.arrayEquals(me._active, me._lastActive);
if (!changed) {
return false;
}
me._lastActive = me._active;
if (options.enabled || options.custom) {
me._eventPosition = {
x: e.x,
y: e.y
};
var model = me._model;
me.update(true);
me.pivot();
changed |= (model.x !== me._model.x) || (model.y !== me._model.y);
}
return changed;
}
});
Chart.Tooltip.positioners = {
average: function(elements) {
if (!elements.length) {
return false;
}
var i, len;
var x = 0;
var y = 0;
var count = 0;
for (i = 0, len = elements.length; i < len; ++i) {
var el = elements[i];
if (el && el.hasValue()) {
var pos = el.tooltipPosition();
x += pos.x;
y += pos.y;
++count;
}
}
return {
x: Math.round(x / count),
y: Math.round(y / count)
};
},
nearest: function(elements, eventPosition) {
var x = eventPosition.x;
var y = eventPosition.y;
var minDistance = Number.POSITIVE_INFINITY;
var i, len, nearestElement;
for (i = 0, len = elements.length; i < len; ++i) {
var el = elements[i];
if (el && el.hasValue()) {
var center = el.getCenterPoint();
var d = helpers.distanceBetweenPoints(eventPosition, center);
if (d < minDistance) {
minDistance = d;
nearestElement = el;
}
}
}
if (nearestElement) {
var tp = nearestElement.tooltipPosition();
x = tp.x;
y = tp.y;
}
return {
x: x,
y: y
};
}
};
};
},{"25":25,"26":26,"45":45}],36:[function(require,module,exports){
'use strict';
var defaults = require(25);
var Element = require(26);
var helpers = require(45);
defaults._set('global', {
elements: {
arc: {
backgroundColor: defaults.global.defaultColor,
borderColor: '#fff',
borderWidth: 2
}
}
});
module.exports = Element.extend({
inLabelRange: function(mouseX) {
var vm = this._view;
if (vm) {
return (Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hoverRadius, 2));
}
return false;
},
inRange: function(chartX, chartY) {
var vm = this._view;
if (vm) {
var pointRelativePosition = helpers.getAngleFromPoint(vm, {x: chartX, y: chartY});
var	angle = pointRelativePosition.angle;
var distance = pointRelativePosition.distance;
var startAngle = vm.startAngle;
var endAngle = vm.endAngle;
while (endAngle < startAngle) {
endAngle += 2.0 * Math.PI;
}
while (angle > endAngle) {
angle -= 2.0 * Math.PI;
}
while (angle < startAngle) {
angle += 2.0 * Math.PI;
}
var betweenAngles = (angle >= startAngle && angle <= endAngle);
var withinRadius = (distance >= vm.innerRadius && distance <= vm.outerRadius);
return (betweenAngles && withinRadius);
}
return false;
},
getCenterPoint: function() {
var vm = this._view;
var halfAngle = (vm.startAngle + vm.endAngle) / 2;
var halfRadius = (vm.innerRadius + vm.outerRadius) / 2;
return {
x: vm.x + Math.cos(halfAngle) * halfRadius,
y: vm.y + Math.sin(halfAngle) * halfRadius
};
},
getArea: function() {
var vm = this._view;
return Math.PI * ((vm.endAngle - vm.startAngle) / (2 * Math.PI)) * (Math.pow(vm.outerRadius, 2) - Math.pow(vm.innerRadius, 2));
},
tooltipPosition: function() {
var vm = this._view;
var centreAngle = vm.startAngle + ((vm.endAngle - vm.startAngle) / 2);
var rangeFromCentre = (vm.outerRadius - vm.innerRadius) / 2 + vm.innerRadius;
return {
x: vm.x + (Math.cos(centreAngle) * rangeFromCentre),
y: vm.y + (Math.sin(centreAngle) * rangeFromCentre)
};
},
draw: function() {
var ctx = this._chart.ctx;
var vm = this._view;
var sA = vm.startAngle;
var eA = vm.endAngle;
ctx.beginPath();
ctx.arc(vm.x, vm.y, vm.outerRadius, sA, eA);
ctx.arc(vm.x, vm.y, vm.innerRadius, eA, sA, true);
ctx.closePath();
ctx.strokeStyle = vm.borderColor;
ctx.lineWidth = vm.borderWidth;
ctx.fillStyle = vm.backgroundColor;
ctx.fill();
ctx.lineJoin = 'bevel';
if (vm.borderWidth) {
ctx.stroke();
}
}
});
},{"25":25,"26":26,"45":45}],37:[function(require,module,exports){
'use strict';
var defaults = require(25);
var Element = require(26);
var helpers = require(45);
var globalDefaults = defaults.global;
defaults._set('global', {
elements: {
line: {
tension: 0.4,
backgroundColor: globalDefaults.defaultColor,
borderWidth: 3,
borderColor: globalDefaults.defaultColor,
borderCapStyle: 'butt',
borderDash: [],
borderDashOffset: 0.0,
borderJoinStyle: 'miter',
capBezierPoints: true,
fill: true, // do we fill in the area between the line and its base axis
}
}
});
module.exports = Element.extend({
draw: function() {
var me = this;
var vm = me._view;
var ctx = me._chart.ctx;
var spanGaps = vm.spanGaps;
var points = me._children.slice(); // clone array
var globalOptionLineElements = globalDefaults.elements.line;
var lastDrawnIndex = -1;
var index, current, previous, currentVM;
if (me._loop && points.length) {
points.push(points[0]);
}
ctx.save();
ctx.lineCap = vm.borderCapStyle || globalOptionLineElements.borderCapStyle;
if (ctx.setLineDash) {
ctx.setLineDash(vm.borderDash || globalOptionLineElements.borderDash);
}
ctx.lineDashOffset = vm.borderDashOffset || globalOptionLineElements.borderDashOffset;
ctx.lineJoin = vm.borderJoinStyle || globalOptionLineElements.borderJoinStyle;
ctx.lineWidth = vm.borderWidth || globalOptionLineElements.borderWidth;
ctx.strokeStyle = vm.borderColor || globalDefaults.defaultColor;
ctx.beginPath();
lastDrawnIndex = -1;
for (index = 0; index < points.length; ++index) {
current = points[index];
previous = helpers.previousItem(points, index);
currentVM = current._view;
if (index === 0) {
if (!currentVM.skip) {
ctx.moveTo(currentVM.x, currentVM.y);
lastDrawnIndex = index;
}
} else {
previous = lastDrawnIndex === -1 ? previous : points[lastDrawnIndex];
if (!currentVM.skip) {
if ((lastDrawnIndex !== (index - 1) && !spanGaps) || lastDrawnIndex === -1) {
ctx.moveTo(currentVM.x, currentVM.y);
} else {
helpers.canvas.lineTo(ctx, previous._view, current._view);
}
lastDrawnIndex = index;
}
}
}
ctx.stroke();
ctx.restore();
}
});
},{"25":25,"26":26,"45":45}],38:[function(require,module,exports){
'use strict';
var defaults = require(25);
var Element = require(26);
var helpers = require(45);
var defaultColor = defaults.global.defaultColor;
defaults._set('global', {
elements: {
point: {
radius: 3,
pointStyle: 'circle',
backgroundColor: defaultColor,
borderColor: defaultColor,
borderWidth: 1,
hitRadius: 1,
hoverRadius: 4,
hoverBorderWidth: 1
}
}
});
function xRange(mouseX) {
var vm = this._view;
return vm ? (Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hitRadius, 2)) : false;
}
function yRange(mouseY) {
var vm = this._view;
return vm ? (Math.pow(mouseY - vm.y, 2) < Math.pow(vm.radius + vm.hitRadius, 2)) : false;
}
module.exports = Element.extend({
inRange: function(mouseX, mouseY) {
var vm = this._view;
return vm ? ((Math.pow(mouseX - vm.x, 2) + Math.pow(mouseY - vm.y, 2)) < Math.pow(vm.hitRadius + vm.radius, 2)) : false;
},
inLabelRange: xRange,
inXRange: xRange,
inYRange: yRange,
getCenterPoint: function() {
var vm = this._view;
return {
x: vm.x,
y: vm.y
};
},
getArea: function() {
return Math.PI * Math.pow(this._view.radius, 2);
},
tooltipPosition: function() {
var vm = this._view;
return {
x: vm.x,
y: vm.y,
padding: vm.radius + vm.borderWidth
};
},
draw: function(chartArea) {
var vm = this._view;
var model = this._model;
var ctx = this._chart.ctx;
var pointStyle = vm.pointStyle;
var radius = vm.radius;
var x = vm.x;
var y = vm.y;
var color = helpers.color;
var errMargin = 1.01; // 1.01 is margin for Accumulated error. (Especially Edge, IE.)
var ratio = 0;
if (vm.skip) {
return;
}
ctx.strokeStyle = vm.borderColor || defaultColor;
ctx.lineWidth = helpers.valueOrDefault(vm.borderWidth, defaults.global.elements.point.borderWidth);
ctx.fillStyle = vm.backgroundColor || defaultColor;
if ((chartArea !== undefined) && ((model.x < chartArea.left) || (chartArea.right * errMargin < model.x) || (model.y < chartArea.top) || (chartArea.bottom * errMargin < model.y))) {
if (model.x < chartArea.left) {
ratio = (x - model.x) / (chartArea.left - model.x);
} else if (chartArea.right * errMargin < model.x) {
ratio = (model.x - x) / (model.x - chartArea.right);
} else if (model.y < chartArea.top) {
ratio = (y - model.y) / (chartArea.top - model.y);
} else if (chartArea.bottom * errMargin < model.y) {
ratio = (model.y - y) / (model.y - chartArea.bottom);
}
ratio = Math.round(ratio * 100) / 100;
ctx.strokeStyle = color(ctx.strokeStyle).alpha(ratio).rgbString();
ctx.fillStyle = color(ctx.fillStyle).alpha(ratio).rgbString();
}
helpers.canvas.drawPoint(ctx, pointStyle, radius, x, y);
}
});
},{"25":25,"26":26,"45":45}],39:[function(require,module,exports){
'use strict';
var defaults = require(25);
var Element = require(26);
defaults._set('global', {
elements: {
rectangle: {
backgroundColor: defaults.global.defaultColor,
borderColor: defaults.global.defaultColor,
borderSkipped: 'bottom',
borderWidth: 0
}
}
});
function isVertical(bar) {
return bar._view.width !== undefined;
}
function getBarBounds(bar) {
var vm = bar._view;
var x1, x2, y1, y2;
if (isVertical(bar)) {
var halfWidth = vm.width / 2;
x1 = vm.x - halfWidth;
x2 = vm.x + halfWidth;
y1 = Math.min(vm.y, vm.base);
y2 = Math.max(vm.y, vm.base);
} else {
var halfHeight = vm.height / 2;
x1 = Math.min(vm.x, vm.base);
x2 = Math.max(vm.x, vm.base);
y1 = vm.y - halfHeight;
y2 = vm.y + halfHeight;
}
return {
left: x1,
top: y1,
right: x2,
bottom: y2
};
}
module.exports = Element.extend({
draw: function() {
var ctx = this._chart.ctx;
var vm = this._view;
var left, right, top, bottom, signX, signY, borderSkipped;
var borderWidth = vm.borderWidth;
if (!vm.horizontal) {
left = vm.x - vm.width / 2;
right = vm.x + vm.width / 2;
top = vm.y;
bottom = vm.base;
signX = 1;
signY = bottom > top ? 1 : -1;
borderSkipped = vm.borderSkipped || 'bottom';
} else {
left = vm.base;
right = vm.x;
top = vm.y - vm.height / 2;
bottom = vm.y + vm.height / 2;
signX = right > left ? 1 : -1;
signY = 1;
borderSkipped = vm.borderSkipped || 'left';
}
if (borderWidth) {
var barSize = Math.min(Math.abs(left - right), Math.abs(top - bottom));
borderWidth = borderWidth > barSize ? barSize : borderWidth;
var halfStroke = borderWidth / 2;
var borderLeft = left + (borderSkipped !== 'left' ? halfStroke * signX : 0);
var borderRight = right + (borderSkipped !== 'right' ? -halfStroke * signX : 0);
var borderTop = top + (borderSkipped !== 'top' ? halfStroke * signY : 0);
var borderBottom = bottom + (borderSkipped !== 'bottom' ? -halfStroke * signY : 0);
if (borderLeft !== borderRight) {
top = borderTop;
bottom = borderBottom;
}
if (borderTop !== borderBottom) {
left = borderLeft;
right = borderRight;
}
}
ctx.beginPath();
ctx.fillStyle = vm.backgroundColor;
ctx.strokeStyle = vm.borderColor;
ctx.lineWidth = borderWidth;
var corners = [
[left, bottom],
[left, top],
[right, top],
[right, bottom]
];
var borders = ['bottom', 'left', 'top', 'right'];
var startCorner = borders.indexOf(borderSkipped, 0);
if (startCorner === -1) {
startCorner = 0;
}
function cornerAt(index) {
return corners[(startCorner + index) % 4];
}
var corner = cornerAt(0);
ctx.moveTo(corner[0], corner[1]);
for (var i = 1; i < 4; i++) {
corner = cornerAt(i);
ctx.lineTo(corner[0], corner[1]);
}
ctx.fill();
if (borderWidth) {
ctx.stroke();
}
},
height: function() {
var vm = this._view;
return vm.base - vm.y;
},
inRange: function(mouseX, mouseY) {
var inRange = false;
if (this._view) {
var bounds = getBarBounds(this);
inRange = mouseX >= bounds.left && mouseX <= bounds.right && mouseY >= bounds.top && mouseY <= bounds.bottom;
}
return inRange;
},
inLabelRange: function(mouseX, mouseY) {
var me = this;
if (!me._view) {
return false;
}
var inRange = false;
var bounds = getBarBounds(me);
if (isVertical(me)) {
inRange = mouseX >= bounds.left && mouseX <= bounds.right;
} else {
inRange = mouseY >= bounds.top && mouseY <= bounds.bottom;
}
return inRange;
},
inXRange: function(mouseX) {
var bounds = getBarBounds(this);
return mouseX >= bounds.left && mouseX <= bounds.right;
},
inYRange: function(mouseY) {
var bounds = getBarBounds(this);
return mouseY >= bounds.top && mouseY <= bounds.bottom;
},
getCenterPoint: function() {
var vm = this._view;
var x, y;
if (isVertical(this)) {
x = vm.x;
y = (vm.y + vm.base) / 2;
} else {
x = (vm.x + vm.base) / 2;
y = vm.y;
}
return {x: x, y: y};
},
getArea: function() {
var vm = this._view;
return vm.width * Math.abs(vm.y - vm.base);
},
tooltipPosition: function() {
var vm = this._view;
return {
x: vm.x,
y: vm.y
};
}
});
},{"25":25,"26":26}],40:[function(require,module,exports){
'use strict';
module.exports = {};
module.exports.Arc = require(36);
module.exports.Line = require(37);
module.exports.Point = require(38);
module.exports.Rectangle = require(39);
},{"36":36,"37":37,"38":38,"39":39}],41:[function(require,module,exports){
'use strict';
var helpers = require(42);
var exports = module.exports = {
clear: function(chart) {
chart.ctx.clearRect(0, 0, chart.width, chart.height);
},
roundedRect: function(ctx, x, y, width, height, radius) {
if (radius) {
var rx = Math.min(radius, width / 2);
var ry = Math.min(radius, height / 2);
ctx.moveTo(x + rx, y);
ctx.lineTo(x + width - rx, y);
ctx.quadraticCurveTo(x + width, y, x + width, y + ry);
ctx.lineTo(x + width, y + height - ry);
ctx.quadraticCurveTo(x + width, y + height, x + width - rx, y + height);
ctx.lineTo(x + rx, y + height);
ctx.quadraticCurveTo(x, y + height, x, y + height - ry);
ctx.lineTo(x, y + ry);
ctx.quadraticCurveTo(x, y, x + rx, y);
} else {
ctx.rect(x, y, width, height);
}
},
drawPoint: function(ctx, style, radius, x, y) {
var type, edgeLength, xOffset, yOffset, height, size;
if (style && typeof style === 'object') {
type = style.toString();
if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {
ctx.drawImage(style, x - style.width / 2, y - style.height / 2, style.width, style.height);
return;
}
}
if (isNaN(radius) || radius <= 0) {
return;
}
switch (style) {
default:
ctx.beginPath();
ctx.arc(x, y, radius, 0, Math.PI * 2);
ctx.closePath();
ctx.fill();
break;
case 'triangle':
ctx.beginPath();
edgeLength = 3 * radius / Math.sqrt(3);
height = edgeLength * Math.sqrt(3) / 2;
ctx.moveTo(x - edgeLength / 2, y + height / 3);
ctx.lineTo(x + edgeLength / 2, y + height / 3);
ctx.lineTo(x, y - 2 * height / 3);
ctx.closePath();
ctx.fill();
break;
case 'rect':
size = 1 / Math.SQRT2 * radius;
ctx.beginPath();
ctx.fillRect(x - size, y - size, 2 * size, 2 * size);
ctx.strokeRect(x - size, y - size, 2 * size, 2 * size);
break;
case 'rectRounded':
var offset = radius / Math.SQRT2;
var leftX = x - offset;
var topY = y - offset;
var sideSize = Math.SQRT2 * radius;
ctx.beginPath();
this.roundedRect(ctx, leftX, topY, sideSize, sideSize, radius / 2);
ctx.closePath();
ctx.fill();
break;
case 'rectRot':
size = 1 / Math.SQRT2 * radius;
ctx.beginPath();
ctx.moveTo(x - size, y);
ctx.lineTo(x, y + size);
ctx.lineTo(x + size, y);
ctx.lineTo(x, y - size);
ctx.closePath();
ctx.fill();
break;
case 'cross':
ctx.beginPath();
ctx.moveTo(x, y + radius);
ctx.lineTo(x, y - radius);
ctx.moveTo(x - radius, y);
ctx.lineTo(x + radius, y);
ctx.closePath();
break;
case 'crossRot':
ctx.beginPath();
xOffset = Math.cos(Math.PI / 4) * radius;
yOffset = Math.sin(Math.PI / 4) * radius;
ctx.moveTo(x - xOffset, y - yOffset);
ctx.lineTo(x + xOffset, y + yOffset);
ctx.moveTo(x - xOffset, y + yOffset);
ctx.lineTo(x + xOffset, y - yOffset);
ctx.closePath();
break;
case 'star':
ctx.beginPath();
ctx.moveTo(x, y + radius);
ctx.lineTo(x, y - radius);
ctx.moveTo(x - radius, y);
ctx.lineTo(x + radius, y);
xOffset = Math.cos(Math.PI / 4) * radius;
yOffset = Math.sin(Math.PI / 4) * radius;
ctx.moveTo(x - xOffset, y - yOffset);
ctx.lineTo(x + xOffset, y + yOffset);
ctx.moveTo(x - xOffset, y + yOffset);
ctx.lineTo(x + xOffset, y - yOffset);
ctx.closePath();
break;
case 'line':
ctx.beginPath();
ctx.moveTo(x - radius, y);
ctx.lineTo(x + radius, y);
ctx.closePath();
break;
case 'dash':
ctx.beginPath();
ctx.moveTo(x, y);
ctx.lineTo(x + radius, y);
ctx.closePath();
break;
}
ctx.stroke();
},
clipArea: function(ctx, area) {
ctx.save();
ctx.beginPath();
ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
ctx.clip();
},
unclipArea: function(ctx) {
ctx.restore();
},
lineTo: function(ctx, previous, target, flip) {
if (target.steppedLine) {
if ((target.steppedLine === 'after' && !flip) || (target.steppedLine !== 'after' && flip)) {
ctx.lineTo(previous.x, target.y);
} else {
ctx.lineTo(target.x, previous.y);
}
ctx.lineTo(target.x, target.y);
return;
}
if (!target.tension) {
ctx.lineTo(target.x, target.y);
return;
}
ctx.bezierCurveTo(
flip ? previous.controlPointPreviousX : previous.controlPointNextX,
flip ? previous.controlPointPreviousY : previous.controlPointNextY,
flip ? target.controlPointNextX : target.controlPointPreviousX,
flip ? target.controlPointNextY : target.controlPointPreviousY,
target.x,
target.y);
}
};
helpers.clear = exports.clear;
helpers.drawRoundedRectangle = function(ctx) {
ctx.beginPath();
exports.roundedRect.apply(exports, arguments);
ctx.closePath();
};
},{"42":42}],42:[function(require,module,exports){
'use strict';
var helpers = {
noop: function() {},
uid: (function() {
var id = 0;
return function() {
return id++;
};
}()),
isNullOrUndef: function(value) {
return value === null || typeof value === 'undefined';
},
isArray: Array.isArray ? Array.isArray : function(value) {
return Object.prototype.toString.call(value) === '[object Array]';
},
isObject: function(value) {
return value !== null && Object.prototype.toString.call(value) === '[object Object]';
},
valueOrDefault: function(value, defaultValue) {
return typeof value === 'undefined' ? defaultValue : value;
},
valueAtIndexOrDefault: function(value, index, defaultValue) {
return helpers.valueOrDefault(helpers.isArray(value) ? value[index] : value, defaultValue);
},
callback: function(fn, args, thisArg) {
if (fn && typeof fn.call === 'function') {
return fn.apply(thisArg, args);
}
},
each: function(loopable, fn, thisArg, reverse) {
var i, len, keys;
if (helpers.isArray(loopable)) {
len = loopable.length;
if (reverse) {
for (i = len - 1; i >= 0; i--) {
fn.call(thisArg, loopable[i], i);
}
} else {
for (i = 0; i < len; i++) {
fn.call(thisArg, loopable[i], i);
}
}
} else if (helpers.isObject(loopable)) {
keys = Object.keys(loopable);
len = keys.length;
for (i = 0; i < len; i++) {
fn.call(thisArg, loopable[keys[i]], keys[i]);
}
}
},
arrayEquals: function(a0, a1) {
var i, ilen, v0, v1;
if (!a0 || !a1 || a0.length !== a1.length) {
return false;
}
for (i = 0, ilen = a0.length; i < ilen; ++i) {
v0 = a0[i];
v1 = a1[i];
if (v0 instanceof Array && v1 instanceof Array) {
if (!helpers.arrayEquals(v0, v1)) {
return false;
}
} else if (v0 !== v1) {
return false;
}
}
return true;
},
clone: function(source) {
if (helpers.isArray(source)) {
return source.map(helpers.clone);
}
if (helpers.isObject(source)) {
var target = {};
var keys = Object.keys(source);
var klen = keys.length;
var k = 0;
for (; k < klen; ++k) {
target[keys[k]] = helpers.clone(source[keys[k]]);
}
return target;
}
return source;
},
_merger: function(key, target, source, options) {
var tval = target[key];
var sval = source[key];
if (helpers.isObject(tval) && helpers.isObject(sval)) {
helpers.merge(tval, sval, options);
} else {
target[key] = helpers.clone(sval);
}
},
_mergerIf: function(key, target, source) {
var tval = target[key];
var sval = source[key];
if (helpers.isObject(tval) && helpers.isObject(sval)) {
helpers.mergeIf(tval, sval);
} else if (!target.hasOwnProperty(key)) {
target[key] = helpers.clone(sval);
}
},
merge: function(target, source, options) {
var sources = helpers.isArray(source) ? source : [source];
var ilen = sources.length;
var merge, i, keys, klen, k;
if (!helpers.isObject(target)) {
return target;
}
options = options || {};
merge = options.merger || helpers._merger;
for (i = 0; i < ilen; ++i) {
source = sources[i];
if (!helpers.isObject(source)) {
continue;
}
keys = Object.keys(source);
for (k = 0, klen = keys.length; k < klen; ++k) {
merge(keys[k], target, source, options);
}
}
return target;
},
mergeIf: function(target, source) {
return helpers.merge(target, source, {merger: helpers._mergerIf});
},
extend: function(target) {
var setFn = function(value, key) {
target[key] = value;
};
for (var i = 1, ilen = arguments.length; i < ilen; ++i) {
helpers.each(arguments[i], setFn);
}
return target;
},
inherits: function(extensions) {
var me = this;
var ChartElement = (extensions && extensions.hasOwnProperty('constructor')) ? extensions.constructor : function() {
return me.apply(this, arguments);
};
var Surrogate = function() {
this.constructor = ChartElement;
};
Surrogate.prototype = me.prototype;
ChartElement.prototype = new Surrogate();
ChartElement.extend = helpers.inherits;
if (extensions) {
helpers.extend(ChartElement.prototype, extensions);
}
ChartElement.__super__ = me.prototype;
return ChartElement;
}
};
module.exports = helpers;
helpers.callCallback = helpers.callback;
helpers.indexOf = function(array, item, fromIndex) {
return Array.prototype.indexOf.call(array, item, fromIndex);
};
helpers.getValueOrDefault = helpers.valueOrDefault;
helpers.getValueAtIndexOrDefault = helpers.valueAtIndexOrDefault;
},{}],43:[function(require,module,exports){
'use strict';
var helpers = require(42);
var effects = {
linear: function(t) {
return t;
},
easeInQuad: function(t) {
return t * t;
},
easeOutQuad: function(t) {
return -t * (t - 2);
},
easeInOutQuad: function(t) {
if ((t /= 0.5) < 1) {
return 0.5 * t * t;
}
return -0.5 * ((--t) * (t - 2) - 1);
},
easeInCubic: function(t) {
return t * t * t;
},
easeOutCubic: function(t) {
return (t = t - 1) * t * t + 1;
},
easeInOutCubic: function(t) {
if ((t /= 0.5) < 1) {
return 0.5 * t * t * t;
}
return 0.5 * ((t -= 2) * t * t + 2);
},
easeInQuart: function(t) {
return t * t * t * t;
},
easeOutQuart: function(t) {
return -((t = t - 1) * t * t * t - 1);
},
easeInOutQuart: function(t) {
if ((t /= 0.5) < 1) {
return 0.5 * t * t * t * t;
}
return -0.5 * ((t -= 2) * t * t * t - 2);
},
easeInQuint: function(t) {
return t * t * t * t * t;
},
easeOutQuint: function(t) {
return (t = t - 1) * t * t * t * t + 1;
},
easeInOutQuint: function(t) {
if ((t /= 0.5) < 1) {
return 0.5 * t * t * t * t * t;
}
return 0.5 * ((t -= 2) * t * t * t * t + 2);
},
easeInSine: function(t) {
return -Math.cos(t * (Math.PI / 2)) + 1;
},
easeOutSine: function(t) {
return Math.sin(t * (Math.PI / 2));
},
easeInOutSine: function(t) {
return -0.5 * (Math.cos(Math.PI * t) - 1);
},
easeInExpo: function(t) {
return (t === 0) ? 0 : Math.pow(2, 10 * (t - 1));
},
easeOutExpo: function(t) {
return (t === 1) ? 1 : -Math.pow(2, -10 * t) + 1;
},
easeInOutExpo: function(t) {
if (t === 0) {
return 0;
}
if (t === 1) {
return 1;
}
if ((t /= 0.5) < 1) {
return 0.5 * Math.pow(2, 10 * (t - 1));
}
return 0.5 * (-Math.pow(2, -10 * --t) + 2);
},
easeInCirc: function(t) {
if (t >= 1) {
return t;
}
return -(Math.sqrt(1 - t * t) - 1);
},
easeOutCirc: function(t) {
return Math.sqrt(1 - (t = t - 1) * t);
},
easeInOutCirc: function(t) {
if ((t /= 0.5) < 1) {
return -0.5 * (Math.sqrt(1 - t * t) - 1);
}
return 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
},
easeInElastic: function(t) {
var s = 1.70158;
var p = 0;
var a = 1;
if (t === 0) {
return 0;
}
if (t === 1) {
return 1;
}
if (!p) {
p = 0.3;
}
if (a < 1) {
a = 1;
s = p / 4;
} else {
s = p / (2 * Math.PI) * Math.asin(1 / a);
}
return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));
},
easeOutElastic: function(t) {
var s = 1.70158;
var p = 0;
var a = 1;
if (t === 0) {
return 0;
}
if (t === 1) {
return 1;
}
if (!p) {
p = 0.3;
}
if (a < 1) {
a = 1;
s = p / 4;
} else {
s = p / (2 * Math.PI) * Math.asin(1 / a);
}
return a * Math.pow(2, -10 * t) * Math.sin((t - s) * (2 * Math.PI) / p) + 1;
},
easeInOutElastic: function(t) {
var s = 1.70158;
var p = 0;
var a = 1;
if (t === 0) {
return 0;
}
if ((t /= 0.5) === 2) {
return 1;
}
if (!p) {
p = 0.45;
}
if (a < 1) {
a = 1;
s = p / 4;
} else {
s = p / (2 * Math.PI) * Math.asin(1 / a);
}
if (t < 1) {
return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));
}
return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p) * 0.5 + 1;
},
easeInBack: function(t) {
var s = 1.70158;
return t * t * ((s + 1) * t - s);
},
easeOutBack: function(t) {
var s = 1.70158;
return (t = t - 1) * t * ((s + 1) * t + s) + 1;
},
easeInOutBack: function(t) {
var s = 1.70158;
if ((t /= 0.5) < 1) {
return 0.5 * (t * t * (((s *= (1.525)) + 1) * t - s));
}
return 0.5 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2);
},
easeInBounce: function(t) {
return 1 - effects.easeOutBounce(1 - t);
},
easeOutBounce: function(t) {
if (t < (1 / 2.75)) {
return 7.5625 * t * t;
}
if (t < (2 / 2.75)) {
return 7.5625 * (t -= (1.5 / 2.75)) * t + 0.75;
}
if (t < (2.5 / 2.75)) {
return 7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375;
}
return 7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375;
},
easeInOutBounce: function(t) {
if (t < 0.5) {
return effects.easeInBounce(t * 2) * 0.5;
}
return effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5;
}
};
module.exports = {
effects: effects
};
helpers.easingEffects = effects;
},{"42":42}],44:[function(require,module,exports){
'use strict';
var helpers = require(42);
module.exports = {
toLineHeight: function(value, size) {
var matches = ('' + value).match(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);
if (!matches || matches[1] === 'normal') {
return size * 1.2;
}
value = +matches[2];
switch (matches[3]) {
case 'px':
return value;
case '%':
value /= 100;
break;
default:
break;
}
return size * value;
},
toPadding: function(value) {
var t, r, b, l;
if (helpers.isObject(value)) {
t = +value.top || 0;
r = +value.right || 0;
b = +value.bottom || 0;
l = +value.left || 0;
} else {
t = r = b = l = +value || 0;
}
return {
top: t,
right: r,
bottom: b,
left: l,
height: t + b,
width: l + r
};
},
resolve: function(inputs, context, index) {
var i, ilen, value;
for (i = 0, ilen = inputs.length; i < ilen; ++i) {
value = inputs[i];
if (value === undefined) {
continue;
}
if (context !== undefined && typeof value === 'function') {
value = value(context);
}
if (index !== undefined && helpers.isArray(value)) {
value = value[index];
}
if (value !== undefined) {
return value;
}
}
}
};
},{"42":42}],45:[function(require,module,exports){
'use strict';
module.exports = require(42);
module.exports.easing = require(43);
module.exports.canvas = require(41);
module.exports.options = require(44);
},{"41":41,"42":42,"43":43,"44":44}],46:[function(require,module,exports){
module.exports = {
acquireContext: function(item) {
if (item && item.canvas) {
item = item.canvas;
}
return item && item.getContext('2d') || null;
}
};
},{}],47:[function(require,module,exports){
'use strict';
var helpers = require(45);
var EXPANDO_KEY = '$chartjs';
var CSS_PREFIX = 'chartjs-';
var CSS_RENDER_MONITOR = CSS_PREFIX + 'render-monitor';
var CSS_RENDER_ANIMATION = CSS_PREFIX + 'render-animation';
var ANIMATION_START_EVENTS = ['animationstart', 'webkitAnimationStart'];
var EVENT_TYPES = {
touchstart: 'mousedown',
touchmove: 'mousemove',
touchend: 'mouseup',
pointerenter: 'mouseenter',
pointerdown: 'mousedown',
pointermove: 'mousemove',
pointerup: 'mouseup',
pointerleave: 'mouseout',
pointerout: 'mouseout'
};
function readUsedSize(element, property) {
var value = helpers.getStyle(element, property);
var matches = value && value.match(/^(\d+)(\.\d+)?px$/);
return matches ? Number(matches[1]) : undefined;
}
function initCanvas(canvas, config) {
var style = canvas.style;
var renderHeight = canvas.getAttribute('height');
var renderWidth = canvas.getAttribute('width');
canvas[EXPANDO_KEY] = {
initial: {
height: renderHeight,
width: renderWidth,
style: {
display: style.display,
height: style.height,
width: style.width
}
}
};
style.display = style.display || 'block';
if (renderWidth === null || renderWidth === '') {
var displayWidth = readUsedSize(canvas, 'width');
if (displayWidth !== undefined) {
canvas.width = displayWidth;
}
}
if (renderHeight === null || renderHeight === '') {
if (canvas.style.height === '') {
canvas.height = canvas.width / (config.options.aspectRatio || 2);
} else {
var displayHeight = readUsedSize(canvas, 'height');
if (displayWidth !== undefined) {
canvas.height = displayHeight;
}
}
}
return canvas;
}
var supportsEventListenerOptions = (function() {
var supports = false;
try {
var options = Object.defineProperty({}, 'passive', {
get: function() {
supports = true;
}
});
window.addEventListener('e', null, options);
} catch (e) {
}
return supports;
}());
var eventListenerOptions = supportsEventListenerOptions ? {passive: true} : false;
function addEventListener(node, type, listener) {
node.addEventListener(type, listener, eventListenerOptions);
}
function removeEventListener(node, type, listener) {
node.removeEventListener(type, listener, eventListenerOptions);
}
function createEvent(type, chart, x, y, nativeEvent) {
return {
type: type,
chart: chart,
native: nativeEvent || null,
x: x !== undefined ? x : null,
y: y !== undefined ? y : null,
};
}
function fromNativeEvent(event, chart) {
var type = EVENT_TYPES[event.type] || event.type;
var pos = helpers.getRelativePosition(event, chart);
return createEvent(type, chart, pos.x, pos.y, event);
}
function throttled(fn, thisArg) {
var ticking = false;
var args = [];
return function() {
args = Array.prototype.slice.call(arguments);
thisArg = thisArg || this;
if (!ticking) {
ticking = true;
helpers.requestAnimFrame.call(window, function() {
ticking = false;
fn.apply(thisArg, args);
});
}
};
}
function createResizer(handler) {
var resizer = document.createElement('div');
var cls = CSS_PREFIX + 'size-monitor';
var maxSize = 1000000;
var style =
'position:absolute;' +
'left:0;' +
'top:0;' +
'right:0;' +
'bottom:0;' +
'overflow:hidden;' +
'pointer-events:none;' +
'visibility:hidden;' +
'z-index:-1;';
resizer.style.cssText = style;
resizer.className = cls;
resizer.innerHTML =
'<div class="' + cls + '-expand" style="' + style + '">' +
'<div style="' +
'position:absolute;' +
'width:' + maxSize + 'px;' +
'height:' + maxSize + 'px;' +
'left:0;' +
'top:0">' +
'</div>' +
'</div>' +
'<div class="' + cls + '-shrink" style="' + style + '">' +
'<div style="' +
'position:absolute;' +
'width:200%;' +
'height:200%;' +
'left:0; ' +
'top:0">' +
'</div>' +
'</div>';
var expand = resizer.childNodes[0];
var shrink = resizer.childNodes[1];
resizer._reset = function() {
expand.scrollLeft = maxSize;
expand.scrollTop = maxSize;
shrink.scrollLeft = maxSize;
shrink.scrollTop = maxSize;
};
var onScroll = function() {
resizer._reset();
handler();
};
addEventListener(expand, 'scroll', onScroll.bind(expand, 'expand'));
addEventListener(shrink, 'scroll', onScroll.bind(shrink, 'shrink'));
return resizer;
}
function watchForRender(node, handler) {
var expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});
var proxy = expando.renderProxy = function(e) {
if (e.animationName === CSS_RENDER_ANIMATION) {
handler();
}
};
helpers.each(ANIMATION_START_EVENTS, function(type) {
addEventListener(node, type, proxy);
});
expando.reflow = !!node.offsetParent;
node.classList.add(CSS_RENDER_MONITOR);
}
function unwatchForRender(node) {
var expando = node[EXPANDO_KEY] || {};
var proxy = expando.renderProxy;
if (proxy) {
helpers.each(ANIMATION_START_EVENTS, function(type) {
removeEventListener(node, type, proxy);
});
delete expando.renderProxy;
}
node.classList.remove(CSS_RENDER_MONITOR);
}
function addResizeListener(node, listener, chart) {
var expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});
var resizer = expando.resizer = createResizer(throttled(function() {
if (expando.resizer) {
return listener(createEvent('resize', chart));
}
}));
watchForRender(node, function() {
if (expando.resizer) {
var container = node.parentNode;
if (container && container !== resizer.parentNode) {
container.insertBefore(resizer, container.firstChild);
}
resizer._reset();
}
});
}
function removeResizeListener(node) {
var expando = node[EXPANDO_KEY] || {};
var resizer = expando.resizer;
delete expando.resizer;
unwatchForRender(node);
if (resizer && resizer.parentNode) {
resizer.parentNode.removeChild(resizer);
}
}
function injectCSS(platform, css) {
var style = platform._style || document.createElement('style');
if (!platform._style) {
platform._style = style;
css = '/* Chart.js */\n' + css;
style.setAttribute('type', 'text/css');
document.getElementsByTagName('head')[0].appendChild(style);
}
style.appendChild(document.createTextNode(css));
}
module.exports = {
_enabled: typeof window !== 'undefined' && typeof document !== 'undefined',
initialize: function() {
var keyframes = 'from{opacity:0.99}to{opacity:1}';
injectCSS(this,
'@-webkit-keyframes ' + CSS_RENDER_ANIMATION + '{' + keyframes + '}' +
'@keyframes ' + CSS_RENDER_ANIMATION + '{' + keyframes + '}' +
'.' + CSS_RENDER_MONITOR + '{' +
'-webkit-animation:' + CSS_RENDER_ANIMATION + ' 0.001s;' +
'animation:' + CSS_RENDER_ANIMATION + ' 0.001s;' +
'}'
);
},
acquireContext: function(item, config) {
if (typeof item === 'string') {
item = document.getElementById(item);
} else if (item.length) {
item = item[0];
}
if (item && item.canvas) {
item = item.canvas;
}
var context = item && item.getContext && item.getContext('2d');
if (context && context.canvas === item) {
initCanvas(item, config);
return context;
}
return null;
},
releaseContext: function(context) {
var canvas = context.canvas;
if (!canvas[EXPANDO_KEY]) {
return;
}
var initial = canvas[EXPANDO_KEY].initial;
['height', 'width'].forEach(function(prop) {
var value = initial[prop];
if (helpers.isNullOrUndef(value)) {
canvas.removeAttribute(prop);
} else {
canvas.setAttribute(prop, value);
}
});
helpers.each(initial.style || {}, function(value, key) {
canvas.style[key] = value;
});
canvas.width = canvas.width;
delete canvas[EXPANDO_KEY];
},
addEventListener: function(chart, type, listener) {
var canvas = chart.canvas;
if (type === 'resize') {
addResizeListener(canvas, listener, chart);
return;
}
var expando = listener[EXPANDO_KEY] || (listener[EXPANDO_KEY] = {});
var proxies = expando.proxies || (expando.proxies = {});
var proxy = proxies[chart.id + '_' + type] = function(event) {
listener(fromNativeEvent(event, chart));
};
addEventListener(canvas, type, proxy);
},
removeEventListener: function(chart, type, listener) {
var canvas = chart.canvas;
if (type === 'resize') {
removeResizeListener(canvas, listener);
return;
}
var expando = listener[EXPANDO_KEY] || {};
var proxies = expando.proxies || {};
var proxy = proxies[chart.id + '_' + type];
if (!proxy) {
return;
}
removeEventListener(canvas, type, proxy);
}
};
helpers.addEvent = addEventListener;
helpers.removeEvent = removeEventListener;
},{"45":45}],48:[function(require,module,exports){
'use strict';
var helpers = require(45);
var basic = require(46);
var dom = require(47);
var implementation = dom._enabled ? dom : basic;
module.exports = helpers.extend({
initialize: function() {},
acquireContext: function() {},
releaseContext: function() {},
addEventListener: function() {},
removeEventListener: function() {}
}, implementation);
},{"45":45,"46":46,"47":47}],49:[function(require,module,exports){
'use strict';
var defaults = require(25);
var elements = require(40);
var helpers = require(45);
defaults._set('global', {
plugins: {
filler: {
propagate: true
}
}
});
module.exports = function() {
var mappers = {
dataset: function(source) {
var index = source.fill;
var chart = source.chart;
var meta = chart.getDatasetMeta(index);
var visible = meta && chart.isDatasetVisible(index);
var points = (visible && meta.dataset._children) || [];
var length = points.length || 0;
return !length ? null : function(point, i) {
return (i < length && points[i]._view) || null;
};
},
boundary: function(source) {
var boundary = source.boundary;
var x = boundary ? boundary.x : null;
var y = boundary ? boundary.y : null;
return function(point) {
return {
x: x === null ? point.x : x,
y: y === null ? point.y : y,
};
};
}
};
function decodeFill(el, index, count) {
var model = el._model || {};
var fill = model.fill;
var target;
if (fill === undefined) {
fill = !!model.backgroundColor;
}
if (fill === false || fill === null) {
return false;
}
if (fill === true) {
return 'origin';
}
target = parseFloat(fill, 10);
if (isFinite(target) && Math.floor(target) === target) {
if (fill[0] === '-' || fill[0] === '+') {
target = index + target;
}
if (target === index || target < 0 || target >= count) {
return false;
}
return target;
}
switch (fill) {
case 'bottom':
return 'start';
case 'top':
return 'end';
case 'zero':
return 'origin';
case 'origin':
case 'start':
case 'end':
return fill;
default:
return false;
}
}
function computeBoundary(source) {
var model = source.el._model || {};
var scale = source.el._scale || {};
var fill = source.fill;
var target = null;
var horizontal;
if (isFinite(fill)) {
return null;
}
if (fill === 'start') {
target = model.scaleBottom === undefined ? scale.bottom : model.scaleBottom;
} else if (fill === 'end') {
target = model.scaleTop === undefined ? scale.top : model.scaleTop;
} else if (model.scaleZero !== undefined) {
target = model.scaleZero;
} else if (scale.getBasePosition) {
target = scale.getBasePosition();
} else if (scale.getBasePixel) {
target = scale.getBasePixel();
}
if (target !== undefined && target !== null) {
if (target.x !== undefined && target.y !== undefined) {
return target;
}
if (typeof target === 'number' && isFinite(target)) {
horizontal = scale.isHorizontal();
return {
x: horizontal ? target : null,
y: horizontal ? null : target
};
}
}
return null;
}
function resolveTarget(sources, index, propagate) {
var source = sources[index];
var fill = source.fill;
var visited = [index];
var target;
if (!propagate) {
return fill;
}
while (fill !== false && visited.indexOf(fill) === -1) {
if (!isFinite(fill)) {
return fill;
}
target = sources[fill];
if (!target) {
return false;
}
if (target.visible) {
return fill;
}
visited.push(fill);
fill = target.fill;
}
return false;
}
function createMapper(source) {
var fill = source.fill;
var type = 'dataset';
if (fill === false) {
return null;
}
if (!isFinite(fill)) {
type = 'boundary';
}
return mappers[type](source);
}
function isDrawable(point) {
return point && !point.skip;
}
function drawArea(ctx, curve0, curve1, len0, len1) {
var i;
if (!len0 || !len1) {
return;
}
ctx.moveTo(curve0[0].x, curve0[0].y);
for (i = 1; i < len0; ++i) {
helpers.canvas.lineTo(ctx, curve0[i - 1], curve0[i]);
}
ctx.lineTo(curve1[len1 - 1].x, curve1[len1 - 1].y);
for (i = len1 - 1; i > 0; --i) {
helpers.canvas.lineTo(ctx, curve1[i], curve1[i - 1], true);
}
}
function doFill(ctx, points, mapper, view, color, loop) {
var count = points.length;
var span = view.spanGaps;
var curve0 = [];
var curve1 = [];
var len0 = 0;
var len1 = 0;
var i, ilen, index, p0, p1, d0, d1;
ctx.beginPath();
for (i = 0, ilen = (count + !!loop); i < ilen; ++i) {
index = i % count;
p0 = points[index]._view;
p1 = mapper(p0, index, view);
d0 = isDrawable(p0);
d1 = isDrawable(p1);
if (d0 && d1) {
len0 = curve0.push(p0);
len1 = curve1.push(p1);
} else if (len0 && len1) {
if (!span) {
drawArea(ctx, curve0, curve1, len0, len1);
len0 = len1 = 0;
curve0 = [];
curve1 = [];
} else {
if (d0) {
curve0.push(p0);
}
if (d1) {
curve1.push(p1);
}
}
}
}
drawArea(ctx, curve0, curve1, len0, len1);
ctx.closePath();
ctx.fillStyle = color;
ctx.fill();
}
return {
id: 'filler',
afterDatasetsUpdate: function(chart, options) {
var count = (chart.data.datasets || []).length;
var propagate = options.propagate;
var sources = [];
var meta, i, el, source;
for (i = 0; i < count; ++i) {
meta = chart.getDatasetMeta(i);
el = meta.dataset;
source = null;
if (el && el._model && el instanceof elements.Line) {
source = {
visible: chart.isDatasetVisible(i),
fill: decodeFill(el, i, count),
chart: chart,
el: el
};
}
meta.$filler = source;
sources.push(source);
}
for (i = 0; i < count; ++i) {
source = sources[i];
if (!source) {
continue;
}
source.fill = resolveTarget(sources, i, propagate);
source.boundary = computeBoundary(source);
source.mapper = createMapper(source);
}
},
beforeDatasetDraw: function(chart, args) {
var meta = args.meta.$filler;
if (!meta) {
return;
}
var ctx = chart.ctx;
var el = meta.el;
var view = el._view;
var points = el._children || [];
var mapper = meta.mapper;
var color = view.backgroundColor || defaults.global.defaultColor;
if (mapper && color && points.length) {
helpers.canvas.clipArea(ctx, chart.chartArea);
doFill(ctx, points, mapper, view, color, el._loop);
helpers.canvas.unclipArea(ctx);
}
}
};
};
},{"25":25,"40":40,"45":45}],50:[function(require,module,exports){
'use strict';
var defaults = require(25);
var Element = require(26);
var helpers = require(45);
defaults._set('global', {
legend: {
display: true,
position: 'top',
fullWidth: true,
reverse: false,
weight: 1000,
onClick: function(e, legendItem) {
var index = legendItem.datasetIndex;
var ci = this.chart;
var meta = ci.getDatasetMeta(index);
meta.hidden = meta.hidden === null ? !ci.data.datasets[index].hidden : null;
ci.update();
},
onHover: null,
labels: {
boxWidth: 40,
padding: 10,
generateLabels: function(chart) {
var data = chart.data;
return helpers.isArray(data.datasets) ? data.datasets.map(function(dataset, i) {
return {
text: dataset.label,
fillStyle: (!helpers.isArray(dataset.backgroundColor) ? dataset.backgroundColor : dataset.backgroundColor[0]),
hidden: !chart.isDatasetVisible(i),
lineCap: dataset.borderCapStyle,
lineDash: dataset.borderDash,
lineDashOffset: dataset.borderDashOffset,
lineJoin: dataset.borderJoinStyle,
lineWidth: dataset.borderWidth,
strokeStyle: dataset.borderColor,
pointStyle: dataset.pointStyle,
datasetIndex: i
};
}, this) : [];
}
}
},
legendCallback: function(chart) {
var text = [];
text.push('<ul class="' + chart.id + '-legend">');
for (var i = 0; i < chart.data.datasets.length; i++) {
text.push('<li><span style="background-color:' + chart.data.datasets[i].backgroundColor + '"></span>');
if (chart.data.datasets[i].label) {
text.push(chart.data.datasets[i].label);
}
text.push('</li>');
}
text.push('</ul>');
return text.join('');
}
});
module.exports = function(Chart) {
var layout = Chart.layoutService;
var noop = helpers.noop;
function getBoxWidth(labelOpts, fontSize) {
return labelOpts.usePointStyle ?
fontSize * Math.SQRT2 :
labelOpts.boxWidth;
}
Chart.Legend = Element.extend({
initialize: function(config) {
helpers.extend(this, config);
this.legendHitBoxes = [];
this.doughnutMode = false;
},
beforeUpdate: noop,
update: function(maxWidth, maxHeight, margins) {
var me = this;
me.beforeUpdate();
me.maxWidth = maxWidth;
me.maxHeight = maxHeight;
me.margins = margins;
me.beforeSetDimensions();
me.setDimensions();
me.afterSetDimensions();
me.beforeBuildLabels();
me.buildLabels();
me.afterBuildLabels();
me.beforeFit();
me.fit();
me.afterFit();
me.afterUpdate();
return me.minSize;
},
afterUpdate: noop,
beforeSetDimensions: noop,
setDimensions: function() {
var me = this;
if (me.isHorizontal()) {
me.width = me.maxWidth;
me.left = 0;
me.right = me.width;
} else {
me.height = me.maxHeight;
me.top = 0;
me.bottom = me.height;
}
me.paddingLeft = 0;
me.paddingTop = 0;
me.paddingRight = 0;
me.paddingBottom = 0;
me.minSize = {
width: 0,
height: 0
};
},
afterSetDimensions: noop,
beforeBuildLabels: noop,
buildLabels: function() {
var me = this;
var labelOpts = me.options.labels || {};
var legendItems = helpers.callback(labelOpts.generateLabels, [me.chart], me) || [];
if (labelOpts.filter) {
legendItems = legendItems.filter(function(item) {
return labelOpts.filter(item, me.chart.data);
});
}
if (me.options.reverse) {
legendItems.reverse();
}
me.legendItems = legendItems;
},
afterBuildLabels: noop,
beforeFit: noop,
fit: function() {
var me = this;
var opts = me.options;
var labelOpts = opts.labels;
var display = opts.display;
var ctx = me.ctx;
var globalDefault = defaults.global;
var valueOrDefault = helpers.valueOrDefault;
var fontSize = valueOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize);
var fontStyle = valueOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle);
var fontFamily = valueOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily);
var labelFont = helpers.fontString(fontSize, fontStyle, fontFamily);
var hitboxes = me.legendHitBoxes = [];
var minSize = me.minSize;
var isHorizontal = me.isHorizontal();
if (isHorizontal) {
minSize.width = me.maxWidth; // fill all the width
minSize.height = display ? 10 : 0;
} else {
minSize.width = display ? 10 : 0;
minSize.height = me.maxHeight; // fill all the height
}
if (display) {
ctx.font = labelFont;
if (isHorizontal) {
var lineWidths = me.lineWidths = [0];
var totalHeight = me.legendItems.length ? fontSize + (labelOpts.padding) : 0;
ctx.textAlign = 'left';
ctx.textBaseline = 'top';
helpers.each(me.legendItems, function(legendItem, i) {
var boxWidth = getBoxWidth(labelOpts, fontSize);
var width = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;
if (lineWidths[lineWidths.length - 1] + width + labelOpts.padding >= me.width) {
totalHeight += fontSize + (labelOpts.padding);
lineWidths[lineWidths.length] = me.left;
}
hitboxes[i] = {
left: 0,
top: 0,
width: width,
height: fontSize
};
lineWidths[lineWidths.length - 1] += width + labelOpts.padding;
});
minSize.height += totalHeight;
} else {
var vPadding = labelOpts.padding;
var columnWidths = me.columnWidths = [];
var totalWidth = labelOpts.padding;
var currentColWidth = 0;
var currentColHeight = 0;
var itemHeight = fontSize + vPadding;
helpers.each(me.legendItems, function(legendItem, i) {
var boxWidth = getBoxWidth(labelOpts, fontSize);
var itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;
if (currentColHeight + itemHeight > minSize.height) {
totalWidth += currentColWidth + labelOpts.padding;
columnWidths.push(currentColWidth); // previous column width
currentColWidth = 0;
currentColHeight = 0;
}
currentColWidth = Math.max(currentColWidth, itemWidth);
currentColHeight += itemHeight;
hitboxes[i] = {
left: 0,
top: 0,
width: itemWidth,
height: fontSize
};
});
totalWidth += currentColWidth;
columnWidths.push(currentColWidth);
minSize.width += totalWidth;
}
}
me.width = minSize.width;
me.height = minSize.height;
},
afterFit: noop,
isHorizontal: function() {
return this.options.position === 'top' || this.options.position === 'bottom';
},
draw: function() {
var me = this;
var opts = me.options;
var labelOpts = opts.labels;
var globalDefault = defaults.global;
var lineDefault = globalDefault.elements.line;
var legendWidth = me.width;
var lineWidths = me.lineWidths;
if (opts.display) {
var ctx = me.ctx;
var valueOrDefault = helpers.valueOrDefault;
var fontColor = valueOrDefault(labelOpts.fontColor, globalDefault.defaultFontColor);
var fontSize = valueOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize);
var fontStyle = valueOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle);
var fontFamily = valueOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily);
var labelFont = helpers.fontString(fontSize, fontStyle, fontFamily);
var cursor;
ctx.textAlign = 'left';
ctx.textBaseline = 'middle';
ctx.lineWidth = 0.5;
ctx.strokeStyle = fontColor; // for strikethrough effect
ctx.fillStyle = fontColor; // render in correct colour
ctx.font = labelFont;
var boxWidth = getBoxWidth(labelOpts, fontSize);
var hitboxes = me.legendHitBoxes;
var drawLegendBox = function(x, y, legendItem) {
if (isNaN(boxWidth) || boxWidth <= 0) {
return;
}
ctx.save();
ctx.fillStyle = valueOrDefault(legendItem.fillStyle, globalDefault.defaultColor);
ctx.lineCap = valueOrDefault(legendItem.lineCap, lineDefault.borderCapStyle);
ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, lineDefault.borderDashOffset);
ctx.lineJoin = valueOrDefault(legendItem.lineJoin, lineDefault.borderJoinStyle);
ctx.lineWidth = valueOrDefault(legendItem.lineWidth, lineDefault.borderWidth);
ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, globalDefault.defaultColor);
var isLineWidthZero = (valueOrDefault(legendItem.lineWidth, lineDefault.borderWidth) === 0);
if (ctx.setLineDash) {
ctx.setLineDash(valueOrDefault(legendItem.lineDash, lineDefault.borderDash));
}
if (opts.labels && opts.labels.usePointStyle) {
var radius = fontSize * Math.SQRT2 / 2;
var offSet = radius / Math.SQRT2;
var centerX = x + offSet;
var centerY = y + offSet;
helpers.canvas.drawPoint(ctx, legendItem.pointStyle, radius, centerX, centerY);
} else {
if (!isLineWidthZero) {
ctx.strokeRect(x, y, boxWidth, fontSize);
}
ctx.fillRect(x, y, boxWidth, fontSize);
}
ctx.restore();
};
var fillText = function(x, y, legendItem, textWidth) {
var halfFontSize = fontSize / 2;
var xLeft = boxWidth + halfFontSize + x;
var yMiddle = y + halfFontSize;
ctx.fillText(legendItem.text, xLeft, yMiddle);
if (legendItem.hidden) {
ctx.beginPath();
ctx.lineWidth = 2;
ctx.moveTo(xLeft, yMiddle);
ctx.lineTo(xLeft + textWidth, yMiddle);
ctx.stroke();
}
};
var isHorizontal = me.isHorizontal();
if (isHorizontal) {
cursor = {
x: me.left + ((legendWidth - lineWidths[0]) / 2),
y: me.top + labelOpts.padding,
line: 0
};
} else {
cursor = {
x: me.left + labelOpts.padding,
y: me.top + labelOpts.padding,
line: 0
};
}
var itemHeight = fontSize + labelOpts.padding;
helpers.each(me.legendItems, function(legendItem, i) {
var textWidth = ctx.measureText(legendItem.text).width;
var width = boxWidth + (fontSize / 2) + textWidth;
var x = cursor.x;
var y = cursor.y;
if (isHorizontal) {
if (x + width >= legendWidth) {
y = cursor.y += itemHeight;
cursor.line++;
x = cursor.x = me.left + ((legendWidth - lineWidths[cursor.line]) / 2);
}
} else if (y + itemHeight > me.bottom) {
x = cursor.x = x + me.columnWidths[cursor.line] + labelOpts.padding;
y = cursor.y = me.top + labelOpts.padding;
cursor.line++;
}
drawLegendBox(x, y, legendItem);
hitboxes[i].left = x;
hitboxes[i].top = y;
fillText(x, y, legendItem, textWidth);
if (isHorizontal) {
cursor.x += width + (labelOpts.padding);
} else {
cursor.y += itemHeight;
}
});
}
},
handleEvent: function(e) {
var me = this;
var opts = me.options;
var type = e.type === 'mouseup' ? 'click' : e.type;
var changed = false;
if (type === 'mousemove') {
if (!opts.onHover) {
return;
}
} else if (type === 'click') {
if (!opts.onClick) {
return;
}
} else {
return;
}
var x = e.x;
var y = e.y;
if (x >= me.left && x <= me.right && y >= me.top && y <= me.bottom) {
var lh = me.legendHitBoxes;
for (var i = 0; i < lh.length; ++i) {
var hitBox = lh[i];
if (x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) {
if (type === 'click') {
opts.onClick.call(me, e.native, me.legendItems[i]);
changed = true;
break;
} else if (type === 'mousemove') {
opts.onHover.call(me, e.native, me.legendItems[i]);
changed = true;
break;
}
}
}
}
return changed;
}
});
function createNewLegendAndAttach(chart, legendOpts) {
var legend = new Chart.Legend({
ctx: chart.ctx,
options: legendOpts,
chart: chart
});
layout.configure(chart, legend, legendOpts);
layout.addBox(chart, legend);
chart.legend = legend;
}
return {
id: 'legend',
beforeInit: function(chart) {
var legendOpts = chart.options.legend;
if (legendOpts) {
createNewLegendAndAttach(chart, legendOpts);
}
},
beforeUpdate: function(chart) {
var legendOpts = chart.options.legend;
var legend = chart.legend;
if (legendOpts) {
helpers.mergeIf(legendOpts, defaults.global.legend);
if (legend) {
layout.configure(chart, legend, legendOpts);
legend.options = legendOpts;
} else {
createNewLegendAndAttach(chart, legendOpts);
}
} else if (legend) {
layout.removeBox(chart, legend);
delete chart.legend;
}
},
afterEvent: function(chart, e) {
var legend = chart.legend;
if (legend) {
legend.handleEvent(e);
}
}
};
};
},{"25":25,"26":26,"45":45}],51:[function(require,module,exports){
'use strict';
var defaults = require(25);
var Element = require(26);
var helpers = require(45);
defaults._set('global', {
title: {
display: false,
fontStyle: 'bold',
fullWidth: true,
lineHeight: 1.2,
padding: 10,
position: 'top',
text: '',
weight: 2000         // by default greater than legend (1000) to be above
}
});
module.exports = function(Chart) {
var layout = Chart.layoutService;
var noop = helpers.noop;
Chart.Title = Element.extend({
initialize: function(config) {
var me = this;
helpers.extend(me, config);
me.legendHitBoxes = [];
},
beforeUpdate: noop,
update: function(maxWidth, maxHeight, margins) {
var me = this;
me.beforeUpdate();
me.maxWidth = maxWidth;
me.maxHeight = maxHeight;
me.margins = margins;
me.beforeSetDimensions();
me.setDimensions();
me.afterSetDimensions();
me.beforeBuildLabels();
me.buildLabels();
me.afterBuildLabels();
me.beforeFit();
me.fit();
me.afterFit();
me.afterUpdate();
return me.minSize;
},
afterUpdate: noop,
beforeSetDimensions: noop,
setDimensions: function() {
var me = this;
if (me.isHorizontal()) {
me.width = me.maxWidth;
me.left = 0;
me.right = me.width;
} else {
me.height = me.maxHeight;
me.top = 0;
me.bottom = me.height;
}
me.paddingLeft = 0;
me.paddingTop = 0;
me.paddingRight = 0;
me.paddingBottom = 0;
me.minSize = {
width: 0,
height: 0
};
},
afterSetDimensions: noop,
beforeBuildLabels: noop,
buildLabels: noop,
afterBuildLabels: noop,
beforeFit: noop,
fit: function() {
var me = this;
var valueOrDefault = helpers.valueOrDefault;
var opts = me.options;
var display = opts.display;
var fontSize = valueOrDefault(opts.fontSize, defaults.global.defaultFontSize);
var minSize = me.minSize;
var lineCount = helpers.isArray(opts.text) ? opts.text.length : 1;
var lineHeight = helpers.options.toLineHeight(opts.lineHeight, fontSize);
var textSize = display ? (lineCount * lineHeight) + (opts.padding * 2) : 0;
if (me.isHorizontal()) {
minSize.width = me.maxWidth; // fill all the width
minSize.height = textSize;
} else {
minSize.width = textSize;
minSize.height = me.maxHeight; // fill all the height
}
me.width = minSize.width;
me.height = minSize.height;
},
afterFit: noop,
isHorizontal: function() {
var pos = this.options.position;
return pos === 'top' || pos === 'bottom';
},
draw: function() {
var me = this;
var ctx = me.ctx;
var valueOrDefault = helpers.valueOrDefault;
var opts = me.options;
var globalDefaults = defaults.global;
if (opts.display) {
var fontSize = valueOrDefault(opts.fontSize, globalDefaults.defaultFontSize);
var fontStyle = valueOrDefault(opts.fontStyle, globalDefaults.defaultFontStyle);
var fontFamily = valueOrDefault(opts.fontFamily, globalDefaults.defaultFontFamily);
var titleFont = helpers.fontString(fontSize, fontStyle, fontFamily);
var lineHeight = helpers.options.toLineHeight(opts.lineHeight, fontSize);
var offset = lineHeight / 2 + opts.padding;
var rotation = 0;
var top = me.top;
var left = me.left;
var bottom = me.bottom;
var right = me.right;
var maxWidth, titleX, titleY;
ctx.fillStyle = valueOrDefault(opts.fontColor, globalDefaults.defaultFontColor); // render in correct colour
ctx.font = titleFont;
if (me.isHorizontal()) {
titleX = left + ((right - left) / 2); // midpoint of the width
titleY = top + offset;
maxWidth = right - left;
} else {
titleX = opts.position === 'left' ? left + offset : right - offset;
titleY = top + ((bottom - top) / 2);
maxWidth = bottom - top;
rotation = Math.PI * (opts.position === 'left' ? -0.5 : 0.5);
}
ctx.save();
ctx.translate(titleX, titleY);
ctx.rotate(rotation);
ctx.textAlign = 'center';
ctx.textBaseline = 'middle';
var text = opts.text;
if (helpers.isArray(text)) {
var y = 0;
for (var i = 0; i < text.length; ++i) {
ctx.fillText(text[i], 0, y, maxWidth);
y += lineHeight;
}
} else {
ctx.fillText(text, 0, 0, maxWidth);
}
ctx.restore();
}
}
});
function createNewTitleBlockAndAttach(chart, titleOpts) {
var title = new Chart.Title({
ctx: chart.ctx,
options: titleOpts,
chart: chart
});
layout.configure(chart, title, titleOpts);
layout.addBox(chart, title);
chart.titleBlock = title;
}
return {
id: 'title',
beforeInit: function(chart) {
var titleOpts = chart.options.title;
if (titleOpts) {
createNewTitleBlockAndAttach(chart, titleOpts);
}
},
beforeUpdate: function(chart) {
var titleOpts = chart.options.title;
var titleBlock = chart.titleBlock;
if (titleOpts) {
helpers.mergeIf(titleOpts, defaults.global.title);
if (titleBlock) {
layout.configure(chart, titleBlock, titleOpts);
titleBlock.options = titleOpts;
} else {
createNewTitleBlockAndAttach(chart, titleOpts);
}
} else if (titleBlock) {
Chart.layoutService.removeBox(chart, titleBlock);
delete chart.titleBlock;
}
}
};
};
},{"25":25,"26":26,"45":45}],52:[function(require,module,exports){
'use strict';
module.exports = function(Chart) {
var defaultConfig = {
position: 'bottom'
};
var DatasetScale = Chart.Scale.extend({
getLabels: function() {
var data = this.chart.data;
return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels;
},
determineDataLimits: function() {
var me = this;
var labels = me.getLabels();
me.minIndex = 0;
me.maxIndex = labels.length - 1;
var findIndex;
if (me.options.ticks.min !== undefined) {
findIndex = labels.indexOf(me.options.ticks.min);
me.minIndex = findIndex !== -1 ? findIndex : me.minIndex;
}
if (me.options.ticks.max !== undefined) {
findIndex = labels.indexOf(me.options.ticks.max);
me.maxIndex = findIndex !== -1 ? findIndex : me.maxIndex;
}
me.min = labels[me.minIndex];
me.max = labels[me.maxIndex];
},
buildTicks: function() {
var me = this;
var labels = me.getLabels();
me.ticks = (me.minIndex === 0 && me.maxIndex === labels.length - 1) ? labels : labels.slice(me.minIndex, me.maxIndex + 1);
},
getLabelForIndex: function(index, datasetIndex) {
var me = this;
var data = me.chart.data;
var isHorizontal = me.isHorizontal();
if (data.yLabels && !isHorizontal) {
return me.getRightValue(data.datasets[datasetIndex].data[index]);
}
return me.ticks[index - me.minIndex];
},
getPixelForValue: function(value, index) {
var me = this;
var offset = me.options.offset;
var offsetAmt = Math.max((me.maxIndex + 1 - me.minIndex - (offset ? 0 : 1)), 1);
var valueCategory;
if (value !== undefined && value !== null) {
valueCategory = me.isHorizontal() ? value.x : value.y;
}
if (valueCategory !== undefined || (value !== undefined && isNaN(index))) {
var labels = me.getLabels();
value = valueCategory || value;
var idx = labels.indexOf(value);
index = idx !== -1 ? idx : index;
}
if (me.isHorizontal()) {
var valueWidth = me.width / offsetAmt;
var widthOffset = (valueWidth * (index - me.minIndex));
if (offset) {
widthOffset += (valueWidth / 2);
}
return me.left + Math.round(widthOffset);
}
var valueHeight = me.height / offsetAmt;
var heightOffset = (valueHeight * (index - me.minIndex));
if (offset) {
heightOffset += (valueHeight / 2);
}
return me.top + Math.round(heightOffset);
},
getPixelForTick: function(index) {
return this.getPixelForValue(this.ticks[index], index + this.minIndex, null);
},
getValueForPixel: function(pixel) {
var me = this;
var offset = me.options.offset;
var value;
var offsetAmt = Math.max((me._ticks.length - (offset ? 0 : 1)), 1);
var horz = me.isHorizontal();
var valueDimension = (horz ? me.width : me.height) / offsetAmt;
pixel -= horz ? me.left : me.top;
if (offset) {
pixel -= (valueDimension / 2);
}
if (pixel <= 0) {
value = 0;
} else {
value = Math.round(pixel / valueDimension);
}
return value + me.minIndex;
},
getBasePixel: function() {
return this.bottom;
}
});
Chart.scaleService.registerScaleType('category', DatasetScale, defaultConfig);
};
},{}],53:[function(require,module,exports){
'use strict';
var defaults = require(25);
var helpers = require(45);
var Ticks = require(34);
module.exports = function(Chart) {
var defaultConfig = {
position: 'left',
ticks: {
callback: Ticks.formatters.linear
}
};
var LinearScale = Chart.LinearScaleBase.extend({
determineDataLimits: function() {
var me = this;
var opts = me.options;
var chart = me.chart;
var data = chart.data;
var datasets = data.datasets;
var isHorizontal = me.isHorizontal();
var DEFAULT_MIN = 0;
var DEFAULT_MAX = 1;
function IDMatches(meta) {
return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;
}
me.min = null;
me.max = null;
var hasStacks = opts.stacked;
if (hasStacks === undefined) {
helpers.each(datasets, function(dataset, datasetIndex) {
if (hasStacks) {
return;
}
var meta = chart.getDatasetMeta(datasetIndex);
if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) &&
meta.stack !== undefined) {
hasStacks = true;
}
});
}
if (opts.stacked || hasStacks) {
var valuesPerStack = {};
helpers.each(datasets, function(dataset, datasetIndex) {
var meta = chart.getDatasetMeta(datasetIndex);
var key = [
meta.type,
((opts.stacked === undefined && meta.stack === undefined) ? datasetIndex : ''),
meta.stack
].join('.');
if (valuesPerStack[key] === undefined) {
valuesPerStack[key] = {
positiveValues: [],
negativeValues: []
};
}
var positiveValues = valuesPerStack[key].positiveValues;
var negativeValues = valuesPerStack[key].negativeValues;
if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
helpers.each(dataset.data, function(rawValue, index) {
var value = +me.getRightValue(rawValue);
if (isNaN(value) || meta.data[index].hidden) {
return;
}
positiveValues[index] = positiveValues[index] || 0;
negativeValues[index] = negativeValues[index] || 0;
if (opts.relativePoints) {
positiveValues[index] = 100;
} else if (value < 0) {
negativeValues[index] += value;
} else {
positiveValues[index] += value;
}
});
}
});
helpers.each(valuesPerStack, function(valuesForType) {
var values = valuesForType.positiveValues.concat(valuesForType.negativeValues);
var minVal = helpers.min(values);
var maxVal = helpers.max(values);
me.min = me.min === null ? minVal : Math.min(me.min, minVal);
me.max = me.max === null ? maxVal : Math.max(me.max, maxVal);
});
} else {
helpers.each(datasets, function(dataset, datasetIndex) {
var meta = chart.getDatasetMeta(datasetIndex);
if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
helpers.each(dataset.data, function(rawValue, index) {
var value = +me.getRightValue(rawValue);
if (isNaN(value) || meta.data[index].hidden) {
return;
}
if (me.min === null) {
me.min = value;
} else if (value < me.min) {
me.min = value;
}
if (me.max === null) {
me.max = value;
} else if (value > me.max) {
me.max = value;
}
});
}
});
}
me.min = isFinite(me.min) && !isNaN(me.min) ? me.min : DEFAULT_MIN;
me.max = isFinite(me.max) && !isNaN(me.max) ? me.max : DEFAULT_MAX;
this.handleTickRangeOptions();
},
getTickLimit: function() {
var maxTicks;
var me = this;
var tickOpts = me.options.ticks;
if (me.isHorizontal()) {
maxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.width / 50));
} else {
var tickFontSize = helpers.valueOrDefault(tickOpts.fontSize, defaults.global.defaultFontSize);
maxTicks = Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(me.height / (2 * tickFontSize)));
}
return maxTicks;
},
handleDirectionalChanges: function() {
if (!this.isHorizontal()) {
this.ticks.reverse();
}
},
getLabelForIndex: function(index, datasetIndex) {
return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
},
getPixelForValue: function(value) {
var me = this;
var start = me.start;
var rightValue = +me.getRightValue(value);
var pixel;
var range = me.end - start;
if (me.isHorizontal()) {
pixel = me.left + (me.width / range * (rightValue - start));
return Math.round(pixel);
}
pixel = me.bottom - (me.height / range * (rightValue - start));
return Math.round(pixel);
},
getValueForPixel: function(pixel) {
var me = this;
var isHorizontal = me.isHorizontal();
var innerDimension = isHorizontal ? me.width : me.height;
var offset = (isHorizontal ? pixel - me.left : me.bottom - pixel) / innerDimension;
return me.start + ((me.end - me.start) * offset);
},
getPixelForTick: function(index) {
return this.getPixelForValue(this.ticksAsNumbers[index]);
}
});
Chart.scaleService.registerScaleType('linear', LinearScale, defaultConfig);
};
},{"25":25,"34":34,"45":45}],54:[function(require,module,exports){
'use strict';
var helpers = require(45);
var Ticks = require(34);
module.exports = function(Chart) {
var noop = helpers.noop;
Chart.LinearScaleBase = Chart.Scale.extend({
getRightValue: function(value) {
if (typeof value === 'string') {
return +value;
}
return Chart.Scale.prototype.getRightValue.call(this, value);
},
handleTickRangeOptions: function() {
var me = this;
var opts = me.options;
var tickOpts = opts.ticks;
if (tickOpts.beginAtZero) {
var minSign = helpers.sign(me.min);
var maxSign = helpers.sign(me.max);
if (minSign < 0 && maxSign < 0) {
me.max = 0;
} else if (minSign > 0 && maxSign > 0) {
me.min = 0;
}
}
var setMin = tickOpts.min !== undefined || tickOpts.suggestedMin !== undefined;
var setMax = tickOpts.max !== undefined || tickOpts.suggestedMax !== undefined;
if (tickOpts.min !== undefined) {
me.min = tickOpts.min;
} else if (tickOpts.suggestedMin !== undefined) {
if (me.min === null) {
me.min = tickOpts.suggestedMin;
} else {
me.min = Math.min(me.min, tickOpts.suggestedMin);
}
}
if (tickOpts.max !== undefined) {
me.max = tickOpts.max;
} else if (tickOpts.suggestedMax !== undefined) {
if (me.max === null) {
me.max = tickOpts.suggestedMax;
} else {
me.max = Math.max(me.max, tickOpts.suggestedMax);
}
}
if (setMin !== setMax) {
if (me.min >= me.max) {
if (setMin) {
me.max = me.min + 1;
} else {
me.min = me.max - 1;
}
}
}
if (me.min === me.max) {
me.max++;
if (!tickOpts.beginAtZero) {
me.min--;
}
}
},
getTickLimit: noop,
handleDirectionalChanges: noop,
buildTicks: function() {
var me = this;
var opts = me.options;
var tickOpts = opts.ticks;
var maxTicks = me.getTickLimit();
maxTicks = Math.max(2, maxTicks);
var numericGeneratorOptions = {
maxTicks: maxTicks,
min: tickOpts.min,
max: tickOpts.max,
stepSize: helpers.valueOrDefault(tickOpts.fixedStepSize, tickOpts.stepSize)
};
var ticks = me.ticks = Ticks.generators.linear(numericGeneratorOptions, me);
me.handleDirectionalChanges();
me.max = helpers.max(ticks);
me.min = helpers.min(ticks);
if (tickOpts.reverse) {
ticks.reverse();
me.start = me.max;
me.end = me.min;
} else {
me.start = me.min;
me.end = me.max;
}
},
convertTicksToLabels: function() {
var me = this;
me.ticksAsNumbers = me.ticks.slice();
me.zeroLineIndex = me.ticks.indexOf(0);
Chart.Scale.prototype.convertTicksToLabels.call(me);
}
});
};
},{"34":34,"45":45}],55:[function(require,module,exports){
'use strict';
var helpers = require(45);
var Ticks = require(34);
module.exports = function(Chart) {
var defaultConfig = {
position: 'left',
ticks: {
callback: Ticks.formatters.logarithmic
}
};
var LogarithmicScale = Chart.Scale.extend({
determineDataLimits: function() {
var me = this;
var opts = me.options;
var tickOpts = opts.ticks;
var chart = me.chart;
var data = chart.data;
var datasets = data.datasets;
var valueOrDefault = helpers.valueOrDefault;
var isHorizontal = me.isHorizontal();
function IDMatches(meta) {
return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;
}
me.min = null;
me.max = null;
me.minNotZero = null;
var hasStacks = opts.stacked;
if (hasStacks === undefined) {
helpers.each(datasets, function(dataset, datasetIndex) {
if (hasStacks) {
return;
}
var meta = chart.getDatasetMeta(datasetIndex);
if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) &&
meta.stack !== undefined) {
hasStacks = true;
}
});
}
if (opts.stacked || hasStacks) {
var valuesPerStack = {};
helpers.each(datasets, function(dataset, datasetIndex) {
var meta = chart.getDatasetMeta(datasetIndex);
var key = [
meta.type,
((opts.stacked === undefined && meta.stack === undefined) ? datasetIndex : ''),
meta.stack
].join('.');
if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
if (valuesPerStack[key] === undefined) {
valuesPerStack[key] = [];
}
helpers.each(dataset.data, function(rawValue, index) {
var values = valuesPerStack[key];
var value = +me.getRightValue(rawValue);
if (isNaN(value) || meta.data[index].hidden) {
return;
}
values[index] = values[index] || 0;
if (opts.relativePoints) {
values[index] = 100;
} else {
values[index] += value;
}
});
}
});
helpers.each(valuesPerStack, function(valuesForType) {
var minVal = helpers.min(valuesForType);
var maxVal = helpers.max(valuesForType);
me.min = me.min === null ? minVal : Math.min(me.min, minVal);
me.max = me.max === null ? maxVal : Math.max(me.max, maxVal);
});
} else {
helpers.each(datasets, function(dataset, datasetIndex) {
var meta = chart.getDatasetMeta(datasetIndex);
if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
helpers.each(dataset.data, function(rawValue, index) {
var value = +me.getRightValue(rawValue);
if (isNaN(value) || meta.data[index].hidden) {
return;
}
if (me.min === null) {
me.min = value;
} else if (value < me.min) {
me.min = value;
}
if (me.max === null) {
me.max = value;
} else if (value > me.max) {
me.max = value;
}
if (value !== 0 && (me.minNotZero === null || value < me.minNotZero)) {
me.minNotZero = value;
}
});
}
});
}
me.min = valueOrDefault(tickOpts.min, me.min);
me.max = valueOrDefault(tickOpts.max, me.max);
if (me.min === me.max) {
if (me.min !== 0 && me.min !== null) {
me.min = Math.pow(10, Math.floor(helpers.log10(me.min)) - 1);
me.max = Math.pow(10, Math.floor(helpers.log10(me.max)) + 1);
} else {
me.min = 1;
me.max = 10;
}
}
},
buildTicks: function() {
var me = this;
var opts = me.options;
var tickOpts = opts.ticks;
var generationOptions = {
min: tickOpts.min,
max: tickOpts.max
};
var ticks = me.ticks = Ticks.generators.logarithmic(generationOptions, me);
if (!me.isHorizontal()) {
ticks.reverse();
}
me.max = helpers.max(ticks);
me.min = helpers.min(ticks);
if (tickOpts.reverse) {
ticks.reverse();
me.start = me.max;
me.end = me.min;
} else {
me.start = me.min;
me.end = me.max;
}
},
convertTicksToLabels: function() {
this.tickValues = this.ticks.slice();
Chart.Scale.prototype.convertTicksToLabels.call(this);
},
getLabelForIndex: function(index, datasetIndex) {
return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
},
getPixelForTick: function(index) {
return this.getPixelForValue(this.tickValues[index]);
},
getPixelForValue: function(value) {
var me = this;
var start = me.start;
var newVal = +me.getRightValue(value);
var opts = me.options;
var tickOpts = opts.ticks;
var innerDimension, pixel, range;
if (me.isHorizontal()) {
range = helpers.log10(me.end) - helpers.log10(start); // todo: if start === 0
if (newVal === 0) {
pixel = me.left;
} else {
innerDimension = me.width;
pixel = me.left + (innerDimension / range * (helpers.log10(newVal) - helpers.log10(start)));
}
} else {
innerDimension = me.height;
if (start === 0 && !tickOpts.reverse) {
range = helpers.log10(me.end) - helpers.log10(me.minNotZero);
if (newVal === start) {
pixel = me.bottom;
} else if (newVal === me.minNotZero) {
pixel = me.bottom - innerDimension * 0.02;
} else {
pixel = me.bottom - innerDimension * 0.02 - (innerDimension * 0.98 / range * (helpers.log10(newVal) - helpers.log10(me.minNotZero)));
}
} else if (me.end === 0 && tickOpts.reverse) {
range = helpers.log10(me.start) - helpers.log10(me.minNotZero);
if (newVal === me.end) {
pixel = me.top;
} else if (newVal === me.minNotZero) {
pixel = me.top + innerDimension * 0.02;
} else {
pixel = me.top + innerDimension * 0.02 + (innerDimension * 0.98 / range * (helpers.log10(newVal) - helpers.log10(me.minNotZero)));
}
} else if (newVal === 0) {
pixel = tickOpts.reverse ? me.top : me.bottom;
} else {
range = helpers.log10(me.end) - helpers.log10(start);
innerDimension = me.height;
pixel = me.bottom - (innerDimension / range * (helpers.log10(newVal) - helpers.log10(start)));
}
}
return pixel;
},
getValueForPixel: function(pixel) {
var me = this;
var range = helpers.log10(me.end) - helpers.log10(me.start);
var value, innerDimension;
if (me.isHorizontal()) {
innerDimension = me.width;
value = me.start * Math.pow(10, (pixel - me.left) * range / innerDimension);
} else { // todo: if start === 0
innerDimension = me.height;
value = Math.pow(10, (me.bottom - pixel) * range / innerDimension) / me.start;
}
return value;
}
});
Chart.scaleService.registerScaleType('logarithmic', LogarithmicScale, defaultConfig);
};
},{"34":34,"45":45}],56:[function(require,module,exports){
'use strict';
var defaults = require(25);
var helpers = require(45);
var Ticks = require(34);
module.exports = function(Chart) {
var globalDefaults = defaults.global;
var defaultConfig = {
display: true,
animate: true,
position: 'chartArea',
angleLines: {
display: true,
color: 'rgba(0, 0, 0, 0.1)',
lineWidth: 1
},
gridLines: {
circular: false
},
ticks: {
showLabelBackdrop: true,
backdropColor: 'rgba(255,255,255,0.75)',
backdropPaddingY: 2,
backdropPaddingX: 2,
callback: Ticks.formatters.linear
},
pointLabels: {
display: true,
fontSize: 10,
callback: function(label) {
return label;
}
}
};
function getValueCount(scale) {
var opts = scale.options;
return opts.angleLines.display || opts.pointLabels.display ? scale.chart.data.labels.length : 0;
}
function getPointLabelFontOptions(scale) {
var pointLabelOptions = scale.options.pointLabels;
var fontSize = helpers.valueOrDefault(pointLabelOptions.fontSize, globalDefaults.defaultFontSize);
var fontStyle = helpers.valueOrDefault(pointLabelOptions.fontStyle, globalDefaults.defaultFontStyle);
var fontFamily = helpers.valueOrDefault(pointLabelOptions.fontFamily, globalDefaults.defaultFontFamily);
var font = helpers.fontString(fontSize, fontStyle, fontFamily);
return {
size: fontSize,
style: fontStyle,
family: fontFamily,
font: font
};
}
function measureLabelSize(ctx, fontSize, label) {
if (helpers.isArray(label)) {
return {
w: helpers.longestText(ctx, ctx.font, label),
h: (label.length * fontSize) + ((label.length - 1) * 1.5 * fontSize)
};
}
return {
w: ctx.measureText(label).width,
h: fontSize
};
}
function determineLimits(angle, pos, size, min, max) {
if (angle === min || angle === max) {
return {
start: pos - (size / 2),
end: pos + (size / 2)
};
} else if (angle < min || angle > max) {
return {
start: pos - size - 5,
end: pos
};
}
return {
start: pos,
end: pos + size + 5
};
}
function fitWithPointLabels(scale) {
var plFont = getPointLabelFontOptions(scale);
var largestPossibleRadius = Math.min(scale.height / 2, scale.width / 2);
var furthestLimits = {
r: scale.width,
l: 0,
t: scale.height,
b: 0
};
var furthestAngles = {};
var i, textSize, pointPosition;
scale.ctx.font = plFont.font;
scale._pointLabelSizes = [];
var valueCount = getValueCount(scale);
for (i = 0; i < valueCount; i++) {
pointPosition = scale.getPointPosition(i, largestPossibleRadius);
textSize = measureLabelSize(scale.ctx, plFont.size, scale.pointLabels[i] || '');
scale._pointLabelSizes[i] = textSize;
var angleRadians = scale.getIndexAngle(i);
var angle = helpers.toDegrees(angleRadians) % 360;
var hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
var vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
if (hLimits.start < furthestLimits.l) {
furthestLimits.l = hLimits.start;
furthestAngles.l = angleRadians;
}
if (hLimits.end > furthestLimits.r) {
furthestLimits.r = hLimits.end;
furthestAngles.r = angleRadians;
}
if (vLimits.start < furthestLimits.t) {
furthestLimits.t = vLimits.start;
furthestAngles.t = angleRadians;
}
if (vLimits.end > furthestLimits.b) {
furthestLimits.b = vLimits.end;
furthestAngles.b = angleRadians;
}
}
scale.setReductions(largestPossibleRadius, furthestLimits, furthestAngles);
}
function fit(scale) {
var largestPossibleRadius = Math.min(scale.height / 2, scale.width / 2);
scale.drawingArea = Math.round(largestPossibleRadius);
scale.setCenterPoint(0, 0, 0, 0);
}
function getTextAlignForAngle(angle) {
if (angle === 0 || angle === 180) {
return 'center';
} else if (angle < 180) {
return 'left';
}
return 'right';
}
function fillText(ctx, text, position, fontSize) {
if (helpers.isArray(text)) {
var y = position.y;
var spacing = 1.5 * fontSize;
for (var i = 0; i < text.length; ++i) {
ctx.fillText(text[i], position.x, y);
y += spacing;
}
} else {
ctx.fillText(text, position.x, position.y);
}
}
function adjustPointPositionForLabelHeight(angle, textSize, position) {
if (angle === 90 || angle === 270) {
position.y -= (textSize.h / 2);
} else if (angle > 270 || angle < 90) {
position.y -= textSize.h;
}
}
function drawPointLabels(scale) {
var ctx = scale.ctx;
var valueOrDefault = helpers.valueOrDefault;
var opts = scale.options;
var angleLineOpts = opts.angleLines;
var pointLabelOpts = opts.pointLabels;
ctx.lineWidth = angleLineOpts.lineWidth;
ctx.strokeStyle = angleLineOpts.color;
var outerDistance = scale.getDistanceFromCenterForValue(opts.ticks.reverse ? scale.min : scale.max);
var plFont = getPointLabelFontOptions(scale);
ctx.textBaseline = 'top';
for (var i = getValueCount(scale) - 1; i >= 0; i--) {
if (angleLineOpts.display) {
var outerPosition = scale.getPointPosition(i, outerDistance);
ctx.beginPath();
ctx.moveTo(scale.xCenter, scale.yCenter);
ctx.lineTo(outerPosition.x, outerPosition.y);
ctx.stroke();
ctx.closePath();
}
if (pointLabelOpts.display) {
var pointLabelPosition = scale.getPointPosition(i, outerDistance + 5);
var pointLabelFontColor = valueOrDefault(pointLabelOpts.fontColor, globalDefaults.defaultFontColor);
ctx.font = plFont.font;
ctx.fillStyle = pointLabelFontColor;
var angleRadians = scale.getIndexAngle(i);
var angle = helpers.toDegrees(angleRadians);
ctx.textAlign = getTextAlignForAngle(angle);
adjustPointPositionForLabelHeight(angle, scale._pointLabelSizes[i], pointLabelPosition);
fillText(ctx, scale.pointLabels[i] || '', pointLabelPosition, plFont.size);
}
}
}
function drawRadiusLine(scale, gridLineOpts, radius, index) {
var ctx = scale.ctx;
ctx.strokeStyle = helpers.valueAtIndexOrDefault(gridLineOpts.color, index - 1);
ctx.lineWidth = helpers.valueAtIndexOrDefault(gridLineOpts.lineWidth, index - 1);
if (scale.options.gridLines.circular) {
ctx.beginPath();
ctx.arc(scale.xCenter, scale.yCenter, radius, 0, Math.PI * 2);
ctx.closePath();
ctx.stroke();
} else {
var valueCount = getValueCount(scale);
if (valueCount === 0) {
return;
}
ctx.beginPath();
var pointPosition = scale.getPointPosition(0, radius);
ctx.moveTo(pointPosition.x, pointPosition.y);
for (var i = 1; i < valueCount; i++) {
pointPosition = scale.getPointPosition(i, radius);
ctx.lineTo(pointPosition.x, pointPosition.y);
}
ctx.closePath();
ctx.stroke();
}
}
function numberOrZero(param) {
return helpers.isNumber(param) ? param : 0;
}
var LinearRadialScale = Chart.LinearScaleBase.extend({
setDimensions: function() {
var me = this;
var opts = me.options;
var tickOpts = opts.ticks;
me.width = me.maxWidth;
me.height = me.maxHeight;
me.xCenter = Math.round(me.width / 2);
me.yCenter = Math.round(me.height / 2);
var minSize = helpers.min([me.height, me.width]);
var tickFontSize = helpers.valueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);
me.drawingArea = opts.display ? (minSize / 2) - (tickFontSize / 2 + tickOpts.backdropPaddingY) : (minSize / 2);
},
determineDataLimits: function() {
var me = this;
var chart = me.chart;
var min = Number.POSITIVE_INFINITY;
var max = Number.NEGATIVE_INFINITY;
helpers.each(chart.data.datasets, function(dataset, datasetIndex) {
if (chart.isDatasetVisible(datasetIndex)) {
var meta = chart.getDatasetMeta(datasetIndex);
helpers.each(dataset.data, function(rawValue, index) {
var value = +me.getRightValue(rawValue);
if (isNaN(value) || meta.data[index].hidden) {
return;
}
min = Math.min(value, min);
max = Math.max(value, max);
});
}
});
me.min = (min === Number.POSITIVE_INFINITY ? 0 : min);
me.max = (max === Number.NEGATIVE_INFINITY ? 0 : max);
me.handleTickRangeOptions();
},
getTickLimit: function() {
var tickOpts = this.options.ticks;
var tickFontSize = helpers.valueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);
return Math.min(tickOpts.maxTicksLimit ? tickOpts.maxTicksLimit : 11, Math.ceil(this.drawingArea / (1.5 * tickFontSize)));
},
convertTicksToLabels: function() {
var me = this;
Chart.LinearScaleBase.prototype.convertTicksToLabels.call(me);
me.pointLabels = me.chart.data.labels.map(me.options.pointLabels.callback, me);
},
getLabelForIndex: function(index, datasetIndex) {
return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
},
fit: function() {
if (this.options.pointLabels.display) {
fitWithPointLabels(this);
} else {
fit(this);
}
},
setReductions: function(largestPossibleRadius, furthestLimits, furthestAngles) {
var me = this;
var radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);
var radiusReductionRight = Math.max(furthestLimits.r - me.width, 0) / Math.sin(furthestAngles.r);
var radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);
var radiusReductionBottom = -Math.max(furthestLimits.b - me.height, 0) / Math.cos(furthestAngles.b);
radiusReductionLeft = numberOrZero(radiusReductionLeft);
radiusReductionRight = numberOrZero(radiusReductionRight);
radiusReductionTop = numberOrZero(radiusReductionTop);
radiusReductionBottom = numberOrZero(radiusReductionBottom);
me.drawingArea = Math.min(
Math.round(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2),
Math.round(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2));
me.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);
},
setCenterPoint: function(leftMovement, rightMovement, topMovement, bottomMovement) {
var me = this;
var maxRight = me.width - rightMovement - me.drawingArea;
var maxLeft = leftMovement + me.drawingArea;
var maxTop = topMovement + me.drawingArea;
var maxBottom = me.height - bottomMovement - me.drawingArea;
me.xCenter = Math.round(((maxLeft + maxRight) / 2) + me.left);
me.yCenter = Math.round(((maxTop + maxBottom) / 2) + me.top);
},
getIndexAngle: function(index) {
var angleMultiplier = (Math.PI * 2) / getValueCount(this);
var startAngle = this.chart.options && this.chart.options.startAngle ?
this.chart.options.startAngle :
0;
var startAngleRadians = startAngle * Math.PI * 2 / 360;
return index * angleMultiplier + startAngleRadians;
},
getDistanceFromCenterForValue: function(value) {
var me = this;
if (value === null) {
return 0; // null always in center
}
var scalingFactor = me.drawingArea / (me.max - me.min);
if (me.options.ticks.reverse) {
return (me.max - value) * scalingFactor;
}
return (value - me.min) * scalingFactor;
},
getPointPosition: function(index, distanceFromCenter) {
var me = this;
var thisAngle = me.getIndexAngle(index) - (Math.PI / 2);
return {
x: Math.round(Math.cos(thisAngle) * distanceFromCenter) + me.xCenter,
y: Math.round(Math.sin(thisAngle) * distanceFromCenter) + me.yCenter
};
},
getPointPositionForValue: function(index, value) {
return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));
},
getBasePosition: function() {
var me = this;
var min = me.min;
var max = me.max;
return me.getPointPositionForValue(0,
me.beginAtZero ? 0 :
min < 0 && max < 0 ? max :
min > 0 && max > 0 ? min :
0);
},
draw: function() {
var me = this;
var opts = me.options;
var gridLineOpts = opts.gridLines;
var tickOpts = opts.ticks;
var valueOrDefault = helpers.valueOrDefault;
if (opts.display) {
var ctx = me.ctx;
var startAngle = this.getIndexAngle(0);
var tickFontSize = valueOrDefault(tickOpts.fontSize, globalDefaults.defaultFontSize);
var tickFontStyle = valueOrDefault(tickOpts.fontStyle, globalDefaults.defaultFontStyle);
var tickFontFamily = valueOrDefault(tickOpts.fontFamily, globalDefaults.defaultFontFamily);
var tickLabelFont = helpers.fontString(tickFontSize, tickFontStyle, tickFontFamily);
helpers.each(me.ticks, function(label, index) {
if (index > 0 || tickOpts.reverse) {
var yCenterOffset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]);
if (gridLineOpts.display && index !== 0) {
drawRadiusLine(me, gridLineOpts, yCenterOffset, index);
}
if (tickOpts.display) {
var tickFontColor = valueOrDefault(tickOpts.fontColor, globalDefaults.defaultFontColor);
ctx.font = tickLabelFont;
ctx.save();
ctx.translate(me.xCenter, me.yCenter);
ctx.rotate(startAngle);
if (tickOpts.showLabelBackdrop) {
var labelWidth = ctx.measureText(label).width;
ctx.fillStyle = tickOpts.backdropColor;
ctx.fillRect(
-labelWidth / 2 - tickOpts.backdropPaddingX,
-yCenterOffset - tickFontSize / 2 - tickOpts.backdropPaddingY,
labelWidth + tickOpts.backdropPaddingX * 2,
tickFontSize + tickOpts.backdropPaddingY * 2
);
}
ctx.textAlign = 'center';
ctx.textBaseline = 'middle';
ctx.fillStyle = tickFontColor;
ctx.fillText(label, 0, -yCenterOffset);
ctx.restore();
}
}
});
if (opts.angleLines.display || opts.pointLabels.display) {
drawPointLabels(me);
}
}
}
});
Chart.scaleService.registerScaleType('radialLinear', LinearRadialScale, defaultConfig);
};
},{"25":25,"34":34,"45":45}],57:[function(require,module,exports){
'use strict';
var moment = require(6);
moment = typeof moment === 'function' ? moment : window.moment;
var defaults = require(25);
var helpers = require(45);
var MIN_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;
var MAX_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
var INTERVALS = {
millisecond: {
common: true,
size: 1,
steps: [1, 2, 5, 10, 20, 50, 100, 250, 500]
},
second: {
common: true,
size: 1000,
steps: [1, 2, 5, 10, 30]
},
minute: {
common: true,
size: 60000,
steps: [1, 2, 5, 10, 30]
},
hour: {
common: true,
size: 3600000,
steps: [1, 2, 3, 6, 12]
},
day: {
common: true,
size: 86400000,
steps: [1, 2, 5]
},
week: {
common: false,
size: 604800000,
steps: [1, 2, 3, 4]
},
month: {
common: true,
size: 2.628e9,
steps: [1, 2, 3]
},
quarter: {
common: false,
size: 7.884e9,
steps: [1, 2, 3, 4]
},
year: {
common: true,
size: 3.154e10
}
};
var UNITS = Object.keys(INTERVALS);
function sorter(a, b) {
return a - b;
}
function arrayUnique(items) {
var hash = {};
var out = [];
var i, ilen, item;
for (i = 0, ilen = items.length; i < ilen; ++i) {
item = items[i];
if (!hash[item]) {
hash[item] = true;
out.push(item);
}
}
return out;
}
function buildLookupTable(timestamps, min, max, distribution) {
if (distribution === 'linear' || !timestamps.length) {
return [
{time: min, pos: 0},
{time: max, pos: 1}
];
}
var table = [];
var items = [min];
var i, ilen, prev, curr, next;
for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
curr = timestamps[i];
if (curr > min && curr < max) {
items.push(curr);
}
}
items.push(max);
for (i = 0, ilen = items.length; i < ilen; ++i) {
next = items[i + 1];
prev = items[i - 1];
curr = items[i];
if (prev === undefined || next === undefined || Math.round((next + prev) / 2) !== curr) {
table.push({time: curr, pos: i / (ilen - 1)});
}
}
return table;
}
function lookup(table, key, value) {
var lo = 0;
var hi = table.length - 1;
var mid, i0, i1;
while (lo >= 0 && lo <= hi) {
mid = (lo + hi) >> 1;
i0 = table[mid - 1] || null;
i1 = table[mid];
if (!i0) {
return {lo: null, hi: i1};
} else if (i1[key] < value) {
lo = mid + 1;
} else if (i0[key] > value) {
hi = mid - 1;
} else {
return {lo: i0, hi: i1};
}
}
return {lo: i1, hi: null};
}
function interpolate(table, skey, sval, tkey) {
var range = lookup(table, skey, sval);
var prev = !range.lo ? table[0] : !range.hi ? table[table.length - 2] : range.lo;
var next = !range.lo ? table[1] : !range.hi ? table[table.length - 1] : range.hi;
var span = next[skey] - prev[skey];
var ratio = span ? (sval - prev[skey]) / span : 0;
var offset = (next[tkey] - prev[tkey]) * ratio;
return prev[tkey] + offset;
}
function momentify(value, options) {
var parser = options.parser;
var format = options.parser || options.format;
if (typeof parser === 'function') {
return parser(value);
}
if (typeof value === 'string' && typeof format === 'string') {
return moment(value, format);
}
if (!(value instanceof moment)) {
value = moment(value);
}
if (value.isValid()) {
return value;
}
if (typeof format === 'function') {
return format(value);
}
return value;
}
function parse(input, scale) {
if (helpers.isNullOrUndef(input)) {
return null;
}
var options = scale.options.time;
var value = momentify(scale.getRightValue(input), options);
if (!value.isValid()) {
return null;
}
if (options.round) {
value.startOf(options.round);
}
return value.valueOf();
}
function determineStepSize(min, max, unit, capacity) {
var range = max - min;
var interval = INTERVALS[unit];
var milliseconds = interval.size;
var steps = interval.steps;
var i, ilen, factor;
if (!steps) {
return Math.ceil(range / ((capacity || 1) * milliseconds));
}
for (i = 0, ilen = steps.length; i < ilen; ++i) {
factor = steps[i];
if (Math.ceil(range / (milliseconds * factor)) <= capacity) {
break;
}
}
return factor;
}
function determineUnitForAutoTicks(minUnit, min, max, capacity) {
var ilen = UNITS.length;
var i, interval, factor;
for (i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
interval = INTERVALS[UNITS[i]];
factor = interval.steps ? interval.steps[interval.steps.length - 1] : MAX_INTEGER;
if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
return UNITS[i];
}
}
return UNITS[ilen - 1];
}
function determineUnitForFormatting(ticks, minUnit, min, max) {
var duration = moment.duration(moment(max).diff(moment(min)));
var ilen = UNITS.length;
var i, unit;
for (i = ilen - 1; i >= UNITS.indexOf(minUnit); i--) {
unit = UNITS[i];
if (INTERVALS[unit].common && duration.as(unit) >= ticks.length) {
return unit;
}
}
return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
}
function determineMajorUnit(unit) {
for (var i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {
if (INTERVALS[UNITS[i]].common) {
return UNITS[i];
}
}
}
function generate(min, max, capacity, options) {
var timeOpts = options.time;
var minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, capacity);
var major = determineMajorUnit(minor);
var stepSize = helpers.valueOrDefault(timeOpts.stepSize, timeOpts.unitStepSize);
var weekday = minor === 'week' ? timeOpts.isoWeekday : false;
var majorTicksEnabled = options.ticks.major.enabled;
var interval = INTERVALS[minor];
var first = moment(min);
var last = moment(max);
var ticks = [];
var time;
if (!stepSize) {
stepSize = determineStepSize(min, max, minor, capacity);
}
if (weekday) {
first = first.isoWeekday(weekday);
last = last.isoWeekday(weekday);
}
first = first.startOf(weekday ? 'day' : minor);
last = last.startOf(weekday ? 'day' : minor);
if (last < max) {
last.add(1, minor);
}
time = moment(first);
if (majorTicksEnabled && major && !weekday && !timeOpts.round) {
time.startOf(major);
time.add(~~((first - time) / (interval.size * stepSize)) * stepSize, minor);
}
for (; time < last; time.add(stepSize, minor)) {
ticks.push(+time);
}
ticks.push(+time);
return ticks;
}
function computeOffsets(table, ticks, min, max, options) {
var left = 0;
var right = 0;
var upper, lower;
if (options.offset && ticks.length) {
if (!options.time.min) {
upper = ticks.length > 1 ? ticks[1] : max;
lower = ticks[0];
left = (
interpolate(table, 'time', upper, 'pos') -
interpolate(table, 'time', lower, 'pos')
) / 2;
}
if (!options.time.max) {
upper = ticks[ticks.length - 1];
lower = ticks.length > 1 ? ticks[ticks.length - 2] : min;
right = (
interpolate(table, 'time', upper, 'pos') -
interpolate(table, 'time', lower, 'pos')
) / 2;
}
}
return {left: left, right: right};
}
function ticksFromTimestamps(values, majorUnit) {
var ticks = [];
var i, ilen, value, major;
for (i = 0, ilen = values.length; i < ilen; ++i) {
value = values[i];
major = majorUnit ? value === +moment(value).startOf(majorUnit) : false;
ticks.push({
value: value,
major: major
});
}
return ticks;
}
module.exports = function(Chart) {
var defaultConfig = {
position: 'bottom',
distribution: 'linear',
bounds: 'data',
time: {
parser: false, // false == a pattern string from http://momentjs.com/docs/#/parsing/string-format/ or a custom callback that converts its argument to a moment
format: false, // DEPRECATED false == date objects, moment object, callback or a pattern string from http://momentjs.com/docs/#/parsing/string-format/
unit: false, // false == automatic or override with week, month, year, etc.
round: false, // none, or override with week, month, year, etc.
displayFormat: false, // DEPRECATED
isoWeekday: false, // override week start day - see http://momentjs.com/docs/#/get-set/iso-weekday/
minUnit: 'millisecond',
displayFormats: {
millisecond: 'h:mm:ss.SSS a', // 11:20:01.123 AM,
second: 'h:mm:ss a', // 11:20:01 AM
minute: 'h:mm a', // 11:20 AM
hour: 'hA', // 5PM
day: 'MMM D', // Sep 4
week: 'll', // Week 46, or maybe "[W]WW - YYYY" ?
month: 'MMM YYYY', // Sept 2015
quarter: '[Q]Q - YYYY', // Q3
year: 'YYYY' // 2015
},
},
ticks: {
autoSkip: false,
source: 'auto',
major: {
enabled: false
}
}
};
var TimeScale = Chart.Scale.extend({
initialize: function() {
if (!moment) {
throw new Error('Chart.js - Moment.js could not be found! You must include it before Chart.js to use the time scale. Download at https://momentjs.com');
}
this.mergeTicksOptions();
Chart.Scale.prototype.initialize.call(this);
},
update: function() {
var me = this;
var options = me.options;
if (options.time && options.time.format) {
console.warn('options.time.format is deprecated and replaced by options.time.parser.');
}
return Chart.Scale.prototype.update.apply(me, arguments);
},
getRightValue: function(rawValue) {
if (rawValue && rawValue.t !== undefined) {
rawValue = rawValue.t;
}
return Chart.Scale.prototype.getRightValue.call(this, rawValue);
},
determineDataLimits: function() {
var me = this;
var chart = me.chart;
var timeOpts = me.options.time;
var min = MAX_INTEGER;
var max = MIN_INTEGER;
var timestamps = [];
var datasets = [];
var labels = [];
var i, j, ilen, jlen, data, timestamp;
for (i = 0, ilen = chart.data.labels.length; i < ilen; ++i) {
labels.push(parse(chart.data.labels[i], me));
}
for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
if (chart.isDatasetVisible(i)) {
data = chart.data.datasets[i].data;
if (helpers.isObject(data[0])) {
datasets[i] = [];
for (j = 0, jlen = data.length; j < jlen; ++j) {
timestamp = parse(data[j], me);
timestamps.push(timestamp);
datasets[i][j] = timestamp;
}
} else {
timestamps.push.apply(timestamps, labels);
datasets[i] = labels.slice(0);
}
} else {
datasets[i] = [];
}
}
if (labels.length) {
labels = arrayUnique(labels).sort(sorter);
min = Math.min(min, labels[0]);
max = Math.max(max, labels[labels.length - 1]);
}
if (timestamps.length) {
timestamps = arrayUnique(timestamps).sort(sorter);
min = Math.min(min, timestamps[0]);
max = Math.max(max, timestamps[timestamps.length - 1]);
}
min = parse(timeOpts.min, me) || min;
max = parse(timeOpts.max, me) || max;
min = min === MAX_INTEGER ? +moment().startOf('day') : min;
max = max === MIN_INTEGER ? +moment().endOf('day') + 1 : max;
me.min = Math.min(min, max);
me.max = Math.max(min + 1, max);
me._horizontal = me.isHorizontal();
me._table = [];
me._timestamps = {
data: timestamps,
datasets: datasets,
labels: labels
};
},
buildTicks: function() {
var me = this;
var min = me.min;
var max = me.max;
var options = me.options;
var timeOpts = options.time;
var timestamps = [];
var ticks = [];
var i, ilen, timestamp;
switch (options.ticks.source) {
case 'data':
timestamps = me._timestamps.data;
break;
case 'labels':
timestamps = me._timestamps.labels;
break;
case 'auto':
default:
timestamps = generate(min, max, me.getLabelCapacity(min), options);
}
if (options.bounds === 'ticks' && timestamps.length) {
min = timestamps[0];
max = timestamps[timestamps.length - 1];
}
min = parse(timeOpts.min, me) || min;
max = parse(timeOpts.max, me) || max;
for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
timestamp = timestamps[i];
if (timestamp >= min && timestamp <= max) {
ticks.push(timestamp);
}
}
me.min = min;
me.max = max;
me._unit = timeOpts.unit || determineUnitForFormatting(ticks, timeOpts.minUnit, me.min, me.max);
me._majorUnit = determineMajorUnit(me._unit);
me._table = buildLookupTable(me._timestamps.data, min, max, options.distribution);
me._offsets = computeOffsets(me._table, ticks, min, max, options);
return ticksFromTimestamps(ticks, me._majorUnit);
},
getLabelForIndex: function(index, datasetIndex) {
var me = this;
var data = me.chart.data;
var timeOpts = me.options.time;
var label = data.labels && index < data.labels.length ? data.labels[index] : '';
var value = data.datasets[datasetIndex].data[index];
if (helpers.isObject(value)) {
label = me.getRightValue(value);
}
if (timeOpts.tooltipFormat) {
label = momentify(label, timeOpts).format(timeOpts.tooltipFormat);
}
return label;
},
tickFormatFunction: function(tick, index, ticks, formatOverride) {
var me = this;
var options = me.options;
var time = tick.valueOf();
var formats = options.time.displayFormats;
var minorFormat = formats[me._unit];
var majorUnit = me._majorUnit;
var majorFormat = formats[majorUnit];
var majorTime = tick.clone().startOf(majorUnit).valueOf();
var majorTickOpts = options.ticks.major;
var major = majorTickOpts.enabled && majorUnit && majorFormat && time === majorTime;
var label = tick.format(formatOverride ? formatOverride : major ? majorFormat : minorFormat);
var tickOpts = major ? majorTickOpts : options.ticks.minor;
var formatter = helpers.valueOrDefault(tickOpts.callback, tickOpts.userCallback);
return formatter ? formatter(label, index, ticks) : label;
},
convertTicksToLabels: function(ticks) {
var labels = [];
var i, ilen;
for (i = 0, ilen = ticks.length; i < ilen; ++i) {
labels.push(this.tickFormatFunction(moment(ticks[i].value), i, ticks));
}
return labels;
},
getPixelForOffset: function(time) {
var me = this;
var size = me._horizontal ? me.width : me.height;
var start = me._horizontal ? me.left : me.top;
var pos = interpolate(me._table, 'time', time, 'pos');
return start + size * (me._offsets.left + pos) / (me._offsets.left + 1 + me._offsets.right);
},
getPixelForValue: function(value, index, datasetIndex) {
var me = this;
var time = null;
if (index !== undefined && datasetIndex !== undefined) {
time = me._timestamps.datasets[datasetIndex][index];
}
if (time === null) {
time = parse(value, me);
}
if (time !== null) {
return me.getPixelForOffset(time);
}
},
getPixelForTick: function(index) {
var ticks = this.getTicks();
return index >= 0 && index < ticks.length ?
this.getPixelForOffset(ticks[index].value) :
null;
},
getValueForPixel: function(pixel) {
var me = this;
var size = me._horizontal ? me.width : me.height;
var start = me._horizontal ? me.left : me.top;
var pos = (size ? (pixel - start) / size : 0) * (me._offsets.left + 1 + me._offsets.left) - me._offsets.right;
var time = interpolate(me._table, 'pos', pos, 'time');
return moment(time);
},
getLabelWidth: function(label) {
var me = this;
var ticksOpts = me.options.ticks;
var tickLabelWidth = me.ctx.measureText(label).width;
var angle = helpers.toRadians(ticksOpts.maxRotation);
var cosRotation = Math.cos(angle);
var sinRotation = Math.sin(angle);
var tickFontSize = helpers.valueOrDefault(ticksOpts.fontSize, defaults.global.defaultFontSize);
return (tickLabelWidth * cosRotation) + (tickFontSize * sinRotation);
},
getLabelCapacity: function(exampleTime) {
var me = this;
var formatOverride = me.options.time.displayFormats.millisecond;	// Pick the longest format for guestimation
var exampleLabel = me.tickFormatFunction(moment(exampleTime), 0, [], formatOverride);
var tickLabelWidth = me.getLabelWidth(exampleLabel);
var innerWidth = me.isHorizontal() ? me.width : me.height;
return Math.floor(innerWidth / tickLabelWidth);
}
});
Chart.scaleService.registerScaleType('time', TimeScale, defaultConfig);
};
},{"25":25,"45":45,"6":6}]},{},[7])(7)
});
Chart.elements.Rectangle.prototype.draw = function() {
var ctx = this._chart.ctx;
var vm = this._view;
var left, right, top, bottom, signX, signY, borderSkipped, radius;
var borderWidth = vm.borderWidth;
var cornerRadius = this._chart.options.barRadius ? this._chart.options.barRadius : 0;
if (!vm.horizontal) {
left = vm.x - vm.width / 2;
right = vm.x + vm.width / 2;
if (vm.y > 2 * cornerRadius) {
top = vm.y - cornerRadius;
} else {
top = vm.y;
}
bottom = vm.base;
signX = 1;
signY = bottom > top? 1: -1;
borderSkipped = vm.borderSkipped || 'bottom';
} else {
left = vm.base;
right = vm.x;
top = vm.y - vm.height / 2;
bottom = vm.y + vm.height / 2;
signX = right > left? 1: -1;
signY = 1;
borderSkipped = vm.borderSkipped || 'left';
}
if (borderWidth) {
var barSize = Math.min(Math.abs(left - right), Math.abs(top - bottom));
borderWidth = borderWidth > barSize? barSize: borderWidth;
var halfStroke = borderWidth / 2;
var borderLeft = left + (borderSkipped !== 'left'? halfStroke * signX: 0);
var borderRight = right + (borderSkipped !== 'right'? -halfStroke * signX: 0);
var borderTop = top + (borderSkipped !== 'top'? halfStroke * signY: 0);
var borderBottom = bottom + (borderSkipped !== 'bottom'? -halfStroke * signY: 0);
if (borderLeft !== borderRight) {
top = borderTop;
bottom = borderBottom;
}
if (borderTop !== borderBottom) {
left = borderLeft;
right = borderRight;
}
}
ctx.beginPath();
ctx.fillStyle = vm.backgroundColor;
ctx.strokeStyle = vm.borderColor;
ctx.lineWidth = borderWidth;
var corners = [
[left, bottom],
[left, top],
[right, top],
[right, bottom]
];
var borders = ['bottom', 'left', 'top', 'right'];
var startCorner = borders.indexOf(borderSkipped, 0);
if (startCorner === -1) {
startCorner = 0;
}
function cornerAt(index) {
return corners[(startCorner + index) % 4];
}
var corner = cornerAt(0);
ctx.moveTo(corner[0], corner[1]);
for (var i = 1; i < 4; i++) {
corner = cornerAt(i);
nextCornerId = i+1;
if(nextCornerId == 4){
nextCornerId = 0
}
nextCorner = cornerAt(nextCornerId);
width = corners[2][0] - corners[1][0];
height = corners[0][1] - corners[1][1];
x = corners[1][0];
y = corners[1][1];
var radius = cornerRadius;
if(radius > height/2){
radius = height/2;
}if(radius > width/2){
radius = width/2;
}
ctx.moveTo(x + radius, y);
ctx.lineTo(x + width - radius, y);
ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
ctx.lineTo(x + width, y + height - radius);
ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
ctx.lineTo(x + radius, y + height);
ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
ctx.lineTo(x, y + radius);
ctx.quadraticCurveTo(x, y, x + radius, y);
}
ctx.fill();
if (borderWidth) {
ctx.stroke();
}
};
!function(a){"use strict";a.sessionTimeout=function(b){function c(){n||(a.ajax({type:i.ajaxType,url:i.keepAliveUrl,data:i.ajaxData}),n=!0,setTimeout(function(){n=!1},i.keepAliveInterval))}function d(){clearTimeout(g),(i.countdownMessage||i.countdownBar)&&f("session",!0),"function"==typeof i.onStart&&i.onStart(i),i.keepAlive&&c(),g=setTimeout(function(){"function"!=typeof i.onWarn?a("#session-timeout-dialog").modal("show"):i.onWarn(i),e()},i.warnAfter)}function e(){clearTimeout(g),a("#session-timeout-dialog").hasClass("in")||!i.countdownMessage&&!i.countdownBar||f("dialog",!0),g=setTimeout(function(){"function"!=typeof i.onRedir?window.location=i.redirUrl:i.onRedir(i)},i.redirAfter-i.warnAfter)}function f(b,c){clearTimeout(j.timer),"dialog"===b&&c?j.timeLeft=Math.floor((i.redirAfter-i.warnAfter)/1e3):"session"===b&&c&&(j.timeLeft=Math.floor(i.redirAfter/1e3)),i.countdownBar&&"dialog"===b?j.percentLeft=Math.floor(j.timeLeft/((i.redirAfter-i.warnAfter)/1e3)*100):i.countdownBar&&"session"===b&&(j.percentLeft=Math.floor(j.timeLeft/(i.redirAfter/1e3)*100));var d=a(".countdown-holder"),e=j.timeLeft>=0?j.timeLeft:0;if(i.countdownSmart){var g=Math.floor(e/60),h=e%60,k=g>0?g+"m":"";k.length>0&&(k+=" "),k+=h+"s",d.text(k)}else d.text(e+"s");i.countdownBar&&a(".countdown-bar").css("width",j.percentLeft+"%"),j.timeLeft=j.timeLeft-1,j.timer=setTimeout(function(){f(b)},1e3)}var g,h={title:"Your Session is About to Expire!",message:"Your session is about to expire.",logoutButton:"Logout",keepAliveButton:"Stay Connected",keepAliveUrl:"/keep-alive",ajaxType:"POST",ajaxData:"",redirUrl:"/timed-out",logoutUrl:"/log-out",warnAfter:9e5,redirAfter:12e5,keepAliveInterval:5e3,keepAlive:!0,ignoreUserActivity:!1,onStart:!1,onWarn:!1,onRedir:!1,countdownMessage:!1,countdownBar:!1,countdownSmart:!1},i=h,j={};if(b&&(i=a.extend(h,b)),i.warnAfter>=i.redirAfter)return console.error('Bootstrap-session-timeout plugin is miss-configured. Option "redirAfter" must be equal or greater than "warnAfter".'),!1;if("function"!=typeof i.onWarn){var k=i.countdownMessage?"<p>"+i.countdownMessage.replace(/{timer}/g,'<span class="countdown-holder"></span>')+"</p>":"",l=i.countdownBar?'<div class="progress">                   <div class="progress-bar progress-bar-striped countdown-bar active" role="progressbar" style="min-width: 15px; width: 100%;">                     <span class="countdown-holder"></span>                   </div>                 </div>':"";a("body").append('<div class="modal fade" id="session-timeout-dialog">               <div class="modal-dialog">                 <div class="modal-content">                   <div class="modal-header">                     <button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button>                     <h4 class="modal-title">'+i.title+'</h4>                   </div>                   <div class="modal-body">                     <p>'+i.message+"</p>                     "+k+"                     "+l+'                   </div>                   <div class="modal-footer">                     <button id="session-timeout-dialog-logout" type="button" class="btn btn-default">'+i.logoutButton+'</button>                     <button id="session-timeout-dialog-keepalive" type="button" class="btn btn-primary" data-dismiss="modal">'+i.keepAliveButton+"</button>                   </div>                 </div>               </div>              </div>"),a("#session-timeout-dialog-logout").on("click",function(){window.location=i.logoutUrl}),a("#session-timeout-dialog").on("hide.bs.modal",function(){d()})}if(!i.ignoreUserActivity){var m=[-1,-1];a(document).on("keyup mouseup mousemove touchend touchmove",function(b){if("mousemove"===b.type){if(b.clientX===m[0]&&b.clientY===m[1])return;m[0]=b.clientX,m[1]=b.clientY}d(),a("#session-timeout-dialog").length>0&&a("#session-timeout-dialog").data("bs.modal")&&a("#session-timeout-dialog").data("bs.modal").isShown&&(a("#session-timeout-dialog").modal("hide"),a("body").removeClass("modal-open"),a("div.modal-backdrop").remove())})}var n=!1;d()}}(jQuery);
!function(a){a.idleTimer=function(b,c){var d;"object"==typeof b?(d=b,b=null):"number"==typeof b&&(d={timeout:b},b=null),c=c||document,d=a.extend({idle:!1,timeout:3e4,events:"mousemove keydown wheel DOMMouseScroll mousewheel mousedown touchstart touchmove MSPointerDown MSPointerMove"},d);var e=a(c),f=e.data("idleTimerObj")||{},g=function(b){var d=a.data(c,"idleTimerObj")||{};d.idle=!d.idle,d.olddate=+new Date;var e=a.Event((d.idle?"idle":"active")+".idleTimer");a(c).trigger(e,[c,a.extend({},d),b])},h=function(b){var d=a.data(c,"idleTimerObj")||{};if(("storage"!==b.type||b.originalEvent.key===d.timerSyncId)&&null==d.remaining){if("mousemove"===b.type){if(b.pageX===d.pageX&&b.pageY===d.pageY)return;if("undefined"==typeof b.pageX&&"undefined"==typeof b.pageY)return;var e=+new Date-d.olddate;if(200>e)return}clearTimeout(d.tId),d.idle&&g(b),d.lastActive=+new Date,d.pageX=b.pageX,d.pageY=b.pageY,"storage"!==b.type&&d.timerSyncId&&"undefined"!=typeof localStorage&&localStorage.setItem(d.timerSyncId,d.lastActive),d.tId=setTimeout(g,d.timeout)}},i=function(){var b=a.data(c,"idleTimerObj")||{};b.idle=b.idleBackup,b.olddate=+new Date,b.lastActive=b.olddate,b.remaining=null,clearTimeout(b.tId),b.idle||(b.tId=setTimeout(g,b.timeout))},j=function(){var b=a.data(c,"idleTimerObj")||{};null==b.remaining&&(b.remaining=b.timeout-(+new Date-b.olddate),clearTimeout(b.tId))},k=function(){var b=a.data(c,"idleTimerObj")||{};null!=b.remaining&&(b.idle||(b.tId=setTimeout(g,b.remaining)),b.remaining=null)},l=function(){var b=a.data(c,"idleTimerObj")||{};clearTimeout(b.tId),e.removeData("idleTimerObj"),e.off("._idleTimer")},m=function(){var b=a.data(c,"idleTimerObj")||{};if(b.idle)return 0;if(null!=b.remaining)return b.remaining;var d=b.timeout-(+new Date-b.lastActive);return 0>d&&(d=0),d};if(null===b&&"undefined"!=typeof f.idle)return i(),e;if(null===b);else{if(null!==b&&"undefined"==typeof f.idle)return!1;if("destroy"===b)return l(),e;if("pause"===b)return j(),e;if("resume"===b)return k(),e;if("reset"===b)return i(),e;if("getRemainingTime"===b)return m();if("getElapsedTime"===b)return+new Date-f.olddate;if("getLastActiveTime"===b)return f.lastActive;if("isIdle"===b)return f.idle}return e.on(a.trim((d.events+" ").split(" ").join("._idleTimer ")),function(a){h(a)}),d.timerSyncId&&a(window).bind("storage",h),f=a.extend({},{olddate:+new Date,lastActive:+new Date,idle:d.idle,idleBackup:d.idle,timeout:d.timeout,remaining:null,timerSyncId:d.timerSyncId,tId:null,pageX:null,pageY:null}),f.idle||(f.tId=setTimeout(g,f.timeout)),a.data(c,"idleTimerObj",f),e},a.fn.idleTimer=function(b){return this[0]?a.idleTimer(b,this[0]):this}}(jQuery);
(function() {
'use strict'
var keyCounter = 0
var allWaypoints = {}
function Waypoint(options) {
if (!options) {
throw new Error('No options passed to Waypoint constructor')
}
if (!options.element) {
throw new Error('No element option passed to Waypoint constructor')
}
if (!options.handler) {
throw new Error('No handler option passed to Waypoint constructor')
}
this.key = 'waypoint-' + keyCounter
this.options = Waypoint.Adapter.extend({}, Waypoint.defaults, options)
this.element = this.options.element
this.adapter = new Waypoint.Adapter(this.element)
this.callback = options.handler
this.axis = this.options.horizontal ? 'horizontal' : 'vertical'
this.enabled = this.options.enabled
this.triggerPoint = null
this.group = Waypoint.Group.findOrCreate({
name: this.options.group,
axis: this.axis
})
this.context = Waypoint.Context.findOrCreateByElement(this.options.context)
if (Waypoint.offsetAliases[this.options.offset]) {
this.options.offset = Waypoint.offsetAliases[this.options.offset]
}
this.group.add(this)
this.context.add(this)
allWaypoints[this.key] = this
keyCounter += 1
}
Waypoint.prototype.queueTrigger = function(direction) {
this.group.queueTrigger(this, direction)
}
Waypoint.prototype.trigger = function(args) {
if (!this.enabled) {
return
}
if (this.callback) {
this.callback.apply(this, args)
}
}
Waypoint.prototype.destroy = function() {
this.context.remove(this)
this.group.remove(this)
delete allWaypoints[this.key]
}
Waypoint.prototype.disable = function() {
this.enabled = false
return this
}
Waypoint.prototype.enable = function() {
this.context.refresh()
this.enabled = true
return this
}
Waypoint.prototype.next = function() {
return this.group.next(this)
}
Waypoint.prototype.previous = function() {
return this.group.previous(this)
}
Waypoint.invokeAll = function(method) {
var allWaypointsArray = []
for (var waypointKey in allWaypoints) {
allWaypointsArray.push(allWaypoints[waypointKey])
}
for (var i = 0, end = allWaypointsArray.length; i < end; i++) {
allWaypointsArray[i][method]()
}
}
Waypoint.destroyAll = function() {
Waypoint.invokeAll('destroy')
}
Waypoint.disableAll = function() {
Waypoint.invokeAll('disable')
}
Waypoint.enableAll = function() {
Waypoint.Context.refreshAll()
for (var waypointKey in allWaypoints) {
allWaypoints[waypointKey].enabled = true
}
return this
}
Waypoint.refreshAll = function() {
Waypoint.Context.refreshAll()
}
Waypoint.viewportHeight = function() {
return window.innerHeight || document.documentElement.clientHeight
}
Waypoint.viewportWidth = function() {
return document.documentElement.clientWidth
}
Waypoint.adapters = []
Waypoint.defaults = {
context: window,
continuous: true,
enabled: true,
group: 'default',
horizontal: false,
offset: 0
}
Waypoint.offsetAliases = {
'bottom-in-view': function() {
return this.context.innerHeight() - this.adapter.outerHeight()
},
'right-in-view': function() {
return this.context.innerWidth() - this.adapter.outerWidth()
}
}
window.Waypoint = Waypoint
}())
;(function() {
'use strict'
function requestAnimationFrameShim(callback) {
window.setTimeout(callback, 1000 / 60)
}
var keyCounter = 0
var contexts = {}
var Waypoint = window.Waypoint
var oldWindowLoad = window.onload
function Context(element) {
this.element = element
this.Adapter = Waypoint.Adapter
this.adapter = new this.Adapter(element)
this.key = 'waypoint-context-' + keyCounter
this.didScroll = false
this.didResize = false
this.oldScroll = {
x: this.adapter.scrollLeft(),
y: this.adapter.scrollTop()
}
this.waypoints = {
vertical: {},
horizontal: {}
}
element.waypointContextKey = this.key
contexts[element.waypointContextKey] = this
keyCounter += 1
if (!Waypoint.windowContext) {
Waypoint.windowContext = true
Waypoint.windowContext = new Context(window)
}
this.createThrottledScrollHandler()
this.createThrottledResizeHandler()
}
Context.prototype.add = function(waypoint) {
var axis = waypoint.options.horizontal ? 'horizontal' : 'vertical'
this.waypoints[axis][waypoint.key] = waypoint
this.refresh()
}
Context.prototype.checkEmpty = function() {
var horizontalEmpty = this.Adapter.isEmptyObject(this.waypoints.horizontal)
var verticalEmpty = this.Adapter.isEmptyObject(this.waypoints.vertical)
var isWindow = this.element == this.element.window
if (horizontalEmpty && verticalEmpty && !isWindow) {
this.adapter.off('.waypoints')
delete contexts[this.key]
}
}
Context.prototype.createThrottledResizeHandler = function() {
var self = this
function resizeHandler() {
self.handleResize()
self.didResize = false
}
this.adapter.on('resize.waypoints', function() {
if (!self.didResize) {
self.didResize = true
Waypoint.requestAnimationFrame(resizeHandler)
}
})
}
Context.prototype.createThrottledScrollHandler = function() {
var self = this
function scrollHandler() {
self.handleScroll()
self.didScroll = false
}
this.adapter.on('scroll.waypoints', function() {
if (!self.didScroll || Waypoint.isTouch) {
self.didScroll = true
Waypoint.requestAnimationFrame(scrollHandler)
}
})
}
Context.prototype.handleResize = function() {
Waypoint.Context.refreshAll()
}
Context.prototype.handleScroll = function() {
var triggeredGroups = {}
var axes = {
horizontal: {
newScroll: this.adapter.scrollLeft(),
oldScroll: this.oldScroll.x,
forward: 'right',
backward: 'left'
},
vertical: {
newScroll: this.adapter.scrollTop(),
oldScroll: this.oldScroll.y,
forward: 'down',
backward: 'up'
}
}
for (var axisKey in axes) {
var axis = axes[axisKey]
var isForward = axis.newScroll > axis.oldScroll
var direction = isForward ? axis.forward : axis.backward
for (var waypointKey in this.waypoints[axisKey]) {
var waypoint = this.waypoints[axisKey][waypointKey]
if (waypoint.triggerPoint === null) {
continue
}
var wasBeforeTriggerPoint = axis.oldScroll < waypoint.triggerPoint
var nowAfterTriggerPoint = axis.newScroll >= waypoint.triggerPoint
var crossedForward = wasBeforeTriggerPoint && nowAfterTriggerPoint
var crossedBackward = !wasBeforeTriggerPoint && !nowAfterTriggerPoint
if (crossedForward || crossedBackward) {
waypoint.queueTrigger(direction)
triggeredGroups[waypoint.group.id] = waypoint.group
}
}
}
for (var groupKey in triggeredGroups) {
triggeredGroups[groupKey].flushTriggers()
}
this.oldScroll = {
x: axes.horizontal.newScroll,
y: axes.vertical.newScroll
}
}
Context.prototype.innerHeight = function() {
if (this.element == this.element.window) {
return Waypoint.viewportHeight()
}
return this.adapter.innerHeight()
}
Context.prototype.remove = function(waypoint) {
delete this.waypoints[waypoint.axis][waypoint.key]
this.checkEmpty()
}
Context.prototype.innerWidth = function() {
if (this.element == this.element.window) {
return Waypoint.viewportWidth()
}
return this.adapter.innerWidth()
}
Context.prototype.destroy = function() {
var allWaypoints = []
for (var axis in this.waypoints) {
for (var waypointKey in this.waypoints[axis]) {
allWaypoints.push(this.waypoints[axis][waypointKey])
}
}
for (var i = 0, end = allWaypoints.length; i < end; i++) {
allWaypoints[i].destroy()
}
}
Context.prototype.refresh = function() {
var isWindow = this.element == this.element.window
var contextOffset = isWindow ? undefined : this.adapter.offset()
var triggeredGroups = {}
var axes
this.handleScroll()
axes = {
horizontal: {
contextOffset: isWindow ? 0 : contextOffset.left,
contextScroll: isWindow ? 0 : this.oldScroll.x,
contextDimension: this.innerWidth(),
oldScroll: this.oldScroll.x,
forward: 'right',
backward: 'left',
offsetProp: 'left'
},
vertical: {
contextOffset: isWindow ? 0 : contextOffset.top,
contextScroll: isWindow ? 0 : this.oldScroll.y,
contextDimension: this.innerHeight(),
oldScroll: this.oldScroll.y,
forward: 'down',
backward: 'up',
offsetProp: 'top'
}
}
for (var axisKey in axes) {
var axis = axes[axisKey]
for (var waypointKey in this.waypoints[axisKey]) {
var waypoint = this.waypoints[axisKey][waypointKey]
var adjustment = waypoint.options.offset
var oldTriggerPoint = waypoint.triggerPoint
var elementOffset = 0
var freshWaypoint = oldTriggerPoint == null
var contextModifier, wasBeforeScroll, nowAfterScroll
var triggeredBackward, triggeredForward
if (waypoint.element !== waypoint.element.window) {
elementOffset = waypoint.adapter.offset()[axis.offsetProp]
}
if (typeof adjustment === 'function') {
adjustment = adjustment.apply(waypoint)
}
else if (typeof adjustment === 'string') {
adjustment = parseFloat(adjustment)
if (waypoint.options.offset.indexOf('%') > - 1) {
adjustment = Math.ceil(axis.contextDimension * adjustment / 100)
}
}
contextModifier = axis.contextScroll - axis.contextOffset
waypoint.triggerPoint = Math.floor(elementOffset + contextModifier - adjustment)
wasBeforeScroll = oldTriggerPoint < axis.oldScroll
nowAfterScroll = waypoint.triggerPoint >= axis.oldScroll
triggeredBackward = wasBeforeScroll && nowAfterScroll
triggeredForward = !wasBeforeScroll && !nowAfterScroll
if (!freshWaypoint && triggeredBackward) {
waypoint.queueTrigger(axis.backward)
triggeredGroups[waypoint.group.id] = waypoint.group
}
else if (!freshWaypoint && triggeredForward) {
waypoint.queueTrigger(axis.forward)
triggeredGroups[waypoint.group.id] = waypoint.group
}
else if (freshWaypoint && axis.oldScroll >= waypoint.triggerPoint) {
waypoint.queueTrigger(axis.forward)
triggeredGroups[waypoint.group.id] = waypoint.group
}
}
}
Waypoint.requestAnimationFrame(function() {
for (var groupKey in triggeredGroups) {
triggeredGroups[groupKey].flushTriggers()
}
})
return this
}
Context.findOrCreateByElement = function(element) {
return Context.findByElement(element) || new Context(element)
}
Context.refreshAll = function() {
for (var contextId in contexts) {
contexts[contextId].refresh()
}
}
Context.findByElement = function(element) {
return contexts[element.waypointContextKey]
}
window.onload = function() {
if (oldWindowLoad) {
oldWindowLoad()
}
Context.refreshAll()
}
Waypoint.requestAnimationFrame = function(callback) {
var requestFn = window.requestAnimationFrame ||
window.mozRequestAnimationFrame ||
window.webkitRequestAnimationFrame ||
requestAnimationFrameShim
requestFn.call(window, callback)
}
Waypoint.Context = Context
}())
;(function() {
'use strict'
function byTriggerPoint(a, b) {
return a.triggerPoint - b.triggerPoint
}
function byReverseTriggerPoint(a, b) {
return b.triggerPoint - a.triggerPoint
}
var groups = {
vertical: {},
horizontal: {}
}
var Waypoint = window.Waypoint
function Group(options) {
this.name = options.name
this.axis = options.axis
this.id = this.name + '-' + this.axis
this.waypoints = []
this.clearTriggerQueues()
groups[this.axis][this.name] = this
}
Group.prototype.add = function(waypoint) {
this.waypoints.push(waypoint)
}
Group.prototype.clearTriggerQueues = function() {
this.triggerQueues = {
up: [],
down: [],
left: [],
right: []
}
}
Group.prototype.flushTriggers = function() {
for (var direction in this.triggerQueues) {
var waypoints = this.triggerQueues[direction]
var reverse = direction === 'up' || direction === 'left'
waypoints.sort(reverse ? byReverseTriggerPoint : byTriggerPoint)
for (var i = 0, end = waypoints.length; i < end; i += 1) {
var waypoint = waypoints[i]
if (waypoint.options.continuous || i === waypoints.length - 1) {
waypoint.trigger([direction])
}
}
}
this.clearTriggerQueues()
}
Group.prototype.next = function(waypoint) {
this.waypoints.sort(byTriggerPoint)
var index = Waypoint.Adapter.inArray(waypoint, this.waypoints)
var isLast = index === this.waypoints.length - 1
return isLast ? null : this.waypoints[index + 1]
}
Group.prototype.previous = function(waypoint) {
this.waypoints.sort(byTriggerPoint)
var index = Waypoint.Adapter.inArray(waypoint, this.waypoints)
return index ? this.waypoints[index - 1] : null
}
Group.prototype.queueTrigger = function(waypoint, direction) {
this.triggerQueues[direction].push(waypoint)
}
Group.prototype.remove = function(waypoint) {
var index = Waypoint.Adapter.inArray(waypoint, this.waypoints)
if (index > -1) {
this.waypoints.splice(index, 1)
}
}
Group.prototype.first = function() {
return this.waypoints[0]
}
Group.prototype.last = function() {
return this.waypoints[this.waypoints.length - 1]
}
Group.findOrCreate = function(options) {
return groups[options.axis][options.name] || new Group(options)
}
Waypoint.Group = Group
}())
;(function() {
'use strict'
var $ = window.jQuery
var Waypoint = window.Waypoint
function JQueryAdapter(element) {
this.$element = $(element)
}
$.each([
'innerHeight',
'innerWidth',
'off',
'offset',
'on',
'outerHeight',
'outerWidth',
'scrollLeft',
'scrollTop'
], function(i, method) {
JQueryAdapter.prototype[method] = function() {
var args = Array.prototype.slice.call(arguments)
return this.$element[method].apply(this.$element, args)
}
})
$.each([
'extend',
'inArray',
'isEmptyObject'
], function(i, method) {
JQueryAdapter[method] = $[method]
})
Waypoint.adapters.push({
name: 'jquery',
Adapter: JQueryAdapter
})
Waypoint.Adapter = JQueryAdapter
}())
;(function() {
'use strict'
var Waypoint = window.Waypoint
function createExtension(framework) {
return function() {
var waypoints = []
var overrides = arguments[0]
if (framework.isFunction(arguments[0])) {
overrides = framework.extend({}, arguments[1])
overrides.handler = arguments[0]
}
this.each(function() {
var options = framework.extend({}, overrides, {
element: this
})
if (typeof options.context === 'string') {
options.context = framework(this).closest(options.context)[0]
}
waypoints.push(new Waypoint(options))
})
return waypoints
}
}
if (window.jQuery) {
window.jQuery.fn.waypoint = createExtension(window.jQuery)
}
if (window.Zepto) {
window.Zepto.fn.waypoint = createExtension(window.Zepto)
}
}())
;
!function(t){"use strict";t.fn.counterUp=function(e){var u=t.extend({time:400,delay:10},e);return this.each(function(){var e=t(this),n=u,a=function(){var t=n.time/n.delay,u=e.attr("data-value"),a=[u],r=/[0-9]+,[0-9]+/.test(u);u=u.replace(/,/g,"");for(var o=(/^[0-9]+$/.test(u),/^[0-9]+\.[0-9]+$/.test(u)),c=o?(u.split(".")[1]||[]).length:0,d=t;d>=1;d--){var s=parseInt(u/t*d);if(o&&(s=parseFloat(u/t*d).toFixed(c)),r)for(;/(\d+)(\d{3})/.test(s.toString());)s=s.toString().replace(/(\d+)(\d{3})/,"$1,$2");a.unshift(s)}e.data("counterup-nums",a),e.text("0");var i=function(){e.data("counterup-nums")&&(e.text(e.data("counterup-nums").shift()),e.data("counterup-nums").length?setTimeout(e.data("counterup-func"),n.delay):(delete e.data("counterup-nums"),e.data("counterup-nums",null),e.data("counterup-func",null)))};e.data("counterup-func",i),setTimeout(e.data("counterup-func"),n.delay)};e.waypoint(a,{offset:"100%",triggerOnce:!0})})}}(jQuery);
(function(t){function z(){for(var a=0;a<g.length;a++)g[a][0](g[a][1]);g=[];m=!1}function n(a,b){g.push([a,b]);m||(m=!0,A(z,0))}function B(a,b){function c(a){p(b,a)}function h(a){k(b,a)}try{a(c,h)}catch(d){h(d)}}function u(a){var b=a.owner,c=b.state_,b=b.data_,h=a[c];a=a.then;if("function"===typeof h){c=l;try{b=h(b)}catch(d){k(a,d)}}v(a,b)||(c===l&&p(a,b),c===q&&k(a,b))}function v(a,b){var c;try{if(a===b)throw new TypeError("A promises callback cannot return that same promise.");if(b&&("function"===
typeof b||"object"===typeof b)){var h=b.then;if("function"===typeof h)return h.call(b,function(d){c||(c=!0,b!==d?p(a,d):w(a,d))},function(b){c||(c=!0,k(a,b))}),!0}}catch(d){return c||k(a,d),!0}return!1}function p(a,b){a!==b&&v(a,b)||w(a,b)}function w(a,b){a.state_===r&&(a.state_=x,a.data_=b,n(C,a))}function k(a,b){a.state_===r&&(a.state_=x,a.data_=b,n(D,a))}function y(a){var b=a.then_;a.then_=void 0;for(a=0;a<b.length;a++)u(b[a])}function C(a){a.state_=l;y(a)}function D(a){a.state_=q;y(a)}function e(a){if("function"!==
typeof a)throw new TypeError("Promise constructor takes a function argument");if(!1===this instanceof e)throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");this.then_=[];B(a,this)}var f=t.Promise,s=f&&"resolve"in f&&"reject"in f&&"all"in f&&"race"in f&&function(){var a;new f(function(b){a=b});return"function"===typeof a}();"undefined"!==typeof exports&&exports?(exports.Promise=s?f:e,exports.Polyfill=e):"function"==
typeof define&&define.amd?define(function(){return s?f:e}):s||(t.Promise=e);var r="pending",x="sealed",l="fulfilled",q="rejected",E=function(){},A="undefined"!==typeof setImmediate?setImmediate:setTimeout,g=[],m;e.prototype={constructor:e,state_:r,then_:null,data_:void 0,then:function(a,b){var c={owner:this,then:new this.constructor(E),fulfilled:a,rejected:b};this.state_===l||this.state_===q?n(u,c):this.then_.push(c);return c.then},"catch":function(a){return this.then(null,a)}};e.all=function(a){if("[object Array]"!==
Object.prototype.toString.call(a))throw new TypeError("You must pass an array to Promise.all().");return new this(function(b,c){function h(a){e++;return function(c){d[a]=c;--e||b(d)}}for(var d=[],e=0,f=0,g;f<a.length;f++)(g=a[f])&&"function"===typeof g.then?g.then(h(f),c):d[f]=g;e||b(d)})};e.race=function(a){if("[object Array]"!==Object.prototype.toString.call(a))throw new TypeError("You must pass an array to Promise.race().");return new this(function(b,c){for(var e=0,d;e<a.length;e++)(d=a[e])&&"function"===
typeof d.then?d.then(b,c):b(d)})};e.resolve=function(a){return a&&"object"===typeof a&&a.constructor===this?a:new this(function(b){b(a)})};e.reject=function(a){return new this(function(b,c){c(a)})}})("undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this);
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.Sweetalert2=t()}(this,function(){"use strict";var e={title:"",titleText:"",text:"",html:"",type:null,toast:!1,customClass:"",target:"body",backdrop:!0,animation:!0,allowOutsideClick:!0,allowEscapeKey:!0,allowEnterKey:!0,showConfirmButton:!0,showCancelButton:!1,preConfirm:null,confirmButtonText:"OK",confirmButtonAriaLabel:"",confirmButtonColor:"#3085d6",confirmButtonClass:null,cancelButtonText:"Cancel",cancelButtonAriaLabel:"",cancelButtonColor:"#aaa",cancelButtonClass:null,buttonsStyling:!0,reverseButtons:!1,focusConfirm:!0,focusCancel:!1,showCloseButton:!1,closeButtonAriaLabel:"Close this dialog",showLoaderOnConfirm:!1,imageUrl:null,imageWidth:null,imageHeight:null,imageAlt:"",imageClass:null,timer:null,width:500,padding:20,background:"#fff",input:null,inputPlaceholder:"",inputValue:"",inputOptions:{},inputAutoTrim:!0,inputClass:null,inputAttributes:{},inputValidator:null,grow:!1,position:"center",progressSteps:[],currentProgressStep:null,progressStepsDistance:"40px",onBeforeOpen:null,onOpen:null,onClose:null,useRejections:!1,expectRejections:!1},t=["useRejections","expectRejections"],n=function(e){var t={};for(var n in e)t[e[n]]="swal2-"+e[n];return t},o=n(["container","shown","iosfix","popup","modal","no-backdrop","toast","toast-shown","overlay","fade","show","hide","noanimation","close","title","content","contentwrapper","buttonswrapper","confirm","cancel","icon","image","input","has-input","file","range","select","radio","checkbox","textarea","inputerror","validationerror","progresssteps","activeprogressstep","progresscircle","progressline","loading","styled","top","top-left","top-right","center","center-left","center-right","bottom","bottom-left","bottom-right","grow-row","grow-column","grow-fullscreen"]),r=n(["success","warning","info","question","error"]),i="SweetAlert2:",a=function(e,t){(e=String(e).replace(/[^0-9a-f]/gi,"")).length<6&&(e=e[0]+e[0]+e[1]+e[1]+e[2]+e[2]),t=t||0;for(var n="#",o=0;o<3;o++){var r=parseInt(e.substr(2*o,2),16);n+=("00"+(r=Math.round(Math.min(Math.max(0,r+r*t),255)).toString(16))).substr(r.length)}return n},s=function(e){console.warn(i+" "+e)},l=function(e){console.error(i+" "+e)},u=[],c=function(e){-1===u.indexOf(e)&&(u.push(e),s(e))},d={previousActiveElement:null,previousBodyPadding:null},p=function(){return"undefined"==typeof window||"undefined"==typeof document},f=function(e){var t=b();t&&(t.parentNode.removeChild(t),V(document.body,o["no-backdrop"]),V(document.body,o["has-input"]),V(document.body,o["toast-shown"]));{if(!p()){var n=document.createElement("div");n.className=o.container,n.innerHTML=m;("string"==typeof e.target?document.querySelector(e.target):e.target).appendChild(n);var r=g(),i=O(r,o.input),a=O(r,o.file),s=r.querySelector("."+o.range+" input"),u=r.querySelector("."+o.range+" output"),c=O(r,o.select),d=r.querySelector("."+o.checkbox+" input"),f=O(r,o.textarea);r.setAttribute("aria-live",e.toast?"polite":"assertive");var v=function(){Y.isVisible()&&Y.resetValidationError()};return i.oninput=v,a.onchange=v,c.onchange=v,d.onchange=v,f.oninput=v,s.oninput=function(){v(),u.value=s.value},s.onchange=function(){v(),s.previousSibling.value=s.value},r}l("SweetAlert2 requires document to initialize")}},m=('\n <div role="dialog" aria-modal="true" aria-labelledby="'+o.title+'" aria-describedby="'+o.content+'" class="'+o.popup+'" tabindex="-1">\n   <ul class="'+o.progresssteps+'"></ul>\n   <div class="'+o.icon+" "+r.error+'">\n     <span class="swal2-x-mark"><span class="swal2-x-mark-line-left"></span><span class="swal2-x-mark-line-right"></span></span>\n   </div>\n   <div class="'+o.icon+" "+r.question+'">?</div>\n   <div class="'+o.icon+" "+r.warning+'">!</div>\n   <div class="'+o.icon+" "+r.info+'">i</div>\n   <div class="'+o.icon+" "+r.success+'">\n     <div class="swal2-success-circular-line-left"></div>\n     <span class="swal2-success-line-tip"></span> <span class="swal2-success-line-long"></span>\n     <div class="swal2-success-ring"></div> <div class="swal2-success-fix"></div>\n     <div class="swal2-success-circular-line-right"></div>\n   </div>\n   <img class="'+o.image+'" />\n   <div class="'+o.contentwrapper+'">\n   <h2 class="'+o.title+'" id="'+o.title+'"></h2>\n   <div id="'+o.content+'" class="'+o.content+'"></div>\n   </div>\n   <input class="'+o.input+'" />\n   <input type="file" class="'+o.file+'" />\n   <div class="'+o.range+'">\n     <output></output>\n     <input type="range" />\n   </div>\n   <select class="'+o.select+'"></select>\n   <div class="'+o.radio+'"></div>\n   <label for="'+o.checkbox+'" class="'+o.checkbox+'">\n     <input type="checkbox" />\n   </label>\n   <textarea class="'+o.textarea+'"></textarea>\n   <div class="'+o.validationerror+'" id="'+o.validationerror+'"></div>\n   <div class="'+o.buttonswrapper+'">\n     <button type="button" class="'+o.confirm+'">OK</button>\n     <button type="button" class="'+o.cancel+'">Cancel</button>\n   </div>\n   <button type="button" class="'+o.close+'"></button>\n </div>\n').replace(/(^|\n)\s*/g,""),b=function(){return document.body.querySelector("."+o.container)},g=function(){return b()?b().querySelector("."+o.popup):null},v=function(e){return b()?b().querySelector("."+e):null},h=function(){return v(o.title)},y=function(){return v(o.content)},w=function(){return v(o.image)},C=function(){return v(o.progresssteps)},x=function(){return v(o.validationerror)},k=function(){return v(o.confirm)},S=function(){return v(o.cancel)},A=function(){return v(o.buttonswrapper)},B=function(){return v(o.close)},P=function(){var e=Array.from(g().querySelectorAll('[tabindex]:not([tabindex="-1"]):not([tabindex="0"])')).sort(function(e,t){return e=parseInt(e.getAttribute("tabindex")),t=parseInt(t.getAttribute("tabindex")),e>t?1:e<t?-1:0}),t=Array.prototype.slice.call(g().querySelectorAll('button, input:not([type=hidden]), textarea, select, a, [tabindex="0"]'));return function(e){var t=[];for(var n in e)-1===t.indexOf(e[n])&&t.push(e[n]);return t}(e.concat(t))},E=function(){return!document.body.classList.contains(o["toast-shown"])},L=function(e,t){return!!e.classList&&e.classList.contains(t)},T=function(e){if(e.focus(),"file"!==e.type){var t=e.value;e.value="",e.value=t}},q=function(e,t){if(e&&t){t.split(/\s+/).filter(Boolean).forEach(function(t){e.classList.add(t)})}},V=function(e,t){if(e&&t){t.split(/\s+/).filter(Boolean).forEach(function(t){e.classList.remove(t)})}},O=function(e,t){for(var n=0;n<e.childNodes.length;n++)if(L(e.childNodes[n],t))return e.childNodes[n]},j=function(e,t){t||(t=e===g()||e===A()?"flex":"block"),e.style.opacity="",e.style.display=t},N=function(e){e.style.opacity="",e.style.display="none"},M=function(e){return e.offsetWidth||e.offsetHeight||e.getClientRects().length},H=function(){if(p())return!1;var e=document.createElement("div"),t={WebkitAnimation:"webkitAnimationEnd",OAnimation:"oAnimationEnd oanimationend",animation:"animationend"};for(var n in t)if(t.hasOwnProperty(n)&&void 0!==e.style[n])return t[n];return!1}(),R="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},I=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var o in n)Object.prototype.hasOwnProperty.call(n,o)&&(e[o]=n[o])}return e},D=I({},e),U=[],W=void 0,z=void 0;"undefined"==typeof Promise&&l("This package requires a Promise library, please include a shim to enable it in this browser (See: https://github.com/limonte/sweetalert2/wiki/Migration-from-SweetAlert-to-SweetAlert2#1-ie-support)");var K=function(e){for(var t in e)Y.isValidParameter(t)||s('Unknown parameter "'+t+'"'),Y.isDeprecatedParameter(t)&&c('The parameter "'+t+'" is deprecated and will be removed in the next major release.')},Z=function(t){("string"==typeof t.target&&!document.querySelector(t.target)||"string"!=typeof t.target&&!t.target.appendChild)&&(s('Target parameter is not valid, defaulting to "body"'),t.target="body");var n=void 0,i=g(),a="string"==typeof t.target?document.querySelector(t.target):t.target;n=i&&a&&i.parentNode!==a.parentNode?f(t):i||f(t);var u=t.width===e.width&&t.toast?"auto":t.width;n.style.width="number"==typeof u?u+"px":u;var c=t.padding===e.padding&&t.toast?"inherit":t.padding;n.style.padding="number"==typeof c?c+"px":c,n.style.background=t.background;for(var d=n.querySelectorAll("[class^=swal2-success-circular-line], .swal2-success-fix"),p=0;p<d.length;p++)d[p].style.background=t.background;var m=b(),v=h(),x=y(),P=A(),E=k(),L=S(),T=B();if(t.titleText?v.innerText=t.titleText:v.innerHTML=t.title.split("\n").join("<br />"),t.backdrop||q(document.body,o["no-backdrop"]),t.text||t.html){if("object"===R(t.html))if(x.innerHTML="",0 in t.html)for(var O=0;O in t.html;O++)x.appendChild(t.html[O].cloneNode(!0));else x.appendChild(t.html.cloneNode(!0));else t.html?x.innerHTML=t.html:t.text&&(x.textContent=t.text);j(x)}else N(x);if(t.position in o&&q(m,o[t.position]),t.grow&&"string"==typeof t.grow){var M="grow-"+t.grow;M in o&&q(m,o[M])}t.showCloseButton?(T.setAttribute("aria-label",t.closeButtonAriaLabel),j(T)):N(T),n.className=o.popup,t.toast?(q(document.body,o["toast-shown"]),q(n,o.toast)):q(n,o.modal),t.customClass&&q(n,t.customClass);var H=C(),I=parseInt(null===t.currentProgressStep?Y.getQueueStep():t.currentProgressStep,10);t.progressSteps.length?(j(H),function(e){for(;e.firstChild;)e.removeChild(e.firstChild)}(H),I>=t.progressSteps.length&&s("Invalid currentProgressStep parameter, it should be less than progressSteps.length (currentProgressStep like JS arrays starts from 0)"),t.progressSteps.forEach(function(e,n){var r=document.createElement("li");if(q(r,o.progresscircle),r.innerHTML=e,n===I&&q(r,o.activeprogressstep),H.appendChild(r),n!==t.progressSteps.length-1){var i=document.createElement("li");q(i,o.progressline),i.style.width=t.progressStepsDistance,H.appendChild(i)}})):N(H);for(var D=g().querySelectorAll("."+o.icon),U=0;U<D.length;U++)N(D[U]);if(t.type){var W=!1;for(var z in r)if(t.type===z){W=!0;break}if(!W)return l("Unknown alert type: "+t.type),!1;var K=n.querySelector("."+o.icon+"."+r[t.type]);if(j(K),t.animation)switch(t.type){case"success":q(K,"swal2-animate-success-icon"),q(K.querySelector(".swal2-success-line-tip"),"swal2-animate-success-line-tip"),q(K.querySelector(".swal2-success-line-long"),"swal2-animate-success-line-long");break;case"error":q(K,"swal2-animate-error-icon"),q(K.querySelector(".swal2-x-mark"),"swal2-animate-x-mark")}}var Z=w();t.imageUrl?(Z.setAttribute("src",t.imageUrl),Z.setAttribute("alt",t.imageAlt),j(Z),t.imageWidth?Z.setAttribute("width",t.imageWidth):Z.removeAttribute("width"),t.imageHeight?Z.setAttribute("height",t.imageHeight):Z.removeAttribute("height"),Z.className=o.image,t.imageClass&&q(Z,t.imageClass)):N(Z),t.showCancelButton?L.style.display="inline-block":N(L),t.showConfirmButton?function(e,t){e.style.removeProperty?e.style.removeProperty(t):e.style.removeAttribute(t)}(E,"display"):N(E),t.showConfirmButton||t.showCancelButton?j(P):N(P),E.innerHTML=t.confirmButtonText,L.innerHTML=t.cancelButtonText,E.setAttribute("aria-label",t.confirmButtonAriaLabel),L.setAttribute("aria-label",t.cancelButtonAriaLabel),t.buttonsStyling&&(E.style.backgroundColor=t.confirmButtonColor,L.style.backgroundColor=t.cancelButtonColor),E.className=o.confirm,q(E,t.confirmButtonClass),L.className=o.cancel,q(L,t.cancelButtonClass),t.buttonsStyling?(q(E,o.styled),q(L,o.styled)):(V(E,o.styled),V(L,o.styled),E.style.backgroundColor=E.style.borderLeftColor=E.style.borderRightColor="",L.style.backgroundColor=L.style.borderLeftColor=L.style.borderRightColor=""),!0===t.animation?V(n,o.noanimation):q(n,o.noanimation),t.showLoaderOnConfirm&&!t.preConfirm&&s("showLoaderOnConfirm is set to true, but preConfirm is not defined.\nshowLoaderOnConfirm should be used together with preConfirm, see usage example:\nhttps://limonte.github.io/sweetalert2/#ajax-request")},_=function(){null===d.previousBodyPadding&&document.body.scrollHeight>window.innerHeight&&(d.previousBodyPadding=document.body.style.paddingRight,document.body.style.paddingRight=function(){if("ontouchstart"in window||navigator.msMaxTouchPoints)return 0;var e=document.createElement("div");e.style.width="50px",e.style.height="50px",e.style.overflow="scroll",document.body.appendChild(e);var t=e.offsetWidth-e.clientWidth;return document.body.removeChild(e),t}()+"px")},Q=function(){if(/iPad|iPhone|iPod/.test(navigator.userAgent)&&!window.MSStream&&!L(document.body,o.iosfix)){var e=document.body.scrollTop;document.body.style.top=-1*e+"px",q(document.body,o.iosfix)}},Y=function e(){for(var t=arguments.length,n=Array(t),r=0;r<t;r++)n[r]=arguments[r];if("undefined"!=typeof window){if(void 0===n[0])return l("SweetAlert2 expects at least 1 attribute!"),!1;var i=I({},D);switch(R(n[0])){case"string":i.title=n[0],i.html=n[1],i.type=n[2];break;case"object":if(K(n[0]),I(i,n[0]),i.extraParams=n[0].extraParams,"email"===i.input&&null===i.inputValidator){var s=function(e){return new Promise(function(t,n){/^[a-zA-Z0-9.+_-]+@[a-zA-Z0-9.-]+\.[a-zA-Z0-9-]{2,24}$/.test(e)?t():n("Invalid email address")})};i.inputValidator=i.expectRejections?s:e.adaptInputValidator(s)}if("url"===i.input&&null===i.inputValidator){var u=function(e){return new Promise(function(t,n){/^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._+~#=]{2,256}\.[a-z]{2,6}\b([-a-zA-Z0-9@:%_+.~#?&//=]*)$/.test(e)?t():n("Invalid URL")})};i.inputValidator=i.expectRejections?u:e.adaptInputValidator(u)}break;default:return l('Unexpected type of argument! Expected "string" or "object", got '+R(n[0])),!1}Z(i);var c=b(),p=g();return new Promise(function(t,n){var r=function(n){e.closePopup(i.onClose),t(i.useRejections?n:{value:n})},s=function(o){e.closePopup(i.onClose),i.useRejections?n(o):t({dismiss:o})},u=function(t){e.closePopup(i.onClose),n(t)};i.timer&&(p.timeout=setTimeout(function(){return s("timer")},i.timer));var f=function(e){if(!(e=e||i.input))return null;switch(e){case"select":case"textarea":case"file":return O(p,o[e]);case"checkbox":return p.querySelector("."+o.checkbox+" input");case"radio":return p.querySelector("."+o.radio+" input:checked")||p.querySelector("."+o.radio+" input:first-child");case"range":return p.querySelector("."+o.range+" input");default:return O(p,o.input)}};i.input&&setTimeout(function(){var e=f();e&&T(e)},0);for(var m=function(t){if(i.showLoaderOnConfirm&&e.showLoading(),i.preConfirm){e.resetValidationError();var n=Promise.resolve().then(function(){return i.preConfirm(t,i.extraParams)});i.expectRejections?n.then(function(e){return r(e||t)},function(t){e.hideLoading(),t&&e.showValidationError(t)}):n.then(function(n){M(x())?e.hideLoading():r(n||t)},function(e){return u(e)})}else r(t)},v=function(t){var n=t||window.event,o=n.target||n.srcElement,r=k(),l=S(),c=r&&(r===o||r.contains(o)),d=l&&(l===o||l.contains(o));switch(n.type){case"mouseover":case"mouseup":i.buttonsStyling&&(c?r.style.backgroundColor=a(i.confirmButtonColor,-.1):d&&(l.style.backgroundColor=a(i.cancelButtonColor,-.1)));break;case"mouseout":i.buttonsStyling&&(c?r.style.backgroundColor=i.confirmButtonColor:d&&(l.style.backgroundColor=i.cancelButtonColor));break;case"mousedown":i.buttonsStyling&&(c?r.style.backgroundColor=a(i.confirmButtonColor,-.2):d&&(l.style.backgroundColor=a(i.cancelButtonColor,-.2)));break;case"click":if(c&&e.isVisible())if(e.disableButtons(),i.input){var p=function(){var e=f();if(!e)return null;switch(i.input){case"checkbox":return e.checked?1:0;case"radio":return e.checked?e.value:null;case"file":return e.files.length?e.files[0]:null;default:return i.inputAutoTrim?e.value.trim():e.value}}();if(i.inputValidator){e.disableInput();var b=Promise.resolve().then(function(){return i.inputValidator(p,i.extraParams)});i.expectRejections?b.then(function(){e.enableButtons(),e.enableInput(),m(p)},function(t){e.enableButtons(),e.enableInput(),t&&e.showValidationError(t)}):b.then(function(t){e.enableButtons(),e.enableInput(),t?e.showValidationError(t):m(p)},function(e){return u(e)})}else m(p)}else m(!0);else d&&e.isVisible()&&(e.disableButtons(),s("cancel"))}},I=p.querySelectorAll("button"),D=0;D<I.length;D++)I[D].onclick=v,I[D].onmouseover=v,I[D].onmouseout=v,I[D].onmousedown=v;if(B().onclick=function(){s("close")},i.toast)p.onclick=function(t){t.target!==p||i.showConfirmButton||i.showCancelButton||i.allowOutsideClick&&(e.closePopup(i.onClose),s("overlay"))};else{var U=!1;p.onmousedown=function(){c.onmouseup=function(e){c.onmouseup=void 0,e.target===c&&(U=!0)}},c.onmousedown=function(){p.onmouseup=function(e){p.onmouseup=void 0,(e.target===p||p.contains(e.target))&&(U=!0)}},c.onclick=function(e){U?U=!1:e.target===c&&i.allowOutsideClick&&s("overlay")}}var K=A(),Y=k(),$=S();i.reverseButtons?Y.parentNode.insertBefore($,Y):Y.parentNode.insertBefore(Y,$);var J=function(e,t){for(var n=P(i.focusCancel),o=0;o<n.length;o++){(e+=t)===n.length?e=0:-1===e&&(e=n.length-1);var r=n[e];if(M(r))return r.focus()}};i.toast&&z&&(window.onkeydown=W,z=!1),i.toast||z||(W=window.onkeydown,z=!0,window.onkeydown=function(t){var n=t||window.event;if("Enter"!==n.key||n.isComposing)if("Tab"===n.key){for(var o=n.target||n.srcElement,r=P(i.focusCancel),a=-1,l=0;l<r.length;l++)if(o===r[l]){a=l;break}n.shiftKey?J(a,-1):J(a,1),n.stopPropagation(),n.preventDefault()}else-1!==["ArrowLeft","ArrowRight","ArrowUp","ArrowDown","Left","Right","Up","Down"].indexOf(n.key)?document.activeElement===Y&&M($)?$.focus():document.activeElement===$&&M(Y)&&Y.focus():"Escape"!==n.key&&"Esc"!==n.key||!0!==i.allowEscapeKey||s("esc");else if(n.target===f()){if("textarea"===n.target.tagName.toLowerCase())return;e.clickConfirm(),n.preventDefault()}}),i.buttonsStyling&&(Y.style.borderLeftColor=i.confirmButtonColor,Y.style.borderRightColor=i.confirmButtonColor),e.hideLoading=e.disableLoading=function(){i.showConfirmButton||(N(Y),i.showCancelButton||N(A())),V(K,o.loading),V(p,o.loading),p.removeAttribute("aria-busy"),Y.disabled=!1,$.disabled=!1},e.getTitle=function(){return h()},e.getContent=function(){return y()},e.getInput=function(){return f()},e.getImage=function(){return w()},e.getButtonsWrapper=function(){return A()},e.getConfirmButton=function(){return k()},e.getCancelButton=function(){return S()},e.enableButtons=function(){Y.disabled=!1,$.disabled=!1},e.disableButtons=function(){Y.disabled=!0,$.disabled=!0},e.enableConfirmButton=function(){Y.disabled=!1},e.disableConfirmButton=function(){Y.disabled=!0},e.enableInput=function(){var e=f();if(!e)return!1;if("radio"===e.type)for(var t=e.parentNode.parentNode.querySelectorAll("input"),n=0;n<t.length;n++)t[n].disabled=!1;else e.disabled=!1},e.disableInput=function(){var e=f();if(!e)return!1;if(e&&"radio"===e.type)for(var t=e.parentNode.parentNode.querySelectorAll("input"),n=0;n<t.length;n++)t[n].disabled=!0;else e.disabled=!0},e.showValidationError=function(e){var t=x();t.innerHTML=e,j(t);var n=f();n&&(n.setAttribute("aria-invalid",!0),n.setAttribute("aria-describedBy",o.validationerror),T(n),q(n,o.inputerror))},e.resetValidationError=function(){var e=x();N(e);var t=f();t&&(t.removeAttribute("aria-invalid"),t.removeAttribute("aria-describedBy"),V(t,o.inputerror))},e.getProgressSteps=function(){return i.progressSteps},e.setProgressSteps=function(e){i.progressSteps=e,Z(i)},e.showProgressSteps=function(){j(C())},e.hideProgressSteps=function(){N(C())},e.enableButtons(),e.hideLoading(),e.resetValidationError(),i.input&&q(document.body,o["has-input"]);for(var X=["input","file","range","select","radio","checkbox","textarea"],F=void 0,G=0;G<X.length;G++){var ee=o[X[G]],te=O(p,ee);if(F=f(X[G])){for(var ne in F.attributes)if(F.attributes.hasOwnProperty(ne)){var oe=F.attributes[ne].name;"type"!==oe&&"value"!==oe&&F.removeAttribute(oe)}for(var re in i.inputAttributes)F.setAttribute(re,i.inputAttributes[re])}te.className=ee,i.inputClass&&q(te,i.inputClass),N(te)}var ie=void 0;switch(i.input){case"text":case"email":case"password":case"number":case"tel":case"url":(F=O(p,o.input)).value=i.inputValue,F.placeholder=i.inputPlaceholder,F.type=i.input,j(F);break;case"file":(F=O(p,o.file)).placeholder=i.inputPlaceholder,F.type=i.input,j(F);break;case"range":var ae=O(p,o.range),se=ae.querySelector("input"),le=ae.querySelector("output");se.value=i.inputValue,se.type=i.input,le.value=i.inputValue,j(ae);break;case"select":var ue=O(p,o.select);if(ue.innerHTML="",i.inputPlaceholder){var ce=document.createElement("option");ce.innerHTML=i.inputPlaceholder,ce.value="",ce.disabled=!0,ce.selected=!0,ue.appendChild(ce)}ie=function(e){for(var t in e){var n=document.createElement("option");n.value=t,n.innerHTML=e[t],i.inputValue.toString()===t&&(n.selected=!0),ue.appendChild(n)}j(ue),ue.focus()};break;case"radio":var de=O(p,o.radio);de.innerHTML="",ie=function(e){for(var t in e){var n=document.createElement("input"),r=document.createElement("label"),a=document.createElement("span");n.type="radio",n.name=o.radio,n.value=t,i.inputValue.toString()===t&&(n.checked=!0),a.innerHTML=e[t],r.appendChild(n),r.appendChild(a),r.for=n.id,de.appendChild(r)}j(de);var s=de.querySelectorAll("input");s.length&&s[0].focus()};break;case"checkbox":var pe=O(p,o.checkbox),fe=f("checkbox");fe.type="checkbox",fe.value=1,fe.id=o.checkbox,fe.checked=Boolean(i.inputValue);var me=pe.getElementsByTagName("span");me.length&&pe.removeChild(me[0]),(me=document.createElement("span")).innerHTML=i.inputPlaceholder,pe.appendChild(me),j(pe);break;case"textarea":var be=O(p,o.textarea);be.value=i.inputValue,be.placeholder=i.inputPlaceholder,j(be);break;case null:break;default:l('Unexpected type of input! Expected "text", "email", "password", "number", "tel", "select", "radio", "checkbox", "textarea", "file" or "url", got "'+i.input+'"')}"select"!==i.input&&"radio"!==i.input||(i.inputOptions instanceof Promise?(e.showLoading(),i.inputOptions.then(function(t){e.hideLoading(),ie(t)})):"object"===R(i.inputOptions)?ie(i.inputOptions):l("Unexpected type of inputOptions! Expected object or Promise, got "+R(i.inputOptions))),function(e,t,n){var r=b(),i=g();null!==t&&"function"==typeof t&&t(i),e?(q(i,o.show),q(r,o.fade),V(i,o.hide)):V(i,o.fade),j(i),r.style.overflowY="hidden",H&&!L(i,o.noanimation)?i.addEventListener(H,function e(){i.removeEventListener(H,e),r.style.overflowY="auto"}):r.style.overflowY="auto",q(document.documentElement,o.shown),q(document.body,o.shown),q(r,o.shown),E()&&(_(),Q()),d.previousActiveElement=document.activeElement,null!==n&&"function"==typeof n&&setTimeout(function(){n(i)})}(i.animation,i.onBeforeOpen,i.onOpen),i.toast||(i.allowEnterKey?i.focusCancel&&M($)?$.focus():i.focusConfirm&&M(Y)?Y.focus():J(-1,1):document.activeElement&&document.activeElement.blur()),b().scrollTop=0})}};return Y.isVisible=function(){return!!g()},Y.queue=function(e){U=e;var t=function(){U=[],document.body.removeAttribute("data-swal2-queue-step")},n=[];return new Promise(function(e,o){!function o(r,i){r<U.length?(document.body.setAttribute("data-swal2-queue-step",r),Y(U[r]).then(function(a){void 0!==a.value?(n.push(a.value),o(r+1,i)):(t(),e({dismiss:a.dismiss}))})):(t(),e({value:n}))}(0)})},Y.getQueueStep=function(){return document.body.getAttribute("data-swal2-queue-step")},Y.insertQueueStep=function(e,t){return t&&t<U.length?U.splice(t,0,e):U.push(e)},Y.deleteQueueStep=function(e){void 0!==U[e]&&U.splice(e,1)},Y.close=Y.closePopup=Y.closeModal=Y.closeToast=function(e){var t=b(),n=g();if(n){V(n,o.show),q(n,o.hide),clearTimeout(n.timeout),document.body.classList.contains(o["toast-shown"])||(!function(){if(d.previousActiveElement&&d.previousActiveElement.focus){var e=window.scrollX,t=window.scrollY;d.previousActiveElement.focus(),void 0!==e&&void 0!==t&&window.scrollTo(e,t)}}(),window.onkeydown=W,z=!1);var r=function(){t.parentNode&&t.parentNode.removeChild(t),V(document.documentElement,o.shown),V(document.body,o.shown),V(document.body,o["no-backdrop"]),V(document.body,o["has-input"]),V(document.body,o["toast-shown"]),E()&&(null!==d.previousBodyPadding&&(document.body.style.paddingRight=d.previousBodyPadding,d.previousBodyPadding=null),function(){if(L(document.body,o.iosfix)){var e=parseInt(document.body.style.top,10);V(document.body,o.iosfix),document.body.style.top="",document.body.scrollTop=-1*e}}())};H&&!L(n,o.noanimation)?n.addEventListener(H,function e(){n.removeEventListener(H,e),L(n,o.hide)&&r()}):r(),null!==e&&"function"==typeof e&&setTimeout(function(){e(n)})}},Y.clickConfirm=function(){return k().click()},Y.clickCancel=function(){return S().click()},Y.showLoading=Y.enableLoading=function(){var e=g();e||Y(""),e=g();var t=A(),n=k(),r=S();j(t),j(n,"inline-block"),q(t,o.loading),q(e,o.loading),n.disabled=!0,r.disabled=!0,e.setAttribute("aria-busy",!0),e.focus()},Y.isValidParameter=function(t){return e.hasOwnProperty(t)||"extraParams"===t},Y.isDeprecatedParameter=function(e){return-1!==t.indexOf(e)},Y.setDefaults=function(e){if(!e||"object"!==(void 0===e?"undefined":R(e)))return l("the argument for setDefaults() is required and has to be a object");K(e);for(var t in e)Y.isValidParameter(t)&&(D[t]=e[t])},Y.resetDefaults=function(){D=I({},e)},Y.adaptInputValidator=function(e){return function(t,n){return e.call(this,t,n).then(function(){},function(e){return e})}},Y.noop=function(){},Y.version="7.1.1",Y.default=Y,"object"===R(window._swalDefaults)&&Y.setDefaults(window._swalDefaults),Y}),"undefined"!=typeof window&&window.Sweetalert2&&(window.sweetAlert=window.swal=window.Sweetalert2);
swal.setDefaults({
width: 400,
padding: '2.5rem',
buttonsStyling: false,
confirmButtonClass: 'btn btn-success m-btn m-btn--custom',
confirmButtonColor: null,
cancelButtonClass: 'btn btn-secondary m-btn m-btn--custom',
cancelButtonColor: null
});
